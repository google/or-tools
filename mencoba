from ortools.constraint_solver import routing_enums_pb2
from ortools.constraint_solver import pywrapcp

def create_data_model():
    """Menyiapkan data untuk masalah CEVRPTW."""
    data = {}
    # Jumlah lokasi (termasuk depot, yang pertama)
    data['num_locations'] = 5
    # Matriks jarak antar lokasi
    data['distance_matrix'] = [
        [0, 2, 4, 7, 3],  # Jarak dari lokasi 0 ke [1, 2, 3, 4]
        [2, 0, 1, 3, 6],
        [4, 1, 0, 2, 4],
        [7, 3, 2, 0, 5],
        [3, 6, 4, 5, 0]
    ]
    # Kapasitas kendaraan
    data['vehicle_capacities'] = [15, 15]
    # Permintaan pada setiap lokasi
    data['demands'] = [0, 5, 7, 8, 4]  # Permintaan depot = 0
    # Jendela waktu untuk setiap lokasi
    data['time_windows'] = [
        (0, 5),  # Waktu untuk lokasi 0 (depot)
        (2, 6),  # Waktu untuk lokasi 1
        (3, 7),  # Waktu untuk lokasi 2
        (4, 9),  # Waktu untuk lokasi 3
        (5, 10)  # Waktu untuk lokasi 4
    ]
    # Jumlah kendaraan
    data['num_vehicles'] = 2
    # Posisi depot
    data['depot'] = 0
    return data

def create_routing_model(data):
    """Membuat model rute kendaraan dengan jendela waktu dan kapasitas."""
    # Membuat model rute kendaraan
    manager = pywrapcp.RoutingIndexManager(data['num_locations'], data['num_vehicles'], data['depot'])
    routing = pywrapcp.RoutingModel(manager)

    # Fungsi jarak (cost) antara dua lokasi
    def distance_callback(from_index, to_index):
        # Mengambil indeks lokasi dalam routing model
        from_node = manager.IndexToNode(from_index)
        to_node = manager.IndexToNode(to_index)
        return data['distance_matrix'][from_node][to_node]

    # Menambah fungsi jarak ke model
    transit_callback_index = routing.RegisterTransitCallback(distance_callback)
    routing.SetArcCostEvaluatorOfAllVehicles(transit_callback_index)

    # Fungsi permintaan dan kapasitas
    def demand_callback(from_index):
        # Mengambil indeks lokasi dalam routing model
        from_node = manager.IndexToNode(from_index)
        return data['demands'][from_node]

    # Menambah kapasitas ke model
    demand_callback_index = routing.RegisterUnaryTransitCallback(demand_callback)
    routing.AddDimensionWithVehicleCapacity(
        demand_callback_index, 0, data['vehicle_capacities'], True, 'Capacity'
    )

    # Fungsi waktu dan jendela waktu
    def time_callback(from_index, to_index):
        # Mengambil indeks lokasi dalam routing model
        from_node = manager.IndexToNode(from_index)
        to_node = manager.IndexToNode(to_index)
        return data['distance_matrix'][from_node][to_node]  # Misal, waktu sebanding dengan jarak

    # Menambah waktu ke model
    time_callback_index = routing.RegisterTransitCallback(time_callback)
    routing.AddDimension(
        time_callback_index,
        30,  # Waktu ekstra untuk buffer
        100,  # Batasan waktu maksimal
        False,  # Kendaraan tidak harus kembali ke depot
        'Time'
    )

    # Menambah jendela waktu
    time_dimension = routing.GetDimensionOrDie('Time')
    for location in range(data['num_locations']):
        index = manager.NodeToIndex(location)
        time_dimension.CumulVar(index).SetRange(data['time_windows'][location][0], data['time_windows'][location][1])

    return routing, manager

def solve_routing_problem(data, routing, manager):
    """Menyelesaikan masalah rute kendaraan dengan jendela waktu dan kapasitas."""
    # Parameter pencarian solusi
    search_parameters = pywrapcp.DefaultRoutingSearchParameters()
    search_parameters.first_solution_strategy = (
        routing_enums_pb2.FirstSolutionStrategy.PATH_CHEAPEST_ARC)
    
    # Mencari solusi
    solution = routing.SolveWithParameters(search_parameters)

    # Menampilkan solusi jika ditemukan
    if solution:
        print_solution(data, manager, routing, solution)
    else:
        print('Tidak ada solusi ditemukan.')

def print_solution(data, manager, routing, solution):
    """Menampilkan solusi."""
    total_distance = 0
    total_load = 0
    for vehicle_id in range(data['num_vehicles']):
        index = routing.Start(vehicle_id)
        route_distance = 0
        route_load = 0
        route_time = 0
        print(f'Rute untuk kendaraan {vehicle_id}:')
        while not routing.IsEnd(index):
            node_index = manager.IndexToNode(index)
            route_load += data['demands'][node_index]
            route_time += solution.Value(routing.CumulVar(index, 'Time'))
            print(f'Lokasi {node_index} -> ', end='')
            previous_index = index
            index = solution.Value(routing.NextVar(index))
            route_distance += routing.GetArcCostForVehicle(previous_index, index, vehicle_id)
        print(f'Kembali ke depot.')
        print(f'Jarak total: {route_distance} unit')
        print(f'Beban total: {route_load}')
        print(f'Waktu total: {route_time}')
        total_distance += route_distance
        total_load += route_load
    print(f'Jarak total: {total_distance} unit')

def main():
    """Menjalankan program utama."""
    data = create_data_model()
    routing, manager = create_routing_model(data)
    solve_routing_problem(data, routing, manager)

if __name__ == '__main__':
    main()
