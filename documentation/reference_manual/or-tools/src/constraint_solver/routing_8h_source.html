<!-- Good morning, Mr. Phelps. -->
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <title>or-tools/src/constraint_solver/routing.h Source File - Doxy</title>
    <link rel="shortcut icon" href="../../../favicon.ico">
    <!-- Both stylesheets are supplied by Doxygen, with maybe minor tweaks from Google. -->
    <link href="../../../doxygen.css" rel="stylesheet" type="text/css">
    <link href="../../../tabs.css" rel="stylesheet" type="text/css">
  </head>

  <body topmargin=0 leftmargin=20 bottommargin=0 rightmargin=20 marginwidth=20 marginheight=0>

  <table width=100% cellpadding=0 cellspacing=0 border=0>
    <!-- Top horizontal line with the color of the day. -->
    <tr valign=top>
      <td colspan=3 bgcolor=#992252 height=3></td>
    </tr>

    <!-- Header row with the links at the right. -->
    <tr valign=top>
      <td colspan=3 align=right>
        <font size=-1>
          Generated on: <font color=#992252><b>Fri Aug 10 02:28:15 CEST 2012</b></font>
            for Revision:2056
        </font>
      </td>
    </tr>

    <!-- Header row with the logo and the search form. -->
    <tr valign=top>
      <!-- Logo. -->
      <td align=left width=150>
        <table width=150 height=54 cellpadding=0 cellspacing=0 border=0>
          <tr valign=top>
            <!-- First part of the secret behind Doxy logo always having the word "Doxy" with the color of the day. -->
            <td>
              <a class="doxy_logo" href="../../../index.html"><img src="../../../doxy_logo.png" alt="OR-Tools" border=0></a>
            </td>
          </tr>
        </table>
      </td>
    </tr>

    <!-- Tiny vertical space below the form. -->
    <tr valign=top>
      <td colspan=3 height=3></td>
    </tr>
  </table>

  <!-- Header navigation row. -->
  <div class="memproto">
    <table width=100% cellpadding=0 cellspacing=0 border=0>
      <tr>
        <td align=left style="padding-left: 20px"><font size=+1><b><tt><font color=#333333>//
            <a href="../../../index.html"><font color=#992252>doxy</font></a>/</font>
            <a href="../../../or-tools/index.html">or-tools</a>/
            <a href="../../../or-tools/src/index.html">src</a>/
            <a href="../../../or-tools/src/constraint_solver/index.html">constraint_solver</a>/
            </tt></b></font>
        </td>
      </tr>
    </table>
  </div>
  <br />
    <!-- No subdirs found. -->
  <!-- End of header. -->
<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">or-tools/src/constraint_solver/routing.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="routing_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// Copyright 2010-2012 Google</span>
<a name="l00002"></a>00002 <span class="comment">// Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);</span>
<a name="l00003"></a>00003 <span class="comment">// you may not use this file except in compliance with the License.</span>
<a name="l00004"></a>00004 <span class="comment">// You may obtain a copy of the License at</span>
<a name="l00005"></a>00005 <span class="comment">//</span>
<a name="l00006"></a>00006 <span class="comment">//     http://www.apache.org/licenses/LICENSE-2.0</span>
<a name="l00007"></a>00007 <span class="comment">//</span>
<a name="l00008"></a>00008 <span class="comment">// Unless required by applicable law or agreed to in writing, software</span>
<a name="l00009"></a>00009 <span class="comment">// distributed under the License is distributed on an &quot;AS IS&quot; BASIS,</span>
<a name="l00010"></a>00010 <span class="comment">// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<a name="l00011"></a>00011 <span class="comment">// See the License for the specific language governing permissions and</span>
<a name="l00012"></a>00012 <span class="comment">// limitations under the License.</span>
<a name="l00013"></a>00013 
<a name="l00014"></a>00014 <span class="comment">// The vehicle routing library lets one model and solve generic vehicle routing</span>
<a name="l00015"></a>00015 <span class="comment">// problems ranging from the Traveling Salesman Problem to more complex</span>
<a name="l00016"></a>00016 <span class="comment">// problems such as the Capacitated Vehicle Routing Problem with Time Windows.</span>
<a name="l00017"></a>00017 <span class="comment">// The objective of a vehicle routing problem is to build routes covering a set</span>
<a name="l00018"></a>00018 <span class="comment">// of nodes minimizing the overall cost of the routes (usually proportional to</span>
<a name="l00019"></a>00019 <span class="comment">// the sum of the lengths of each segment of the routes) while respecting some</span>
<a name="l00020"></a>00020 <span class="comment">// problem-specific constraints (such as the length of a route). A route is</span>
<a name="l00021"></a>00021 <span class="comment">// equivalent to a path connecting nodes, starting/ending at specific</span>
<a name="l00022"></a>00022 <span class="comment">// starting/ending nodes.</span>
<a name="l00023"></a>00023 <span class="comment">// The term &quot;vehicle routing&quot; is historical and the category of problems solved</span>
<a name="l00024"></a>00024 <span class="comment">// is not limited to the routing of vehicles: any problem involving finding</span>
<a name="l00025"></a>00025 <span class="comment">// routes visiting a given number of nodes optimally falls under this category</span>
<a name="l00026"></a>00026 <span class="comment">// of problems, such as finding the optimal sequence in a playlist.</span>
<a name="l00027"></a>00027 <span class="comment">// The literature around vehicle routing problems is extremelly dense but one</span>
<a name="l00028"></a>00028 <span class="comment">// can find some basic introductions in the following links:</span>
<a name="l00029"></a>00029 <span class="comment">// http://en.wikipedia.org/wiki/Travelling_salesman_problem</span>
<a name="l00030"></a>00030 <span class="comment">// http://www.tsp.gatech.edu/history/index.html</span>
<a name="l00031"></a>00031 <span class="comment">// http://en.wikipedia.org/wiki/Vehicle_routing_problem</span>
<a name="l00032"></a>00032 <span class="comment">//</span>
<a name="l00033"></a>00033 <span class="comment">// The vehicle routing library is a vertical layer above the constraint</span>
<a name="l00034"></a>00034 <span class="comment">// programming library (constraint_programming:cp).</span>
<a name="l00035"></a>00035 <span class="comment">// One has access to all underlying constrained variables of the vehicle</span>
<a name="l00036"></a>00036 <span class="comment">// routing model which can therefore be enriched by adding any constraint</span>
<a name="l00037"></a>00037 <span class="comment">// available in the constraint programming library.</span>
<a name="l00038"></a>00038 <span class="comment">// There are two sets of variables available:</span>
<a name="l00039"></a>00039 <span class="comment">// - path variables:</span>
<a name="l00040"></a>00040 <span class="comment">//   * &quot;next(i)&quot; variables representing the immediate successor of the node</span>
<a name="l00041"></a>00041 <span class="comment">//     corresponding to i; use IndexToNode() to get the node corresponding to</span>
<a name="l00042"></a>00042 <span class="comment">//     a &quot;next&quot; variable value; note that node indices are strongly typed</span>
<a name="l00043"></a>00043 <span class="comment">//     integers (cf. base/int-type.h);</span>
<a name="l00044"></a>00044 <span class="comment">//   * &quot;vehicle(i)&quot; variables representing the vehicle route to which the</span>
<a name="l00045"></a>00045 <span class="comment">//     node corresponding to i belongs;</span>
<a name="l00046"></a>00046 <span class="comment">//   * &quot;active(i)&quot; boolean variables, true if the node corresponding to i is</span>
<a name="l00047"></a>00047 <span class="comment">//     visited and false if not; this can be false when nodes are either</span>
<a name="l00048"></a>00048 <span class="comment">//     optional or part of a disjunction;</span>
<a name="l00049"></a>00049 <span class="comment">// - dimension variables, used when one is accumulating quantities along routes,</span>
<a name="l00050"></a>00050 <span class="comment">//   such as weight or volume carried, distance or time:</span>
<a name="l00051"></a>00051 <span class="comment">//   * &quot;cumul(i,d)&quot; variables representing the quantity of dimension d when</span>
<a name="l00052"></a>00052 <span class="comment">//     arriving at the node corresponding to i;</span>
<a name="l00053"></a>00053 <span class="comment">//   * &quot;transit(i,d)&quot; variables representing the quantity of dimension d added</span>
<a name="l00054"></a>00054 <span class="comment">//     after visiting the node corresponding to i.</span>
<a name="l00055"></a>00055 <span class="comment">// Solving the vehicle routing problems is mainly done using approximate methods</span>
<a name="l00056"></a>00056 <span class="comment">// (namely local search,</span>
<a name="l00057"></a>00057 <span class="comment">// cf. http://en.wikipedia.org/wiki/Local_search_(optimization)), potentially</span>
<a name="l00058"></a>00058 <span class="comment">// combined with exact techniques based on dynamic programming and exhaustive</span>
<a name="l00059"></a>00059 <span class="comment">// tree search.</span>
<a name="l00060"></a>00060 <span class="comment">//</span>
<a name="l00061"></a>00061 <span class="comment">// Advanced tips: Flags are available to tune the search used to solve routing</span>
<a name="l00062"></a>00062 <span class="comment">// problems. Here is a quick overview of the ones one might want to modify:</span>
<a name="l00063"></a>00063 <span class="comment">// - Limiting the search for solutions:</span>
<a name="l00064"></a>00064 <span class="comment">//   * routing_solution_limit (default: kint64max): stop the search after</span>
<a name="l00065"></a>00065 <span class="comment">//     finding &#39;routing_solution_limit&#39; improving solutions;</span>
<a name="l00066"></a>00066 <span class="comment">//   * routing_time_limit (default: kint64max): stop the search after</span>
<a name="l00067"></a>00067 <span class="comment">//     &#39;routing_time_limit&#39; milliseconds;</span>
<a name="l00068"></a>00068 <span class="comment">// - Customizing search:</span>
<a name="l00069"></a>00069 <span class="comment">//   * routing_first_solution (default: select the first node with an unbound</span>
<a name="l00070"></a>00070 <span class="comment">//     successor and connect it to the first available node): selects the</span>
<a name="l00071"></a>00071 <span class="comment">//     heuristic to build a first solution which will then be improved by local</span>
<a name="l00072"></a>00072 <span class="comment">//     search; possible values are GlobalCheapestArc (iteratively connect two</span>
<a name="l00073"></a>00073 <span class="comment">//     nodes which produce the cheapest route segment), LocalCheapestArc (select</span>
<a name="l00074"></a>00074 <span class="comment">//     the first node with an unbound successor and connect it to the node</span>
<a name="l00075"></a>00075 <span class="comment">//     which produces the cheapest route segment), PathCheapestArc (starting</span>
<a name="l00076"></a>00076 <span class="comment">//     from a route &quot;start&quot; node, connect it to the node which produces the</span>
<a name="l00077"></a>00077 <span class="comment">//     cheapest route segment, then extend the route by iterating on the last</span>
<a name="l00078"></a>00078 <span class="comment">//     node added to the route).</span>
<a name="l00079"></a>00079 <span class="comment">//   * Local search neighborhoods:</span>
<a name="l00080"></a>00080 <span class="comment">//     - routing_no_lns (default: false): forbids the use of Large Neighborhood</span>
<a name="l00081"></a>00081 <span class="comment">//       Search (LNS); LNS can find good solutions but is usually very slow.</span>
<a name="l00082"></a>00082 <span class="comment">//       Refer to the description of PATHLNS in the LocalSearchOperators enum</span>
<a name="l00083"></a>00083 <span class="comment">//       in constraint_solver.h for more information.</span>
<a name="l00084"></a>00084 <span class="comment">//     - routing_no_tsp (default: true): forbids the use of exact methods to</span>
<a name="l00085"></a>00085 <span class="comment">//       solve &quot;sub&quot;-traveling salesman problems (TSPs) of the current model</span>
<a name="l00086"></a>00086 <span class="comment">//       (such as sub-parts of a route, or one route in a multiple route</span>
<a name="l00087"></a>00087 <span class="comment">//       problem). Uses dynamic programming to solve such TSPs with a maximum</span>
<a name="l00088"></a>00088 <span class="comment">//       size (in number of nodes) up to cp_local_search_tsp_opt_size (flag with</span>
<a name="l00089"></a>00089 <span class="comment">//       a default value of 13 nodes). It is not activated by default because it</span>
<a name="l00090"></a>00090 <span class="comment">//       can slow down the search.</span>
<a name="l00091"></a>00091 <span class="comment">//   * Meta-heuritics: used to guide the search out of local minima found by</span>
<a name="l00092"></a>00092 <span class="comment">//     local search. Note that, in general, a search with metaheuristics</span>
<a name="l00093"></a>00093 <span class="comment">//     activated never stops, therefore one must specify a search limit.</span>
<a name="l00094"></a>00094 <span class="comment">//     Several types of metaheuristics are provided:</span>
<a name="l00095"></a>00095 <span class="comment">//     - routing_guided_local_search (default: false): activates guided local</span>
<a name="l00096"></a>00096 <span class="comment">//       search (cf. http://en.wikipedia.org/wiki/Guided_Local_Search);</span>
<a name="l00097"></a>00097 <span class="comment">//       this is generally the most efficient metaheuristic for vehicle</span>
<a name="l00098"></a>00098 <span class="comment">//       routing;</span>
<a name="l00099"></a>00099 <span class="comment">//     - routing_simulated_annealing (default: false): activates simulated</span>
<a name="l00100"></a>00100 <span class="comment">//       annealing (cf. http://en.wikipedia.org/wiki/Simulated_annealing);</span>
<a name="l00101"></a>00101 <span class="comment">//     - routing_tabu_search (default: false): activates tabu search (cf.</span>
<a name="l00102"></a>00102 <span class="comment">//       http://en.wikipedia.org/wiki/Tabu_search).</span>
<a name="l00103"></a>00103 <span class="comment">//</span>
<a name="l00104"></a>00104 <span class="comment">// Code sample:</span>
<a name="l00105"></a>00105 <span class="comment">// Here is a simple example solving a traveling salesman problem given a cost</span>
<a name="l00106"></a>00106 <span class="comment">// function callback (returns the cost of a route segment):</span>
<a name="l00107"></a>00107 <span class="comment">//</span>
<a name="l00108"></a>00108 <span class="comment">// - Define a custom distance/cost function from a node to another; in this</span>
<a name="l00109"></a>00109 <span class="comment">//   example just returns the sum of the node indices (note the conversion from</span>
<a name="l00110"></a>00110 <span class="comment">//   the strongly-typed indices to integers):</span>
<a name="l00111"></a>00111 <span class="comment">//</span>
<a name="l00112"></a>00112 <span class="comment">//     int64 MyDistance(RoutingModel::NodeIndex from,</span>
<a name="l00113"></a>00113 <span class="comment">//                      RoutingModel::NodeIndex to) {</span>
<a name="l00114"></a>00114 <span class="comment">//       return (from + to).value();</span>
<a name="l00115"></a>00115 <span class="comment">//     }</span>
<a name="l00116"></a>00116 <span class="comment">//</span>
<a name="l00117"></a>00117 <span class="comment">// - Create a routing model for a given problem size (int number of nodes) and</span>
<a name="l00118"></a>00118 <span class="comment">//   number of routes (here 1):</span>
<a name="l00119"></a>00119 <span class="comment">//</span>
<a name="l00120"></a>00120 <span class="comment">//     RoutingModel routing(...number of nodes..., 1);</span>
<a name="l00121"></a>00121 <span class="comment">//</span>
<a name="l00122"></a>00122 <span class="comment">// - Set the cost function by passing a permanent callback to the distance</span>
<a name="l00123"></a>00123 <span class="comment">//   accessor here. The callback has the following signature:</span>
<a name="l00124"></a>00124 <span class="comment">//   ResultCallback2&lt;int64, int64, int64&gt;.</span>
<a name="l00125"></a>00125 <span class="comment">//</span>
<a name="l00126"></a>00126 <span class="comment">//    routing.SetCost(NewPermanentCallback(MyDistance));</span>
<a name="l00127"></a>00127 <span class="comment">//</span>
<a name="l00128"></a>00128 <span class="comment">// - Find a solution using Solve(), returns a solution if any (owned by</span>
<a name="l00129"></a>00129 <span class="comment">//   routing):</span>
<a name="l00130"></a>00130 <span class="comment">//</span>
<a name="l00131"></a>00131 <span class="comment">//    const Assignment* solution = routing.Solve();</span>
<a name="l00132"></a>00132 <span class="comment">//    CHECK(solution != NULL);</span>
<a name="l00133"></a>00133 <span class="comment">//</span>
<a name="l00134"></a>00134 <span class="comment">// - Inspect the solution cost and route (only one route here:</span>
<a name="l00135"></a>00135 <span class="comment">//</span>
<a name="l00136"></a>00136 <span class="comment">//    LG &lt;&lt; &quot;Cost &quot; &lt;&lt; solution-&gt;ObjectiveValue();</span>
<a name="l00137"></a>00137 <span class="comment">//    const int route_number = 0;</span>
<a name="l00138"></a>00138 <span class="comment">//    for (int64 node = routing.Start(route_number);</span>
<a name="l00139"></a>00139 <span class="comment">//         !routing.IsEnd(node);</span>
<a name="l00140"></a>00140 <span class="comment">//         node = solution-&gt;Value(routing.NextVar(node))) {</span>
<a name="l00141"></a>00141 <span class="comment">//      LG &lt;&lt; routing.IndexToNode(node);</span>
<a name="l00142"></a>00142 <span class="comment">//    }</span>
<a name="l00143"></a>00143 <span class="comment">//</span>
<a name="l00144"></a>00144 <span class="comment">// More information on the usage of the routing library can be found here:</span>
<a name="l00145"></a>00145 <span class="comment">// More information on the range of vehicle routing problems the library can</span>
<a name="l00146"></a>00146 <span class="comment">// tackle can be found here:</span>
<a name="l00147"></a>00147 <span class="comment">// Keywords: Vehicle Routing, Traveling Salesman Problem, TSP, VRP, CVRPTW, PDP.</span>
<a name="l00148"></a>00148 
<a name="l00149"></a>00149 <span class="preprocessor">#ifndef OR_TOOLS_CONSTRAINT_SOLVER_ROUTING_H_</span>
<a name="l00150"></a>00150 <span class="preprocessor"></span><span class="preprocessor">#define OR_TOOLS_CONSTRAINT_SOLVER_ROUTING_H_</span>
<a name="l00151"></a>00151 <span class="preprocessor"></span>
<a name="l00152"></a>00152 <span class="preprocessor">#include &lt;stddef.h&gt;</span>
<a name="l00153"></a>00153 <span class="preprocessor">#include &quot;base/hash.h&quot;</span>
<a name="l00154"></a>00154 <span class="preprocessor">#include &quot;base/hash.h&quot;</span>
<a name="l00155"></a>00155 <span class="preprocessor">#include &lt;string&gt;</span>
<a name="l00156"></a>00156 <span class="preprocessor">#include &lt;utility&gt;</span>
<a name="l00157"></a>00157 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00158"></a>00158 
<a name="l00159"></a>00159 <span class="preprocessor">#include &quot;base/callback-types.h&quot;</span>
<a name="l00160"></a>00160 <span class="preprocessor">#include &quot;base/commandlineflags.h&quot;</span>
<a name="l00161"></a>00161 <span class="preprocessor">#include &quot;base/integral_types.h&quot;</span>
<a name="l00162"></a>00162 <span class="preprocessor">#include &quot;base/macros.h&quot;</span>
<a name="l00163"></a>00163 <span class="preprocessor">#include &quot;base/scoped_ptr.h&quot;</span>
<a name="l00164"></a>00164 <span class="preprocessor">#include &quot;base/int-type-indexed-vector.h&quot;</span>
<a name="l00165"></a>00165 <span class="preprocessor">#include &quot;base/int-type.h&quot;</span>
<a name="l00166"></a>00166 <span class="preprocessor">#include &quot;base/hash.h&quot;</span>
<a name="l00167"></a>00167 <span class="preprocessor">#include &quot;<a class="code" href="constraint__solver_8h.html">constraint_solver/constraint_solver.h</a>&quot;</span>
<a name="l00168"></a>00168 
<a name="l00169"></a>00169 <span class="keyword">namespace </span>operations_research {
<a name="l00170"></a>00170 
<a name="l00171"></a>00171 <span class="keyword">class </span>LocalSearchOperator;
<a name="l00172"></a>00172 <span class="keyword">class </span>RoutingCache;
<a name="l00173"></a>00173 
<a name="l00174"></a>00174 <span class="comment">// The type must be defined outside the class RoutingModel, SWIG does not parse</span>
<a name="l00175"></a>00175 <span class="comment">// it correctly if it&#39;s inside.</span>
<a name="l00176"></a>00176 <a class="code" href="namespaceoperations__research.html#a30cd29caf636315c7dff36737342b4f8" title="The type must be defined outside the class RoutingModel, SWIG does not parse it correctly if it&#39;s ins...">DEFINE_INT_TYPE</a>(_RoutingModel_NodeIndex, <span class="keywordtype">int</span>);
<a name="l00177"></a>00177 
<a name="l00178"></a><a class="code" href="classoperations__research_1_1RoutingModel.html">00178</a> <span class="keyword">class </span><a class="code" href="classoperations__research_1_1RoutingModel.html">RoutingModel</a> {
<a name="l00179"></a>00179  <span class="keyword">public</span>:
<a name="l00180"></a>00180   <span class="comment">// First solution strategies, used as starting point of local search.</span>
<a name="l00181"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#a6f38b3ff9a2e455677856d97e339da6d">00181</a>   <span class="keyword">enum</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#a6f38b3ff9a2e455677856d97e339da6d" title="First solution strategies, used as starting point of local search.">RoutingStrategy</a> {
<a name="l00182"></a>00182     <span class="comment">// Select the first node with an unbound successor and connect it to the</span>
<a name="l00183"></a>00183     <span class="comment">// first available node.</span>
<a name="l00184"></a>00184     <span class="comment">// This is equivalent to the CHOOSE_FIRST_UNBOUND strategy combined with</span>
<a name="l00185"></a>00185     <span class="comment">// ASSIGN_MIN_VALUE (cf. constraint_solver.h).</span>
<a name="l00186"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#a6f38b3ff9a2e455677856d97e339da6da6f1cf5f6e92490db44f50b647f90f56c">00186</a>     <a class="code" href="classoperations__research_1_1RoutingModel.html#a6f38b3ff9a2e455677856d97e339da6da6f1cf5f6e92490db44f50b647f90f56c" title="Select the first node with an unbound successor and connect it to the first available node...">ROUTING_DEFAULT_STRATEGY</a>,
<a name="l00187"></a>00187     <span class="comment">// Iteratively connect two nodes which produce the cheapest route segment.</span>
<a name="l00188"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#a6f38b3ff9a2e455677856d97e339da6dabb864ec796188b14106446600fd330f8">00188</a>     <a class="code" href="classoperations__research_1_1RoutingModel.html#a6f38b3ff9a2e455677856d97e339da6dabb864ec796188b14106446600fd330f8" title="Iteratively connect two nodes which produce the cheapest route segment.">ROUTING_GLOBAL_CHEAPEST_ARC</a>,
<a name="l00189"></a>00189     <span class="comment">// Select the first node with an unbound successor and connect it to the</span>
<a name="l00190"></a>00190     <span class="comment">// node which produces the cheapest route segment.</span>
<a name="l00191"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#a6f38b3ff9a2e455677856d97e339da6da4c2534a4236ed8b1c937467da71a55a7">00191</a>     <a class="code" href="classoperations__research_1_1RoutingModel.html#a6f38b3ff9a2e455677856d97e339da6da4c2534a4236ed8b1c937467da71a55a7" title="Select the first node with an unbound successor and connect it to the node which produces the cheapes...">ROUTING_LOCAL_CHEAPEST_ARC</a>,
<a name="l00192"></a>00192     <span class="comment">// Starting from a route &quot;start&quot; node, connect it to the node which produces</span>
<a name="l00193"></a>00193     <span class="comment">// the cheapest route segment, then extend the route by iterating on the</span>
<a name="l00194"></a>00194     <span class="comment">// last node added to the route.</span>
<a name="l00195"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#a6f38b3ff9a2e455677856d97e339da6dab84d29872d22f4d9cf1a1fd21c05dcf4">00195</a>     <a class="code" href="classoperations__research_1_1RoutingModel.html#a6f38b3ff9a2e455677856d97e339da6dab84d29872d22f4d9cf1a1fd21c05dcf4" title="Starting from a route &quot;start&quot; node, connect it to the node which produces the cheapest route segment...">ROUTING_PATH_CHEAPEST_ARC</a>,
<a name="l00196"></a>00196     <span class="comment">// Same as ROUTING_PATH_CHEAPEST_ARC, except that arc costs are evaluated</span>
<a name="l00197"></a>00197     <span class="comment">// using the function passed to RoutingModel::SetFirstSolutionEvaluator().</span>
<a name="l00198"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#a6f38b3ff9a2e455677856d97e339da6daa62cb62928ab4fdd761e7568e8737083">00198</a>     <a class="code" href="classoperations__research_1_1RoutingModel.html#a6f38b3ff9a2e455677856d97e339da6daa62cb62928ab4fdd761e7568e8737083" title="Same as ROUTING_PATH_CHEAPEST_ARC, except that arc costs are evaluated using the function passed to R...">ROUTING_EVALUATOR_STRATEGY</a>,
<a name="l00199"></a>00199     <span class="comment">// Make all node inactive. Only finds a solution if nodes are optional (are</span>
<a name="l00200"></a>00200     <span class="comment">// element of a disjunction constraint with a finite penalty cost).</span>
<a name="l00201"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#a6f38b3ff9a2e455677856d97e339da6dae11807c0a7813e4ace23425911f4c582">00201</a>     <a class="code" href="classoperations__research_1_1RoutingModel.html#a6f38b3ff9a2e455677856d97e339da6dae11807c0a7813e4ace23425911f4c582" title="Make all node inactive.">ROUTING_ALL_UNPERFORMED</a>,
<a name="l00202"></a>00202     <span class="comment">// Iteratively build a solution by inserting nodes at their cheapest (best)</span>
<a name="l00203"></a>00203     <span class="comment">// position. As of 2/2012, only works on models with optional nodes</span>
<a name="l00204"></a>00204     <span class="comment">// (with finite penalty costs).</span>
<a name="l00205"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#a6f38b3ff9a2e455677856d97e339da6da9d13a87ad6a77f4fc63f28af90451c6e">00205</a>     <a class="code" href="classoperations__research_1_1RoutingModel.html#a6f38b3ff9a2e455677856d97e339da6da9d13a87ad6a77f4fc63f28af90451c6e" title="Iteratively build a solution by inserting nodes at their cheapest (best) position.">ROUTING_BEST_INSERTION</a>,
<a name="l00206"></a>00206   };
<a name="l00207"></a>00207 
<a name="l00208"></a>00208   <span class="comment">// Metaheuristics used to guide the search. Apart greedy descent, they will</span>
<a name="l00209"></a>00209   <span class="comment">// try to escape local minima.</span>
<a name="l00210"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#a0f0bd97e25af059ab2e8e7f263afc8e1">00210</a>   <span class="keyword">enum</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#a0f0bd97e25af059ab2e8e7f263afc8e1" title="Metaheuristics used to guide the search.">RoutingMetaheuristic</a> {
<a name="l00211"></a>00211     <span class="comment">// Accepts improving (cost-reducing) local search neighbors until a local</span>
<a name="l00212"></a>00212     <span class="comment">// minimum is reached. This is the default heuristic.</span>
<a name="l00213"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#a0f0bd97e25af059ab2e8e7f263afc8e1a582d58f88269611b1065f8c4c5e58fed">00213</a>     <a class="code" href="classoperations__research_1_1RoutingModel.html#a0f0bd97e25af059ab2e8e7f263afc8e1a582d58f88269611b1065f8c4c5e58fed" title="Accepts improving (cost-reducing) local search neighbors until a local minimum is reached...">ROUTING_GREEDY_DESCENT</a>,
<a name="l00214"></a>00214     <span class="comment">// Uses guided local search to escape local minima</span>
<a name="l00215"></a>00215     <span class="comment">// (cf. http://en.wikipedia.org/wiki/Guided_Local_Search); this is</span>
<a name="l00216"></a>00216     <span class="comment">// generally the most efficient metaheuristic for vehicle routing.</span>
<a name="l00217"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#a0f0bd97e25af059ab2e8e7f263afc8e1a89a5042196881240e6b78a52c87b1588">00217</a>     <a class="code" href="classoperations__research_1_1RoutingModel.html#a0f0bd97e25af059ab2e8e7f263afc8e1a89a5042196881240e6b78a52c87b1588" title="Uses guided local search to escape local minima (cf.">ROUTING_GUIDED_LOCAL_SEARCH</a>,
<a name="l00218"></a>00218     <span class="comment">// Uses simulated annealing to escape local minima</span>
<a name="l00219"></a>00219     <span class="comment">// (cf. http://en.wikipedia.org/wiki/Simulated_annealing).</span>
<a name="l00220"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#a0f0bd97e25af059ab2e8e7f263afc8e1aa166bff87b6170318a34b1af38fc98fe">00220</a>     <a class="code" href="classoperations__research_1_1RoutingModel.html#a0f0bd97e25af059ab2e8e7f263afc8e1aa166bff87b6170318a34b1af38fc98fe" title="Uses simulated annealing to escape local minima (cf.">ROUTING_SIMULATED_ANNEALING</a>,
<a name="l00221"></a>00221     <span class="comment">// Uses tabu search to escape local minima</span>
<a name="l00222"></a>00222     <span class="comment">// (cf. http://en.wikipedia.org/wiki/Tabu_search).</span>
<a name="l00223"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#a0f0bd97e25af059ab2e8e7f263afc8e1a0dd042e16dd28cfdd370382de2f51a35">00223</a>     <a class="code" href="classoperations__research_1_1RoutingModel.html#a0f0bd97e25af059ab2e8e7f263afc8e1a0dd042e16dd28cfdd370382de2f51a35" title="Uses tabu search to escape local minima (cf.">ROUTING_TABU_SEARCH</a>,
<a name="l00224"></a>00224   };
<a name="l00225"></a>00225 
<a name="l00226"></a>00226   <span class="comment">// Status of the search.</span>
<a name="l00227"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#a328a19213729eec49288128061bc2044">00227</a>   <span class="keyword">enum</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#a328a19213729eec49288128061bc2044" title="Status of the search.">Status</a> {
<a name="l00228"></a>00228     <span class="comment">// Problem not solved yet (before calling RoutingModel::Solve()).</span>
<a name="l00229"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#a328a19213729eec49288128061bc2044a73b2e79d6934957ec86f60a69036e055">00229</a>     <a class="code" href="classoperations__research_1_1RoutingModel.html#a328a19213729eec49288128061bc2044a73b2e79d6934957ec86f60a69036e055" title="Problem not solved yet (before calling RoutingModel::Solve()).">ROUTING_NOT_SOLVED</a>,
<a name="l00230"></a>00230     <span class="comment">// Problem solved successfully after calling RoutingModel::Solve().</span>
<a name="l00231"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#a328a19213729eec49288128061bc2044afb2bbe1690a8f9be1575ade98e4e61dd">00231</a>     <a class="code" href="classoperations__research_1_1RoutingModel.html#a328a19213729eec49288128061bc2044afb2bbe1690a8f9be1575ade98e4e61dd" title="Problem solved successfully after calling RoutingModel::Solve().">ROUTING_SUCCESS</a>,
<a name="l00232"></a>00232     <span class="comment">// No solution found to the problem after calling RoutingModel::Solve().</span>
<a name="l00233"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#a328a19213729eec49288128061bc2044acaf3d0fb83c0c1be4881362c0e2e0592">00233</a>     <a class="code" href="classoperations__research_1_1RoutingModel.html#a328a19213729eec49288128061bc2044acaf3d0fb83c0c1be4881362c0e2e0592" title="No solution found to the problem after calling RoutingModel::Solve().">ROUTING_FAIL</a>,
<a name="l00234"></a>00234     <span class="comment">// Time limit reached before finding a solution with RoutingModel::Solve().</span>
<a name="l00235"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#a328a19213729eec49288128061bc2044aa8b79310730408de7bae61835301a93e">00235</a>     <a class="code" href="classoperations__research_1_1RoutingModel.html#a328a19213729eec49288128061bc2044aa8b79310730408de7bae61835301a93e" title="Time limit reached before finding a solution with RoutingModel::Solve().">ROUTING_FAIL_TIMEOUT</a>
<a name="l00236"></a>00236   };
<a name="l00237"></a>00237 
<a name="l00238"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#a2e9f7da1126111a69ee0b7bcf7edeffe">00238</a>   <span class="keyword">typedef</span> _RoutingModel_NodeIndex <a class="code" href="classoperations__research_1_1RoutingModel.html#a2e9f7da1126111a69ee0b7bcf7edeffe">NodeIndex</a>;
<a name="l00239"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#a5ad22b1565f2e5b1735601a824629289">00239</a>   <span class="keyword">typedef</span> ResultCallback2&lt;int64, NodeIndex, NodeIndex&gt; <a class="code" href="classoperations__research_1_1RoutingModel.html#a5ad22b1565f2e5b1735601a824629289">NodeEvaluator2</a>;
<a name="l00240"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#a4251c2ca5b1558dc69e696991c853ae3">00240</a>   <span class="keyword">typedef</span> std::vector&lt;std::pair&lt;int, int&gt; &gt; <a class="code" href="classoperations__research_1_1RoutingModel.html#a4251c2ca5b1558dc69e696991c853ae3">NodePairs</a>;
<a name="l00241"></a>00241 
<a name="l00242"></a>00242   <span class="comment">// Constants with an index of the first node (to be used in for loops for</span>
<a name="l00243"></a>00243   <span class="comment">// iteration), and a special index to signalize an invalid/unused value.</span>
<a name="l00244"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#a2fe3671c7bac6070d8c3f03a12722c70">00244</a>   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#a2e9f7da1126111a69ee0b7bcf7edeffe">NodeIndex</a> <a class="code" href="classoperations__research_1_1RoutingModel.html#a2fe3671c7bac6070d8c3f03a12722c70" title="Constants with an index of the first node (to be used in for loops for iteration), and a special index to signalize an invalid/unused value.">kFirstNode</a>;
<a name="l00245"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#a86465650deeb78a3ff59ac0fe5af60bf">00245</a>   <span class="keyword">static</span> <span class="keyword">const</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#a2e9f7da1126111a69ee0b7bcf7edeffe">NodeIndex</a> <a class="code" href="classoperations__research_1_1RoutingModel.html#a86465650deeb78a3ff59ac0fe5af60bf">kInvalidNodeIndex</a>;
<a name="l00246"></a>00246 
<a name="l00247"></a>00247   <span class="comment">// Supposes a single depot. A depot is the start and end node of the route of</span>
<a name="l00248"></a>00248   <span class="comment">// a vehicle.</span>
<a name="l00249"></a>00249   <a class="code" href="classoperations__research_1_1RoutingModel.html#a67e90b8e5fba64a285e2eed07a39b2ca" title="Supposes a single depot.">RoutingModel</a>(<span class="keywordtype">int</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#a20c1bf5b1ac1353c9e132774f3f7e1df" title="Sizes and indices Returns the number of nodes in the model.">nodes</a>, <span class="keywordtype">int</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#a9236103b3dca8a4112bd2a8be05b0b71" title="Returns the number of vehicle routes in the model.">vehicles</a>);
<a name="l00250"></a>00250   <span class="comment">// Constructor taking a vector of (start node, end node) pairs for each</span>
<a name="l00251"></a>00251   <span class="comment">// vehicle route. Used to model multiple depots.</span>
<a name="l00252"></a>00252   <a class="code" href="classoperations__research_1_1RoutingModel.html#a67e90b8e5fba64a285e2eed07a39b2ca" title="Supposes a single depot.">RoutingModel</a>(<span class="keywordtype">int</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#a20c1bf5b1ac1353c9e132774f3f7e1df" title="Sizes and indices Returns the number of nodes in the model.">nodes</a>,
<a name="l00253"></a>00253                <span class="keywordtype">int</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#a9236103b3dca8a4112bd2a8be05b0b71" title="Returns the number of vehicle routes in the model.">vehicles</a>,
<a name="l00254"></a>00254                <span class="keyword">const</span> std::vector&lt;std::pair&lt;NodeIndex, NodeIndex&gt; &gt;&amp; start_end);
<a name="l00255"></a>00255   <span class="comment">// Constructor taking vectors of start nodes and end nodes for each</span>
<a name="l00256"></a>00256   <span class="comment">// vehicle route. Used to model multiple depots.</span>
<a name="l00257"></a>00257   <span class="comment">// TODO(user): added to simplify SWIG wrapping. Remove when swigging</span>
<a name="l00258"></a>00258   <span class="comment">// std::vector&lt;std::pair&lt;int, int&gt; &gt; is ok.</span>
<a name="l00259"></a>00259   <a class="code" href="classoperations__research_1_1RoutingModel.html#a67e90b8e5fba64a285e2eed07a39b2ca" title="Supposes a single depot.">RoutingModel</a>(<span class="keywordtype">int</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#a20c1bf5b1ac1353c9e132774f3f7e1df" title="Sizes and indices Returns the number of nodes in the model.">nodes</a>,
<a name="l00260"></a>00260                <span class="keywordtype">int</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#a9236103b3dca8a4112bd2a8be05b0b71" title="Returns the number of vehicle routes in the model.">vehicles</a>,
<a name="l00261"></a>00261                <span class="keyword">const</span> std::vector&lt;NodeIndex&gt;&amp; starts,
<a name="l00262"></a>00262                <span class="keyword">const</span> std::vector&lt;NodeIndex&gt;&amp; ends);
<a name="l00263"></a>00263   <a class="code" href="classoperations__research_1_1RoutingModel.html#a6ee4a1c4dda01e2138f79ed5ec913754">~RoutingModel</a>();
<a name="l00264"></a>00264 
<a name="l00265"></a>00265   <span class="comment">// Model creation</span>
<a name="l00266"></a>00266 
<a name="l00267"></a>00267   <span class="comment">// Methods to add dimensions to routes; dimensions represent quantities</span>
<a name="l00268"></a>00268   <span class="comment">// accumulated at nodes along the routes. They represent quantities such as</span>
<a name="l00269"></a>00269   <span class="comment">// weights or volumes carried along the route, or distance or times.</span>
<a name="l00270"></a>00270   <span class="comment">// Quantities at a node are represented by &quot;cumul&quot; variables and the increase</span>
<a name="l00271"></a>00271   <span class="comment">// or decrease of quantities between nodes are represented by &quot;transit&quot;</span>
<a name="l00272"></a>00272   <span class="comment">// variables. These variables are linked as follows:</span>
<a name="l00273"></a>00273   <span class="comment">// if j == next(i), cumul(j) = cumul(i) + transit(i) + slack(i)</span>
<a name="l00274"></a>00274   <span class="comment">// where slack is a positive slack variable (can represent waiting times for</span>
<a name="l00275"></a>00275   <span class="comment">// a time dimension).</span>
<a name="l00276"></a>00276 
<a name="l00277"></a>00277   <span class="comment">// Creates a dimension where the transit variable is constrained to be</span>
<a name="l00278"></a>00278   <span class="comment">// equal to evaluator(i, next(i)); &#39;slack_max&#39; is the upper bound of the</span>
<a name="l00279"></a>00279   <span class="comment">// slack variable and &#39;capacity&#39; is the upper bound of the cumul variables.</span>
<a name="l00280"></a>00280   <span class="comment">// &#39;name&#39; is the name used to reference the dimension; this name is used to</span>
<a name="l00281"></a>00281   <span class="comment">// get cumul and transit variables from the routing model.</span>
<a name="l00282"></a>00282   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#a0c519ba1ff5b906df2a576451feb379c" title="Model creation.">AddDimension</a>(<a class="code" href="classoperations__research_1_1RoutingModel.html#a5ad22b1565f2e5b1735601a824629289">NodeEvaluator2</a>* evaluator,
<a name="l00283"></a>00283                     int64 slack_max,
<a name="l00284"></a>00284                     int64 capacity,
<a name="l00285"></a>00285                     <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; <a class="code" href="default__search_8cc.html#a1848ae81740c68c2502b2f176cfadcef" title="A name for logging purposes.">name</a>);
<a name="l00286"></a>00286   <span class="comment">// Creates a dimension where the transit variable is constrained to be</span>
<a name="l00287"></a>00287   <span class="comment">// equal to &#39;value&#39;; &#39;capacity&#39; is the upper bound of the cumul variables.</span>
<a name="l00288"></a>00288   <span class="comment">// &#39;name&#39; is the name used to reference the dimension; this name is used to</span>
<a name="l00289"></a>00289   <span class="comment">// get cumul and transit variables from the routing model.</span>
<a name="l00290"></a>00290   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#a366617606fccc8017b91a5efeae6c4cf" title="Creates a dimension where the transit variable is constrained to be equal to &#39;value&#39;; &#39;capacity&#39; is t...">AddConstantDimension</a>(int64 <a class="code" href="search_8cc.html#a21edc7ca4cc5802c8779d68556bc09cf">value</a>, int64 capacity, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; <a class="code" href="default__search_8cc.html#a1848ae81740c68c2502b2f176cfadcef" title="A name for logging purposes.">name</a>);
<a name="l00291"></a>00291   <span class="comment">// Creates a dimension where the transit variable is constrained to be</span>
<a name="l00292"></a>00292   <span class="comment">// equal to &#39;values[i]&#39; for node i; &#39;capacity&#39; is the upper bound of</span>
<a name="l00293"></a>00293   <span class="comment">// the cumul variables. &#39;name&#39; is the name used to reference the dimension;</span>
<a name="l00294"></a>00294   <span class="comment">// this name is used to get cumul and transit variables from the routing</span>
<a name="l00295"></a>00295   <span class="comment">// model.</span>
<a name="l00296"></a>00296   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#a665b56459ca82c4d791477466b8e621c" title="Creates a dimension where the transit variable is constrained to be equal to &#39;values[i]&#39; for node i; ...">AddVectorDimension</a>(<span class="keyword">const</span> int64* values,
<a name="l00297"></a>00297                           int64 capacity,
<a name="l00298"></a>00298                           <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; <a class="code" href="default__search_8cc.html#a1848ae81740c68c2502b2f176cfadcef" title="A name for logging purposes.">name</a>);
<a name="l00299"></a>00299   <span class="comment">// Creates a dimension where the transit variable is constrained to be</span>
<a name="l00300"></a>00300   <span class="comment">// equal to &#39;values[i][next[i]&#39; for node i; &#39;capacity&#39; is the upper bound of</span>
<a name="l00301"></a>00301   <span class="comment">// the cumul variables. &#39;name&#39; is the name used to reference the dimension;</span>
<a name="l00302"></a>00302   <span class="comment">// this name is used to get cumul and transit variables from the routing</span>
<a name="l00303"></a>00303   <span class="comment">// model.</span>
<a name="l00304"></a>00304   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#a7d00a87827f4216f9d209a82034e220a" title="Creates a dimension where the transit variable is constrained to be equal to &#39;values[i][next[i]&#39; for ...">AddMatrixDimension</a>(<span class="keyword">const</span> int64* <span class="keyword">const</span>* values,
<a name="l00305"></a>00305                           int64 capacity,
<a name="l00306"></a>00306                           <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; <a class="code" href="default__search_8cc.html#a1848ae81740c68c2502b2f176cfadcef" title="A name for logging purposes.">name</a>);
<a name="l00307"></a>00307   <span class="comment">// Constrains all nodes to be active (to belong to a route).</span>
<a name="l00308"></a>00308   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#afa5489925a39e8484fea85ad916ab72b" title="Constrains all nodes to be active (to belong to a route).">AddAllActive</a>();
<a name="l00309"></a>00309   <span class="comment">// Adds a disjunction constraint on the nodes: exactly one of the nodes is</span>
<a name="l00310"></a>00310   <span class="comment">// active. Start and end nodes of any vehicle cannot be part of a disjunction.</span>
<a name="l00311"></a>00311   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#ac2388945ac0d9e706b72c75a82f4baf0" title="Adds a disjunction constraint on the nodes: exactly one of the nodes is active.">AddDisjunction</a>(<span class="keyword">const</span> std::vector&lt;NodeIndex&gt;&amp; <a class="code" href="classoperations__research_1_1RoutingModel.html#a20c1bf5b1ac1353c9e132774f3f7e1df" title="Sizes and indices Returns the number of nodes in the model.">nodes</a>);
<a name="l00312"></a>00312   <span class="comment">// Adds a penalized disjunction constraint on the nodes: at most one of the</span>
<a name="l00313"></a>00313   <span class="comment">// nodes is active; if none are active a penalty cost is applied (this cost</span>
<a name="l00314"></a>00314   <span class="comment">// is added to the global cost function).</span>
<a name="l00315"></a>00315   <span class="comment">// This is equivalent to adding the constraint:</span>
<a name="l00316"></a>00316   <span class="comment">// p + Sum(i)active[i] == 1, where p is a boolean variable</span>
<a name="l00317"></a>00317   <span class="comment">// and the following cost to the cost function:</span>
<a name="l00318"></a>00318   <span class="comment">// p * penalty.</span>
<a name="l00319"></a>00319   <span class="comment">// &quot;penalty&quot; must be positive.</span>
<a name="l00320"></a>00320   <span class="comment">// Note: passing a vector with a single node will model an optional node</span>
<a name="l00321"></a>00321   <span class="comment">// with a penalty cost if it is not visited.</span>
<a name="l00322"></a>00322   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#ac2388945ac0d9e706b72c75a82f4baf0" title="Adds a disjunction constraint on the nodes: exactly one of the nodes is active.">AddDisjunction</a>(<span class="keyword">const</span> std::vector&lt;NodeIndex&gt;&amp; <a class="code" href="classoperations__research_1_1RoutingModel.html#a20c1bf5b1ac1353c9e132774f3f7e1df" title="Sizes and indices Returns the number of nodes in the model.">nodes</a>, int64 penalty);
<a name="l00323"></a>00323 <span class="preprocessor">#if defined(SWIGPYTHON)</span>
<a name="l00324"></a>00324 <span class="preprocessor"></span>  <span class="keywordtype">void</span> AddDisjunctionWithPenalty(<span class="keyword">const</span> std::vector&lt;NodeIndex&gt;&amp; <a class="code" href="classoperations__research_1_1RoutingModel.html#a20c1bf5b1ac1353c9e132774f3f7e1df" title="Sizes and indices Returns the number of nodes in the model.">nodes</a>,
<a name="l00325"></a>00325                                  int64 penalty) {
<a name="l00326"></a>00326     <a class="code" href="classoperations__research_1_1RoutingModel.html#ac2388945ac0d9e706b72c75a82f4baf0" title="Adds a disjunction constraint on the nodes: exactly one of the nodes is active.">AddDisjunction</a>(nodes, penalty);
<a name="l00327"></a>00327   }
<a name="l00328"></a>00328 <span class="preprocessor">#endif  // SWIGPYTHON</span>
<a name="l00329"></a>00329 <span class="preprocessor"></span>  <span class="comment">// Notifies that node1 and node2 form a pair of nodes which should belong</span>
<a name="l00330"></a>00330   <span class="comment">// to the same route. This methods helps the search find better solutions,</span>
<a name="l00331"></a>00331   <span class="comment">// especially in the local search phase.</span>
<a name="l00332"></a>00332   <span class="comment">// It should be called each time you have an equality constraint linking</span>
<a name="l00333"></a>00333   <span class="comment">// the vehicle variables of two node (including for instance pickup and</span>
<a name="l00334"></a>00334   <span class="comment">// delivery problems):</span>
<a name="l00335"></a>00335   <span class="comment">//     Solver* const solver = routing.solver();</span>
<a name="l00336"></a>00336   <span class="comment">//     solver-&gt;AddConstraint(solver-&gt;MakeEquality(</span>
<a name="l00337"></a>00337   <span class="comment">//         routing.VehicleVar(routing.NodeToIndex(node1)),</span>
<a name="l00338"></a>00338   <span class="comment">//         routing.VehicleVar(routing.NodeToIndex(node2))));</span>
<a name="l00339"></a>00339   <span class="comment">//     solver-&gt;AddPickupAndDelivery(node1, node2);</span>
<a name="l00340"></a>00340   <span class="comment">//</span>
<a name="l00341"></a>00341   <span class="comment">// TODO(user): Remove this when model introspection detects linked nodes.</span>
<a name="l00342"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#a646c16f383b852c39804223d77520e07">00342</a>   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#a646c16f383b852c39804223d77520e07">AddPickupAndDelivery</a>(<a class="code" href="classoperations__research_1_1RoutingModel.html#a2e9f7da1126111a69ee0b7bcf7edeffe">NodeIndex</a> node1, <a class="code" href="classoperations__research_1_1RoutingModel.html#a2e9f7da1126111a69ee0b7bcf7edeffe">NodeIndex</a> node2) {
<a name="l00343"></a>00343     pickup_delivery_pairs_.push_back(std::make_pair(<a class="code" href="classoperations__research_1_1RoutingModel.html#a6c88d9d5da962886bfe0924bc5ea6457" title="Returns the variable index from a node value.">NodeToIndex</a>(node1),
<a name="l00344"></a>00344                                                     <a class="code" href="classoperations__research_1_1RoutingModel.html#a6c88d9d5da962886bfe0924bc5ea6457" title="Returns the variable index from a node value.">NodeToIndex</a>(node2)));
<a name="l00345"></a>00345   }
<a name="l00346"></a>00346   <span class="comment">// Makes &#39;depot&#39; the starting node of all routes.</span>
<a name="l00347"></a>00347   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#afc62358888d00d45c4769cdc6e3d3cbb" title="Makes &#39;depot&#39; the starting node of all routes.">SetDepot</a>(<a class="code" href="classoperations__research_1_1RoutingModel.html#a2e9f7da1126111a69ee0b7bcf7edeffe">NodeIndex</a> depot);
<a name="l00348"></a>00348   <span class="comment">// Sets the cost function of the model such that the cost of a segment of a</span>
<a name="l00349"></a>00349   <span class="comment">// route between node &#39;from&#39; and &#39;to&#39; is evaluator(from, to), whatever the</span>
<a name="l00350"></a>00350   <span class="comment">// route or vehicle performing the route.</span>
<a name="l00351"></a>00351   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#aad67d6674b1bbfd192b094a78b98ae00" title="Sets the cost function of the model such that the cost of a segment of a route between node &#39;from&#39; an...">SetCost</a>(<a class="code" href="classoperations__research_1_1RoutingModel.html#a5ad22b1565f2e5b1735601a824629289">NodeEvaluator2</a>* evaluator);
<a name="l00352"></a>00352   <span class="comment">// Sets the cost function for a given vehicle route.</span>
<a name="l00353"></a>00353   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#a5acf5c0059bb744313072e90f9a6c13d" title="Sets the cost function for a given vehicle route.">SetVehicleCost</a>(<span class="keywordtype">int</span> vehicle, <a class="code" href="classoperations__research_1_1RoutingModel.html#a5ad22b1565f2e5b1735601a824629289">NodeEvaluator2</a>* evaluator);
<a name="l00354"></a>00354   <span class="comment">// The fixed cost of a route is taken into account if the route is</span>
<a name="l00355"></a>00355   <span class="comment">// not empty, aka there&#39;s at least one node on the route other than the</span>
<a name="l00356"></a>00356   <span class="comment">// first and last nodes.</span>
<a name="l00357"></a>00357   <span class="comment">// Gets the fixed cost of all vehicle routes if they are all the same;</span>
<a name="l00358"></a>00358   <span class="comment">// otherwise returns the fixed cost of the first vehicle route.</span>
<a name="l00359"></a>00359   <span class="comment">// Deprecated by GetVehicleFixedCost().</span>
<a name="l00360"></a>00360   int64 <a class="code" href="classoperations__research_1_1RoutingModel.html#a89f79076ce6ef6d5587f2ebe3439a073" title="The fixed cost of a route is taken into account if the route is not empty, aka there&#39;s at least one n...">GetRouteFixedCost</a>() <span class="keyword">const</span>;
<a name="l00361"></a>00361   <span class="comment">// Sets the fixed cost of all vehicle routes. It is equivalent to calling</span>
<a name="l00362"></a>00362   <span class="comment">// SetVehicleFixedCost on all vehicle routes.</span>
<a name="l00363"></a>00363   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#af387904bbb3960d15461d10e307f28f5" title="Sets the fixed cost of all vehicle routes.">SetRouteFixedCost</a>(int64 cost);
<a name="l00364"></a>00364   <span class="comment">// Returns the route fixed cost taken into account if the route of the</span>
<a name="l00365"></a>00365   <span class="comment">// vehicle is not empty, aka there&#39;s at least one node on the route other than</span>
<a name="l00366"></a>00366   <span class="comment">// the first and last nodes.</span>
<a name="l00367"></a>00367   int64 <a class="code" href="classoperations__research_1_1RoutingModel.html#a619c7630314932daf1b6338eb2285027" title="Returns the route fixed cost taken into account if the route of the vehicle is not empty...">GetVehicleFixedCost</a>(<span class="keywordtype">int</span> vehicle) <span class="keyword">const</span>;
<a name="l00368"></a>00368   <span class="comment">// Sets the fixed cost of one vehicle route.</span>
<a name="l00369"></a>00369   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#a51249142dcbabc08d16ae7f8dac64ab7" title="Sets the fixed cost of one vehicle route.">SetVehicleFixedCost</a>(<span class="keywordtype">int</span> vehicle, int64 cost);
<a name="l00370"></a>00370 
<a name="l00371"></a>00371 
<a name="l00372"></a>00372   <span class="comment">// Search</span>
<a name="l00373"></a>00373   <span class="comment">// Returns the strategy used to build a first solution.</span>
<a name="l00374"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#a0557e242e3fb2350c80576dc56f6e534">00374</a>   <a class="code" href="classoperations__research_1_1RoutingModel.html#a6f38b3ff9a2e455677856d97e339da6d" title="First solution strategies, used as starting point of local search.">RoutingStrategy</a> <a class="code" href="classoperations__research_1_1RoutingModel.html#a0557e242e3fb2350c80576dc56f6e534" title="Search Returns the strategy used to build a first solution.">first_solution_strategy</a>()<span class="keyword"> const </span>{
<a name="l00375"></a>00375     <span class="keywordflow">return</span> first_solution_strategy_;
<a name="l00376"></a>00376   }
<a name="l00377"></a>00377   <span class="comment">// Sets the strategy used to build a first solution.</span>
<a name="l00378"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#a68b6f5c365d384256ff87eff7d8b4920">00378</a>   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#a68b6f5c365d384256ff87eff7d8b4920" title="Sets the strategy used to build a first solution.">set_first_solution_strategy</a>(<a class="code" href="classoperations__research_1_1RoutingModel.html#a6f38b3ff9a2e455677856d97e339da6d" title="First solution strategies, used as starting point of local search.">RoutingStrategy</a> strategy) {
<a name="l00379"></a>00379     first_solution_strategy_ = strategy;
<a name="l00380"></a>00380   }
<a name="l00381"></a>00381   <span class="comment">// Gets/sets the evaluator used when the first solution heuristic is set to</span>
<a name="l00382"></a>00382   <span class="comment">// ROUTING_EVALUATOR_STRATEGY (variant of ROUTING_PATH_CHEAPEST_ARC using</span>
<a name="l00383"></a>00383   <span class="comment">// &#39;evaluator&#39; to sort node segments).</span>
<a name="l00384"></a>00384 <span class="preprocessor">#ifndef SWIG</span>
<a name="l00385"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#a81b797890236948ef7aa87d781ad7ec7">00385</a> <span class="preprocessor"></span>  <a class="code" href="classoperations__research_1_1Solver.html#a487b521ee809f0f4ee397b9f6ea06f59">Solver::IndexEvaluator2</a>* <a class="code" href="classoperations__research_1_1RoutingModel.html#a81b797890236948ef7aa87d781ad7ec7" title="Gets/sets the evaluator used when the first solution heuristic is set to ROUTING_EVALUATOR_STRATEGY (...">first_solution_evaluator</a>()<span class="keyword"> const </span>{
<a name="l00386"></a>00386     <span class="keywordflow">return</span> first_solution_evaluator_.get();
<a name="l00387"></a>00387   }
<a name="l00388"></a>00388 <span class="preprocessor">#endif</span>
<a name="l00389"></a>00389 <span class="preprocessor"></span>  <span class="comment">// Takes ownership of evaluator.</span>
<a name="l00390"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#a5853301edd4fdc7f45cf38a7bb2ec049">00390</a>   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#a5853301edd4fdc7f45cf38a7bb2ec049" title="Takes ownership of evaluator.">SetFirstSolutionEvaluator</a>(<a class="code" href="classoperations__research_1_1Solver.html#a487b521ee809f0f4ee397b9f6ea06f59">Solver::IndexEvaluator2</a>* evaluator) {
<a name="l00391"></a>00391     first_solution_evaluator_.reset(evaluator);
<a name="l00392"></a>00392   }
<a name="l00393"></a>00393   <span class="comment">// If a first solution flag has been set (to a value different than Default),</span>
<a name="l00394"></a>00394   <span class="comment">// returns the corresponding strategy, otherwise returns the strategy which</span>
<a name="l00395"></a>00395   <span class="comment">// was set.</span>
<a name="l00396"></a>00396   <a class="code" href="classoperations__research_1_1RoutingModel.html#a6f38b3ff9a2e455677856d97e339da6d" title="First solution strategies, used as starting point of local search.">RoutingStrategy</a> <a class="code" href="classoperations__research_1_1RoutingModel.html#ada509d882b2aed55dc59021c3a149c7e" title="If a first solution flag has been set (to a value different than Default), returns the corresponding ...">GetSelectedFirstSolutionStrategy</a>() <span class="keyword">const</span>;
<a name="l00397"></a>00397   <span class="comment">// Adds a local search operator to the set of operators used to solve the</span>
<a name="l00398"></a>00398   <span class="comment">// vehicle routing problem.</span>
<a name="l00399"></a>00399   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#a421504809966a6abc4cd725c48780060" title="Adds a local search operator to the set of operators used to solve the vehicle routing problem...">AddLocalSearchOperator</a>(<a class="code" href="classoperations__research_1_1LocalSearchOperator.html" title="&lt; !defined(SWIG)">LocalSearchOperator</a>* ls_operator);
<a name="l00400"></a>00400   <span class="comment">// Returns the metaheuristic used.</span>
<a name="l00401"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#aac8ac681a6a334db9b808208d616235a">00401</a>   <a class="code" href="classoperations__research_1_1RoutingModel.html#a0f0bd97e25af059ab2e8e7f263afc8e1" title="Metaheuristics used to guide the search.">RoutingMetaheuristic</a> <a class="code" href="classoperations__research_1_1RoutingModel.html#aac8ac681a6a334db9b808208d616235a" title="Returns the metaheuristic used.">metaheuristic</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> metaheuristic_; }
<a name="l00402"></a>00402   <span class="comment">// Sets the metaheuristic to be used.</span>
<a name="l00403"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#ad38e1582f53db33bca76ff9c2a4ab0c1">00403</a>   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#ad38e1582f53db33bca76ff9c2a4ab0c1" title="Sets the metaheuristic to be used.">set_metaheuristic</a>(<a class="code" href="classoperations__research_1_1RoutingModel.html#a0f0bd97e25af059ab2e8e7f263afc8e1" title="Metaheuristics used to guide the search.">RoutingMetaheuristic</a> <a class="code" href="classoperations__research_1_1RoutingModel.html#aac8ac681a6a334db9b808208d616235a" title="Returns the metaheuristic used.">metaheuristic</a>) {
<a name="l00404"></a>00404     metaheuristic_ = <a class="code" href="classoperations__research_1_1RoutingModel.html#aac8ac681a6a334db9b808208d616235a" title="Returns the metaheuristic used.">metaheuristic</a>;
<a name="l00405"></a>00405   }
<a name="l00406"></a>00406   <span class="comment">// If a metaheuristic flag has been set, returns the corresponding</span>
<a name="l00407"></a>00407   <span class="comment">// metaheuristic, otherwise returns the metaheuristic which was set.</span>
<a name="l00408"></a>00408   <a class="code" href="classoperations__research_1_1RoutingModel.html#a0f0bd97e25af059ab2e8e7f263afc8e1" title="Metaheuristics used to guide the search.">RoutingMetaheuristic</a> <a class="code" href="classoperations__research_1_1RoutingModel.html#a22f429a899b1c00cad6e6ff04a117ee4" title="If a metaheuristic flag has been set, returns the corresponding metaheuristic, otherwise returns the ...">GetSelectedMetaheuristic</a>() <span class="keyword">const</span>;
<a name="l00409"></a>00409   <span class="comment">// Adds a search monitor to the search used to solve the routing model.</span>
<a name="l00410"></a>00410   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#a4928a8a9f21302a215a6f26dda90eef1" title="Adds a search monitor to the search used to solve the routing model.">AddSearchMonitor</a>(<a class="code" href="classoperations__research_1_1SearchMonitor.html" title="A search monitor is a simple set of callbacks to monitor all search events.">SearchMonitor</a>* <span class="keyword">const</span> monitor);
<a name="l00411"></a>00411   <span class="comment">// Closes the current routing model; after this method is called, no</span>
<a name="l00412"></a>00412   <span class="comment">// modification to the model can be done, but RoutesToAssignment becomes</span>
<a name="l00413"></a>00413   <span class="comment">// available. Note that CloseModel() is automatically called by Solve() and</span>
<a name="l00414"></a>00414   <span class="comment">// other methods that produce solution.</span>
<a name="l00415"></a>00415   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#ae84602b98050ad382d725e35326aab3d" title="Closes the current routing model; after this method is called, no modification to the model can be do...">CloseModel</a>();
<a name="l00416"></a>00416   <span class="comment">// Solves the current routing model; closes the current model.</span>
<a name="l00417"></a>00417   <span class="keyword">const</span> <a class="code" href="classoperations__research_1_1Assignment.html" title="Assignment.">Assignment</a>* <a class="code" href="classoperations__research_1_1RoutingModel.html#a79e79d503b81e378485b402293a5828c" title="Solves the current routing model; closes the current model.">Solve</a>(<span class="keyword">const</span> <a class="code" href="classoperations__research_1_1Assignment.html" title="Assignment.">Assignment</a>* assignment = NULL);
<a name="l00418"></a>00418   <span class="comment">// Computes a lower bound to the routing problem solving a linear assignment</span>
<a name="l00419"></a>00419   <span class="comment">// problem. The routing model must be closed before calling this method.</span>
<a name="l00420"></a>00420   <span class="comment">// Note that problems with node disjunction constraints (including optional</span>
<a name="l00421"></a>00421   <span class="comment">// nodes) and non-homogenous costs are not supported (the method returns 0 in</span>
<a name="l00422"></a>00422   <span class="comment">// these cases).</span>
<a name="l00423"></a>00423   <span class="comment">// TODO(user): Add support for non-homogeneous costs and disjunctions.</span>
<a name="l00424"></a>00424   int64 <a class="code" href="classoperations__research_1_1RoutingModel.html#ab94b51a3ffa939b647cc2fc0eeff8400" title="Computes a lower bound to the routing problem solving a linear assignment problem.">ComputeLowerBound</a>();
<a name="l00425"></a>00425   <span class="comment">// Returns the current status of the routing model.</span>
<a name="l00426"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#acc9cbc5c610da66a71220657d366c471">00426</a>   <a class="code" href="classoperations__research_1_1RoutingModel.html#a328a19213729eec49288128061bc2044" title="Status of the search.">Status</a> <a class="code" href="classoperations__research_1_1RoutingModel.html#acc9cbc5c610da66a71220657d366c471" title="Returns the current status of the routing model.">status</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> status_; }
<a name="l00427"></a>00427   <span class="comment">// Applies a lock chain to the next search. &#39;locks&#39; represents an ordered</span>
<a name="l00428"></a>00428   <span class="comment">// vector of nodes representing a partial route which will be fixed during the</span>
<a name="l00429"></a>00429   <span class="comment">// next search; it will constrain next variables such that:</span>
<a name="l00430"></a>00430   <span class="comment">// next[locks[i]] == locks[i+1].</span>
<a name="l00431"></a>00431   <span class="comment">// Returns the next variable at the end of the locked chain; this variable is</span>
<a name="l00432"></a>00432   <span class="comment">// not locked. An assignment containing the locks can be obtained by calling</span>
<a name="l00433"></a>00433   <span class="comment">// PreAssignment().</span>
<a name="l00434"></a>00434   <a class="code" href="classoperations__research_1_1IntVar.html" title="The class IntVar is a subset of IntExpr.">IntVar</a>* <a class="code" href="classoperations__research_1_1RoutingModel.html#a4db46f77834dbcbbf4e54ec6b0e76047" title="Applies a lock chain to the next search.">ApplyLocks</a>(<span class="keyword">const</span> std::vector&lt;int&gt;&amp; locks);
<a name="l00435"></a>00435   <span class="comment">// Applies lock chains to all vehicles to the next search, such that locks[p]</span>
<a name="l00436"></a>00436   <span class="comment">// is the lock chain for route p. Returns false if the locks do not contain</span>
<a name="l00437"></a>00437   <span class="comment">// valid routes; expects that the routes do not contain the depots,</span>
<a name="l00438"></a>00438   <span class="comment">// i.e. there are empty vectors in place of empty routes.</span>
<a name="l00439"></a>00439   <span class="comment">// If close_routes is set to true, adds the end nodes to the route of each</span>
<a name="l00440"></a>00440   <span class="comment">// vehicle and deactivates other nodes.</span>
<a name="l00441"></a>00441   <span class="comment">// An assignment containing the locks can be obtained by calling</span>
<a name="l00442"></a>00442   <span class="comment">// PreAssignment().</span>
<a name="l00443"></a>00443   <span class="keywordtype">bool</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#a1bde9342e06eb1d4d12986a8d3be5d30" title="Applies lock chains to all vehicles to the next search, such that locks[p] is the lock chain for rout...">ApplyLocksToAllVehicles</a>(<span class="keyword">const</span> std::vector&lt;std::vector&lt;NodeIndex&gt; &gt;&amp; locks,
<a name="l00444"></a>00444                                <span class="keywordtype">bool</span> close_routes);
<a name="l00445"></a>00445   <span class="comment">// Returns an assignment used to fix some of the variables of the problem.</span>
<a name="l00446"></a>00446   <span class="comment">// In practice, this assignment locks partial routes of the problem. This</span>
<a name="l00447"></a>00447   <span class="comment">// can be used in the context of locking the parts of the routes which have</span>
<a name="l00448"></a>00448   <span class="comment">// already been driven in online routing problems.</span>
<a name="l00449"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#adb8c703e9d29b2046db433b8c74e338c">00449</a>   <span class="keyword">const</span> <a class="code" href="classoperations__research_1_1Assignment.html" title="Assignment.">Assignment</a>* <span class="keyword">const</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#adb8c703e9d29b2046db433b8c74e338c" title="Returns an assignment used to fix some of the variables of the problem.">PreAssignment</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> preassignment_; }
<a name="l00450"></a>00450   <span class="comment">// Writes the current solution to a file containing an AssignmentProto.</span>
<a name="l00451"></a>00451   <span class="comment">// Returns false if the file cannot be opened or if there is no current</span>
<a name="l00452"></a>00452   <span class="comment">// solution.</span>
<a name="l00453"></a>00453   <span class="keywordtype">bool</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#a07804a0abc492e87498bb10f0aea0843" title="Writes the current solution to a file containing an AssignmentProto.">WriteAssignment</a>(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; file_name) <span class="keyword">const</span>;
<a name="l00454"></a>00454   <span class="comment">// Reads an assignment from a file and returns the current solution.</span>
<a name="l00455"></a>00455   <span class="comment">// Returns NULL if the file cannot be opened or if the assignment is not</span>
<a name="l00456"></a>00456   <span class="comment">// valid.</span>
<a name="l00457"></a>00457   <a class="code" href="classoperations__research_1_1Assignment.html" title="Assignment.">Assignment</a>* <a class="code" href="classoperations__research_1_1RoutingModel.html#ad1201189a16e0c6dd658c2331f023d3c" title="Reads an assignment from a file and returns the current solution.">ReadAssignment</a>(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; file_name);
<a name="l00458"></a>00458   <span class="comment">// Restores an assignment as a solution in the routing model and returns the</span>
<a name="l00459"></a>00459   <span class="comment">// new solution. Returns NULL if the assignment is not valid.</span>
<a name="l00460"></a>00460   <a class="code" href="classoperations__research_1_1Assignment.html" title="Assignment.">Assignment</a>* <a class="code" href="classoperations__research_1_1RoutingModel.html#a6bcbb26b40d556ec60449c93f81bc5d5" title="Restores an assignment as a solution in the routing model and returns the new solution.">RestoreAssignment</a>(<span class="keyword">const</span> <a class="code" href="classoperations__research_1_1Assignment.html" title="Assignment.">Assignment</a>&amp; solution);
<a name="l00461"></a>00461   <span class="comment">// Restores the routes as the current solution. Returns NULL if the solution</span>
<a name="l00462"></a>00462   <span class="comment">// cannot be restored (routes do not contain a valid solution).</span>
<a name="l00463"></a>00463   <span class="comment">// Note that calling this method will run the solver to assign values to the</span>
<a name="l00464"></a>00464   <span class="comment">// dimension variables; this may take considerable amount of time, especially</span>
<a name="l00465"></a>00465   <span class="comment">// when using dimensions with slack.</span>
<a name="l00466"></a>00466   <a class="code" href="classoperations__research_1_1Assignment.html" title="Assignment.">Assignment</a>* <a class="code" href="classoperations__research_1_1RoutingModel.html#a6a9ea98665bf82cb8d542453ccf2ee9b" title="Restores the routes as the current solution.">ReadAssignmentFromRoutes</a>(<span class="keyword">const</span> std::vector&lt;std::vector&lt;NodeIndex&gt; &gt;&amp; routes,
<a name="l00467"></a>00467                                        <span class="keywordtype">bool</span> ignore_inactive_nodes);
<a name="l00468"></a>00468   <span class="comment">// Fills an assignment from a specification of the routes of the vehicles. The</span>
<a name="l00469"></a>00469   <span class="comment">// routes are specified as lists of nodes that appear on the routes of the</span>
<a name="l00470"></a>00470   <span class="comment">// vehicles. The indices of the outer vector in &#39;routes&#39; correspond to</span>
<a name="l00471"></a>00471   <span class="comment">// vehicles IDs, the inner vector contain the nodes on the routes for the</span>
<a name="l00472"></a>00472   <span class="comment">// given vehicle. The inner vectors must not contain the start and end nodes,</span>
<a name="l00473"></a>00473   <span class="comment">// as these are determined by the routing model.</span>
<a name="l00474"></a>00474   <span class="comment">// Sets the value of NextVars in the assignment, adding the variables to the</span>
<a name="l00475"></a>00475   <span class="comment">// assignment if necessary. The method does not touch other variables in the</span>
<a name="l00476"></a>00476   <span class="comment">// assignment. The method can only be called after the model is closed.</span>
<a name="l00477"></a>00477   <span class="comment">// With ignore_inactive_nodes set to false, this method will fail (return</span>
<a name="l00478"></a>00478   <span class="comment">// NULL) in case some of the route contain nodes that are deactivated in the</span>
<a name="l00479"></a>00479   <span class="comment">// model; when set to true, these nodes will be skipped.</span>
<a name="l00480"></a>00480   <span class="comment">// Returns true if the route was successfully loaded. However, such assignment</span>
<a name="l00481"></a>00481   <span class="comment">// still might not be a valid solution to the routing problem due to more</span>
<a name="l00482"></a>00482   <span class="comment">// complex constraints; it is advisible to call solver()-&gt;CheckSolution()</span>
<a name="l00483"></a>00483   <span class="comment">// afterwards.</span>
<a name="l00484"></a>00484   <span class="keywordtype">bool</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#ac7560ce4597182518954a502dea3c91d" title="Fills an assignment from a specification of the routes of the vehicles.">RoutesToAssignment</a>(<span class="keyword">const</span> std::vector&lt;std::vector&lt;NodeIndex&gt; &gt;&amp; routes,
<a name="l00485"></a>00485                           <span class="keywordtype">bool</span> ignore_inactive_nodes,
<a name="l00486"></a>00486                           <span class="keywordtype">bool</span> close_routes,
<a name="l00487"></a>00487                           <a class="code" href="classoperations__research_1_1Assignment.html" title="Assignment.">Assignment</a>* <span class="keyword">const</span> assignment) <span class="keyword">const</span>;
<a name="l00488"></a>00488   <span class="comment">// Converts the solution in the given assignment to routes for all vehicles.</span>
<a name="l00489"></a>00489   <span class="comment">// Expects that assignment contains a valid solution (i.e. routes for all</span>
<a name="l00490"></a>00490   <span class="comment">// vehicles end with an end node for that vehicle).</span>
<a name="l00491"></a>00491   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#a67a2a68974ee09e85bba490c78bf4c0a" title="Converts the solution in the given assignment to routes for all vehicles.">AssignmentToRoutes</a>(<span class="keyword">const</span> <a class="code" href="classoperations__research_1_1Assignment.html" title="Assignment.">Assignment</a>&amp; assignment,
<a name="l00492"></a>00492                           std::vector&lt;std::vector&lt;NodeIndex&gt; &gt;* <span class="keyword">const</span> routes) <span class="keyword">const</span>;
<a name="l00493"></a>00493   <span class="comment">// Returns a compacted version of the given assignment, in which all vehicles</span>
<a name="l00494"></a>00494   <span class="comment">// with id lower or equal to some N have non-empty routes, and all vehicles</span>
<a name="l00495"></a>00495   <span class="comment">// with id greater than N have empty routes. Does not take ownership of the</span>
<a name="l00496"></a>00496   <span class="comment">// returned object.</span>
<a name="l00497"></a>00497   <span class="comment">// If found, the cost of the compact assignment is the same as in the</span>
<a name="l00498"></a>00498   <span class="comment">// original assignment and it preserves the values of &#39;active&#39; variables.</span>
<a name="l00499"></a>00499   <span class="comment">// Returns NULL if a compact assignment was not found.</span>
<a name="l00500"></a>00500   <span class="comment">// This method only works in homogenous mode, and it only swaps equivalent</span>
<a name="l00501"></a>00501   <span class="comment">// vehicles (vehicles with the same start and end nodes). When creating the</span>
<a name="l00502"></a>00502   <span class="comment">// compact assignment, the empty plan is replaced by the route assigned to the</span>
<a name="l00503"></a>00503   <span class="comment">// compatible vehicle with the highest id. Note that with more complex</span>
<a name="l00504"></a>00504   <span class="comment">// constraints on vehicle variables, this method might fail even if a compact</span>
<a name="l00505"></a>00505   <span class="comment">// solution exists.</span>
<a name="l00506"></a>00506   <span class="comment">// This method changes the vehicle and dimension variables as necessary.</span>
<a name="l00507"></a>00507   <span class="comment">// While compacting the solution, only basic checks on vehicle variables are</span>
<a name="l00508"></a>00508   <span class="comment">// performed; the complete solution is checked at the end and if it is not</span>
<a name="l00509"></a>00509   <span class="comment">// valid, no attempts to repair it are made (instead, the method returns</span>
<a name="l00510"></a>00510   <span class="comment">// NULL).</span>
<a name="l00511"></a>00511   <a class="code" href="classoperations__research_1_1Assignment.html" title="Assignment.">Assignment</a>* <a class="code" href="classoperations__research_1_1RoutingModel.html#a6d67433ee6cb41435ecec227ba2d9139" title="Returns a compacted version of the given assignment, in which all vehicles with id lower or equal to ...">CompactAssignment</a>(<span class="keyword">const</span> <a class="code" href="classoperations__research_1_1Assignment.html" title="Assignment.">Assignment</a>&amp; assignment) <span class="keyword">const</span>;
<a name="l00512"></a>00512   <span class="comment">// Adds an extra variable to the vehicle routing assignment.</span>
<a name="l00513"></a>00513   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#a1a11f61fc549eed60a0ee9fe937fbac6" title="Adds an extra variable to the vehicle routing assignment.">AddToAssignment</a>(<a class="code" href="classoperations__research_1_1IntVar.html" title="The class IntVar is a subset of IntExpr.">IntVar</a>* <span class="keyword">const</span> <a class="code" href="expr__array_8cc.html#a472a99923cbe11ae7b5a5d157d9ad465">var</a>);
<a name="l00514"></a>00514 
<a name="l00515"></a>00515 
<a name="l00516"></a>00516   <span class="comment">// Model inspection.</span>
<a name="l00517"></a>00517   <span class="comment">// Returns the variable index of the starting node of a vehicle route.</span>
<a name="l00518"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#ae6c177c3dd7409f9dd60c10220e043e1">00518</a>   int64 <a class="code" href="classoperations__research_1_1RoutingModel.html#ae6c177c3dd7409f9dd60c10220e043e1" title="Model inspection.">Start</a>(<span class="keywordtype">int</span> vehicle)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> starts_[vehicle]; }
<a name="l00519"></a>00519   <span class="comment">// Returns the variable index of the ending node of a vehicle route.</span>
<a name="l00520"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#a15fbc75264cec5b173e7f1dc6cc92703">00520</a>   int64 <a class="code" href="classoperations__research_1_1RoutingModel.html#a15fbc75264cec5b173e7f1dc6cc92703" title="Returns the variable index of the ending node of a vehicle route.">End</a>(<span class="keywordtype">int</span> vehicle)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> ends_[vehicle]; }
<a name="l00521"></a>00521   <span class="comment">// Returns true if &#39;index&#39; represents the first node of a route.</span>
<a name="l00522"></a>00522   <span class="keywordtype">bool</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#a7f1ed907da5e1918e60d7a206e7dc0d7" title="Returns true if &#39;index&#39; represents the first node of a route.">IsStart</a>(int64 <a class="code" href="pack_8cc.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>) <span class="keyword">const</span>;
<a name="l00523"></a>00523   <span class="comment">// Returns true if &#39;index&#39; represents the last node of a route.</span>
<a name="l00524"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#ad542c0716ca8948f8e6240b2ff24d878">00524</a>   <span class="keywordtype">bool</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#ad542c0716ca8948f8e6240b2ff24d878" title="Returns true if &#39;index&#39; represents the last node of a route.">IsEnd</a>(int64 <a class="code" href="pack_8cc.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> index &gt;= <a class="code" href="classoperations__research_1_1RoutingModel.html#afcb19f39e0670d42a070dc34246416c9" title="Returns the number of next variables in the model.">Size</a>(); }
<a name="l00525"></a>00525   int64 <a class="code" href="classoperations__research_1_1RoutingModel.html#a1d7c2d652d782ca3930583b98ee3f15d" title="Return high cost if connecting to end node; used in cost-based first solution.">GetFirstSolutionCost</a>(int64 i, int64 j);
<a name="l00526"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#a5a4f31c561411ae89bf266e41ceb509c">00526</a>   <span class="keywordtype">bool</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#a5a4f31c561411ae89bf266e41ceb509c">homogeneous_costs</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> homogeneous_costs_; }
<a name="l00527"></a>00527   <span class="comment">// Assignment inspection</span>
<a name="l00528"></a>00528   <span class="comment">// Returns the variable index of the node directly after the node</span>
<a name="l00529"></a>00529   <span class="comment">// corresponding to &#39;index&#39; in &#39;assignment&#39;.</span>
<a name="l00530"></a>00530   int64 <a class="code" href="classoperations__research_1_1RoutingModel.html#ac3b6c0ed8ce1a0f2efe650c6eb7e4c1f" title="Assignment inspection Returns the variable index of the node directly after the node corresponding to...">Next</a>(<span class="keyword">const</span> <a class="code" href="classoperations__research_1_1Assignment.html" title="Assignment.">Assignment</a>&amp; assignment, int64 <a class="code" href="pack_8cc.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>) <span class="keyword">const</span>;
<a name="l00531"></a>00531   <span class="comment">// Returns true if the route of &#39;vehicle&#39; is non empty in &#39;assignment&#39;.</span>
<a name="l00532"></a>00532   <span class="keywordtype">bool</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#a47b43075c4e09efcdc59b3368b0242fb" title="Returns true if the route of &#39;vehicle&#39; is non empty in &#39;assignment&#39;.">IsVehicleUsed</a>(<span class="keyword">const</span> <a class="code" href="classoperations__research_1_1Assignment.html" title="Assignment.">Assignment</a>&amp; assignment, <span class="keywordtype">int</span> vehicle) <span class="keyword">const</span>;
<a name="l00533"></a>00533   <span class="comment">// Variables</span>
<a name="l00534"></a>00534 <span class="preprocessor">#if !defined(SWIG)</span>
<a name="l00535"></a>00535 <span class="preprocessor"></span>  <span class="comment">// Returns all next variables of the model, such that Nexts(i) is the next</span>
<a name="l00536"></a>00536   <span class="comment">// variable of the node corresponding to i.</span>
<a name="l00537"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#ad0bcbeb12364a5869fd36d11a8b65471">00537</a>   <span class="keyword">const</span> std::vector&lt;IntVar*&gt;&amp; <a class="code" href="classoperations__research_1_1RoutingModel.html#ad0bcbeb12364a5869fd36d11a8b65471" title="Variables.">Nexts</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> nexts_; }
<a name="l00538"></a>00538   <span class="comment">// Returns all vehicle variables of the model,  such that VehicleVars(i) is</span>
<a name="l00539"></a>00539   <span class="comment">// the vehicle variable of the node corresponding to i.</span>
<a name="l00540"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#a4ab2be7183b79406003541170c54881a">00540</a>   <span class="keyword">const</span> std::vector&lt;IntVar*&gt;&amp; <a class="code" href="classoperations__research_1_1RoutingModel.html#a4ab2be7183b79406003541170c54881a" title="Returns all vehicle variables of the model, such that VehicleVars(i) is the vehicle variable of the n...">VehicleVars</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> vehicle_vars_; }
<a name="l00541"></a>00541 <span class="preprocessor">#endif</span>
<a name="l00542"></a>00542 <span class="preprocessor"></span>  <span class="comment">// Returns the next variable of the node corresponding to index.</span>
<a name="l00543"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#a131f2181343be56fd836b64747fe9f49">00543</a>   <a class="code" href="classoperations__research_1_1IntVar.html" title="The class IntVar is a subset of IntExpr.">IntVar</a>* <a class="code" href="classoperations__research_1_1RoutingModel.html#a131f2181343be56fd836b64747fe9f49" title="Returns the next variable of the node corresponding to index.">NextVar</a>(int64 <a class="code" href="pack_8cc.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> nexts_[<a class="code" href="pack_8cc.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>]; }
<a name="l00544"></a>00544   <span class="comment">// Returns the active variable of the node corresponding to index.</span>
<a name="l00545"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#a5254602b653dda44c6f6a6611e8cd6f2">00545</a>   <a class="code" href="classoperations__research_1_1IntVar.html" title="The class IntVar is a subset of IntExpr.">IntVar</a>* <a class="code" href="classoperations__research_1_1RoutingModel.html#a5254602b653dda44c6f6a6611e8cd6f2" title="Returns the active variable of the node corresponding to index.">ActiveVar</a>(int64 <a class="code" href="pack_8cc.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> active_[<a class="code" href="pack_8cc.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>]; }
<a name="l00546"></a>00546   <span class="comment">// Returns the vehicle variable of the node corresponding to index.</span>
<a name="l00547"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#a618a961dcb65e02d6d310a83d1f60722">00547</a>   <a class="code" href="classoperations__research_1_1IntVar.html" title="The class IntVar is a subset of IntExpr.">IntVar</a>* <a class="code" href="classoperations__research_1_1RoutingModel.html#a618a961dcb65e02d6d310a83d1f60722" title="Returns the vehicle variable of the node corresponding to index.">VehicleVar</a>(int64 <a class="code" href="pack_8cc.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>)<span class="keyword"> const </span>{ <span class="keywordflow">return</span> vehicle_vars_[<a class="code" href="pack_8cc.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>]; }
<a name="l00548"></a>00548   <span class="comment">// Returns the cumul variable for the dimension named &#39;name&#39;.</span>
<a name="l00549"></a>00549   <a class="code" href="classoperations__research_1_1IntVar.html" title="The class IntVar is a subset of IntExpr.">IntVar</a>* <a class="code" href="classoperations__research_1_1RoutingModel.html#aa1e366cd50bfdfac06e032d9eb22612f" title="Returns the cumul variable for the dimension named &#39;name&#39;.">CumulVar</a>(int64 <a class="code" href="pack_8cc.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; <a class="code" href="default__search_8cc.html#a1848ae81740c68c2502b2f176cfadcef" title="A name for logging purposes.">name</a>) <span class="keyword">const</span>;
<a name="l00550"></a>00550   <span class="comment">// Returns the transit variable for the dimension named &#39;name&#39;.</span>
<a name="l00551"></a>00551   <a class="code" href="classoperations__research_1_1IntVar.html" title="The class IntVar is a subset of IntExpr.">IntVar</a>* <a class="code" href="classoperations__research_1_1RoutingModel.html#a8d0a9a90e331b113628418013cfa813e" title="Returns the transit variable for the dimension named &#39;name&#39;.">TransitVar</a>(int64 <a class="code" href="pack_8cc.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; <a class="code" href="default__search_8cc.html#a1848ae81740c68c2502b2f176cfadcef" title="A name for logging purposes.">name</a>) <span class="keyword">const</span>;
<a name="l00552"></a>00552   <span class="comment">// Return the slack variable for the dimension named &#39;name&#39;.</span>
<a name="l00553"></a>00553   <a class="code" href="classoperations__research_1_1IntVar.html" title="The class IntVar is a subset of IntExpr.">IntVar</a>* <a class="code" href="classoperations__research_1_1RoutingModel.html#ad2d8e442bcf7cb1ba759edc13a3a9389" title="Return the slack variable for the dimension named &#39;name&#39;.">SlackVar</a>(int64 <a class="code" href="pack_8cc.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; <a class="code" href="default__search_8cc.html#a1848ae81740c68c2502b2f176cfadcef" title="A name for logging purposes.">name</a>) <span class="keyword">const</span>;
<a name="l00554"></a>00554   <span class="comment">// Returns the global cost variable which is being minimized.</span>
<a name="l00555"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#ac76b2c7544a4fc56d06945cbde4480a6">00555</a>   <a class="code" href="classoperations__research_1_1IntVar.html" title="The class IntVar is a subset of IntExpr.">IntVar</a>* <a class="code" href="classoperations__research_1_1RoutingModel.html#ac76b2c7544a4fc56d06945cbde4480a6" title="Returns the global cost variable which is being minimized.">CostVar</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> cost_; }
<a name="l00556"></a>00556   <span class="comment">// Returns the cost of the segment between two nodes for a given vehicle</span>
<a name="l00557"></a>00557   <span class="comment">// route. Input are variable indices of node.</span>
<a name="l00558"></a>00558   int64 <a class="code" href="classoperations__research_1_1RoutingModel.html#a2fc423d06fca461e5220ee4c42672f37" title="Returns the cost of the segment between two nodes for a given vehicle route.">GetCost</a>(int64 from_index, int64 to_index, int64 vehicle);
<a name="l00559"></a>00559   <span class="comment">// Returns the cost of the segment between two nodes supposing all vehicle</span>
<a name="l00560"></a>00560   <span class="comment">// costs are the same (returns the cost for the first vehicle otherwise).</span>
<a name="l00561"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#a6f274d2ace4d354140b9c086ef4dceee">00561</a>   int64 <a class="code" href="classoperations__research_1_1RoutingModel.html#a6f274d2ace4d354140b9c086ef4dceee" title="Returns the cost of the segment between two nodes supposing all vehicle costs are the same (returns t...">GetHomogeneousCost</a>(int64 i, int64 j) {
<a name="l00562"></a>00562     <span class="keywordflow">return</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#a2fc423d06fca461e5220ee4c42672f37" title="Returns the cost of the segment between two nodes for a given vehicle route.">GetCost</a>(i, j, 0);
<a name="l00563"></a>00563   }
<a name="l00564"></a>00564   <span class="comment">// Returns the number of different vehicle cost callbacks in the model.</span>
<a name="l00565"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#a9a73f66587912a44e43be4c8c840256c">00565</a>   <span class="keywordtype">int</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#a9a73f66587912a44e43be4c8c840256c" title="Returns the number of different vehicle cost callbacks in the model.">GetVehicleCostCount</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> cost_callback_vehicles_.size(); }
<a name="l00566"></a>00566 
<a name="l00567"></a>00567   <span class="comment">// Returns the underlying constraint solver. Can be used to add extra</span>
<a name="l00568"></a>00568   <span class="comment">// constraints and/or modify search algoithms.</span>
<a name="l00569"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#a35a094db917c3c996826285424bb2f54">00569</a>   <a class="code" href="classoperations__research_1_1Solver.html" title="Solver Class.">Solver</a>* <a class="code" href="classoperations__research_1_1RoutingModel.html#a35a094db917c3c996826285424bb2f54" title="Returns the underlying constraint solver.">solver</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> solver_.get(); }
<a name="l00570"></a>00570 
<a name="l00571"></a>00571   <span class="comment">// Sizes and indices</span>
<a name="l00572"></a>00572   <span class="comment">// Returns the number of nodes in the model.</span>
<a name="l00573"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#a20c1bf5b1ac1353c9e132774f3f7e1df">00573</a>   <span class="keywordtype">int</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#a20c1bf5b1ac1353c9e132774f3f7e1df" title="Sizes and indices Returns the number of nodes in the model.">nodes</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> nodes_; }
<a name="l00574"></a>00574   <span class="comment">// Returns the number of vehicle routes in the model.</span>
<a name="l00575"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#a9236103b3dca8a4112bd2a8be05b0b71">00575</a>   <span class="keywordtype">int</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#a9236103b3dca8a4112bd2a8be05b0b71" title="Returns the number of vehicle routes in the model.">vehicles</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> vehicles_; }
<a name="l00576"></a>00576   <span class="comment">// Returns the number of next variables in the model.</span>
<a name="l00577"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#afcb19f39e0670d42a070dc34246416c9">00577</a>   int64 <a class="code" href="classoperations__research_1_1RoutingModel.html#afcb19f39e0670d42a070dc34246416c9" title="Returns the number of next variables in the model.">Size</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> nodes_ + vehicles_ - start_end_count_; }
<a name="l00578"></a>00578   <span class="comment">// Returns the node index from an index value resulting fron a next variable.</span>
<a name="l00579"></a>00579   <a class="code" href="classoperations__research_1_1RoutingModel.html#a2e9f7da1126111a69ee0b7bcf7edeffe">NodeIndex</a> <a class="code" href="classoperations__research_1_1RoutingModel.html#aca1b6ad06bed2a28e3debeed4512db0d" title="Returns the node index from an index value resulting fron a next variable.">IndexToNode</a>(int64 <a class="code" href="pack_8cc.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>) <span class="keyword">const</span>;
<a name="l00580"></a>00580   <span class="comment">// Returns the variable index from a node value.</span>
<a name="l00581"></a>00581   <span class="comment">// Should not be used for nodes at the start / end of a route,</span>
<a name="l00582"></a>00582   <span class="comment">// because of node multiplicity.  These cases return -1, which is</span>
<a name="l00583"></a>00583   <span class="comment">// considered a failure case.  Clients who need start and end</span>
<a name="l00584"></a>00584   <span class="comment">// variable indices should use RoutingModel::Start and RoutingModel::End.</span>
<a name="l00585"></a>00585   int64 <a class="code" href="classoperations__research_1_1RoutingModel.html#a6c88d9d5da962886bfe0924bc5ea6457" title="Returns the variable index from a node value.">NodeToIndex</a>(<a class="code" href="classoperations__research_1_1RoutingModel.html#a2e9f7da1126111a69ee0b7bcf7edeffe">NodeIndex</a> <a class="code" href="dependency__graph_8cc.html#a4eefd1c2b90c940bb972d6d038744cc3">node</a>) <span class="keyword">const</span>;
<a name="l00586"></a>00586   <span class="comment">// Returns the variable indices of the nodes in the same disjunction as the</span>
<a name="l00587"></a>00587   <span class="comment">// node corresponding to the variable of index &#39;index&#39;.</span>
<a name="l00588"></a>00588   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#a23961d60010f2c38f156f2e705c6e781" title="Returns the variable indices of the nodes in the same disjunction as the node corresponding to the va...">GetDisjunctionIndicesFromIndex</a>(int64 <a class="code" href="pack_8cc.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>, std::vector&lt;int&gt;* indices) <span class="keyword">const</span>;
<a name="l00589"></a>00589 
<a name="l00590"></a>00590   <span class="comment">// Time limits</span>
<a name="l00591"></a>00591   <span class="comment">// Returns the current time limit used in the search.</span>
<a name="l00592"></a><a class="code" href="classoperations__research_1_1RoutingModel.html#a814299b5554ee840394457c61fec466f">00592</a>   int64 <a class="code" href="classoperations__research_1_1RoutingModel.html#a814299b5554ee840394457c61fec466f" title="Time limits Returns the current time limit used in the search.">TimeLimit</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> time_limit_ms_; }
<a name="l00593"></a>00593   <span class="comment">// Updates the time limit used in the search.</span>
<a name="l00594"></a>00594   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#adaff11f77b3ff5eec418ca0fe74d5890" title="Updates the time limit used in the search.">UpdateTimeLimit</a>(int64 limit_ms);
<a name="l00595"></a>00595   <span class="comment">// Updates the time limit used in the Large Neighborhood search tree.</span>
<a name="l00596"></a>00596   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#ae5d2063233d64b4c746080d0e3bb429c" title="Updates the time limit used in the Large Neighborhood search tree.">UpdateLNSTimeLimit</a>(int64 limit_ms);
<a name="l00597"></a>00597 
<a name="l00598"></a>00598   <span class="comment">// Utilities for swig to set flags in python or java.</span>
<a name="l00599"></a>00599   <span class="keywordtype">void</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#a6d58b03c066bfedc30d6555244bee0f8" title="Utilities for swig to set flags in python or java.">SetCommandLineOption</a>(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; <a class="code" href="default__search_8cc.html#a1848ae81740c68c2502b2f176cfadcef" title="A name for logging purposes.">name</a>, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; <a class="code" href="search_8cc.html#a21edc7ca4cc5802c8779d68556bc09cf">value</a>);
<a name="l00600"></a>00600 
<a name="l00601"></a>00601   <span class="comment">// Conversion between enums and strings; the Parse*() conversions return true</span>
<a name="l00602"></a>00602   <span class="comment">// on success and the *Name() conversions return NULL when given unknown</span>
<a name="l00603"></a>00603   <span class="comment">// values. See the .cc for the name conversions. The rule of thumb is:</span>
<a name="l00604"></a>00604   <span class="comment">// RoutingModel::ROUTING_PATH_CHEAPEST_ARC &lt;-&gt; &quot;PathCheapestArc&quot;.</span>
<a name="l00605"></a>00605   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classoperations__research_1_1RoutingModel.html#a350049a8735106a149d65252b0bbcff2" title="Conversion between enums and strings; the Parse*() conversions return true on success and the *Name()...">RoutingStrategyName</a>(<a class="code" href="classoperations__research_1_1RoutingModel.html#a6f38b3ff9a2e455677856d97e339da6d" title="First solution strategies, used as starting point of local search.">RoutingStrategy</a> strategy);
<a name="l00606"></a>00606   <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#af65ba5a7c153ed25d49b0ab25b7abc47" title="static">ParseRoutingStrategy</a>(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; strategy_str,
<a name="l00607"></a>00607                                    <a class="code" href="classoperations__research_1_1RoutingModel.html#a6f38b3ff9a2e455677856d97e339da6d" title="First solution strategies, used as starting point of local search.">RoutingStrategy</a>* strategy);
<a name="l00608"></a>00608   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span>* <a class="code" href="classoperations__research_1_1RoutingModel.html#aed129260b60ad9a5ff39ba13db6fad12" title="static">RoutingMetaheuristicName</a>(
<a name="l00609"></a>00609       <a class="code" href="classoperations__research_1_1RoutingModel.html#a0f0bd97e25af059ab2e8e7f263afc8e1" title="Metaheuristics used to guide the search.">RoutingMetaheuristic</a> <a class="code" href="classoperations__research_1_1RoutingModel.html#aac8ac681a6a334db9b808208d616235a" title="Returns the metaheuristic used.">metaheuristic</a>);
<a name="l00610"></a>00610   <span class="keyword">static</span> <span class="keywordtype">bool</span> <a class="code" href="classoperations__research_1_1RoutingModel.html#a05391d82512d6775b7aae4e3b200756c" title="static">ParseRoutingMetaheuristic</a>(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; metaheuristic_str,
<a name="l00611"></a>00611                                         <a class="code" href="classoperations__research_1_1RoutingModel.html#a0f0bd97e25af059ab2e8e7f263afc8e1" title="Metaheuristics used to guide the search.">RoutingMetaheuristic</a>* <a class="code" href="classoperations__research_1_1RoutingModel.html#aac8ac681a6a334db9b808208d616235a" title="Returns the metaheuristic used.">metaheuristic</a>);
<a name="l00612"></a>00612 
<a name="l00613"></a>00613  <span class="keyword">private</span>:
<a name="l00614"></a>00614   <span class="keyword">typedef</span> hash_map&lt;string, std::vector&lt;IntVar*&gt; &gt; VarMap;
<a name="l00615"></a>00615   <span class="keyword">struct </span>Disjunction {
<a name="l00616"></a>00616     std::vector&lt;int&gt; <a class="code" href="classoperations__research_1_1RoutingModel.html#a20c1bf5b1ac1353c9e132774f3f7e1df" title="Sizes and indices Returns the number of nodes in the model.">nodes</a>;
<a name="l00617"></a>00617     int64 penalty;
<a name="l00618"></a>00618   };
<a name="l00619"></a>00619 
<a name="l00620"></a>00620   <span class="keyword">struct </span>CostCacheElement {
<a name="l00621"></a>00621     <a class="code" href="classoperations__research_1_1RoutingModel.html#a2e9f7da1126111a69ee0b7bcf7edeffe">NodeIndex</a> <a class="code" href="dependency__graph_8cc.html#a4eefd1c2b90c940bb972d6d038744cc3">node</a>;
<a name="l00622"></a>00622     <span class="keywordtype">int</span> cost_class;
<a name="l00623"></a>00623     int64 cost;
<a name="l00624"></a>00624   };
<a name="l00625"></a>00625 
<a name="l00626"></a>00626   <span class="comment">// Internal methods.</span>
<a name="l00627"></a>00627   <span class="keywordtype">void</span> Initialize();
<a name="l00628"></a>00628   <span class="keywordtype">void</span> SetStartEnd(<span class="keyword">const</span> std::vector&lt;std::pair&lt;NodeIndex, NodeIndex&gt; &gt;&amp; start_end);
<a name="l00629"></a>00629   <span class="keywordtype">void</span> AddDisjunctionInternal(<span class="keyword">const</span> std::vector&lt;NodeIndex&gt;&amp; <a class="code" href="classoperations__research_1_1RoutingModel.html#a20c1bf5b1ac1353c9e132774f3f7e1df" title="Sizes and indices Returns the number of nodes in the model.">nodes</a>, int64 penalty);
<a name="l00630"></a>00630   <span class="keywordtype">void</span> AddNoCycleConstraintInternal();
<a name="l00631"></a>00631   <span class="keywordtype">void</span> SetVehicleCostInternal(<span class="keywordtype">int</span> vehicle, <a class="code" href="classoperations__research_1_1RoutingModel.html#a5ad22b1565f2e5b1735601a824629289">NodeEvaluator2</a>* evaluator);
<a name="l00632"></a>00632   Assignment* DoRestoreAssignment();
<a name="l00633"></a>00633   <span class="comment">// Variants of GetCost and GetHomogeneousCost returning costs used in local</span>
<a name="l00634"></a>00634   <span class="comment">// search filters.</span>
<a name="l00635"></a>00635   int64 GetFilterCost(int64 i, int64 j, int64 vehicle);
<a name="l00636"></a>00636   int64 GetHomogeneousFilterCost(int64 i, int64 j) {
<a name="l00637"></a>00637     <span class="keywordflow">return</span> GetFilterCost(i, j, 0);
<a name="l00638"></a>00638   }
<a name="l00639"></a>00639   <span class="comment">// Returns the cost of the segment between two nodes for a given vehicle</span>
<a name="l00640"></a>00640   <span class="comment">// class. Input are variable indices of nodes and the vehicle class.</span>
<a name="l00641"></a>00641   int64 GetVehicleClassCost(int64 from_index, int64 to_index, int64 cost_class);
<a name="l00642"></a>00642   int64 GetSafeVehicleCostClass(int64 vehicle)<span class="keyword"> const </span>{
<a name="l00643"></a>00643     DCHECK_LT(0, vehicles_);
<a name="l00644"></a>00644     <span class="keywordflow">return</span> vehicle &gt;= 0 ? GetVehicleCostClass(vehicle) : 0;
<a name="l00645"></a>00645   }
<a name="l00646"></a>00646   int64 GetVehicleCostClass(int64 vehicle)<span class="keyword"> const </span>{
<a name="l00647"></a>00647     <span class="keywordflow">return</span> vehicle_cost_classes_[vehicle];
<a name="l00648"></a>00648   }
<a name="l00649"></a>00649   <span class="keywordtype">void</span> SetVehicleCostClass(int64 vehicle, int64 cost_class) {
<a name="l00650"></a>00650     vehicle_cost_classes_[vehicle] = cost_class;
<a name="l00651"></a>00651   }
<a name="l00652"></a>00652   <span class="comment">// Returns NULL if no penalty cost, otherwise returns penalty variable.</span>
<a name="l00653"></a>00653   IntVar* CreateDisjunction(<span class="keywordtype">int</span> disjunction);
<a name="l00654"></a>00654   <span class="comment">// Returns the first active node in nodes starting from index + 1.</span>
<a name="l00655"></a>00655   <span class="keywordtype">int</span> FindNextActive(<span class="keywordtype">int</span> <a class="code" href="pack_8cc.html#a750b5d744c39a06bfb13e6eb010e35d0">index</a>, <span class="keyword">const</span> std::vector&lt;int&gt;&amp; <a class="code" href="classoperations__research_1_1RoutingModel.html#a20c1bf5b1ac1353c9e132774f3f7e1df" title="Sizes and indices Returns the number of nodes in the model.">nodes</a>) <span class="keyword">const</span>;
<a name="l00656"></a>00656 
<a name="l00657"></a>00657   <span class="comment">// Checks that all nodes on the route starting at start_index (using the</span>
<a name="l00658"></a>00658   <span class="comment">// solution stored in assignment) can be visited by the given vehicle.</span>
<a name="l00659"></a>00659   <span class="keywordtype">bool</span> RouteCanBeUsedByVehicle(<span class="keyword">const</span> Assignment&amp; assignment,
<a name="l00660"></a>00660                                <span class="keywordtype">int</span> start_index,
<a name="l00661"></a>00661                                <span class="keywordtype">int</span> vehicle) <span class="keyword">const</span>;
<a name="l00662"></a>00662   <span class="comment">// Replaces the route of unused_vehicle with the route of active_vehicle in</span>
<a name="l00663"></a>00663   <span class="comment">// compact_assignment. Expects that unused_vehicle is a vehicle with an empty</span>
<a name="l00664"></a>00664   <span class="comment">// route and that the route of active_vehicle is non-empty. Also expects that</span>
<a name="l00665"></a>00665   <span class="comment">// &#39;assignment&#39; contains the original assignment, from which</span>
<a name="l00666"></a>00666   <span class="comment">// compact_assignment was created.</span>
<a name="l00667"></a>00667   <span class="comment">// Returns true if the vehicles were successfully swapped; otherwise, returns</span>
<a name="l00668"></a>00668   <span class="comment">// false.</span>
<a name="l00669"></a>00669   <span class="keywordtype">bool</span> ReplaceUnusedVehicle(<span class="keywordtype">int</span> unused_vehicle,
<a name="l00670"></a>00670                             <span class="keywordtype">int</span> active_vehicle,
<a name="l00671"></a>00671                             Assignment* compact_assignment) <span class="keyword">const</span>;
<a name="l00672"></a>00672 
<a name="l00673"></a>00673   <a class="code" href="classoperations__research_1_1RoutingModel.html#a5ad22b1565f2e5b1735601a824629289">NodeEvaluator2</a>* NewCachedCallback(<a class="code" href="classoperations__research_1_1RoutingModel.html#a5ad22b1565f2e5b1735601a824629289">NodeEvaluator2</a>* callback);
<a name="l00674"></a>00674   <a class="code" href="classoperations__research_1_1Solver.html#afd80e55c6251fec492c4887f11b5b0e0">Solver::IndexEvaluator3</a>* BuildCostCallback();
<a name="l00675"></a>00675   <span class="keywordtype">void</span> CheckDepot();
<a name="l00676"></a>00676   <span class="keywordtype">void</span> QuietCloseModel() {
<a name="l00677"></a>00677     <span class="keywordflow">if</span> (!closed_) {
<a name="l00678"></a>00678       <a class="code" href="classoperations__research_1_1RoutingModel.html#ae84602b98050ad382d725e35326aab3d" title="Closes the current routing model; after this method is called, no modification to the model can be do...">CloseModel</a>();
<a name="l00679"></a>00679     }
<a name="l00680"></a>00680   }
<a name="l00681"></a>00681   <span class="comment">// Sets up search objects, such as decision builders and monitors.</span>
<a name="l00682"></a>00682   <span class="keywordtype">void</span> SetupSearch();
<a name="l00683"></a>00683   <span class="comment">// Set of auxiliary methods used to setup the search.</span>
<a name="l00684"></a>00684   <span class="comment">// TODO(user): Document each auxiliary method.</span>
<a name="l00685"></a>00685   Assignment* GetOrCreateAssignment();
<a name="l00686"></a>00686   SearchLimit* GetOrCreateLimit();
<a name="l00687"></a>00687   SearchLimit* GetOrCreateLocalSearchLimit();
<a name="l00688"></a>00688   SearchLimit* GetOrCreateLargeNeighborhoodSearchLimit();
<a name="l00689"></a>00689   LocalSearchOperator* CreateInsertionOperator();
<a name="l00690"></a>00690   LocalSearchOperator* CreateNeighborhoodOperators();
<a name="l00691"></a>00691   <span class="keyword">const</span> std::vector&lt;LocalSearchFilter*&gt;&amp; GetOrCreateLocalSearchFilters();
<a name="l00692"></a>00692   DecisionBuilder* CreateSolutionFinalizer();
<a name="l00693"></a>00693   DecisionBuilder* CreateFirstSolutionDecisionBuilder();
<a name="l00694"></a>00694   LocalSearchPhaseParameters* CreateLocalSearchParameters();
<a name="l00695"></a>00695   DecisionBuilder* CreateLocalSearchDecisionBuilder();
<a name="l00696"></a>00696   <span class="keywordtype">void</span> SetupDecisionBuilders();
<a name="l00697"></a>00697   <span class="keywordtype">void</span> SetupMetaheuristics();
<a name="l00698"></a>00698   <span class="keywordtype">void</span> SetupAssignmentCollector();
<a name="l00699"></a>00699   <span class="keywordtype">void</span> SetupTrace();
<a name="l00700"></a>00700   <span class="keywordtype">void</span> SetupSearchMonitors();
<a name="l00701"></a>00701 
<a name="l00702"></a>00702   <span class="keyword">const</span> std::vector&lt;IntVar*&gt;&amp; GetOrMakeCumuls(int64 capacity, <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; <a class="code" href="default__search_8cc.html#a1848ae81740c68c2502b2f176cfadcef" title="A name for logging purposes.">name</a>);
<a name="l00703"></a>00703   <span class="keyword">const</span> std::vector&lt;IntVar*&gt;&amp; GetOrMakeTransits(<a class="code" href="classoperations__research_1_1RoutingModel.html#a5ad22b1565f2e5b1735601a824629289">NodeEvaluator2</a>* evaluator,
<a name="l00704"></a>00704                                                int64 slack_max,
<a name="l00705"></a>00705                                                int64 capacity,
<a name="l00706"></a>00706                                                <span class="keyword">const</span> <span class="keywordtype">string</span>&amp; <a class="code" href="default__search_8cc.html#a1848ae81740c68c2502b2f176cfadcef" title="A name for logging purposes.">name</a>);
<a name="l00707"></a>00707 
<a name="l00708"></a>00708   int64 GetArcCost(int64 i, int64 j, int64 cost_class);
<a name="l00709"></a>00709   int64 GetPenaltyCost(int64 i) <span class="keyword">const</span>;
<a name="l00710"></a>00710   int64 WrappedEvaluator(<a class="code" href="classoperations__research_1_1RoutingModel.html#a5ad22b1565f2e5b1735601a824629289">NodeEvaluator2</a>* evaluator,
<a name="l00711"></a>00711                          int64 from,
<a name="l00712"></a>00712                          int64 to);
<a name="l00713"></a>00713 
<a name="l00714"></a>00714   <span class="comment">// Model</span>
<a name="l00715"></a>00715   scoped_ptr&lt;Solver&gt; solver_;
<a name="l00716"></a>00716   Constraint* no_cycle_constraint_;
<a name="l00717"></a>00717   std::vector&lt;IntVar*&gt; nexts_;
<a name="l00718"></a>00718   std::vector&lt;IntVar*&gt; vehicle_vars_;
<a name="l00719"></a>00719   std::vector&lt;IntVar*&gt; active_;
<a name="l00720"></a>00720   std::vector&lt;NodeEvaluator2*&gt; costs_;
<a name="l00721"></a>00721   <span class="keywordtype">bool</span> homogeneous_costs_;
<a name="l00722"></a>00722   std::vector&lt;CostCacheElement&gt; cost_cache_;
<a name="l00723"></a>00723   std::vector&lt;RoutingCache*&gt; routing_caches_;
<a name="l00724"></a>00724   hash_map&lt;NodeEvaluator2*, std::vector&lt;int&gt; &gt; cost_callback_vehicles_;
<a name="l00725"></a>00725   std::vector&lt;int64&gt; vehicle_cost_classes_;
<a name="l00726"></a>00726   std::vector&lt;Disjunction&gt; disjunctions_;
<a name="l00727"></a>00727   hash_map&lt;int64, int&gt; node_to_disjunction_;
<a name="l00728"></a>00728   <a class="code" href="classoperations__research_1_1RoutingModel.html#a4251c2ca5b1558dc69e696991c853ae3">NodePairs</a> pickup_delivery_pairs_;
<a name="l00729"></a>00729   IntVar* cost_;
<a name="l00730"></a>00730   std::vector&lt;int64&gt; fixed_costs_;
<a name="l00731"></a>00731   <span class="keywordtype">int</span> nodes_;
<a name="l00732"></a>00732   <span class="keywordtype">int</span> vehicles_;
<a name="l00733"></a>00733   std::vector&lt;NodeIndex&gt; index_to_node_;
<a name="l00734"></a>00734   ITIVector&lt;NodeIndex, int&gt; node_to_index_;
<a name="l00735"></a>00735   std::vector&lt;int&gt; index_to_vehicle_;
<a name="l00736"></a>00736   std::vector&lt;int64&gt; starts_;
<a name="l00737"></a>00737   std::vector&lt;int64&gt; ends_;
<a name="l00738"></a>00738   <span class="keywordtype">int</span> start_end_count_;
<a name="l00739"></a>00739   <span class="keywordtype">bool</span> is_depot_set_;
<a name="l00740"></a>00740   VarMap cumuls_;
<a name="l00741"></a>00741   VarMap transits_;
<a name="l00742"></a>00742   VarMap slacks_;
<a name="l00743"></a>00743   hash_map&lt;string, Solver::IndexEvaluator2*&gt; transit_evaluators_;
<a name="l00744"></a>00744   <span class="keywordtype">bool</span> closed_;
<a name="l00745"></a>00745   <a class="code" href="classoperations__research_1_1RoutingModel.html#a328a19213729eec49288128061bc2044" title="Status of the search.">Status</a> status_;
<a name="l00746"></a>00746 
<a name="l00747"></a>00747   <span class="comment">// Search data</span>
<a name="l00748"></a>00748   <a class="code" href="classoperations__research_1_1RoutingModel.html#a6f38b3ff9a2e455677856d97e339da6d" title="First solution strategies, used as starting point of local search.">RoutingStrategy</a> first_solution_strategy_;
<a name="l00749"></a>00749   scoped_ptr&lt;Solver::IndexEvaluator2&gt; first_solution_evaluator_;
<a name="l00750"></a>00750   <a class="code" href="classoperations__research_1_1RoutingModel.html#a0f0bd97e25af059ab2e8e7f263afc8e1" title="Metaheuristics used to guide the search.">RoutingMetaheuristic</a> metaheuristic_;
<a name="l00751"></a>00751   std::vector&lt;SearchMonitor*&gt; monitors_;
<a name="l00752"></a>00752   SolutionCollector* collect_assignments_;
<a name="l00753"></a>00753   DecisionBuilder* solve_db_;
<a name="l00754"></a>00754   DecisionBuilder* improve_db_;
<a name="l00755"></a>00755   DecisionBuilder* restore_assignment_;
<a name="l00756"></a>00756   Assignment* assignment_;
<a name="l00757"></a>00757   Assignment* preassignment_;
<a name="l00758"></a>00758   std::vector&lt;IntVar*&gt; extra_vars_;
<a name="l00759"></a>00759   std::vector&lt;LocalSearchOperator*&gt; extra_operators_;
<a name="l00760"></a>00760   std::vector&lt;LocalSearchFilter*&gt; filters_;
<a name="l00761"></a>00761 
<a name="l00762"></a>00762   int64 time_limit_ms_;
<a name="l00763"></a>00763   int64 lns_time_limit_ms_;
<a name="l00764"></a>00764   SearchLimit* limit_;
<a name="l00765"></a>00765   SearchLimit* ls_limit_;
<a name="l00766"></a>00766   SearchLimit* lns_limit_;
<a name="l00767"></a>00767 
<a name="l00768"></a>00768   <span class="comment">// Callbacks to be deleted</span>
<a name="l00769"></a>00769   hash_set&lt;NodeEvaluator2*&gt; owned_node_callbacks_;
<a name="l00770"></a>00770   hash_set&lt;Solver::IndexEvaluator2*&gt; owned_index_callbacks_;
<a name="l00771"></a>00771 
<a name="l00772"></a>00772   DISALLOW_COPY_AND_ASSIGN(<a class="code" href="classoperations__research_1_1RoutingModel.html#a67e90b8e5fba64a285e2eed07a39b2ca" title="Supposes a single depot.">RoutingModel</a>);
<a name="l00773"></a>00773 };
<a name="l00774"></a>00774 
<a name="l00775"></a>00775 }  <span class="comment">// namespace operations_research</span>
<a name="l00776"></a>00776 
<a name="l00777"></a>00777 <span class="preprocessor">#endif  // OR_TOOLS_CONSTRAINT_SOLVER_ROUTING_H_</span>
</pre></div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>


  <!-- Start of footer. -->
  <table width=100% cellpadding=0 cellspacing=0 border=0>
    <tr valign=top>
      <td colspan=2 height=10></td>
    </tr>
    <tr valign=top>
      <td colspan=2 bgcolor=#992252 height=3></td>
    </tr>
  </table>

  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br />

  
  </body>
</html>
