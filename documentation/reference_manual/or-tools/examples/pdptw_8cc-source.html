<!-- Good morning, Mr. Phelps. -->
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <title>or-tools/examples/pdptw.cc Source File - Doxy</title>
    <link rel="shortcut icon" href="../../favicon.ico">
    <!-- Both stylesheets are supplied by Doxygen, with maybe minor tweaks from Google. -->
    <link href="../../doxygen.css" rel="stylesheet" type="text/css">
    <link href="../../tabs.css" rel="stylesheet" type="text/css">
  </head>

  <body topmargin=0 leftmargin=20 bottommargin=0 rightmargin=20 marginwidth=20 marginheight=0>
  <!-- Second part of the secret behind Doxy logo always having the word "Doxy" with the color of the day. -->
  <style>
    a.doxy_logo:hover {
      background-color: #025402
    }
  </style>

  <table width=100% cellpadding=0 cellspacing=0 border=0>
    <!-- Top horizontal line with the color of the day. -->
    <tr valign=top>
      <td colspan=3 bgcolor=#025402 height=3></td>
    </tr>

    <!-- Header row with the links at the right. -->
    <tr valign=top>
      <td colspan=3 align=right>
        <font size=-1>
          Generated on: <font color=#025402><b>Wed Feb  1 13:21:45 PST 2012</b></font>
            for <b>custom file set</b>
        </font>
      </td>
    </tr>

    <!-- Header row with the logo and the search form. -->
    <tr valign=top>
      <!-- Logo. -->
      <td align=left width=150>
        <table width=150 height=54 cellpadding=0 cellspacing=0 border=0>
          <tr valign=top>
            <!-- First part of the secret behind Doxy logo always having the word "Doxy" with the color of the day. -->
            <td bgcolor=#025402>
              <a class="doxy_logo" href="../../index.html"><img src="../../doxy_logo.png" alt="Doxy" border=0></a>
            </td>
          </tr>
        </table>
      </td>
    </tr>

    <!-- Tiny vertical space below the form. -->
    <tr valign=top>
      <td colspan=3 height=3></td>
    </tr>
  </table>

  <!-- Header navigation row. -->
  <div class="memproto">
    <table width=100% cellpadding=0 cellspacing=0 border=0>
      <tr>
        <td align=left style="padding-left: 20px"><font size=+1><b><tt><font color=#333333>//
            <a href="../../index.html"><font color=#025402>doxy</font></a>/</font>
            <a href="../../or-tools/index.html">or-tools</a>/
            <a href="../../or-tools/examples/index.html">examples</a>/
            </tt></b></font>
        </td>
      </tr>
    </table>
  </div>
  <br />
    <!-- No subdirs found. -->
  <!-- End of header. -->
<!-- Generated by Doxygen 1.5.6 -->
<div class="navigation" id="top">
  <div class="tabs">
    <ul>
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<h1>or-tools/examples/pdptw.cc</h1><a href="pdptw_8cc.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">// Copyright 2010-2011 Google</span>
<a name="l00002"></a>00002 <span class="comment">// Licensed under the Apache License, Version 2.0 (the "License");</span>
<a name="l00003"></a>00003 <span class="comment">// you may not use this file except in compliance with the License.</span>
<a name="l00004"></a>00004 <span class="comment">// You may obtain a copy of the License at</span>
<a name="l00005"></a>00005 <span class="comment">//</span>
<a name="l00006"></a>00006 <span class="comment">//     http://www.apache.org/licenses/LICENSE-2.0</span>
<a name="l00007"></a>00007 <span class="comment">//</span>
<a name="l00008"></a>00008 <span class="comment">// Unless required by applicable law or agreed to in writing, software</span>
<a name="l00009"></a>00009 <span class="comment">// distributed under the License is distributed on an "AS IS" BASIS,</span>
<a name="l00010"></a>00010 <span class="comment">// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<a name="l00011"></a>00011 <span class="comment">// See the License for the specific language governing permissions and</span>
<a name="l00012"></a>00012 <span class="comment">// limitations under the License.</span>
<a name="l00013"></a>00013 <span class="comment">//</span>
<a name="l00014"></a>00014 <span class="comment">// Pickup and Delivery Problem with Time Windows.</span>
<a name="l00015"></a>00015 <span class="comment">// The overall objective is to minimize the length of the routes delivering</span>
<a name="l00016"></a>00016 <span class="comment">// quantities of goods between pickup and delivery locations, taking into</span>
<a name="l00017"></a>00017 <span class="comment">// account vehicle capacities and node time windows.</span>
<a name="l00018"></a>00018 <span class="comment">// Given a set of pairs of pickup and delivery nodes, find the set of routes</span>
<a name="l00019"></a>00019 <span class="comment">// visiting all the nodes, such that</span>
<a name="l00020"></a>00020 <span class="comment">// - corresponding pickup and delivery nodes are visited on the same route,</span>
<a name="l00021"></a>00021 <span class="comment">// - the pickup node is visited before the corresponding delivery node,</span>
<a name="l00022"></a>00022 <span class="comment">// - the quantity picked up at the pickup node is the same as the quantity</span>
<a name="l00023"></a>00023 <span class="comment">//   delivered at the delivery node,</span>
<a name="l00024"></a>00024 <span class="comment">// - the total quantity carried by a vehicle at any time is less than its</span>
<a name="l00025"></a>00025 <span class="comment">//   capacity,</span>
<a name="l00026"></a>00026 <span class="comment">// - each node must be visited within its time window (time range during which</span>
<a name="l00027"></a>00027 <span class="comment">//   the node is accessible).</span>
<a name="l00028"></a>00028 <span class="comment">// The maximum number of vehicles used (i.e. the number of routes used) is</span>
<a name="l00029"></a>00029 <span class="comment">// specified in the data but can be overriden using the --pdp_force_vehicles</span>
<a name="l00030"></a>00030 <span class="comment">// flag.</span>
<a name="l00031"></a>00031 <span class="comment">//</span>
<a name="l00032"></a>00032 <span class="comment">// A further description of the problem can be found here:</span>
<a name="l00033"></a>00033 <span class="comment">// http://http://en.wikipedia.org/wiki/Vehicle_routing_problem</span>
<a name="l00034"></a>00034 <span class="comment">// http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.123.9965&amp;rep=rep1&amp;type=pdf.</span>
<a name="l00035"></a>00035 <span class="comment">// Reads data in the format defined by Li &amp; Lim</span>
<a name="l00036"></a>00036 <span class="comment">// (http://www.sintef.no/static/am/opti/projects/top/vrp/format_pdp.htm).</span>
<a name="l00037"></a>00037 
<a name="l00038"></a>00038 <span class="preprocessor">#include &lt;vector&gt;</span>
<a name="l00039"></a>00039 
<a name="l00040"></a>00040 <span class="preprocessor">#include "base/callback.h"</span>
<a name="l00041"></a>00041 <span class="preprocessor">#include "base/commandlineflags.h"</span>
<a name="l00042"></a>00042 <span class="preprocessor">#include "base/commandlineflags.h"</span>
<a name="l00043"></a>00043 <span class="preprocessor">#include "base/strtoint.h"</span>
<a name="l00044"></a>00044 <span class="preprocessor">#include "base/file.h"</span>
<a name="l00045"></a>00045 <span class="preprocessor">#include "base/split.h"</span>
<a name="l00046"></a>00046 <span class="preprocessor">#include "base/mathutil.h"</span>
<a name="l00047"></a>00047 <span class="preprocessor">#include "constraint_solver/routing.h"</span>
<a name="l00048"></a>00048 
<a name="l00049"></a>00049 <a class="code" href="costas__array_8cc.html#5236ef9cc4490cd59f344852dc768c45">DEFINE_string</a>(pdp_file, <span class="stringliteral">""</span>,
<a name="l00050"></a>00050               <span class="stringliteral">"File containing the Pickup and Delivery Problem to solve."</span>);
<a name="l00051"></a>00051 <a class="code" href="costas__array_8cc.html#af677423bc95ff6ddd8928486064c9c1" title="Licensed under the Apache License, Version 2.0 (the &amp;quot;License&amp;quot;); you may...">DEFINE_int32</a>(pdp_force_vehicles, 0,
<a name="l00052"></a>00052              <span class="stringliteral">"Force the number of vehicles used (maximum number of routes."</span>);
<a name="l00053"></a>00053 <a class="code" href="costas__array_8cc.html#481252203d46207b482271a18f5b5399">DEFINE_bool</a>(pdp_display_solution, <span class="keyword">false</span>,
<a name="l00054"></a>00054             <span class="stringliteral">"Displays the solution of the Pickup and Delivery Problem."</span>);
<a name="l00055"></a>00055 
<a name="l00056"></a>00056 <span class="keyword">namespace </span>operations_research {
<a name="l00057"></a>00057 
<a name="l00058"></a>00058 <span class="comment">// Scaling factor used to scale up distances, allowing a bit more precision</span>
<a name="l00059"></a>00059 <span class="comment">// from Euclidean distances.</span>
<a name="l00060"></a><a class="code" href="namespaceoperations__research.html#1ecc1740b95fee9e7a7748eeb15f32dd">00060</a> <span class="keyword">const</span> int64 <a class="code" href="namespaceoperations__research.html#1ecc1740b95fee9e7a7748eeb15f32dd" title="Scaling factor used to scale up distances, allowing a bit more precision from Euclidean...">kScalingFactor</a> = 1000;
<a name="l00061"></a>00061 
<a name="l00062"></a>00062 <span class="comment">// Vector of (x,y) node coordinates, *unscaled*, in some imaginary planar,</span>
<a name="l00063"></a>00063 <span class="comment">// metric grid.</span>
<a name="l00064"></a><a class="code" href="namespaceoperations__research.html#ca37e8fb299d814c3af0b3bf206a9c27">00064</a> <span class="keyword">typedef</span> std::vector&lt;std::pair&lt;int, int&gt; &gt; <a class="code" href="namespaceoperations__research.html#ca37e8fb299d814c3af0b3bf206a9c27" title="Vector of (x,y) node coordinates, *unscaled*, in some imaginary planar, metric grid...">Coordinates</a>;
<a name="l00065"></a>00065 
<a name="l00066"></a>00066 <span class="comment">// Returns the scaled Euclidean distance between two nodes, coords holding the</span>
<a name="l00067"></a>00067 <span class="comment">// coordinates of the nodes.</span>
<a name="l00068"></a><a class="code" href="namespaceoperations__research.html#62615656dde53d8931420c2cd24e9562">00068</a> int64 <a class="code" href="namespaceoperations__research.html#62615656dde53d8931420c2cd24e9562" title="Returns the scaled Euclidean distance between two nodes, coords holding the coordinates...">Travel</a>(<span class="keyword">const</span> <a class="code" href="namespaceoperations__research.html#ca37e8fb299d814c3af0b3bf206a9c27" title="Vector of (x,y) node coordinates, *unscaled*, in some imaginary planar, metric grid...">Coordinates</a>* <span class="keyword">const</span> coords,
<a name="l00069"></a>00069              RoutingModel::NodeIndex from,
<a name="l00070"></a>00070              RoutingModel::NodeIndex to) {
<a name="l00071"></a>00071   DCHECK(coords != NULL);
<a name="l00072"></a>00072   <span class="keyword">const</span> <span class="keywordtype">int</span> xd =
<a name="l00073"></a>00073       coords-&gt;at(from.value()).first - coords-&gt;at(to.value()).first;
<a name="l00074"></a>00074   <span class="keyword">const</span> <span class="keywordtype">int</span> yd =
<a name="l00075"></a>00075       coords-&gt;at(from.value()).second - coords-&gt;at(to.value()).second;
<a name="l00076"></a>00076   <span class="keywordflow">return</span> <span class="keyword">static_cast&lt;</span>int64<span class="keyword">&gt;</span>(<a class="code" href="namespaceoperations__research.html#1ecc1740b95fee9e7a7748eeb15f32dd" title="Scaling factor used to scale up distances, allowing a bit more precision from Euclidean...">kScalingFactor</a> * sqrt(1.0L * xd * xd + yd * yd));
<a name="l00077"></a>00077 }
<a name="l00078"></a>00078 
<a name="l00079"></a>00079 <span class="comment">// Returns the scaled service time at a given node, service_times holding the</span>
<a name="l00080"></a>00080 <span class="comment">// service times.</span>
<a name="l00081"></a><a class="code" href="namespaceoperations__research.html#54d0d8fe7245170d0d57923052534c55">00081</a> int64 <a class="code" href="namespaceoperations__research.html#54d0d8fe7245170d0d57923052534c55" title="Returns the scaled service time at a given node, service_times holding the service...">ServiceTime</a>(<span class="keyword">const</span> std::vector&lt;int64&gt;* <span class="keyword">const</span> service_times,
<a name="l00082"></a>00082                   RoutingModel::NodeIndex node) {
<a name="l00083"></a>00083   <span class="keywordflow">return</span> <a class="code" href="namespaceoperations__research.html#1ecc1740b95fee9e7a7748eeb15f32dd" title="Scaling factor used to scale up distances, allowing a bit more precision from Euclidean...">kScalingFactor</a> * service_times-&gt;at(node.value());
<a name="l00084"></a>00084 }
<a name="l00085"></a>00085 
<a name="l00086"></a>00086 <span class="comment">// Returns the scaled (distance plus service time) between two nodes, coords</span>
<a name="l00087"></a>00087 <span class="comment">// holding the coordinates of the nodes and service_times holding the service</span>
<a name="l00088"></a>00088 <span class="comment">// times.</span>
<a name="l00089"></a>00089 <span class="comment">// The service time is the time spent to execute a delivery or a pickup.</span>
<a name="l00090"></a><a class="code" href="namespaceoperations__research.html#2a4cd35bcbb1b316b7664c1eaf206052">00090</a> int64 <a class="code" href="namespaceoperations__research.html#2a4cd35bcbb1b316b7664c1eaf206052" title="Returns the scaled (distance plus service time) between two nodes, coords holding...">TravelPlusServiceTime</a>(<span class="keyword">const</span> <a class="code" href="namespaceoperations__research.html#ca37e8fb299d814c3af0b3bf206a9c27" title="Vector of (x,y) node coordinates, *unscaled*, in some imaginary planar, metric grid...">Coordinates</a>* <span class="keyword">const</span> coords,
<a name="l00091"></a>00091                             <span class="keyword">const</span> std::vector&lt;int64&gt;* <span class="keyword">const</span> service_times,
<a name="l00092"></a>00092                             RoutingModel::NodeIndex from,
<a name="l00093"></a>00093                             RoutingModel::NodeIndex to) {
<a name="l00094"></a>00094   <span class="keywordflow">return</span> <a class="code" href="namespaceoperations__research.html#54d0d8fe7245170d0d57923052534c55" title="Returns the scaled service time at a given node, service_times holding the service...">ServiceTime</a>(service_times, from) + <a class="code" href="namespaceoperations__research.html#62615656dde53d8931420c2cd24e9562" title="Returns the scaled Euclidean distance between two nodes, coords holding the coordinates...">Travel</a>(coords, from, to);
<a name="l00095"></a>00095 }
<a name="l00096"></a>00096 
<a name="l00097"></a>00097 <span class="comment">// Returns the demand (quantity picked up or delivered) of a node, demands</span>
<a name="l00098"></a>00098 <span class="comment">// holds the demand of each node.</span>
<a name="l00099"></a><a class="code" href="namespaceoperations__research.html#13d47e87dd02eb50070ccc017d8ea68c">00099</a> int64 <a class="code" href="namespaceoperations__research.html#13d47e87dd02eb50070ccc017d8ea68c" title="Returns the demand (quantity picked up or delivered) of a node, demands holds the...">Demand</a>(<span class="keyword">const</span> std::vector&lt;int64&gt;* <span class="keyword">const</span> demands,
<a name="l00100"></a>00100              RoutingModel::NodeIndex from,
<a name="l00101"></a>00101              RoutingModel::NodeIndex to) {
<a name="l00102"></a>00102   <span class="keywordflow">return</span> demands-&gt;at(from.value());
<a name="l00103"></a>00103 }
<a name="l00104"></a>00104 
<a name="l00105"></a>00105 <span class="comment">// Outputs a solution to the current model in a string.</span>
<a name="l00106"></a><a class="code" href="namespaceoperations__research.html#0f9a7f1456850f9c6c7fa685781b6a27">00106</a> <span class="keywordtype">string</span> <a class="code" href="namespaceoperations__research.html#0f9a7f1456850f9c6c7fa685781b6a27" title="Outputs a solution to the current model in a string.">VerboseOutput</a>(<span class="keyword">const</span> RoutingModel&amp; routing,
<a name="l00107"></a>00107                      <span class="keyword">const</span> Assignment&amp; assignment,
<a name="l00108"></a>00108                      <span class="keyword">const</span> <a class="code" href="namespaceoperations__research.html#ca37e8fb299d814c3af0b3bf206a9c27" title="Vector of (x,y) node coordinates, *unscaled*, in some imaginary planar, metric grid...">Coordinates</a>&amp; coords,
<a name="l00109"></a>00109                      <span class="keyword">const</span> std::vector&lt;int64&gt;&amp; service_times) {
<a name="l00110"></a>00110   <span class="keywordtype">string</span> output;
<a name="l00111"></a>00111   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; routing.vehicles(); ++i) {
<a name="l00112"></a>00112       StringAppendF(&amp;output, <span class="stringliteral">"Vehicle %d: "</span>, i);
<a name="l00113"></a>00113     int64 index = routing.Start(i);
<a name="l00114"></a>00114     <span class="keywordflow">if</span> (routing.IsEnd(assignment.Value(routing.NextVar(index)))) {
<a name="l00115"></a>00115       StringAppendF(&amp;output, <span class="stringliteral">"empty"</span>);
<a name="l00116"></a>00116     } <span class="keywordflow">else</span> {
<a name="l00117"></a>00117       <span class="keywordflow">while</span> (!routing.IsEnd(index)) {
<a name="l00118"></a>00118         RoutingModel::NodeIndex real_node = routing.IndexToNode(index);
<a name="l00119"></a>00119         StringAppendF(&amp;output, <span class="stringliteral">"%d "</span>, real_node.value());
<a name="l00120"></a>00120         <span class="keyword">const</span> IntVar* vehicle = routing.VehicleVar(index);
<a name="l00121"></a>00121         StringAppendF(&amp;output, <span class="stringliteral">"Vehicle(%lld) "</span>, assignment.Value(vehicle));
<a name="l00122"></a>00122         <span class="keyword">const</span> IntVar* arrival = routing.CumulVar(index, <span class="stringliteral">"time"</span>);
<a name="l00123"></a>00123         StringAppendF(&amp;output, <span class="stringliteral">"Time(%lld..%lld) "</span>,
<a name="l00124"></a>00124                       assignment.Min(arrival),
<a name="l00125"></a>00125                       assignment.Max(arrival));
<a name="l00126"></a>00126         <span class="keyword">const</span> IntVar* load = routing.CumulVar(index, <span class="stringliteral">"demand"</span>);
<a name="l00127"></a>00127         StringAppendF(&amp;output, <span class="stringliteral">"Load(%lld..%lld) "</span>,
<a name="l00128"></a>00128                       assignment.Min(load),
<a name="l00129"></a>00129                       assignment.Max(load));
<a name="l00130"></a>00130         index = assignment.Value(routing.NextVar(index));
<a name="l00131"></a>00131         StringAppendF(&amp;output, <span class="stringliteral">"Transit(%lld) "</span>,
<a name="l00132"></a>00132                       <a class="code" href="namespaceoperations__research.html#2a4cd35bcbb1b316b7664c1eaf206052" title="Returns the scaled (distance plus service time) between two nodes, coords holding...">TravelPlusServiceTime</a>(&amp;coords,
<a name="l00133"></a>00133                                             &amp;service_times,
<a name="l00134"></a>00134                                             real_node,
<a name="l00135"></a>00135                                             routing.IndexToNode(index)));
<a name="l00136"></a>00136       }
<a name="l00137"></a>00137       StringAppendF(&amp;output, <span class="stringliteral">"Route end "</span>);
<a name="l00138"></a>00138       <span class="keyword">const</span> IntVar* vehicle = routing.VehicleVar(index);
<a name="l00139"></a>00139       StringAppendF(&amp;output, <span class="stringliteral">"Vehicle(%lld) "</span>, assignment.Value(vehicle));
<a name="l00140"></a>00140       <span class="keyword">const</span> IntVar* arrival = routing.CumulVar(index, <span class="stringliteral">"time"</span>);
<a name="l00141"></a>00141       StringAppendF(&amp;output, <span class="stringliteral">"Time(%lld..%lld) "</span>,
<a name="l00142"></a>00142                     assignment.Min(arrival),
<a name="l00143"></a>00143                     assignment.Max(arrival));
<a name="l00144"></a>00144       <span class="keyword">const</span> IntVar* load = routing.CumulVar(index, <span class="stringliteral">"demand"</span>);
<a name="l00145"></a>00145       StringAppendF(&amp;output, <span class="stringliteral">"Load(%lld..%lld) "</span>,
<a name="l00146"></a>00146                     assignment.Min(load),
<a name="l00147"></a>00147                     assignment.Max(load));
<a name="l00148"></a>00148     }
<a name="l00149"></a>00149     StringAppendF(&amp;output, <span class="stringliteral">"\n"</span>);
<a name="l00150"></a>00150   }
<a name="l00151"></a>00151   <span class="keywordflow">return</span> output;
<a name="l00152"></a>00152 }
<a name="l00153"></a>00153 
<a name="l00154"></a>00154 <span class="keyword">namespace </span>{
<a name="l00155"></a>00155 <span class="comment">// An inefficient but convenient method to parse a whitespace-separated list</span>
<a name="l00156"></a>00156 <span class="comment">// of integers. Returns true iff the input string was entirely valid and parsed.</span>
<a name="l00157"></a><a class="code" href="namespaceoperations__research.html#ced86e1ff9781b10235319d45615602f">00157</a> <span class="keywordtype">bool</span> <a class="code" href="namespaceoperations__research.html#ced86e1ff9781b10235319d45615602f" title="An inefficient but convenient method to parse a whitespace-separated list of integers...">SafeParseInt64Array</a>(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; str, std::vector&lt;int64&gt;* parsed_int) {
<a name="l00158"></a>00158   std::vector&lt;string&gt; items;
<a name="l00159"></a>00159   <span class="keyword">static</span> <span class="keyword">const</span> <span class="keywordtype">char</span> kWhiteSpaces[] = <span class="stringliteral">" \t\n\v\f\r"</span>;
<a name="l00160"></a>00160   SplitStringUsing(str, kWhiteSpaces, &amp;items);
<a name="l00161"></a>00161   parsed_int-&gt;assign(items.size(), 0);
<a name="l00162"></a>00162   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; items.size(); ++i) {
<a name="l00163"></a>00163     <span class="keyword">const</span> <span class="keywordtype">char</span>* item = items[i].c_str();
<a name="l00164"></a>00164     <span class="keywordtype">char</span> *endptr = NULL;
<a name="l00165"></a>00165     (*parsed_int)[i] = strto64(item, &amp;endptr, 10);  <span class="comment">// NOLINT</span>
<a name="l00166"></a>00166     <span class="comment">// The whole item should have been consumed.</span>
<a name="l00167"></a>00167     <span class="keywordflow">if</span> (*endptr != <span class="charliteral">'\0'</span>) <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00168"></a>00168   }
<a name="l00169"></a>00169   <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00170"></a>00170 }
<a name="l00171"></a>00171 }
<a name="l00172"></a>00172 
<a name="l00173"></a>00173 <span class="comment">// Builds and solves a model from a file in the format defined by Li &amp; Lim</span>
<a name="l00174"></a>00174 <span class="comment">// (http://www.sintef.no/static/am/opti/projects/top/vrp/format_pdp.htm).</span>
<a name="l00175"></a><a class="code" href="namespaceoperations__research.html#a6e773eda1c0257625a1d8b9b304b971">00175</a> <span class="keywordtype">bool</span> <a class="code" href="namespaceoperations__research.html#a6e773eda1c0257625a1d8b9b304b971" title="Builds and solves a model from a file in the format defined by Li &amp;amp; Lim (http://www...">LoadAndSolve</a>(<span class="keyword">const</span> <span class="keywordtype">string</span>&amp; pdp_file) {
<a name="l00176"></a>00176   <span class="comment">// Load all the lines of the file in RAM (it shouldn't be too large anyway).</span>
<a name="l00177"></a>00177   std::vector&lt;string&gt; lines;
<a name="l00178"></a>00178   {
<a name="l00179"></a>00179     <span class="keyword">const</span> int64 kMaxInputFileSize = 1 &lt;&lt; 30;  <span class="comment">// 1GB</span>
<a name="l00180"></a>00180     File* data_file = File::OpenOrDie(pdp_file.c_str(), <span class="stringliteral">"r"</span>);
<a name="l00181"></a>00181     <span class="keywordtype">string</span> contents;
<a name="l00182"></a>00182     data_file-&gt;ReadToString(&amp;contents, kMaxInputFileSize);
<a name="l00183"></a>00183     data_file-&gt;Close();
<a name="l00184"></a>00184     <span class="keywordflow">if</span> (contents.size() == kMaxInputFileSize) {
<a name="l00185"></a>00185       LOG(WARNING)
<a name="l00186"></a>00186           &lt;&lt; <span class="stringliteral">"Input file '"</span> &lt;&lt; pdp_file &lt;&lt; <span class="stringliteral">"' is too large (&gt;"</span>
<a name="l00187"></a>00187           &lt;&lt; kMaxInputFileSize &lt;&lt; <span class="stringliteral">" bytes)."</span>;
<a name="l00188"></a>00188       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00189"></a>00189     }
<a name="l00190"></a>00190     SplitStringUsing(contents, <span class="stringliteral">"\n"</span>, &amp;lines);
<a name="l00191"></a>00191   }
<a name="l00192"></a>00192   <span class="comment">// Reading header.</span>
<a name="l00193"></a>00193   <span class="keywordflow">if</span> (lines.empty()) {
<a name="l00194"></a>00194     LOG(WARNING) &lt;&lt; <span class="stringliteral">"Empty file: "</span> &lt;&lt; pdp_file;
<a name="l00195"></a>00195     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00196"></a>00196   }
<a name="l00197"></a>00197   <span class="comment">// Parse file header.</span>
<a name="l00198"></a>00198   std::vector&lt;int64&gt; parsed_int;
<a name="l00199"></a>00199   <span class="keywordflow">if</span> (!<a class="code" href="namespaceoperations__research.html#ced86e1ff9781b10235319d45615602f" title="An inefficient but convenient method to parse a whitespace-separated list of integers...">SafeParseInt64Array</a>(lines[0], &amp;parsed_int)
<a name="l00200"></a>00200       || parsed_int.size() != 3
<a name="l00201"></a>00201       || parsed_int[0] &lt; 0
<a name="l00202"></a>00202       || parsed_int[1] &lt; 0
<a name="l00203"></a>00203       || parsed_int[2] &lt; 0) {
<a name="l00204"></a>00204     LOG(WARNING) &lt;&lt; <span class="stringliteral">"Malformed header: "</span> &lt;&lt; lines[0];
<a name="l00205"></a>00205     <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00206"></a>00206   }
<a name="l00207"></a>00207   <span class="keyword">const</span> <span class="keywordtype">int</span> num_vehicles = FLAGS_pdp_force_vehicles &gt; 0 ?
<a name="l00208"></a>00208       FLAGS_pdp_force_vehicles : parsed_int[0];
<a name="l00209"></a>00209   <span class="keyword">const</span> int64 capacity = parsed_int[1];
<a name="l00210"></a>00210   <span class="comment">// We do not care about the 'speed' field, in third position.</span>
<a name="l00211"></a>00211 
<a name="l00212"></a>00212   <span class="comment">// Parse order data.</span>
<a name="l00213"></a>00213   std::vector&lt;int&gt; customer_ids;
<a name="l00214"></a>00214   std::vector&lt;std::pair&lt;int, int&gt; &gt; coords;
<a name="l00215"></a>00215   std::vector&lt;int64&gt; demands;
<a name="l00216"></a>00216   std::vector&lt;int64&gt; open_times;
<a name="l00217"></a>00217   std::vector&lt;int64&gt; close_times;
<a name="l00218"></a>00218   std::vector&lt;int64&gt; service_times;
<a name="l00219"></a>00219   std::vector&lt;RoutingModel::NodeIndex&gt; pickups;
<a name="l00220"></a>00220   std::vector&lt;RoutingModel::NodeIndex&gt; deliveries;
<a name="l00221"></a>00221   int64 horizon = 0;
<a name="l00222"></a>00222   <span class="keywordflow">for</span> (<span class="keywordtype">int</span> line_index = 1; line_index &lt; lines.size(); ++line_index) {
<a name="l00223"></a>00223     <span class="keywordflow">if</span> (!<a class="code" href="namespaceoperations__research.html#ced86e1ff9781b10235319d45615602f" title="An inefficient but convenient method to parse a whitespace-separated list of integers...">SafeParseInt64Array</a>(lines[line_index], &amp;parsed_int)
<a name="l00224"></a>00224         || parsed_int.size() != 9
<a name="l00225"></a>00225         || parsed_int[0] &lt; 0
<a name="l00226"></a>00226         || parsed_int[4] &lt; 0
<a name="l00227"></a>00227         || parsed_int[5] &lt; 0
<a name="l00228"></a>00228         || parsed_int[6] &lt; 0
<a name="l00229"></a>00229         || parsed_int[7] &lt; 0
<a name="l00230"></a>00230         || parsed_int[8] &lt; 0) {
<a name="l00231"></a>00231       LOG(WARNING)
<a name="l00232"></a>00232           &lt;&lt; <span class="stringliteral">"Malformed line #"</span> &lt;&lt; line_index &lt;&lt; <span class="stringliteral">": "</span> &lt;&lt; lines[line_index];
<a name="l00233"></a>00233       <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00234"></a>00234     }
<a name="l00235"></a>00235     <span class="keyword">const</span> <span class="keywordtype">int</span> customer_id = parsed_int[0];
<a name="l00236"></a>00236     <span class="keyword">const</span> <span class="keywordtype">int</span> x = parsed_int[1];
<a name="l00237"></a>00237     <span class="keyword">const</span> <span class="keywordtype">int</span> y = parsed_int[2];
<a name="l00238"></a>00238     <span class="keyword">const</span> <span class="keywordtype">int</span> delivery = parsed_int[8];  <span class="comment">// Parse 'delivery' before 'demand'.</span>
<a name="l00239"></a>00239     <span class="keyword">const</span> int64 demand = delivery == 0 ? -parsed_int[3] : parsed_int[3];
<a name="l00240"></a>00240     <span class="keyword">const</span> int64 open_time = parsed_int[4];
<a name="l00241"></a>00241     <span class="keyword">const</span> int64 close_time = parsed_int[5];
<a name="l00242"></a>00242     <span class="keyword">const</span> int64 service_time = parsed_int[6];
<a name="l00243"></a>00243     <span class="keyword">const</span> <span class="keywordtype">int</span> pickup = parsed_int[7];
<a name="l00244"></a>00244     customer_ids.push_back(customer_id);
<a name="l00245"></a>00245     coords.push_back(std::make_pair(x, y));
<a name="l00246"></a>00246     demands.push_back(demand);
<a name="l00247"></a>00247     open_times.push_back(open_time);
<a name="l00248"></a>00248     close_times.push_back(close_time);
<a name="l00249"></a>00249     service_times.push_back(service_time);
<a name="l00250"></a>00250     pickups.push_back(RoutingModel::NodeIndex(pickup));
<a name="l00251"></a>00251     deliveries.push_back(RoutingModel::NodeIndex(delivery));
<a name="l00252"></a>00252     horizon = std::max(horizon, close_time);
<a name="l00253"></a>00253   }
<a name="l00254"></a>00254 
<a name="l00255"></a>00255   <span class="comment">// Build pickup and delivery model.</span>
<a name="l00256"></a>00256   <span class="keyword">const</span> <span class="keywordtype">int</span> num_nodes = customer_ids.size();
<a name="l00257"></a>00257   RoutingModel routing(num_nodes, num_vehicles);
<a name="l00258"></a>00258   routing.SetCost(NewPermanentCallback(
<a name="l00259"></a>00259       <a class="code" href="namespaceoperations__research.html#62615656dde53d8931420c2cd24e9562" title="Returns the scaled Euclidean distance between two nodes, coords holding the coordinates...">Travel</a>, const_cast&lt;const Coordinates*&gt;(&amp;coords)));
<a name="l00260"></a>00260   routing.AddDimension(
<a name="l00261"></a>00261       NewPermanentCallback(&amp;<a class="code" href="structoperations__research_1_1Demand.html" title="Solving the Problem.">Demand</a>, <span class="keyword">const_cast&lt;</span><span class="keyword">const </span>std::vector&lt;int64&gt;*<span class="keyword">&gt;</span>(&amp;demands)),
<a name="l00262"></a>00262       0, capacity, <span class="stringliteral">"demand"</span>);
<a name="l00263"></a>00263   routing.AddDimension(
<a name="l00264"></a>00264       NewPermanentCallback(&amp;<a class="code" href="namespaceoperations__research.html#2a4cd35bcbb1b316b7664c1eaf206052" title="Returns the scaled (distance plus service time) between two nodes, coords holding...">TravelPlusServiceTime</a>,
<a name="l00265"></a>00265                            const_cast&lt;const Coordinates*&gt;(&amp;coords),
<a name="l00266"></a>00266                            <span class="keyword">const_cast&lt;</span><span class="keyword">const </span>std::vector&lt;int64&gt;*<span class="keyword">&gt;</span>(&amp;service_times)),
<a name="l00267"></a>00267       <a class="code" href="namespaceoperations__research.html#1ecc1740b95fee9e7a7748eeb15f32dd" title="Scaling factor used to scale up distances, allowing a bit more precision from Euclidean...">kScalingFactor</a> * horizon,
<a name="l00268"></a>00268       <a class="code" href="namespaceoperations__research.html#1ecc1740b95fee9e7a7748eeb15f32dd" title="Scaling factor used to scale up distances, allowing a bit more precision from Euclidean...">kScalingFactor</a> * horizon,
<a name="l00269"></a>00269       <span class="stringliteral">"time"</span>);
<a name="l00270"></a>00270   Solver* <span class="keyword">const</span> solver = routing.solver();
<a name="l00271"></a>00271   <span class="keywordflow">for</span> (RoutingModel::NodeIndex i(0); i &lt; num_nodes; ++i) {
<a name="l00272"></a>00272     <span class="keyword">const</span> int64 index = routing.NodeToIndex(i);
<a name="l00273"></a>00273     <span class="keywordflow">if</span> (pickups[i.value()] == 0) {
<a name="l00274"></a>00274       <span class="keywordflow">if</span> (deliveries[i.value()] == 0) {
<a name="l00275"></a>00275         routing.SetDepot(i);
<a name="l00276"></a>00276       } <span class="keywordflow">else</span> {
<a name="l00277"></a>00277         <span class="keyword">const</span> int64 delivery_index = routing.NodeToIndex(deliveries[i.value()]);
<a name="l00278"></a>00278         solver-&gt;AddConstraint(solver-&gt;MakeEquality(
<a name="l00279"></a>00279             routing.VehicleVar(index),
<a name="l00280"></a>00280             routing.VehicleVar(delivery_index)));
<a name="l00281"></a>00281         solver-&gt;AddConstraint(solver-&gt;MakeLessOrEqual(
<a name="l00282"></a>00282             routing.CumulVar(index, <span class="stringliteral">"time"</span>),
<a name="l00283"></a>00283             routing.CumulVar(delivery_index, <span class="stringliteral">"time"</span>)));
<a name="l00284"></a>00284         routing.AddPickupAndDelivery(i, deliveries[i.value()]);
<a name="l00285"></a>00285       }
<a name="l00286"></a>00286     }
<a name="l00287"></a>00287     IntVar* <span class="keyword">const</span> cumul = routing.CumulVar(index, <span class="stringliteral">"time"</span>);
<a name="l00288"></a>00288     cumul-&gt;SetMin(<a class="code" href="namespaceoperations__research.html#1ecc1740b95fee9e7a7748eeb15f32dd" title="Scaling factor used to scale up distances, allowing a bit more precision from Euclidean...">kScalingFactor</a> * open_times[i.value()]);
<a name="l00289"></a>00289     cumul-&gt;SetMax(<a class="code" href="namespaceoperations__research.html#1ecc1740b95fee9e7a7748eeb15f32dd" title="Scaling factor used to scale up distances, allowing a bit more precision from Euclidean...">kScalingFactor</a> * close_times[i.value()]);
<a name="l00290"></a>00290   }
<a name="l00291"></a>00291   <span class="comment">// Adding penalty costs to allow skipping orders.</span>
<a name="l00292"></a>00292   <span class="keyword">const</span> int64 kPenalty = 10000000;
<a name="l00293"></a>00293   <span class="keywordflow">for</span> (RoutingModel::NodeIndex order(1);
<a name="l00294"></a>00294        order &lt; routing.nodes(); ++order) {
<a name="l00295"></a>00295     std::vector&lt;RoutingModel::NodeIndex&gt; orders(1, order);
<a name="l00296"></a>00296     routing.AddDisjunction(orders, kPenalty);
<a name="l00297"></a>00297   }
<a name="l00298"></a>00298 
<a name="l00299"></a>00299   <span class="comment">// Set up search parameters.</span>
<a name="l00300"></a>00300   routing.set_first_solution_strategy(RoutingModel::ROUTING_ALL_UNPERFORMED);
<a name="l00301"></a>00301   routing.SetCommandLineOption(<span class="stringliteral">"routing_no_lns"</span>, <span class="stringliteral">"true"</span>);
<a name="l00302"></a>00302 
<a name="l00303"></a>00303   <span class="comment">// Solve pickup and delivery problem.</span>
<a name="l00304"></a>00304   <span class="keyword">const</span> Assignment* assignment =  routing.Solve(NULL);
<a name="l00305"></a>00305   <span class="keywordflow">if</span> (NULL != assignment) {
<a name="l00306"></a>00306     LG &lt;&lt; <span class="stringliteral">"Cost: "</span> &lt;&lt; assignment-&gt;ObjectiveValue();
<a name="l00307"></a>00307     LG &lt;&lt; <a class="code" href="namespaceoperations__research.html#0f9a7f1456850f9c6c7fa685781b6a27" title="Outputs a solution to the current model in a string.">VerboseOutput</a>(routing, *assignment, coords, service_times);
<a name="l00308"></a>00308     <span class="keywordflow">return</span> <span class="keyword">true</span>;
<a name="l00309"></a>00309   }
<a name="l00310"></a>00310   <span class="keywordflow">return</span> <span class="keyword">false</span>;
<a name="l00311"></a>00311 }
<a name="l00312"></a>00312 
<a name="l00313"></a>00313 }  <span class="comment">// namespace operations_research</span>
<a name="l00314"></a>00314 
<a name="l00315"></a><a class="code" href="pdptw_8cc.html#3c04138a5bfe5d72780bb7e82a18e627">00315</a> <span class="keywordtype">int</span> <a class="code" href="costas__array_8cc.html#3c04138a5bfe5d72780bb7e82a18e627" title="namespace operations_research">main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> **argv) {
<a name="l00316"></a>00316   google::ParseCommandLineFlags(&amp;argc, &amp;argv, <span class="keyword">true</span>);
<a name="l00317"></a>00317   <span class="keywordflow">if</span> (!<a class="code" href="namespaceoperations__research.html#a6e773eda1c0257625a1d8b9b304b971" title="Builds and solves a model from a file in the format defined by Li &amp;amp; Lim (http://www...">operations_research::LoadAndSolve</a>(FLAGS_pdp_file)) {
<a name="l00318"></a>00318     LG &lt;&lt; <span class="stringliteral">"Error solving "</span> &lt;&lt; FLAGS_pdp_file;
<a name="l00319"></a>00319   }
<a name="l00320"></a>00320   <span class="keywordflow">return</span> 0;
<a name="l00321"></a>00321 }
</pre></div></div>

  <!-- Start of footer. -->
  <table width=100% cellpadding=0 cellspacing=0 border=0>
    <tr valign=top>
      <td colspan=2 height=10></td>
    </tr>
    <tr valign=top>
      <td colspan=2 bgcolor=#025402 height=3></td>
    </tr>
  </table>

  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br /><br />
  <br /><br />

  
  </body>
</html>
