

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>6.5. Basic working of the solver: Local Search &mdash; or-tools User&#39;s Manual</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     'doc version 0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../_static/logo.ico"/>
    <link rel="top" title="or-tools User&#39;s Manual" href="../../index.html" />
    <link rel="up" title="6. Local search: the job-shop problem" href="../LS.html" />
    <link rel="next" title="6.6. Local Search Operators" href="ls_operators.html" />
    <link rel="prev" title="6.4. What is local search (LS)?" href="local_search.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="ls_operators.html" title="6.6. Local Search Operators"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="local_search.html" title="6.4. What is local search (LS)?"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">or-tools User&#39;s Manual</a> &raquo;</li>
          <li><a href="../LS.html" accesskey="U">6. Local search: the job-shop problem</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="basic-working-of-the-solver-local-search">
<span id="basic-working-local-search"></span><h1>6.5. Basic working of the solver: Local Search</h1>
<p>In this section, we present the implementation of Local Search in <em>or-tools</em>. First, we sketch the main basic idea
and then we list the main actors (aka classes) that participate in the Local Search. It&#8217;s good to keep them in memory
for the rest of this section. We then overview the implementation
and describe some of its main components. Finally, we detail the inner workings of the Local Search algorithm and
indicate where the callbacks of the <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt>s are called.</p>
<p>We present a simplified version of the local search algorithm. Yes, this is well worth a warning box!</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">We describe a simplified version of the local search algorithm.</p>
</div>
<div class="section" id="the-basic-idea">
<h2>6.5.1. The basic idea</h2>
<p>The Local Search algorithm is implemented with the <tt class="docutils literal"><span class="pre">LocalSearch</span></tt> <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> which
returns <tt class="docutils literal"><span class="pre">NestedSolveDecision</span></tt>s (through its <tt class="docutils literal"><span class="pre">Next()</span></tt> method). These <tt class="docutils literal"><span class="pre">NestedSolveDecision</span></tt>s in turn
collect the solutions returned by the <tt class="docutils literal"><span class="pre">FindOneNeighbor</span></tt>
<tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> in their left branches (and don&#8217;t do anything in their right branches). As its name implies, the
<tt class="docutils literal"><span class="pre">FindOneNeighbor</span></tt> <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> tries to find one solution. The <tt class="docutils literal"><span class="pre">LocalSearch</span></tt> <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>
stops the search when stopping criteria are met or when it can not improve the last solution found. This
solution is thus a local optimum w.r.t. the chosen neighborhood.</p>
<p>If needed, the search
can be restarted again around a new initial solution. The <tt class="docutils literal"><span class="pre">LocalSearch</span></tt>
<tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> then acts like a multi-restart <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>. We exploit this property in the
chapter <a class="reference internal" href="../metaheuristics.html#chapter-metaheuristics"><em>Meta-heuristics: several previous problems</em></a> when we implement (meta-)heuristics based on local searches that restart
from a given solution.</p>
<p>Wow, this went fast! Let&#8217;s summarize all this in the next picture:</p>
<img alt="../../_images/ls_basic_idea1.png" class="align-center" src="../../_images/ls_basic_idea1.png" style="width: 500pt;" />
<p><tt class="docutils literal"><span class="pre">ls</span></tt> is the <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt> that constructs the candidate solutions. The search
tree very quickly becomes completely unbalanced if we only keep finding solutions in the left branches. We&#8217;ll see a balancing
mechanism that involves one <tt class="docutils literal"><span class="pre">BalancingDecision</span></tt> at the end of this section.</p>
<p>Speaking about <em>candidate</em> solutions, let&#8217;s agree on some wordings. The next figure presents the beginning of a Local Search.
<img class="math" src="../../_images/math/17f1249ad95b7682b8316ad21de8ce4ee9fdcf93.png" alt="x_0" style="vertical-align: -3px"/> is the initial solution. In <em>or-tools</em>, this solution is given by an <tt class="docutils literal"><span class="pre">Assignment</span></tt> or a <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> that
the <tt class="docutils literal"><span class="pre">LocalSearch</span></tt> class uses to construct this initial solution. <img class="math" src="../../_images/math/c3ea81f00b5d17fe09a364fafffd82aec51d2c4a.png" alt="x_0, x_1, x_2, \ldots" style="vertical-align: -4px"/> are <em>solutions</em>. As we have seen,
the Local Search algorithm moves from one solution to another. It takes a starting solution <img class="math" src="../../_images/math/67bc6daa9d6b964201d6cef60cbeb1ac5fd26ead.png" alt="x_i" style="vertical-align: -3px"/> and visit the
neighborhood defined around <img class="math" src="../../_images/math/67bc6daa9d6b964201d6cef60cbeb1ac5fd26ead.png" alt="x_i" style="vertical-align: -3px"/> to find the next solution <img class="math" src="../../_images/math/b5c170dc53fce7452e6f7df461222672d913e34e.png" alt="x_{i+1}" style="vertical-align: -4px"/>. By <em>visiting</em> the neighborhood, we mean
constructing and testing feasible solutions <img class="math" src="../../_images/math/a88de92e555acbcd03724adc1816ed1c044438c7.png" alt="y_0 = x_i, y_1, y_2, \ldots" style="vertical-align: -4px"/> of this neighborhood. We call these solutions
<em>candidate</em> solutions. In the code, they are called <em>neighbors</em>. The <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt> produces these candidates and
the <tt class="docutils literal"><span class="pre">FindOneNeighbor</span></tt> <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> filter these out to keep the interesting candidate solutions only. When a
stopping criteria is met or the neighborhood has been exhausted, the current solution of the CP solver is the next starting
solution.</p>
<p>Let&#8217;s illustrate this:</p>
<img alt="../../_images/ls_basic_idea2.png" class="align-center" src="../../_images/ls_basic_idea2.png" style="width: 500pt;" />
<p>The code consistently use the term <em>neighbor</em> to denote what we call a <em>candidate solution</em> in this manual.
We prefer to emphasize the fact
that this <em>neighbor</em> solution is in fact a feasible solution that the CP solver tests and accepts or rejects.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">In this manual, we use the term <em>candidate solution</em> for what is consistently called a <em>neighbor</em> in the code.</p>
</div>
<div class="section" id="the-main-actors">
<h3>6.5.1.1. The main actors</h3>
<p>The main classes involved in the local search algorithm are:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">LocalSearch</span></tt>: This <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> controls the local search algorithm.</li>
<li><tt class="docutils literal"><span class="pre">LocalSearchPhaseParameters</span></tt>: This class gathers the components to define the current local search.</li>
<li><tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>s: This class is responsible of constructing the candidate solutions.</li>
<li><tt class="docutils literal"><span class="pre">FindOneNeighbor</span></tt>: This <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> filters the candidate solutions given by the <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>
and only constructs <em>filtered</em> and <em>accepted</em> (solutions accepted by the CP solver as feasible solutions) solutions.</li>
<li><tt class="docutils literal"><span class="pre">NestedSolveDecision</span></tt>: This <tt class="docutils literal"><span class="pre">Decision</span></tt> invokes a nested search with another <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>
(<tt class="docutils literal"><span class="pre">FindOneNeighbor</span></tt> in this case) in its left branch
(<tt class="docutils literal"><span class="pre">Apply()</span></tt> method) and does nothing in its right branch (<tt class="docutils literal"><span class="pre">Refute()</span></tt> method).</li>
<li><tt class="docutils literal"><span class="pre">LocalSearchFilter</span></tt>: This filter allows to immediately skip (discard) a candidate solution. It is used
by <tt class="docutils literal"><span class="pre">FindOneNeighbor</span></tt> to filter the candidate solutions.</li>
</ul>
<p>We will not discuss the filtering mechanism here (see the dedicated section <a class="reference internal" href="ls_filtering.html#local-search-filtering"><em>Filtering</em></a>).</p>
</div>
</div>
<div class="section" id="overview-of-the-local-search-mechanism-in-or-tools">
<span id="local-search-mechanism"></span><h2>6.5.2. Overview of the Local Search Mechanism in <em>or-tools</em></h2>
<p>The next figure illustrates the basic mechanism of local search in <em>or-tools</em>:</p>
<img alt="../../_images/lsn_mechanism.png" class="align-center" src="../../_images/lsn_mechanism.png" style="width: 500pt;" />
<p>We start with an initial feasible solution. The <tt class="docutils literal"><span class="pre">MakeOneNeighbor()</span></tt> callback method
from the local search operator(s)<a class="footnote-reference" href="#local-search-operator-singular" id="id1">[1]</a>
constructs candidate solutions one by one<a class="footnote-reference" href="#makeoneneighbor-convenience-fct" id="id2">[2]</a>. These solutions are checked by the CP solver and completed if needed.
The &#8220;best&#8221; solution
is chosen and the process is repeated starting with this new improved
solution<a class="footnote-reference" href="#local-search-default-best-solution-update" id="id3">[3]</a>.</p>
<table class="docutils footnote" frame="void" id="local-search-operator-singular" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>In the code, you are only allowed to use <strong>one</strong> <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt> but
you can combine several <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>s in one <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>. This is a common pattern in the code.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="makeoneneighbor-convenience-fct" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><tt class="docutils literal"><span class="pre">MakeOneNeighbor()</span></tt> is a convenient method. The real method to create a new
candidate is <tt class="docutils literal"><span class="pre">MakeNextNeighbor(Assignment*</span> <span class="pre">delta,</span> <span class="pre">Assignment*</span> <span class="pre">deltadelta)</span></tt> but you have to deal with the low
level <tt class="docutils literal"><span class="pre">delta</span></tt> and <tt class="docutils literal"><span class="pre">deltadelta</span></tt>. We discuss these details in the
section <a class="reference internal" href="jobshop_ls.html#local-search-operators-the-real-thing"><em>LocalSearchOperators: the real thing!</em></a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="local-search-default-best-solution-update" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>By default, the solver accepts the
first feasible solution and repeats the search starting with
this new solution. The idea is that if you combine the local search with an <tt class="docutils literal"><span class="pre">ObjectiveVar</span></tt>,
the next feasible solution will be a solution that beats the current best solution.
You can change this behaviour with a <tt class="docutils literal"><span class="pre">SearchLimit</span></tt>. See below.</td></tr>
</tbody>
</table>
<p>The whole search process stops
whenever a stopping criterion is reached or the CP solver cannot improve anymore the current best solution.</p>
<p>Let&#8217;s describe some pieces of the <em>or-tools</em> mechanism for local search:</p>
<blockquote>
<div><ul class="simple">
<li><strong>initial solution</strong>: we need a <strong>feasible</strong> solution to start with. You can either pass an <tt class="docutils literal"><span class="pre">Assignment</span></tt> or
a <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> to the <tt class="docutils literal"><span class="pre">LocalSearch</span></tt>&#8216;s constructor.</li>
<li><strong>LocalSearchPhaseParameters</strong>: the <tt class="docutils literal"><span class="pre">LocalSearchPhaseParameters</span></tt> parameter holds the actual definition
of the local search phase:<ul>
<li>a <strong>SolutionPool</strong> that keep solution(s);</li>
<li>a <strong>LocalSearchOperator</strong> used to explore the neighborhood of the current solution. You can combine
several <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>s into one <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>;</li>
<li>a <em>complementary</em> <strong>DecisionBuilder</strong> to instantiate unbound variables once an (incomplete) candidate solution has
been defined by the <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>. It will also complete the initial <tt class="docutils literal"><span class="pre">Assignment</span></tt> or the solution provided
by the initial <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>.;</li>
<li>a <strong>Searchlimit</strong> specifying the stopping criteria each time we start searching a new neighborhood;</li>
<li>an <tt class="docutils literal"><span class="pre">std::vector</span></tt> of <strong>LocalSearchFilter</strong>s used to speed up the search by pruning
unfeasible (or undesirable) candidate solutions: instead of letting the solver find out if a candidate solution is feasible or not, you
can help it by bypassing its checking mechanism and telling it right away if a candidate solution is not feasible.</li>
</ul>
</li>
</ul>
</div></blockquote>
<p><tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>s are detailed in the next section and <tt class="docutils literal"><span class="pre">LocalSearchFilter</span></tt>s in
the section <a class="reference internal" href="ls_filtering.html#local-search-filtering"><em>Filtering</em></a>.</p>
<p>We now detail these two basics ingredients that are the initial solution and the <tt class="docutils literal"><span class="pre">LocalSearchPhaseParameters</span></tt> parameter.</p>
<div class="section" id="the-initial-solution">
<h3>6.5.2.1. The initial solution</h3>
<p>To start the local search, we need an initial <em>feasible</em> solution. We can either give a starting
solution or we can ask the CP solver to find one for us. To let the solver find a solution for us,
we pass to it a <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>. The <strong>first</strong> solution discovered by this <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> will be taken
as the initial solution.</p>
<p>There is a factory method for each one of the two options:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">DecisionBuilder</span><span class="o">*</span> <span class="n">Solver</span><span class="o">::</span><span class="n">MakeLocalSearchPhase</span><span class="p">(</span><span class="n">Assignment</span><span class="o">*</span> <span class="n">assignment</span><span class="p">,</span>
                              <span class="n">LocalSearchPhaseParameters</span><span class="o">*</span> <span class="n">parameters</span><span class="p">)</span>

<span class="n">DecisionBuilder</span><span class="o">*</span> <span class="n">Solver</span><span class="o">::</span><span class="n">MakeLocalSearchPhase</span><span class="p">(</span>
                              <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IntVar</span><span class="o">*&gt;&amp;</span> <span class="n">vars</span><span class="p">,</span>
                              <span class="n">DecisionBuilder</span><span class="o">*</span> <span class="n">first_solution</span><span class="p">,</span>
                              <span class="n">LocalSearchPhaseParameters</span><span class="o">*</span> <span class="n">parameters</span><span class="p">)</span>
</pre></div>
</div>
<p>In the file <tt class="file docutils literal"><span class="pre">dummy_ls.cc</span></tt>, we use a <strong class="program">gflags</strong> flag <tt class="docutils literal"><span class="pre">FLAG_initial_phase</span></tt>
to switch between these two possibilities.</p>
<div class="topic">
<p class="topic-title first">What are the variables involved in the local search procedure?</p>
<p>The local search <strong>only</strong> applies to the variables contained either in the <tt class="docutils literal"><span class="pre">Assignment</span></tt>
or the <tt class="docutils literal"><span class="pre">std::vector&lt;IntVar*&gt;</span></tt> of variables given to <tt class="docutils literal"><span class="pre">MakeLocalSearchPhase()</span></tt>.</p>
</div>
</div>
<div class="section" id="the-localsearchphaseparameters-parameter">
<span id="local-search-parameters"></span><h3>6.5.2.2. The <tt class="docutils literal"><span class="pre">LocalSearchPhaseParameters</span></tt> parameter</h3>
<p>The <tt class="docutils literal"><span class="pre">LocalSearchPhaseParameters</span></tt> parameter holds the actual definition
of the local search phase.</p>
<p>It basically consists in:</p>
<ul>
<li><p class="first">a <tt class="docutils literal"><span class="pre">SolutionPool</span></tt>: as its name implies, this class is a pool of solutions. As usual, <tt class="docutils literal"><span class="pre">SolutionPool</span></tt> is a pure virtual
class that must be implemented. One such implementation is the <tt class="docutils literal"><span class="pre">DefaultSolutionPool</span></tt> that only keeps the current
solution. You don&#8217;t have to provide one as it is constructed by default if you use the appropriate factory method.
If you want to keep intermediate solutions
or want to modify these solutions during the search, you might have to implement your own version. Four methods have to
be implemented:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">void</span> <span class="pre">Initialize(Assignment*</span> <span class="pre">const</span> <span class="pre">assignment)</span></tt>: This method is called to initialize the
<tt class="docutils literal"><span class="pre">SolutionPool</span></tt> with the initial <tt class="docutils literal"><span class="pre">Assignment</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">void</span> <span class="pre">RegisterNewSolution(Assignment*</span> <span class="pre">const</span> <span class="pre">assignment)</span></tt>: This method is called when a new
solution has been accepted by the local search algorithm.</li>
<li><tt class="docutils literal"><span class="pre">void</span> <span class="pre">GetNextSolution(Assignment*</span> <span class="pre">const</span> <span class="pre">assignment)</span></tt>: This method is called when the local search algorithm
starts a new neighborhood. <tt class="docutils literal"><span class="pre">assigment</span></tt> is the solution to start the new neighborhood search.</li>
<li><tt class="docutils literal"><span class="pre">bool</span> <span class="pre">SyncNeeded(Assignment*</span> <span class="pre">const</span> <span class="pre">local_assignment)</span></tt>: This method checks if the current solution needs to
be updated, i.e. the pool can oblige the solver to start a new neighborhood search with the next
solution given by the pool (given by its <tt class="docutils literal"><span class="pre">GetNextSolution()</span></tt> method, see the <tt class="docutils literal"><span class="pre">Next()</span></tt> method of
the <tt class="docutils literal"><span class="pre">FindOneNeighbor</span></tt> <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> class below).</li>
</ul>
<p>A <tt class="docutils literal"><span class="pre">SolutionPool</span></tt> gives you complete control on the starting solution(s). Note that the <tt class="docutils literal"><span class="pre">SolutionPool</span></tt>
<strong>must</strong> take ownership of the <tt class="docutils literal"><span class="pre">Assignment</span></tt>s it keeps<a class="footnote-reference" href="#solution-pool-takes-ownership-of-solutions-or-else" id="id4">[4]</a>.</p>
<table class="docutils footnote" frame="void" id="solution-pool-takes-ownership-of-solutions-or-else" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td><p class="first last">Well, you could devise another way to keep track of the solutions
and take care of their existence but anyhow, you are responsible for these solutions.</p>
</td></tr>
</tbody>
</table>
</li>
<li><p class="first">a <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>: a <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt> or a combination of <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>s explore the
neighborhood of the current solution. We detail them in the next section.</p>
</li>
<li><p class="first">a <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>: this <em>complementary</em> <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> helps creating feasible solutions if your <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>s
only return partial solutions, i.e. solutions with unbounded variables. It also completes the initial solution if needed.
If you know that your candidate and the initial solutions are already feasible, you don&#8217;t have to provide this
<tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> (set the corresponding pointer to <tt class="docutils literal"><span class="pre">NULL</span></tt>).</p>
</li>
</ul>
<ul id="index-0">
<li><p class="first">a <tt class="docutils literal"><span class="pre">SearchLimit</span></tt>: This <tt class="docutils literal"><span class="pre">SearchLimit</span></tt> limits the search of <strong>one</strong> neighborhood.
The most interesting statistic to limit is probably the number of found
solutions:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">SearchLimit</span> <span class="o">*</span> <span class="k">const</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">MakeSolutionsLimit</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<p>This would limit the search to maximum two candidate solutions in the same neighborhood.
By default, the CP solver stops the neighborhood search as soon as it finds a filtered and feasible candidate solution.
If you add an <tt class="docutils literal"><span class="pre">OptimizeVar</span></tt> to your model, once the solver finds this good candidate solution, it changes the model
to exclude solutions with the same objective value. The second solution found can only be better than the first one.
See the section <a class="reference internal" href="../objectives/optimization_how.html#golomb-ruler-optimization-how"><em>How does the solver optimize?</em></a>
to refresh your memory if needed. When the solver
finds 2 solutions (or when the whole neighborhood is explored), it stops and starts over again with the best solution.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">LocalSearchFilter</span></tt>s: these filters speed up the search by bypassing the solver checking mechanism if you know that the
solution must be rejected (because it is not feasible, because it is not good enough, ...). If the filters accept a
solution, the solver still tests the feasibility of this solution.</p>
<p><tt class="docutils literal"><span class="pre">LocalSearchFilter</span></tt>s are discussed in
the section <a class="reference internal" href="ls_filtering.html#local-search-filtering"><em>Filtering</em></a>.</p>
</li>
</ul>
<p>Several factory methods are available to create a <tt class="docutils literal"><span class="pre">LocalSearchPhaseParameters</span></tt> parameter.
At least you need to declare a <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt> and a complementary <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">LocalSearchPhaseParameters</span> <span class="o">*</span> <span class="n">Solver</span><span class="o">::</span><span class="n">MakeLocalSearchPhaseParameters</span><span class="p">(</span>
                    <span class="n">LocalSearchOperator</span> <span class="o">*</span><span class="k">const</span> <span class="n">ls_operator</span><span class="p">,</span>
                    <span class="n">DecisionBuilder</span> <span class="o">*</span><span class="k">const</span>
                                    <span class="n">complementary_decision_builder</span><span class="p">);</span>
</pre></div>
</div>
<p>You can also pass all the above enumerated parameters :</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">LocalSearchPhaseParameters</span><span class="o">*</span> <span class="n">Solver</span><span class="o">::</span><span class="n">MakeLocalSearchPhaseParameters</span><span class="p">(</span>
                    <span class="n">SolutionPool</span><span class="o">*</span> <span class="k">const</span> <span class="n">pool</span><span class="p">,</span>
                    <span class="n">LocalSearchOperator</span><span class="o">*</span> <span class="k">const</span> <span class="n">ls_operator</span><span class="p">,</span>
                    <span class="n">DecisionBuilder</span><span class="o">*</span> <span class="k">const</span>
                                     <span class="n">complementary_decision_builder</span><span class="p">,</span>
                    <span class="n">SearchLimit</span><span class="o">*</span> <span class="k">const</span> <span class="n">limit</span><span class="p">,</span>
                    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">LocalSearchFilter</span><span class="o">*&gt;&amp;</span> <span class="n">filters</span><span class="p">);</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt> will find candidate solutions while the <tt class="docutils literal"><span class="pre">complementary_decision_builder</span></tt>
<tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> will complete
the candidate solutions if some of the variables are not assigned.</p>
<p>A handy way to create a <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> to assist the local search operator(s) is to limit one
with <tt class="docutils literal"><span class="pre">MakeSolveOnce()</span></tt>. <tt class="docutils literal"><span class="pre">MakeSolveOnce</span></tt> is a <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> that takes another <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> <tt class="docutils literal"><span class="pre">db</span></tt>
and <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt>s:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">DecisionBuilder</span> <span class="o">*</span> <span class="k">const</span> <span class="n">db</span> <span class="o">=</span> <span class="p">...</span>
<span class="n">SearchLimit</span><span class="o">*</span> <span class="k">const</span> <span class="n">limit</span> <span class="o">=</span> <span class="n">solver</span><span class="p">.</span><span class="n">MakeLimit</span><span class="p">(...);</span>
<span class="n">DecisionBuilder</span> <span class="o">*</span> <span class="k">const</span> <span class="n">complementary_decision_builder</span> <span class="o">=</span>
                                   <span class="n">solver</span><span class="p">.</span><span class="n">MakeSolveOnce</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="n">limit</span><span class="p">);</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">SolveOnce</span></tt> <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> created by <tt class="docutils literal"><span class="pre">MakeSolveOnce()</span></tt> will collapse the search tree described by the
<tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> <tt class="docutils literal"><span class="pre">db</span></tt> and a set of <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt>s and wrap it into a single point. The nested search stops after
the first solution is found.
If there are no solutions in this nested tree, then (the <tt class="docutils literal"><span class="pre">Next()</span></tt> method of) <tt class="docutils literal"><span class="pre">SolveOnce</span></tt> will
fail.</p>
<p>If you know for sure that your <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt> will return feasible
solutions, you don&#8217;t have to provide a <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> to assist: just submit <tt class="docutils literal"><span class="pre">NULL</span></tt> as argument
for the <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> pointer.</p>
</div>
</div>
<div class="section" id="the-basic-local-search-algorithm-and-the-callback-hooks-for-the-searchmonitors-difficulty-difficulty">
<span id="basic-local-search-algorithm-and-the-callback-hooks"></span><h2>6.5.3. The basic local search algorithm and the callback hooks for the <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt>s <img class="math" src="../../_images/math/3c25d09394c6358cf833abe028213dac4633bdc5.png" alt="\scriptscriptstyle\bigstar" style="vertical-align: -2px"/> <img class="math" src="../../_images/math/3c25d09394c6358cf833abe028213dac4633bdc5.png" alt="\scriptscriptstyle\bigstar" style="vertical-align: -2px"/></h2>
<p>We feel compelled to use our warning box again:</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">We describe a simplified version of the Local Search algorithm.</p>
</div>
<p>If you want to know more, have a look at the section
<a class="reference internal" href="../under_the_hood/ls.html#hood-ls"><em>Local Search (LS)</em></a> in the chapter <a class="reference internal" href="../under_the_hood.html#chapter-under-the-hood"><em>Under the hood</em></a>.</p>
<p>In this subsection, we present the following callbacks of the <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt> class and show you
exactly when they are called in the Local Search algorithm:</p>
<table border="1" class="docutils">
<caption>Local Search algorithm callbacks from the <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt> class.</caption>
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Methods</th>
<th class="head">Descriptions</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">LocalOptimum()</span></tt></td>
<td>When a local optimum is reached. If <tt class="docutils literal"><span class="pre">true</span></tt> is returned, the last solution is discarded and the search proceeds to find the next local optimum. Handy when you implement a meta-heuristic with a <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt>.</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">AcceptDelta(Assignment</span> <span class="pre">*delta,</span> <span class="pre">Assignment</span> <span class="pre">*deltadelta)</span></tt></td>
<td>When the <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt> has produced the next candidate solution given in the form of <tt class="docutils literal"><span class="pre">delta</span></tt> and <tt class="docutils literal"><span class="pre">deltadelta</span></tt>. You can accept or reject this new candidate solution.</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">AcceptNeighbor()</span></tt></td>
<td>After accepting a candidate solution during local search.</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">PeriodicCheck()</span></tt></td>
<td>Periodic call to check limits in long running procedures, like Local Search.</td>
</tr>
</tbody>
</table>
<br><p>To ensure the communication between the local search and the global search, three utility functions are defined.
These functions simply call their <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt>&#8216;s counterparts, i.e. they call the corresponding methods of the
involved <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt>s:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">bool</span> <span class="pre">LocalOptimumReached()</span></tt>: <tt class="docutils literal"><span class="pre">FalseExceptIfOneTrue</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">bool</span> <span class="pre">AcceptDelta()</span></tt>: <tt class="docutils literal"><span class="pre">TrueExceptIfOneFalse</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">void</span> <span class="pre">AcceptNeighbor()</span></tt>: Notification.</li>
</ul>
<p>Before we delve into the core of the local search algorithm and the implementation of the <tt class="docutils literal"><span class="pre">LocalSearch</span></tt> <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>&#8216;s
<tt class="docutils literal"><span class="pre">Next()</span></tt> method, we first discuss the inner workings of the <tt class="docutils literal"><span class="pre">FindOneNeighbor</span></tt> <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> whose job is to find
the next filtered and accepted candidate solution. This <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> is used inside a <tt class="docutils literal"><span class="pre">NestedSolveDecision</span></tt> that we study next.
This <tt class="docutils literal"><span class="pre">Decision</span></tt> is returned by the <tt class="docutils literal"><span class="pre">Next()</span></tt> method of
the <tt class="docutils literal"><span class="pre">LocalSearch</span></tt> <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> in the main loop of the local search algorithm. Finally, we address the
<tt class="docutils literal"><span class="pre">LocalSearch</span></tt> <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> class. In particular, we study its initializing phase and its <tt class="docutils literal"><span class="pre">Next()</span></tt> method.
We consider the case where an initial <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> constructs the initial solution.</p>
<p>SearchMonitorâ€˜s callbacks are indicated in the code by the comment:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// SEARCHMONITOR CALLBACK</span>
</pre></div>
</div>
<div class="section" id="the-findoneneighbor-decisionbuilder">
<h3>6.5.3.1. The <tt class="docutils literal"><span class="pre">FindOneNeighbor</span></tt> <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt></h3>
<p>This <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> tries to find the next filtered and accepted candidate solution.
It tests (and sometimes completes) the candidate solutions given by the <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>.</p>
<p>We present its <tt class="docutils literal"><span class="pre">Next()</span></tt> method and discuss it after:</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">Decision</span><span class="o">*</span> <span class="n">FindOneNeighbor</span><span class="o">::</span><span class="n">Next</span><span class="p">(</span><span class="n">Solver</span><span class="o">*</span> <span class="k">const</span> <span class="n">solver</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">//  No neighbor (candidate solution) found</span>
  <span class="c1">//  only on the first call to Next().</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">neighbor_found_</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">//  SYNCHRONIZE ALL</span>
    <span class="p">...</span>
  <span class="p">}</span>

  <span class="c1">// Another assignment is needed to apply the delta</span>
  <span class="n">Assignment</span><span class="o">*</span> <span class="n">assignment_copy</span> <span class="o">=</span>
               <span class="n">solver</span><span class="o">-&gt;</span><span class="n">MakeAssignment</span><span class="p">(</span><span class="n">reference_assignment_</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
  <span class="kt">int</span> <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">DecisionBuilder</span><span class="o">*</span> <span class="n">restore</span> <span class="o">=</span>
                    <span class="n">solver</span><span class="o">-&gt;</span><span class="n">MakeRestoreAssignment</span><span class="p">(</span><span class="n">assignment_copy</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">sub_decision_builder_</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">restore</span> <span class="o">=</span> <span class="n">solver</span><span class="o">-&gt;</span><span class="n">Compose</span><span class="p">(</span><span class="n">restore</span><span class="p">,</span> <span class="n">sub_decision_builder_</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="n">Assignment</span><span class="o">*</span> <span class="n">delta</span> <span class="o">=</span> <span class="n">solver</span><span class="o">-&gt;</span><span class="n">MakeAssignment</span><span class="p">();</span>
  <span class="n">Assignment</span><span class="o">*</span> <span class="n">deltadelta</span> <span class="o">=</span> <span class="n">solver</span><span class="o">-&gt;</span><span class="n">MakeAssignment</span><span class="p">();</span>

  <span class="c1">//  MAIN LOOP</span>
  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">delta</span><span class="o">-&gt;</span><span class="n">Clear</span><span class="p">();</span>
    <span class="n">deltadelta</span><span class="o">-&gt;</span><span class="n">Clear</span><span class="p">();</span>
                                          <span class="c1">//  SEARCHMONITOR CALLBACK</span>
    <span class="n">solver</span><span class="o">-&gt;</span><span class="n">TopPeriodicCheck</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">++</span><span class="n">counter</span> <span class="o">&gt;=</span> <span class="n">FLAGS_cp_local_search_sync_frequency</span> <span class="o">&amp;&amp;</span>
      <span class="n">pool_</span><span class="o">-&gt;</span><span class="n">SyncNeeded</span><span class="p">(</span><span class="n">reference_assignment_</span><span class="p">.</span><span class="n">get</span><span class="p">()))</span> <span class="p">{</span>
      <span class="c1">//  SYNCHRONIZE ALL</span>
      <span class="p">...</span>
      <span class="n">counter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">limit_</span><span class="o">-&gt;</span><span class="n">Check</span><span class="p">()</span>
      <span class="o">&amp;&amp;</span> <span class="n">ls_operator_</span><span class="o">-&gt;</span><span class="n">MakeNextNeighbor</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">solver</span><span class="o">-&gt;</span><span class="n">neighbors_</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
                                          <span class="c1">//  SEARCHMONITOR CALLBACK</span>
      <span class="k">const</span> <span class="kt">bool</span> <span class="n">meta_heuristics_filter</span> <span class="o">=</span>
             <span class="n">AcceptDelta</span><span class="p">(</span><span class="n">solver</span><span class="o">-&gt;</span><span class="n">ParentSearch</span><span class="p">(),</span> <span class="n">delta</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">);</span>
      <span class="k">const</span> <span class="kt">bool</span> <span class="n">move_filter</span> <span class="o">=</span> <span class="n">FilterAccept</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">meta_heuristics_filter</span> <span class="o">&amp;&amp;</span> <span class="n">move_filter</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">solver</span><span class="o">-&gt;</span><span class="n">filtered_neighbors_</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">assignment_copy</span><span class="o">-&gt;</span><span class="n">Copy</span><span class="p">(</span><span class="n">reference_assignment_</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
        <span class="n">assignment_copy</span><span class="o">-&gt;</span><span class="n">Copy</span><span class="p">(</span><span class="n">delta</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">solver</span><span class="o">-&gt;</span><span class="n">SolveAndCommit</span><span class="p">(</span><span class="n">restore</span><span class="p">))</span> <span class="p">{</span>
          <span class="n">solver</span><span class="o">-&gt;</span><span class="n">accepted_neighbors_</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
          <span class="n">assignment_</span><span class="o">-&gt;</span><span class="n">Store</span><span class="p">();</span>
          <span class="n">neighbor_found_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
          <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">neighbor_found_</span><span class="p">)</span> <span class="p">{</span>
                                          <span class="c1">//  SEARCHMONITOR CALLBACK</span>
        <span class="n">AcceptNeighbor</span><span class="p">(</span><span class="n">solver</span><span class="o">-&gt;</span><span class="n">ParentSearch</span><span class="p">());</span>
        <span class="n">pool_</span><span class="o">-&gt;</span><span class="n">RegisterNewSolution</span><span class="p">(</span><span class="n">assignment_</span><span class="p">);</span>
        <span class="c1">//  SYNCHRONIZE ALL</span>
        <span class="p">...</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">break</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">solver</span><span class="o">-&gt;</span><span class="n">Fail</span><span class="p">();</span>
  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>You might wonder why there are so many lines of code but there
are a some subtleties to consider.</p>
<p>The code of lines 5 to 8 is only called the first time the <tt class="docutils literal"><span class="pre">Next()</span></tt> method is invoked
and allow to synchronize the Local Search machinery with the initial solution. In general,
the words <tt class="docutils literal"><span class="pre">SYNCHRONIZE</span> <span class="pre">ALL</span></tt> in the comments mean that we synchronize the <em>Local Search Operators</em> <strong>and</strong> the
<em>Local Search Filters</em> with
a solution.</p>
<p><tt class="docutils literal"><span class="pre">reference_assignment_</span></tt> is an <tt class="docutils literal"><span class="pre">Assignment</span></tt> with the initial solution while <tt class="docutils literal"><span class="pre">assignment_</span></tt> is an
<tt class="docutils literal"><span class="pre">Assignment</span></tt> with the current solution.
On line 10, we copy <tt class="docutils literal"><span class="pre">reference_assignment_</span></tt> to the local <tt class="docutils literal"><span class="pre">assignment_copy</span></tt> <tt class="docutils literal"><span class="pre">Assignment</span></tt>
to be able to define the <tt class="docutils literal"><span class="pre">delta</span></tt>s. <tt class="docutils literal"><span class="pre">counter</span></tt> counts the number candidate solutions.
This counter is used on line 29 to test if we shouldn&#8217;t start again the Local Search with another solution.</p>
<p>On lines 15-19, we define the <tt class="docutils literal"><span class="pre">restore</span></tt> <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> that will allow us to
keep the newly found candidate solution.</p>
<p>We construct the <tt class="docutils literal"><span class="pre">delta</span></tt> and <tt class="docutils literal"><span class="pre">deltadelta</span></tt> on lines 20 and 21 and are
now ready to enter the main loop to find the
next solution.</p>
<p>On lines 25 and 26 we clear our <tt class="docutils literal"><span class="pre">delta</span></tt>s and on line 28 we allow for a periodic check: for searches that last long,
we allow the <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt>s to interfere and test if the search needs to continue or not and/or must be adapted.</p>
<p>Lines 29-34 allow to change the starting solution and ask the solution pool <tt class="docutils literal"><span class="pre">pool_</span></tt> for a new solution via its
<tt class="docutils literal"><span class="pre">GetNextSolution()</span></tt>. The <tt class="docutils literal"><span class="pre">FLAGS_cp_local_search_sync_frequency</span></tt> value corresponds to the number of attempts
before the CP solver tries to synchronize the Local Search with a new solution.</p>
<p>On line 36 and 37, the <tt class="docutils literal"><span class="pre">SearchLimit</span></tt>s applied to the search of one neighborhood are tested.
If the limits are not reached and if the
<tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt> succeeds to find a new candidate solution, we enter the <tt class="docutils literal"><span class="pre">if</span></tt> statement
on line 38. The <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>&#8216;s <tt class="docutils literal"><span class="pre">MakeNextNeighbor()</span></tt> method is
called to create the next candidate solution in <tt class="docutils literal"><span class="pre">delta</span></tt>s format.</p>
<p>If you overwrite the <tt class="docutils literal"><span class="pre">MakeNextNeighbor()</span></tt> method, you need to manage the <tt class="docutils literal"><span class="pre">delta</span></tt>s:
you must take care of <em>applying</em> and <em>reverting</em> the <tt class="docutils literal"><span class="pre">delta</span></tt>s yourself if needed. You can use the
<tt class="docutils literal"><span class="pre">ApplyChanges()</span></tt> and <tt class="docutils literal"><span class="pre">RevertChanges()</span></tt> helper functions to do so. For instance, here is the implementation of the
<tt class="docutils literal"><span class="pre">MakeNextNeighbor()</span></tt> method of the <tt class="docutils literal"><span class="pre">IntVarLocalSearchOperator</span></tt>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="n">IntVarLocalSearchOperator</span><span class="o">::</span><span class="n">MakeNextNeighbor</span><span class="p">(</span><span class="n">Assignment</span><span class="o">*</span> <span class="n">delta</span><span class="p">,</span>
                                         <span class="n">Assignment</span><span class="o">*</span> <span class="n">deltadelta</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">CHECK_NOTNULL</span><span class="p">(</span><span class="n">delta</span><span class="p">);</span>
  <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">RevertChanges</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MakeOneNeighbor</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">ApplyChanges</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">ApplyChanges()</span></tt> actually fills the <tt class="docutils literal"><span class="pre">delta</span></tt>s after you use the helper methods
<tt class="docutils literal"><span class="pre">SetValue()</span></tt>, <tt class="docutils literal"><span class="pre">Activate()</span></tt> and the like to change the current candidate solution.</p>
<p>Once we enter the <tt class="docutils literal"><span class="pre">if</span></tt> statement on line 38, we have a new candidate solution and we update the candidate
solution counter accordingly.
It is now time to test this new candidate solution. The <strong>first test</strong> comes from the <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt>s in their
<tt class="docutils literal"><span class="pre">AcceptDelta()</span></tt> methods. If only one <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt> rejects this solution, it is rejected. In <em>or-tools</em>, we
implement (meta-)heuristics with <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt>s. See the chapter <a class="reference internal" href="../metaheuristics.html#chapter-metaheuristics"><em>Meta-heuristics: several previous problems</em></a> for more.</p>
<p>The <tt class="docutils literal"><span class="pre">AcceptDelta()</span></tt> function is the global utility function we mentioned above.
We&#8217;ll meet <tt class="docutils literal"><span class="pre">LocalOptimumReached()</span></tt> and <tt class="docutils literal"><span class="pre">AcceptNeighbor()</span></tt> a few lines below.</p>
<p>The <strong>second test</strong> is the <em>filtering</em> test on line 42. <tt class="docutils literal"><span class="pre">FilterAccept()</span></tt> returns a <tt class="docutils literal"><span class="pre">TrueExceptIfOneFalse</span></tt>.
If both tests are successful, we enter the <tt class="docutils literal"><span class="pre">if</span></tt> statement on line 44. If not, we simply generate another
candidate solution. On lines 44 and 46, we update the
counter of <tt class="docutils literal"><span class="pre">filtered_neighbors_</span></tt> and store the candidate solution in the <tt class="docutils literal"><span class="pre">assignment_copy</span></tt> <tt class="docutils literal"><span class="pre">Assignment</span></tt>.</p>
<p>On line 47, we try (and if needed complete) the candidate. If we succeed, the current solution
and the counter <tt class="docutils literal"><span class="pre">accepted_neighbors_</span></tt> are updated.
The <tt class="docutils literal"><span class="pre">Next()</span></tt> method returns <tt class="docutils literal"><span class="pre">NULL</span></tt> because the <tt class="docutils literal"><span class="pre">FindOneNeighbor</span></tt>
<tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> has finished its job at this node of the search tree. If we don&#8217;t succeed, the solver fails on
line 66.</p>
<p>The <tt class="docutils literal"><span class="pre">SolveAndCommit()</span></tt> method is similar to the <tt class="docutils literal"><span class="pre">Solve()</span></tt> method <strong>except</strong> that
<tt class="docutils literal"><span class="pre">SolveAndCommit</span></tt> will not backtrack all modifications at the end of the search and this is why you should:</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Use the <tt class="docutils literal"><span class="pre">SolveAndCommit()</span></tt> method <strong>only</strong> in the <tt class="docutils literal"><span class="pre">Next()</span></tt> method of a <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>!</p>
</div>
<p>If the <tt class="docutils literal"><span class="pre">if</span></tt> test on line 36 and 37 fails, we enter the <tt class="docutils literal"><span class="pre">else</span></tt> part of the statement on line 55. This means that
either one <tt class="docutils literal"><span class="pre">SearchLimit</span></tt> was reached or that the neighborhood is exhausted. If a solution (stored in <tt class="docutils literal"><span class="pre">assignment_</span></tt>)
was found during the local search, we register it and synchronize the <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>s and <tt class="docutils literal"><span class="pre">LocalSearchFilter</span></tt>s
with a new solution provided by the solution pool <tt class="docutils literal"><span class="pre">pool_</span></tt> on lines 58-60. We also notify the <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt>s
on line 57. If no solution was found, we simply <tt class="docutils literal"><span class="pre">break</span></tt> out of the
<tt class="docutils literal"><span class="pre">while()</span></tt> loop on line 62 and make the CP solver fail on line 66.</p>
</div>
<div class="section" id="the-nestedsolvedecision-decision">
<h3>6.5.3.2. The <tt class="docutils literal"><span class="pre">NestedSolveDecision</span></tt> <tt class="docutils literal"><span class="pre">Decision</span></tt></h3>
<p>The <tt class="docutils literal"><span class="pre">NestedSolveDecision</span></tt> is the <tt class="docutils literal"><span class="pre">Decision</span></tt> that the <tt class="docutils literal"><span class="pre">LocalSearch</span></tt>&#8216;s <tt class="docutils literal"><span class="pre">Next()</span></tt> method returns
to find the next solution.
This <tt class="docutils literal"><span class="pre">Decision</span></tt> is basically a <tt class="docutils literal"><span class="pre">Decision</span></tt> wrapper around a nested solve with a given <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>
and <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt>s. It doesn&#8217;t do anything in its right
branch (in its <tt class="docutils literal"><span class="pre">Refute()</span></tt> method) and calls <tt class="docutils literal"><span class="pre">Solve()</span></tt> or <tt class="docutils literal"><span class="pre">SolveAndCommit()</span></tt> depending on a <tt class="docutils literal"><span class="pre">restore</span></tt> <tt class="docutils literal"><span class="pre">bool</span></tt>
in its left branch (in its <tt class="docutils literal"><span class="pre">Apply()</span></tt> method).</p>
<p>The <tt class="docutils literal"><span class="pre">NestedSolveDecision</span></tt> <tt class="docutils literal"><span class="pre">Decision</span></tt> can be in three states that are also the three states of the Local Search:</p>
<table border="1" class="docutils">
<colgroup>
<col width="29%" />
<col width="71%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Value</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">DECISION_FAILED</span></tt></td>
<td>The nested search phase failed, i.e. <tt class="docutils literal"><span class="pre">Solve()</span></tt> or <tt class="docutils literal"><span class="pre">SolveAndCommit()</span></tt>
failed.</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">DECISION_PENDING</span></tt></td>
<td>The nested search hasn&#8217;t been called yet. The local search is in this
state when it balances the search tree.</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">DECISION_FOUND</span></tt></td>
<td>The nested search phase succeeded and found a solution, i.e. <tt class="docutils literal"><span class="pre">Solve()</span></tt>
or <tt class="docutils literal"><span class="pre">SolveAndCommit()</span></tt> succeeded and returned <tt class="docutils literal"><span class="pre">true</span></tt>.</td>
</tr>
</tbody>
</table>
<p>The three states are defined in the <tt class="docutils literal"><span class="pre">NestedSolveDecision</span></tt> <tt class="docutils literal"><span class="pre">StateType</span></tt> <tt class="docutils literal"><span class="pre">enum</span></tt>.</p>
<p>We are now ready to assemble all the pieces of the puzzle together to understand the (simplified)
local search algorithm in <em>or-tools</em>.</p>
</div>
<div class="section" id="the-localsearch-decisionbuilder">
<h3>6.5.3.3. The <tt class="docutils literal"><span class="pre">LocalSearch</span></tt> <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt></h3>
<p>We first consider the initialization phase and then we discuss in details its <tt class="docutils literal"><span class="pre">Next()</span></tt> method.</p>
<p class="rubric">Initialization</p>
<p>Consider the situation where we already have a <tt class="docutils literal"><span class="pre">LocalSearchPhaseParameters</span></tt> parameter set up and we let the CP solver
construct the initial solution:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Solver</span> <span class="nf">s</span><span class="p">(</span><span class="s">&quot;Dummy LS&quot;</span><span class="p">);</span>
<span class="p">...</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IntVar</span><span class="o">*&gt;</span> <span class="n">vars</span> <span class="o">=</span> <span class="p">...</span>
<span class="p">...</span>
<span class="n">LocalSearchOperator</span> <span class="o">*</span> <span class="k">const</span> <span class="n">ls_operator</span> <span class="o">=</span> <span class="p">...</span>
<span class="n">DecisionBuilder</span> <span class="o">*</span> <span class="k">const</span> <span class="n">complementary_decision_builder</span> <span class="o">=</span> <span class="p">...</span>
<span class="p">...</span>
<span class="n">LocalSearchPhaseParameters</span> <span class="n">params</span> <span class="o">=</span>
   <span class="n">s</span><span class="p">.</span><span class="n">MakeLocalSearchPhaseParameters</span><span class="p">(</span><span class="n">ls_operator</span><span class="p">,</span>
                                    <span class="n">complementary_decision_builder</span><span class="p">);</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">complementary_decision_builder</span></tt> <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> will help us complete
the candidate solutions found by the <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt> <tt class="docutils literal"><span class="pre">ls_operator</span></tt>. Our initial solution will be constructed
by the <tt class="docutils literal"><span class="pre">initial_solution</span></tt> <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> (and completed by the <tt class="docutils literal"><span class="pre">complementary_decision_builder</span></tt> <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>
if needed). Remember, that the solution chosen by the CP solver is the <strong>first</strong>
solution found by this <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>. We are now ready to create the <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> for the local search:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">DecisionBuilder</span> <span class="o">*</span> <span class="k">const</span> <span class="n">initial_solution</span> <span class="o">=</span> <span class="p">...</span>
<span class="p">...</span>
<span class="n">DecisionBuilder</span> <span class="o">*</span> <span class="k">const</span> <span class="n">ls</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">MakeLocalSearchPhase</span><span class="p">(</span><span class="n">vars</span><span class="p">,</span>
                                                    <span class="n">initial_solution</span><span class="p">,</span>
                                                    <span class="n">params</span><span class="p">);</span>
</pre></div>
</div>
<p>We can now add as many monitors as we want and launch the solving process:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SearchMonitor</span> <span class="o">*&gt;</span> <span class="n">monitors</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">s</span><span class="p">.</span><span class="n">Solve</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">monitors</span><span class="p">);</span>
</pre></div>
</div>
<p>It&#8217;s interesting to see how this initial solution is constructed in the <tt class="docutils literal"><span class="pre">LocalSearch</span></tt> class.
First, we create an <tt class="docutils literal"><span class="pre">Assignment</span></tt> to store this
initial solution:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Assignment</span> <span class="o">*</span> <span class="k">const</span> <span class="n">initial_sol</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">MakeAssignment</span><span class="p">();</span>
</pre></div>
</div>
<p>To store an <tt class="docutils literal"><span class="pre">Assignment</span></tt> found by the CP solver, we use the <tt class="docutils literal"><span class="pre">StoreAssignment</span></tt> <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">DecisionBuilder</span> <span class="o">*</span> <span class="n">store</span> <span class="o">=</span> <span class="n">solver</span><span class="o">-&gt;</span><span class="n">MakeStoreAssignment</span><span class="p">(</span><span class="n">initial_sol</span><span class="p">);</span>
</pre></div>
</div>
<p>This <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> simply stores the current solution in the <tt class="docutils literal"><span class="pre">initial_sol</span></tt> <tt class="docutils literal"><span class="pre">Assignment</span></tt>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">DecisionBuilder</span> <span class="o">*</span> <span class="n">initial_solution_and_store</span> <span class="o">=</span> <span class="n">solver</span><span class="o">-&gt;</span><span class="n">Compose</span><span class="p">(</span>
                                     <span class="n">initial_solution</span><span class="p">,</span>
                                     <span class="n">complementary_decision_builder</span><span class="p">,</span>
                                     <span class="n">store</span><span class="p">);</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">initial_solution_and_store</span></tt> constructs this initial solution. This <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>
is used in a nested search:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SearchMonitor</span> <span class="o">*&gt;</span> <span class="n">monitors</span><span class="p">;</span>
<span class="n">monitors</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">limit</span><span class="p">);</span>
<span class="n">NestedSolveDecision</span> <span class="o">*</span> <span class="n">initial_solution_decision</span> <span class="o">=</span>
                  <span class="k">new</span> <span class="n">NestedSolveDecision</span><span class="p">(</span><span class="n">initial_solution_and_store</span><span class="p">,</span>
                                          <span class="nb">false</span><span class="p">,</span>
                                          <span class="n">monitors</span><span class="p">);</span>
</pre></div>
</div>
<p>where:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">limit</span></tt> is the <tt class="docutils literal"><span class="pre">SearchLimit</span></tt> given to the local search algorithm;</li>
<li>the <tt class="docutils literal"><span class="pre">NestedSolveDecision</span></tt> constructor&#8217;s arguments are respectively:<ul>
<li>a <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> to construct the next solution;</li>
<li>a <tt class="docutils literal"><span class="pre">bool</span></tt> to indicate if we restore the last solution in case we cannot
find a solution;</li>
<li>an <tt class="docutils literal"><span class="pre">std::vector&lt;SearchMonitor</span> <span class="pre">*&gt;</span></tt>.</li>
</ul>
</li>
</ul>
</div></blockquote>
<p>The <tt class="docutils literal"><span class="pre">Apply()</span></tt> method of a <tt class="docutils literal"><span class="pre">NestedSolveDecision</span></tt> calls <tt class="docutils literal"><span class="pre">SolveAndCommit()</span></tt>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">solver</span><span class="o">-&gt;</span><span class="n">SolveAndCommit</span><span class="p">(</span><span class="n">initial_solution_and_store</span><span class="p">,</span> <span class="n">monitors</span><span class="p">);</span>
</pre></div>
</div>
<p>where the arguments respectively are:</p>
<blockquote>
<div><ul class="simple">
<li>a <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>;</li>
<li>an <tt class="docutils literal"><span class="pre">std::vector&lt;SearchMonitor</span> <span class="pre">*&gt;</span></tt>.</li>
</ul>
</div></blockquote>
<p>The <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> companion to <tt class="docutils literal"><span class="pre">StoreAssignment</span></tt> is <tt class="docutils literal"><span class="pre">RestoreAssignment</span></tt> that
<em>installs</em> an <tt class="docutils literal"><span class="pre">Assignment</span></tt> as the current solution:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Assignment</span> <span class="o">*</span> <span class="n">solution</span> <span class="o">=</span> <span class="p">...</span>
<span class="p">...</span>
<span class="n">DecisionBuilder</span> <span class="o">*</span> <span class="n">current_sol</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">MakeRestoreAssignment</span><span class="p">(</span><span class="n">solution</span><span class="p">);</span>
<span class="p">...</span>
<span class="c1">//  do something fancy starting with current_sol</span>
<span class="n">DecisionBuilder</span> <span class="o">*</span> <span class="n">fancy_db</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">Compose</span><span class="p">(</span><span class="n">current_sol</span><span class="p">,</span> <span class="p">...);</span>
<span class="p">...</span>
<span class="n">s</span><span class="p">.</span><span class="n">Solve</span><span class="p">(</span><span class="n">fancy_db</span><span class="p">,...);</span>
</pre></div>
</div>
<p>This is exactly the <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> used when you give an initial solution to the CP solver.
The <tt class="docutils literal"><span class="pre">initial_solution</span></tt> <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> is simply replaced with a <tt class="docutils literal"><span class="pre">RestoreAssignment</span></tt> <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>
taking your initial <tt class="docutils literal"><span class="pre">Assignment</span></tt>.</p>
<p>Now that we have developed the machinery to find and test the initial solution, we are ready to wrap the nested solve process
into a <tt class="docutils literal"><span class="pre">NestedSolveDecision</span></tt>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//  Main DecisionBuilder to find candidate solutions one by one</span>
<span class="n">DecisionBuilder</span><span class="o">*</span> <span class="n">find_neighbors</span> <span class="o">=</span>
  <span class="n">solver</span><span class="o">-&gt;</span><span class="n">RevAlloc</span><span class="p">(</span><span class="k">new</span> <span class="n">FindOneNeighbor</span><span class="p">(</span><span class="n">assignment_</span><span class="p">,</span>
                                       <span class="n">pool_</span><span class="p">,</span>
                                       <span class="n">ls_operator_</span><span class="p">,</span>
                                       <span class="n">sub_decision_builder_</span><span class="p">,</span>
                                       <span class="n">limit_</span><span class="p">,</span>
                                       <span class="n">filters_</span><span class="p">));</span>
<span class="n">NestedSolveDecision</span><span class="o">*</span> <span class="n">decision</span> <span class="o">=</span> <span class="n">solver</span><span class="o">-&gt;</span><span class="n">RevAlloc</span><span class="p">(</span>
                            <span class="k">new</span> <span class="n">NestedSolveDecision</span><span class="p">(</span><span class="n">find_neighbors</span><span class="p">,</span>
                                                    <span class="nb">false</span><span class="p">)));</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">boolean</span></tt> argument in the <tt class="docutils literal"><span class="pre">NestedSolveDecision</span></tt>&#8216;s constructor indicates that we don&#8217;t want to backtrack.
The <tt class="docutils literal"><span class="pre">decision</span></tt> <tt class="docutils literal"><span class="pre">Decision</span></tt> will thus call <tt class="docutils literal"><span class="pre">SolveAndCommit()</span></tt> in its left branch.</p>
<p class="rubric">The <tt class="docutils literal"><span class="pre">Next()</span></tt> method</p>
<p>The <tt class="docutils literal"><span class="pre">Next()</span></tt> method of the <tt class="docutils literal"><span class="pre">LocalSearch</span></tt> <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> is in charge of controling the Local Search. We present it
first and discuss it next:</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">Decision</span> <span class="o">*</span> <span class="nf">Next</span><span class="p">(</span><span class="n">Solver</span> <span class="o">*</span> <span class="n">solver</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">state</span> <span class="o">=</span> <span class="n">decision</span><span class="o">-&gt;</span><span class="n">state</span><span class="p">();</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">state</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">NestedSolveDecision</span>:<span class="o">:</span><span class="n">DECISION_FAILED</span><span class="o">:</span> <span class="p">{</span>
                                          <span class="c1">// SEARCHMONITOR CALLBACK</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">LocalOptimumReached</span><span class="p">(</span><span class="n">solver</span><span class="o">-&gt;</span><span class="n">ActiveSearch</span><span class="p">()))</span> <span class="p">{</span>
        <span class="c1">// Stop the current search</span>
        <span class="p">...</span>
      <span class="p">}</span>
      <span class="n">solver</span><span class="o">-&gt;</span><span class="n">Fail</span><span class="p">();</span>
      <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="n">NestedSolveDecision</span>:<span class="o">:</span><span class="n">DECISION_PENDING</span><span class="o">:</span> <span class="p">{</span>
      <span class="c1">//  Stabilize search tree by balancing the current search tree.</span>
      <span class="c1">//  Statistics are updated even if this is not relevant to the</span>
      <span class="c1">//  global search</span>
      <span class="p">...</span>
      <span class="k">const</span> <span class="kt">int</span> <span class="n">depth</span> <span class="o">=</span> <span class="n">solver</span><span class="o">-&gt;</span><span class="n">SearchDepth</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">&lt;</span> <span class="n">kLocalSearchBalancedTreeDepth</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">solver</span><span class="o">-&gt;</span><span class="n">balancing_decision</span><span class="p">();</span>
      <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">depth</span> <span class="o">&gt;</span> <span class="n">kLocalSearchBalancedTreeDepth</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">solver</span><span class="o">-&gt;</span><span class="n">Fail</span><span class="p">();</span>
      <span class="p">}</span>
      <span class="p">...</span>
      <span class="k">return</span> <span class="n">decision</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="n">NestedSolveDecision</span>:<span class="o">:</span><span class="n">DECISION_FOUND</span><span class="o">:</span> <span class="p">{</span>
      <span class="c1">// Nothing important for us in this simplified version</span>
      <span class="p">...</span>
      <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="nl">default:</span> <span class="p">{</span>
      <span class="n">LOG</span><span class="p">(</span><span class="n">ERROR</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Unknown local search state&quot;</span><span class="p">;</span>
      <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>The <tt class="docutils literal"><span class="pre">decision</span></tt> variable on line 3 is the <tt class="docutils literal"><span class="pre">NestedSolveDecision</span></tt> created with
the <tt class="docutils literal"><span class="pre">FindOneNeighbor</span></tt> <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>.
We <tt class="docutils literal"><span class="pre">switch</span></tt> between three cases depending on the state of the nested search initiated by this <tt class="docutils literal"><span class="pre">Decision</span></tt>.</p>
<ul class="simple">
<li>Line 5: case <strong>DECISION_FAILED</strong>:
The nested solving process failed, meaning that there are no solution left. We let the <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt>s
decide if a local optimum has been reached and cannot be improved. <tt class="docutils literal"><span class="pre">LocalOptimum()</span></tt> returns
a <tt class="docutils literal"><span class="pre">FalseExceptIfOneTrue</span></tt>.</li>
<li>Line 14: case <strong>DECISION_PENDING</strong>:
This is the most interesting case: we try to keep the search tree balanced and force its height to be bounded.
<tt class="docutils literal"><span class="pre">kLocalSearchBalancedTreeDepth</span></tt> is set to 32. So as long as the tree height is smaller than 32, the <tt class="docutils literal"><span class="pre">LocalSearch</span></tt>
<tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> returns the <strong>same</strong> <tt class="docutils literal"><span class="pre">BalancingDecision</span></tt> on line 21. <tt class="docutils literal"><span class="pre">BalancingDecision</span></tt>s don&#8217;t do anything
by default. Once the search tree height is over 32, the <tt class="docutils literal"><span class="pre">NestedSolveDecision</span></tt>
<tt class="docutils literal"><span class="pre">Decision</span></tt> enters in action and when the height of the three gets higher than 32, we make the CP solver <tt class="docutils literal"><span class="pre">Fail()</span></tt>
to backtrack on line 23 thus keeping the height of the tree bounded.</li>
<li>Line 28: case <strong>DECISION_FOUND</strong>:
The nested search found a solution that is the current solution. The <tt class="docutils literal"><span class="pre">LocalSearch</span></tt>&#8216;s <tt class="docutils literal"><span class="pre">Next()</span></tt> method has done its job
at the current node and nothing needs to be done.</li>
</ul>
<div class="topic">
<p class="topic-title first"><tt class="docutils literal"><span class="pre">Solve()</span></tt>, <tt class="docutils literal"><span class="pre">SolveAndCommit()</span></tt>, <tt class="docutils literal"><span class="pre">SolveOnce()</span></tt>, etc...: what are the differences?</p>
<p>This topic is so important that the whole section <a class="reference internal" href="../modeling_tricks/solving_options.html#solving-options"><em>What are my solving options?</em></a> is devoted to it.
You already can jump and read this section if you&#8217;re curious.</p>
</div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<table>
<tr>
<td width="60"><img src="../../_static/logo.png" width="50" height="50"  alt="" /></td>
<td><p class="library_name">Google <a href="http://code.google.com/p/or-tools/"><strong>or-tools</strong></a><br>open source library</p></td>
</tr>
</table>
<h1>User's Manual</h1>

  
   



<h3>Google search</h3>

<form method="get" action="http://www.google.com/search">

<div style="padding:-1px;width:15em;">
<table border="0" cellpadding="0">
<tr><td>
<input type="text"   name="q" size="25"
 maxlength="255" value="" />
<input type="submit" value="Go" /></td></tr>
<tr><td align="center" style="font-size:80%">
Search:
<select name="sitesearch" width="125" style="width: 125px">
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/user_manual/" selected>user's manual</option>
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/faq/">faq</option>
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/reference_manual/or-tools/">reference manual</option>
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/">All or-tools doc</option>
</select>
</td></tr>
</table>
</div>

</form>
</br>




  <h3>Welcome</h3>
  
  <ul>
  	<li><a href="../../index.html">Content and foreword</a></li>
  	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html">Documentation's hub</a></li>
	<li><a href="http://code.google.com/p/or-tools/">The or-tools open source library</a></li></li>	
  </ul>
  
   
	


  <h3>Tutorial examples</h3>
  
  <ul>
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_C++">C++</a></li>
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_Python">Python</a></li>	
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_Java">Java</a></li>
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_Csharp">C#</a></li>
</ul>
  
   
	

  <h3>Current chapter</h3>
  <p class="topless"><a href="../LS.html"
                        title="previous chapter">6. Local search: the job-shop problem</a></p>
  <h3>Previous section</h3>
  <p class="topless"><a href="local_search.html"
                        title="previous chapter">6.4. What is local search (LS)?</a></p>
  <h3>Next section</h3>
  <p class="topless"><a href="ls_operators.html"
                        title="next chapter">6.6. Local Search Operators</a></p>
  <h3>Current section</a></h3>
  <ul>
<li><a class="reference internal" href="#">6.5. Basic working of the solver: Local Search</a><ul>
<li><a class="reference internal" href="#the-basic-idea">6.5.1. The basic idea</a><ul>
<li><a class="reference internal" href="#the-main-actors">6.5.1.1. The main actors</a></li>
</ul>
</li>
<li><a class="reference internal" href="#overview-of-the-local-search-mechanism-in-or-tools">6.5.2. Overview of the Local Search Mechanism in <em>or-tools</em></a><ul>
<li><a class="reference internal" href="#the-initial-solution">6.5.2.1. The initial solution</a></li>
<li><a class="reference internal" href="#the-localsearchphaseparameters-parameter">6.5.2.2. The <tt class="docutils literal"><span class="pre">LocalSearchPhaseParameters</span></tt> parameter</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-basic-local-search-algorithm-and-the-callback-hooks-for-the-searchmonitors-difficulty-difficulty">6.5.3. The basic local search algorithm and the callback hooks for the <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt>s <img class="math" src="../../_images/math/3c25d09394c6358cf833abe028213dac4633bdc5.png" alt="\scriptscriptstyle\bigstar" style="vertical-align: -2px"/> <img class="math" src="../../_images/math/3c25d09394c6358cf833abe028213dac4633bdc5.png" alt="\scriptscriptstyle\bigstar" style="vertical-align: -2px"/></a><ul>
<li><a class="reference internal" href="#the-findoneneighbor-decisionbuilder">6.5.3.1. The <tt class="docutils literal"><span class="pre">FindOneNeighbor</span></tt> <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt></a></li>
<li><a class="reference internal" href="#the-nestedsolvedecision-decision">6.5.3.2. The <tt class="docutils literal"><span class="pre">NestedSolveDecision</span></tt> <tt class="docutils literal"><span class="pre">Decision</span></tt></a></li>
<li><a class="reference internal" href="#the-localsearch-decisionbuilder">6.5.3.3. The <tt class="docutils literal"><span class="pre">LocalSearch</span></tt> <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt></a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="ls_operators.html" title="6.6. Local Search Operators"
             >next</a> |</li>
        <li class="right" >
          <a href="local_search.html" title="6.4. What is local search (LS)?"
             >previous</a> |</li>
        <li><a href="../../index.html">or-tools User&#39;s Manual</a> &raquo;</li>
          <li><a href="../LS.html" >6. Local search: the job-shop problem</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012-2014, Google.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>