

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>5.7. Customized search primitives: DecisionBuilders and Decisions &mdash; or-tools User&#39;s Manual</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     'doc version 0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../_static/logo.ico"/>
    <link rel="top" title="or-tools User&#39;s Manual" href="../../index.html" />
    <link rel="up" title="5. Defining search primitives: the n-Queens Problem" href="../search_primitives.html" />
    <link rel="next" title="5.8. Breaking symmetries with SymmetryBreakers" href="breaking_symmetry.html" />
    <link rel="prev" title="5.6. Out of the box variables and values selection primitives" href="out_of_the_box_search_primitives.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="breaking_symmetry.html" title="5.8. Breaking symmetries with SymmetryBreakers"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="out_of_the_box_search_primitives.html" title="5.6. Out of the box variables and values selection primitives"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">or-tools User&#39;s Manual</a> &raquo;</li>
          <li><a href="../search_primitives.html" accesskey="U">5. Defining search primitives: the n-Queens Problem</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="customized-search-primitives-decisionbuilders-and-decisions">
<span id="customized-search-primitives"></span><h1>5.7. Customized search primitives: <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>s and <tt class="docutils literal"><span class="pre">Decision</span></tt>s</h1>
<p>The search tree is traversed in a <em>linear</em> fashion: you go down <em>left</em> to <em>assign</em> values
until it is no longer possible and
you backtrack whenever necessary and go <em>right</em><a class="footnote-reference" href="#decision-left-right" id="id1">[1]</a>. This means that you cannot jump from one branch of the tree to another<a class="footnote-reference" href="#no-jump-in-search-tree" id="id2">[2]</a>.</p>
<p>But what you can do however is define the tree thanks to combinations of <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>s and <tt class="docutils literal"><span class="pre">Decision</span></tt>s<a class="footnote-reference" href="#other-primitives-to-shape-the-search-tree" id="id3">[3]</a>.</p>
<p>To compare our customized search primitives with the basic search strategy used until now (<tt class="docutils literal"><span class="pre">CHOOSE_FIRST_UNBOUND</span></tt> and <tt class="docutils literal"><span class="pre">ASSIGN_MIN_VALUE</span></tt>), we&#8217;ll gather some statistics. Then we&#8217;ll define
two customized search strategies using two different mechanisms: in the first one, we&#8217;ll use <em>callbacks</em> and in the second one, we&#8217;ll define our own <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> class.
In neither cases we&#8217;ll use rocket science: the goal is to give you a taste of what you can do and how you can do it.
Finally, we&#8217;ll say a few words about which search primitives to customize and why.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Some customizable <em>search primitives</em> are declared in the header
<tt class="file docutils literal"><span class="pre">constraint_solver/constraint_solveri.h</span></tt> (notice the <em>i</em> at the end).</p>
</div>
<p>Before we go on, let&#8217;s pause and take a second to discuss the inner mechanism used by the CP Solver to keep track of some objects.</p>
<div class="section" id="baseobject-and-revalloc">
<span id="rev-alloc"></span><h2>5.7.1. <tt class="docutils literal"><span class="pre">BaseObject</span></tt> and <tt class="docutils literal"><span class="pre">RevAlloc</span></tt></h2>
<p>We have seen that most objects can be created with a factory method (the <tt class="docutils literal"><span class="pre">Make...()</span></tt> methods). This allows the CP solver to keep track
of the created objects and delete them when they are no longer required. When backtracking, some objects are no longer needed and the CP Solver knows exactly when
and what to delete. The <tt class="docutils literal"><span class="pre">BaseObject</span></tt> class is the root of all reversibly<a class="footnote-reference" href="#reveribly" id="id4">[5]</a> allocated objects.</p>
<p>Whenever you define your own subclass of <tt class="docutils literal"><span class="pre">BaseObject</span></tt> (<tt class="docutils literal"><span class="pre">Decision</span></tt>s, <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>s and for instance the  <tt class="docutils literal"><span class="pre">SymmetryBreaker</span></tt>s we&#8217;ll see in the next section are <tt class="docutils literal"><span class="pre">BaseObject</span></tt>s),
it is good practice
to register the given object as being <em>reversible</em> to the solver. That is, the solver will take ownership
of the object and delete it
when it backtracks out of the current state. To register an object as reversible, you invoke the <tt class="docutils literal"><span class="pre">RevAlloc()</span></tt> method<a class="footnote-reference" href="#revalloc-others" id="id5">[6]</a>
of the solver. For instance, the <tt class="docutils literal"><span class="pre">Next()</span></tt> method  of the <tt class="docutils literal"><span class="pre">BaseAssignVariables</span></tt> <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> is implemented as follow:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Decision</span><span class="o">*</span> <span class="n">BaseAssignVariables</span><span class="o">::</span><span class="n">Next</span><span class="p">(</span><span class="n">Solver</span><span class="o">*</span> <span class="k">const</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">int64</span> <span class="n">id</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">IntVar</span><span class="o">*</span> <span class="k">const</span> <span class="n">var</span> <span class="o">=</span> <span class="n">selector_</span><span class="o">-&gt;</span><span class="n">SelectVariable</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">id</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">nullptr</span> <span class="o">!=</span> <span class="n">var</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">const</span> <span class="n">int64</span> <span class="n">value</span> <span class="o">=</span> <span class="n">selector_</span><span class="o">-&gt;</span><span class="n">SelectValue</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">id</span><span class="p">);</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">mode_</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">case</span> <span class="n">ASSIGN</span>:
            <span class="k">return</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">RevAlloc</span><span class="p">(</span><span class="k">new</span> <span class="n">AssignOneVariableValue</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">));</span>
          <span class="p">...</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="n">nullptr</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">RevAlloc()</span></tt> returns a pointer to the newly created and registered object, in this case the returned <tt class="docutils literal"><span class="pre">AssignOneVariableValue</span></tt> object.
You can thus invoke this method with
arguments
in the constructor of the constructed object without having to keep a pointer to this object.</p>
<p>The solver will now take care of your object. If you have an array of objects that are
subclasses of <tt class="docutils literal"><span class="pre">BaseObject</span></tt>, <tt class="docutils literal"><span class="pre">IntVar</span></tt>,
<tt class="docutils literal"><span class="pre">IntExpr</span></tt> and <tt class="docutils literal"><span class="pre">Constraint</span></tt>, you can register your array with <tt class="docutils literal"><span class="pre">RevAllocArray()</span></tt>. This method is also
valid for arrays of <tt class="docutils literal"><span class="pre">int</span></tt>s,
<tt class="docutils literal"><span class="pre">int64</span></tt>, <tt class="docutils literal"><span class="pre">uint64</span></tt> and <tt class="docutils literal"><span class="pre">bool</span></tt>. The array must have been allocated with the <tt class="docutils literal"><span class="pre">new[]</span></tt>
operator.</p>
<p>If you take a look at the source code, you will see that the factories
methods call <tt class="docutils literal"><span class="pre">RevAlloc()</span></tt> to
pass ownership of their objects to the solver.</p>
<p>Note that if no variable can be selected, the <tt class="docutils literal"><span class="pre">Next()</span></tt> method returns a <tt class="docutils literal"><span class="pre">nullptr</span></tt> which is the way to tell the CP solver that this <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> has done its job.</p>
</div>
<div class="section" id="the-basic-search-strategy-visualized">
<h2>5.7.2. The basic search strategy visualized</h2>
<p>Let&#8217;s have a look at our default strategy:</p>
<ul class="simple">
<li>We first choose the first unbound variable: <tt class="docutils literal"><span class="pre">CHOOSE_FIRST_UNBOUND</span></tt>.</li>
<li>Then we assign it the smallest available value: <tt class="docutils literal"><span class="pre">ASSIGN_MIN_VALUE</span></tt>.</li>
</ul>
<p>The complete search tree for <img class="math" src="../../_images/math/5218af40079081e694d8b82eeac2d368ef6ea76a.png" alt="n = 4" style="vertical-align: -1px"/> looks nice:</p>
<img alt="../../_images/complete_search_tree_n_4.png" class="align-center" src="../../_images/complete_search_tree_n_4.png" style="height: 110pt;" />
<p>There are indeed two feasible solutions:</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="o">============================</span>
size: 4
The Solve method took 0.001 seconds
Number of solutions: 2
Failures: 6
Branches: 10
Backtracks: 9
Stamps: 29
</pre></div>
</div>
<p>The complete search tree for <img class="math" src="../../_images/math/ec37f4048b4f92c2227c9bfe79fcb7d52ab99c9c.png" alt="n = 5" style="vertical-align: 0px"/> looks even better:</p>
<img alt="../../_images/complete_search_tree_n_5.png" class="align-center" src="../../_images/complete_search_tree_n_5.png" style="width: 300pt;" />
<p>The solver seems to find the 10 feasible solutions quite quickly:</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="o">============================</span>
size: 5
The Solve method took 0.07 seconds
Number of solutions: 10
Failures: 14
Branches: 26
Backtracks: 17
Stamps: 61
</pre></div>
</div>
<p>But then, <img class="math" src="../../_images/math/5218af40079081e694d8b82eeac2d368ef6ea76a.png" alt="n = 4" style="vertical-align: -1px"/> and <img class="math" src="../../_images/math/ec37f4048b4f92c2227c9bfe79fcb7d52ab99c9c.png" alt="n = 5" style="vertical-align: 0px"/> are really small numbers. And indeed, with <img class="math" src="../../_images/math/e326b48726d4c73525c3b980409600fd87ea9846.png" alt="n = 6" style="vertical-align: 0px"/>, things start to
look really ugly:</p>
<img alt="../../_images/complete_search_tree_n_6.png" class="align-center" src="../../_images/complete_search_tree_n_6.png" style="width: 500pt;" />
<p>That&#8217;s a real nightmare! The statistics collected during the search confirm this:</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="o">============================</span>
size: 6
The Solve method took 0.005 seconds
Number of solutions: 4
Failures: 36
Branches: 70
Backtracks: 39
Stamps: 149
</pre></div>
</div>
<p>To only find 4 solutions, we need 70 branches and 39 backtracks!</p>
<p>This trend is confirmed if we look at larger values of <img class="math" src="../../_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n" style="vertical-align: 0px"/>:</p>
<table border="1" class="docutils">
<colgroup>
<col width="27%" />
<col width="11%" />
<col width="11%" />
<col width="11%" />
<col width="11%" />
<col width="15%" />
<col width="15%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><img class="math" src="../../_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n" style="vertical-align: 0px"/></th>
<th class="head">7</th>
<th class="head">8</th>
<th class="head">9</th>
<th class="head">10</th>
<th class="head">11</th>
<th class="head">12</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Time (s)</td>
<td>0,014</td>
<td>0,052</td>
<td>0,25</td>
<td>0,899</td>
<td>4,236</td>
<td>21,773</td>
</tr>
<tr class="row-odd"><td>Number of sol.</td>
<td>40</td>
<td>92</td>
<td>352</td>
<td>724</td>
<td>2680</td>
<td>14200</td>
</tr>
<tr class="row-even"><td>Failures</td>
<td>110</td>
<td>396</td>
<td>1546</td>
<td>6079</td>
<td>27246</td>
<td>131006</td>
</tr>
<tr class="row-odd"><td>Branches</td>
<td>218</td>
<td>790</td>
<td>3090</td>
<td>12156</td>
<td>54490</td>
<td>262010</td>
</tr>
<tr class="row-even"><td>Backtracks</td>
<td>113</td>
<td>399</td>
<td>1549</td>
<td>6082</td>
<td>27249</td>
<td>131009</td>
</tr>
<tr class="row-odd"><td>Stamps</td>
<td>445</td>
<td>1583</td>
<td>6189</td>
<td>24321</td>
<td>108989</td>
<td>524029</td>
</tr>
</tbody>
</table>
<p>We clearly see the exponential pattern of intractable problems<a class="footnote-reference" href="#not-proof-exponential-behaviour" id="id6">[4]</a>.</p>
<p>We have seen in the previous section that the other implemented search strategies didn&#8217;t seem to do better.
Can we do better? Let&#8217;s try!</p>
<div class="topic">
<p class="topic-title first">How did we produce these wonderful images?</p>
<p>All the images of search trees were produced with <strong class="program">cpviz</strong> and <strong class="program">nqueens4</strong>.
See the section <a class="reference internal" href="cpviz.html#cpviz"><em>cpviz: how to visualize the search</em></a> for more details on how
to obtain them.</p>
</div>
</div>
<div class="section" id="first-try-start-from-the-center-and-use-callbacks">
<span id="nqueens-phases-callbacks"></span><h2>5.7.3. First try: start from the center (and use callbacks)</h2>
<div class="files-sidebar container">
<ol>
  <li>C++ code:
    <ol>
      <li><a href="../../../tutorials/cplusplus/chap5/nqueens5.cc">nqueens5.cc</a></li>
    </ol>
  </li>

</ol></div>
<p>Our default search strategy (<tt class="docutils literal"><span class="pre">CHOOSE_FIRST_UNBOUND</span></tt> and <tt class="docutils literal"><span class="pre">ASSIGN_MIN_VALUE</span></tt>) starts with the variables from the left and then slowly assigns variables more in the center and finishes with
the variables at the other end, i.e. it will first try to assign some value to <img class="math" src="../../_images/math/17f1249ad95b7682b8316ad21de8ce4ee9fdcf93.png" alt="x_0" style="vertical-align: -3px"/>, then <img class="math" src="../../_images/math/ccada11db7b2b90693e2fac4f887a57fce6f96bf.png" alt="x_1" style="vertical-align: -4px"/>, and so on until <img class="math" src="../../_images/math/50d4b9ad2bdffcfcc00b960cf271a20d87ba85e7.png" alt="x_{n-1}" style="vertical-align: -4px"/> for an <img class="math" src="../../_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n" style="vertical-align: 0px"/>-Queens Problem.</p>
<p>When propagating the constraints <em>from the side first</em>, we don&#8217;t exclude as much values as when we propagate from the center. This is illustrated on the next figure:</p>
<div align="center"><img alt="../../_images/queen_in_the_corner.png" src="../../_images/queen_in_the_corner.png" style="height: 149pt;" />
<img alt="../../_images/queen_in_the_middle.png" src="../../_images/queen_in_the_middle.png" style="height: 149pt;" />
</div><p>In the left figure, the queen in the left upper corner forbids 9 variable-value combinations, while the queen on the right in the middle forbids 11 variable-value combinations.</p>
<p>Maybe it would be worth trying to first select the variables from the middle? To do so, let&#8217;s use a callback and define a simple way to evaluate the <em>middleness</em> of a variable index.
We use a simple callback <tt class="docutils literal"><span class="pre">IndexEvaluator1</span></tt> that allows to evaluate the next variable to branch on by giving the index of this variable in the std::vector&lt;IntVar*&gt; for unbounded variables:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">typedef</span> <span class="n">ResultCallback1</span><span class="o">&lt;</span><span class="n">int64</span><span class="p">,</span> <span class="n">int64</span><span class="o">&gt;</span> <span class="n">IndexEvaluator1</span><span class="p">;</span>
</pre></div>
</div>
<p>As stated in <a class="reference internal" href="basic_working_phases.html#make-phase-callback-to-the-rescue"><em>Callbacks to the rescue</em></a>, the smallest value returned by this callback will give the index of the chosen variable to branch on.
Define <img class="math" src="../../_images/math/7afeb8d0367d105bc23fccd19d9d23ac9f2ff46d.png" alt="\lfloor \frac{n}{2} \rfloor" style="vertical-align: -6px"/> to be the <em>middle</em> of a <img class="math" src="../../_images/math/c3d38f82f48ef9e81c04d49354293305b0067afc.png" alt="n \times n" style="vertical-align: 0px"/> chessboard. An easy way to measure the distance of the index <img class="math" src="../../_images/math/34857b3ba74ce5cd8607f3ebd23e9015908ada71.png" alt="i" style="vertical-align: 0px"/> of a variable to the middle of the chessboard is:</p>
<div class="math">
<p><img src="../../_images/math/07e910c7cc558497d30caa89d760138c5745905d.png" alt="|\lfloor \frac{n}{2} \rfloor - i|"/></p>
</div><p>where <img class="math" src="../../_images/math/29680a0e11fad163e3a724436f78a84ae70d098a.png" alt="|X|" style="vertical-align: -5px"/> denotes the absolute value of <img class="math" src="../../_images/math/6a47ca0fe7cb276abc022af6ac88ddae1a9d6894.png" alt="X" style="vertical-align: 0px"/>, i.e. <img class="math" src="../../_images/math/6a47ca0fe7cb276abc022af6ac88ddae1a9d6894.png" alt="X" style="vertical-align: 0px"/> if <img class="math" src="../../_images/math/525288b4fc7ce8d89ff397742cbf58515595b904.png" alt="X \geqslant 0" style="vertical-align: -3px"/> or <img class="math" src="../../_images/math/af412fbd450b065679fa9e1440a8a1fb3d7553a9.png" alt="-X" style="vertical-align: 0px"/> if <img class="math" src="../../_images/math/dcdc98e86d96a1dff12b077f25a490d68b0f007f.png" alt="X &lt; 0" style="vertical-align: 0px"/>.
Translated into code, we have the next callback:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MiddleVariableIndexSelector</span> <span class="o">:</span> <span class="k">public</span> <span class="n">IndexEvaluator1</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">MiddleVariableIndexSelector</span><span class="p">(</span><span class="k">const</span> <span class="n">int64</span> <span class="n">n</span><span class="p">)</span><span class="o">:</span> <span class="n">n_</span><span class="p">(</span><span class="n">n</span><span class="p">),</span>
                                           <span class="n">middle_var_index_</span><span class="p">((</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="p">{}</span>
  <span class="o">~</span><span class="n">MiddleVariableIndexSelector</span><span class="p">()</span> <span class="p">{}</span>
  <span class="n">int64</span> <span class="n">Run</span><span class="p">(</span><span class="n">int64</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">abs</span><span class="p">(</span><span class="n">middle_var_index_</span> <span class="o">-</span> <span class="n">index</span><span class="p">);</span>
  <span class="p">}</span>

<span class="nl">private:</span>
  <span class="k">const</span> <span class="n">int64</span> <span class="n">n_</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">int64</span> <span class="n">middle_var_index_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>To assign a value, we can use the predefined <tt class="docutils literal"><span class="pre">ASSIGN_CENTER_VALUE</span></tt> strategy that selects the first available value that is the closest to the center of the domain of the selected variable.</p>
<p>Our code becomes:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">MiddleVariableIndexSelector</span> <span class="o">*</span> <span class="n">index_evaluator</span> <span class="o">=</span>
                                  <span class="k">new</span> <span class="n">MiddleVariableIndexSelector</span><span class="p">(</span><span class="n">size</span><span class="p">);</span>

<span class="n">DecisionBuilder</span><span class="o">*</span> <span class="k">const</span> <span class="n">db</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">MakePhase</span><span class="p">(</span><span class="n">queens</span><span class="p">,</span>
                                        <span class="n">index_evaluator</span><span class="p">,</span>
                                        <span class="n">Solver</span><span class="o">::</span><span class="n">ASSIGN_CENTER_VALUE</span><span class="p">);</span>

<span class="n">s</span><span class="p">.</span><span class="n">Solve</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="n">monitors</span><span class="p">);</span>  <span class="c1">// go!</span>
</pre></div>
</div>
<p>In the next table, we compare this strategy to our default strategy:</p>
<table border="1" class="docutils">
<colgroup>
<col width="25%" />
<col width="23%" />
<col width="28%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><img class="math" src="../../_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n" style="vertical-align: 0px"/></th>
<th class="head">Statistics</th>
<th class="head">Default strategy</th>
<th class="head">New strategy</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>7</td>
<td>Failures</td>
<td>110</td>
<td>98</td>
</tr>
<tr class="row-odd"><td></td>
<td>Branches</td>
<td>218</td>
<td>194</td>
</tr>
<tr class="row-even"><td>8</td>
<td>Failures</td>
<td>396</td>
<td>368</td>
</tr>
<tr class="row-odd"><td></td>
<td>Branches</td>
<td>790</td>
<td>734</td>
</tr>
<tr class="row-even"><td>9</td>
<td>Failures</td>
<td>1546</td>
<td>1272</td>
</tr>
<tr class="row-odd"><td></td>
<td>Branches</td>
<td>3090</td>
<td>2542</td>
</tr>
<tr class="row-even"><td>10</td>
<td>Failures</td>
<td>6079</td>
<td>4950</td>
</tr>
<tr class="row-odd"><td></td>
<td>Branches</td>
<td>12156</td>
<td>9898</td>
</tr>
<tr class="row-even"><td>11</td>
<td>Failures</td>
<td>27246</td>
<td>20441</td>
</tr>
<tr class="row-odd"><td></td>
<td>Branches</td>
<td>54490</td>
<td>40880</td>
</tr>
<tr class="row-even"><td>12</td>
<td>Failures</td>
<td>131006</td>
<td>97335</td>
</tr>
<tr class="row-odd"><td></td>
<td>Branches</td>
<td>262010</td>
<td>194668</td>
</tr>
</tbody>
</table>
<p>Our new strategy is better and - even if this is not shown - quicker. That said, is it really that clever? In the next table we compare our <tt class="docutils literal"><span class="pre">IndexEvaluator1</span></tt> <tt class="docutils literal"><span class="pre">MiddleVariableIndexSelector</span></tt>
combined with the <tt class="docutils literal"><span class="pre">ASSIGN_MIN_VALUE</span></tt> assign value strategy:</p>
<table border="1" class="docutils">
<colgroup>
<col width="18%" />
<col width="17%" />
<col width="20%" />
<col width="45%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><img class="math" src="../../_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n" style="vertical-align: 0px"/></th>
<th class="head">Statistics</th>
<th class="head">New strategy</th>
<th class="head">New strategy with <tt class="docutils literal"><span class="pre">ASSIGN_MIN_VALUE</span></tt></th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>7</td>
<td>Failures</td>
<td>98</td>
<td>97</td>
</tr>
<tr class="row-odd"><td></td>
<td>Branches</td>
<td>194</td>
<td>192</td>
</tr>
<tr class="row-even"><td>8</td>
<td>Failures</td>
<td>368</td>
<td>363</td>
</tr>
<tr class="row-odd"><td></td>
<td>Branches</td>
<td>734</td>
<td>724</td>
</tr>
<tr class="row-even"><td>9</td>
<td>Failures</td>
<td>1272</td>
<td>1254</td>
</tr>
<tr class="row-odd"><td></td>
<td>Branches</td>
<td>2542</td>
<td>2506</td>
</tr>
<tr class="row-even"><td>10</td>
<td>Failures</td>
<td>4950</td>
<td>4857</td>
</tr>
<tr class="row-odd"><td></td>
<td>Branches</td>
<td>9898</td>
<td>9712</td>
</tr>
<tr class="row-even"><td>11</td>
<td>Failures</td>
<td>20441</td>
<td>20072</td>
</tr>
<tr class="row-odd"><td></td>
<td>Branches</td>
<td>40880</td>
<td>40142</td>
</tr>
<tr class="row-even"><td>12</td>
<td>Failures</td>
<td>97335</td>
<td>95396</td>
</tr>
<tr class="row-odd"><td></td>
<td>Branches</td>
<td>194668</td>
<td>190784</td>
</tr>
</tbody>
</table>
<p>How come that the value assigning strategy <tt class="docutils literal"><span class="pre">ASSIGN_MIN_VALUE</span></tt> does (slightly) better than the <tt class="docutils literal"><span class="pre">ASSIGN_CENTER_VALUE</span></tt>? At first, assigning the smallest eligible value doesn&#8217;t seem a good idea but you have to keep
the big picture in mind: we are looking for all solutions. Despite the fact that looking from the center seems to accelerate the search when looking for one solution, it is counter-productive in some cases.
Always test your ideas as the search is always a  matter of tradeoffs.</p>
<p>Another thing that should bug you is that the <tt class="docutils literal"><span class="pre">IndexEvaluator1</span></tt> is called on all unbounded variables for evaluation while we already know what the best unbounded variable is, no need to go over all
of them. Maybe we can use a shortcut and why not use our knowledge to select the unbounded variables and assign them values? This is what we&#8217;ll try next.</p>
</div>
<div class="section" id="second-try-dynamic-variable-selection-and-define-our-own-decisionbuilder-class">
<span id="nqueens-phases-decision-builder-decision"></span><h2>5.7.4. Second try: dynamic variable selection (and define our own <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> class)</h2>
<div class="files-sidebar container">
<ol>
  <li>C++ code:
    <ol>
      <li><a href="../../../tutorials/cplusplus/chap5/nqueens6.cc">nqueens6.cc</a></li>
    </ol>
  </li>

</ol></div>
<p>In this sub-section, we will implement our own <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> class. The idea is to give you a glimpse of what can be done, not to solve the <img class="math" src="../../_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n" style="vertical-align: 0px"/>-Queens Problem. The idea proposed here can be
further developed but this would lead us too far.</p>
<p>We continue with our first intuition to assign variables &#8220;from the center&#8221; as in our first try but this time we select the variables dynamically. We could have constructed our own customized <tt class="docutils literal"><span class="pre">Decision</span></tt>
class but because we only assign one variable at a time, we can reuse the already implemented <tt class="docutils literal"><span class="pre">AssignVariableValue</span></tt> <tt class="docutils literal"><span class="pre">Decision</span></tt> class. As usual, this class is not directly available and we use the corresponding factory method <tt class="docutils literal"><span class="pre">MakeAssignVariableValue()</span></tt>. To mimic this implementation choice, we also use the anonymous <tt class="docutils literal"><span class="pre">namespace</span></tt><a class="footnote-reference" href="#anonymous-namespace-and-c11" id="id7">[7]</a>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">namespace</span> <span class="p">{</span>
  <span class="p">...</span> <span class="c1">// code here is inaccessible in another unit</span>
<span class="p">}</span>
</pre></div>
</div>
<p>and use a factory method for our customized <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> class. This is just to show you why you cannot (and <strong>should not</strong>!) use some classes directly<a class="footnote-reference" href="#anonymous-in-same-unit" id="id8">[8]</a>.</p>
<p>We name our customized <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> <tt class="docutils literal"><span class="pre">NQueensDecisionBuilder</span></tt>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">NQueensDecisionBuilder</span> <span class="o">:</span> <span class="k">public</span> <span class="n">DecisionBuilder</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">NQueensDecisionBuilder</span><span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span>
                         <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IntVar</span><span class="o">*&gt;&amp;</span> <span class="n">vars</span><span class="p">)</span><span class="o">:</span>
               <span class="n">size_</span><span class="p">(</span><span class="n">size</span><span class="p">),</span> <span class="n">vars_</span><span class="p">(</span><span class="n">vars</span><span class="p">),</span> <span class="n">middle_var_index_</span><span class="p">((</span><span class="n">size</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">/</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">CHECK_EQ</span><span class="p">(</span><span class="n">vars_</span><span class="p">.</span><span class="n">size</span><span class="p">(),</span> <span class="n">size_</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="o">~</span><span class="n">NQueensDecisionBuilder</span><span class="p">()</span> <span class="p">{}</span>

<span class="p">...</span>
<span class="nl">private:</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">size_</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IntVar</span><span class="o">*&gt;</span> <span class="n">vars_</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">middle_var_index_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>and here is our factory method:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">DecisionBuilder</span><span class="o">*</span> <span class="nf">MakeNQueensDecisionBuilder</span><span class="p">(</span><span class="n">Solver</span><span class="o">*</span> <span class="k">const</span> <span class="n">s</span><span class="p">,</span>
                            <span class="k">const</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IntVar</span><span class="o">*&gt;&amp;</span> <span class="n">vars</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">RevAlloc</span><span class="p">(</span><span class="k">new</span> <span class="n">NQueensDecisionBuilder</span><span class="p">(</span><span class="n">size</span><span class="p">,</span> <span class="n">vars</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As you see, we construct a <em>middle</em> index for our variables in the constructor and assign this value to <tt class="docutils literal"><span class="pre">middle_var_index_</span></tt> as we did in our first try.</p>
<p>We again use a two-stages approach: we first select a variable to branch on and then we select a value from its domain to assign it in the <tt class="docutils literal"><span class="pre">Apply()</span></tt> section of the search tree. Remember that this is
exactly what a <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> does: at each node in the search tree, it returns a <tt class="docutils literal"><span class="pre">Decision</span></tt> that is applied on one branch (<tt class="docutils literal"><span class="pre">Apply()</span></tt>) and refuted on the other branch (<tt class="docutils literal"><span class="pre">Refute()</span></tt>). We select the
variable that has the smallest domain, i.e. the smallest number of values still available to assign to this variable. We could have chosen one of the <tt class="docutils literal"><span class="pre">CHOOSE_MIN_SIZE_XXX</span></tt> variable selection strategies except
that in the case of a tie, we explicitly want to select the variable that is the &#8220;most in the middle&#8221;. To select this variable, we use the following method:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">IntVar</span><span class="o">*</span> <span class="nf">SelectVar</span><span class="p">(</span><span class="n">Solver</span><span class="o">*</span> <span class="k">const</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">IntVar</span><span class="o">*</span> <span class="n">selected_var</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
  <span class="n">int64</span> <span class="n">id</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="n">int64</span> <span class="n">min_domain_size</span> <span class="o">=</span> <span class="n">kint64max</span><span class="p">;</span>

  <span class="c1">// go left on the chessboard</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">int64</span> <span class="n">i</span> <span class="o">=</span> <span class="n">middle_var_index_</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">IntVar</span><span class="o">*</span> <span class="k">const</span> <span class="n">var</span> <span class="o">=</span> <span class="n">vars_</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">var</span><span class="o">-&gt;</span><span class="n">Bound</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">Size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">min_domain_size</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">selected_var</span> <span class="o">=</span> <span class="n">var</span><span class="p">;</span>
      <span class="n">id</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
      <span class="n">min_domain_size</span> <span class="o">=</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">Size</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// go right on the chessboard</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">int64</span> <span class="n">i</span> <span class="o">=</span> <span class="n">middle_var_index_</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size_</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">IntVar</span><span class="o">*</span> <span class="k">const</span> <span class="n">var</span> <span class="o">=</span> <span class="n">vars_</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">var</span><span class="o">-&gt;</span><span class="n">Bound</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">Size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">min_domain_size</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">selected_var</span> <span class="o">=</span> <span class="n">var</span><span class="p">;</span>
      <span class="n">id</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
      <span class="n">min_domain_size</span> <span class="o">=</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">Size</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">id</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">nullptr</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">selected_var</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p id="index-0">This method simply returns (a pointer to) the selected <tt class="docutils literal"><span class="pre">IntVar</span></tt> variable. Of interest are the methods <tt class="docutils literal"><span class="pre">Bound()</span></tt> that returns <tt class="docutils literal"><span class="pre">true</span></tt> if the variable is bounded, i.e. if it is assigned a value and <tt class="docutils literal"><span class="pre">Size()</span></tt>
that returns the size of the current domain of a variable. If we can not find any variable, we return a <tt class="docutils literal"><span class="pre">nullptr</span></tt>. The idea behind this selection strategy is to choose a variable that can make the solver fail as soon as possible. Indeed, if a queen doesn&#8217;t have many possibilities, it&#8217;s probably because there is not enough room for her. This is strategy is called the <em>first fail principle</em>.</p>
<p id="index-1">Once a variable is selected, we select a value to be assigned to it. Different scenarii are possible. Let&#8217;s try to select the row with the least compatible columns, i.e. the row that has the least number of
possibilities to be occupied by a queen. The idea is that we want to choose the row that has the least possibilities to welcome a queen because this might lead to the best choice for a queen on her column. Indeed,
other choices might even reduce the number of possibilities on this row. This strategy, the one that will <em>most probably</em> lead to a solution, is called the <em>best success principle</em>.</p>
<p>We devise a simple method to count the number of incompatibilities for one row:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">int64</span> <span class="nf">count_number_of_row_incompatibilities</span><span class="p">(</span><span class="n">int64</span> <span class="n">row</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">int64</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">int64</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size_</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">vars_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-&gt;</span><span class="n">Contains</span><span class="p">(</span><span class="n">row</span><span class="p">))</span> <span class="p">{</span>
      <span class="o">++</span><span class="n">count</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">count</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Given a row <tt class="docutils literal"><span class="pre">row</span></tt>, we count the impossibilities, i.e. the number of queens that cannot be placed on this row. Note the use of the method <tt class="docutils literal"><span class="pre">Contains()</span></tt> that returns if a given value is in the domain or not.
The corresponding <tt class="docutils literal"><span class="pre">SelectValue()</span></tt> method is straightforward and we don&#8217;t discuss it here. We now turn to the main method of the <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>: its <tt class="docutils literal"><span class="pre">Next()</span></tt> method. It is deceivingly simple:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Decision</span><span class="o">*</span> <span class="nf">Next</span><span class="p">(</span><span class="n">Solver</span><span class="o">*</span> <span class="k">const</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">IntVar</span><span class="o">*</span> <span class="k">const</span> <span class="n">var</span> <span class="o">=</span> <span class="n">SelectVar</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">nullptr</span> <span class="o">!=</span> <span class="n">var</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">int64</span> <span class="n">value</span> <span class="o">=</span> <span class="n">SelectValue</span><span class="p">(</span><span class="n">var</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">MakeAssignVariableValue</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If we find a variable and a value, we return an <tt class="docutils literal"><span class="pre">AssignVariableValue</span></tt> <tt class="docutils literal"><span class="pre">Decision</span></tt> that will assign the value to the variable in its <tt class="docutils literal"><span class="pre">Apply()</span></tt> method and remove this value for this variable in its
<tt class="docutils literal"><span class="pre">Refute()</span></tt> method.</p>
<p>How does this simple strategy perform? In the next table, we compare the number of failures and branches for our best first try strategy and this one:</p>
<table border="1" class="docutils">
<colgroup>
<col width="15%" />
<col width="14%" />
<col width="41%" />
<col width="30%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"><img class="math" src="../../_images/math/174fadd07fd54c9afe288e96558c92e0c1da733a.png" alt="n" style="vertical-align: 0px"/></th>
<th class="head">Statistics</th>
<th class="head">first try with <tt class="docutils literal"><span class="pre">ASSIGN_MIN_VALUE</span></tt></th>
<th class="head">Second try</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>7</td>
<td>Failures</td>
<td>97</td>
<td>92</td>
</tr>
<tr class="row-odd"><td></td>
<td>Branches</td>
<td>192</td>
<td>182</td>
</tr>
<tr class="row-even"><td>8</td>
<td>Failures</td>
<td>363</td>
<td>328</td>
</tr>
<tr class="row-odd"><td></td>
<td>Branches</td>
<td>724</td>
<td>654</td>
</tr>
<tr class="row-even"><td>9</td>
<td>Failures</td>
<td>1254</td>
<td>1216</td>
</tr>
<tr class="row-odd"><td></td>
<td>Branches</td>
<td>2506</td>
<td>2430</td>
</tr>
<tr class="row-even"><td>10</td>
<td>Failures</td>
<td>4857</td>
<td>4500</td>
</tr>
<tr class="row-odd"><td></td>
<td>Branches</td>
<td>9712</td>
<td>8998</td>
</tr>
<tr class="row-even"><td>11</td>
<td>Failures</td>
<td>20072</td>
<td>17847</td>
</tr>
<tr class="row-odd"><td></td>
<td>Branches</td>
<td>40142</td>
<td>35692</td>
</tr>
<tr class="row-even"><td>12</td>
<td>Failures</td>
<td>95396</td>
<td>86102</td>
</tr>
<tr class="row-odd"><td></td>
<td>Branches</td>
<td>190784</td>
<td>172202</td>
</tr>
</tbody>
</table>
<p>So, yes, we did better by using some knowledge of the problem to prune the search tree but to really tackle this problem, we need a deeper understanding of... symmetries. This is the subject of the next section.</p>
<p>Don&#8217;t hesitate to have a look at the code. The routing library in particular has very specialized implementations of <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>s and <tt class="docutils literal"><span class="pre">Decision</span></tt>s. In particular, have a look at the different
<tt class="docutils literal"><span class="pre">IntVarFilteredDecisionBuilder</span></tt>s and you may want to implement your versions only
if you add lots of knowledge of the problem at hand. Otherwise, you can reuse the already implemented (and more general <strong>and</strong> tested) versions.</p>
</div>
<div class="section" id="how-to-customize-search-primitives">
<h2>5.7.5. How to customize search primitives?</h2>
<p>Basically, think about an algorithm and implement whatever you need. To customize search primitives, you can, in order of complexity:</p>
<ul class="simple">
<li>combine existing ones;</li>
<li>redefine callbacks;</li>
<li>implement your own version of some search primitive classes;</li>
<li>mix all of the above.</li>
</ul>
<p>Often, there is more than one way to do it. Choose the simplest way first to prototype your algorithm. Combining existing chunks of code shouldn&#8217;t need too much coding effort and you will know right away
if your idea has some potential or not. Being able to rapidly construct an algorithm in a few lines of code is one of the strength of the <strong>or-tools</strong> library. Once your idea is implemented, profile your code
to see if you really need an improved version or not. Maybe the existing code is too general and you should adapt it to your specific problem with the help of callbacks. Again, profile your code. Last situation, maybe there isn&#8217;t any piece of code to do what you want. In this case, you&#8217;ll need to implement your own version. The library was conceived with reuse and extension in mind. If you find yourself stuck, maybe it is because you are not using/redefining the right search primitives? In the section <a class="reference internal" href="../modeling_tricks/customized_search_primitives.html#what-search-primitives-to-customize"><em>What search primitives to customize?</em></a>, we discuss what search primitives to customize.</p>
<p>If you think your piece of code might be general enough and could be used by others, ask on the mailing list if we are not interested in implementing it ourselves or if by any chance we don&#8217;t already have
some code that we can open source.</p>
<p>Last but not least, if you have produced a piece of code of general interest, share it with the community.</p>
<h4>Footnotes</h4><table class="docutils footnote" frame="void" id="decision-left-right" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>We keep our visualization of our binary search tree, with going left to assign some values to variables and going right
to do the contrary, i.e. to avoid the assignment of these values to the same variables. Of course, there is no left nor right in the tree. The basic idea is to partition
the sub-tree at this point in the search into two sub-trees.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="no-jump-in-search-tree" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>Well, this is not totally exact. The search tree is conceptual and depending on the view you have of the tree, you can visit it in different ways but let us keep it simple
for the moment. We have one search tree and the CP Solver use a pre-order traversal to traverse this tree. Reread the section <a class="reference internal" href="basic_working_search_algorithm.html#basic-working-search-algorithm"><em>Basic working of the solver: the search algorithm</em></a> if needed.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="other-primitives-to-shape-the-search-tree" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>And other primitives like <tt class="docutils literal"><span class="pre">SymmetryBreaker</span></tt>s,
subject of the section <a class="reference internal" href="breaking_symmetry.html#search-primitives-breaking-symmetry"><em>Breaking symmetries with SymmetryBreakers</em></a>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="not-proof-exponential-behaviour" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[4]</a></td><td>This is not a proof of course. Maybe another search strategy would yield a better
algorithm but we do know that this problem <strong>is</strong> intractable.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="reveribly" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[5]</a></td><td>This is in reference to the backtracking mechanism of the CP Solver.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="revalloc-others" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[6]</a></td><td>Or one of its sibling methods.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="anonymous-namespace-and-c11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[7]</a></td><td>Although anonymous <tt class="docutils literal"><span class="pre">namespace</span></tt>s are no longer required in <tt class="docutils literal"><span class="pre">C++11</span></tt>.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="anonymous-in-same-unit" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[8]</a></td><td>You can access the class definitions in the same file though.</td></tr>
</tbody>
</table>
<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br>
<br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<table>
<tr>
<td width="60"><img src="../../_static/logo.png" width="50" height="50"  alt="" /></td>
<td><p class="library_name">Google <a href="http://code.google.com/p/or-tools/"><strong>or-tools</strong></a><br>open source library</p></td>
</tr>
</table>
<h1>User's Manual</h1>

  
   



<h3>Google search</h3>

<form method="get" action="http://www.google.com/search">

<div style="padding:-1px;width:15em;">
<table border="0" cellpadding="0">
<tr><td>
<input type="text"   name="q" size="25"
 maxlength="255" value="" />
<input type="submit" value="Go" /></td></tr>
<tr><td align="center" style="font-size:80%">
Search:
<select name="sitesearch" width="125" style="width: 125px">
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/user_manual/" selected>user's manual</option>
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/faq/">faq</option>
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/reference_manual/or-tools/">reference manual</option>
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/">All or-tools doc</option>
</select>
</td></tr>
</table>
</div>

</form>
</br>




  <h3>Welcome</h3>
  
  <ul>
  	<li><a href="../../index.html">Content and foreword</a></li>
  	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html">Documentation's hub</a></li>
	<li><a href="http://code.google.com/p/or-tools/">The or-tools open source library</a></li></li>	
  </ul>
  
   
	


  <h3>Tutorial examples</h3>
  
  <ul>
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_C++">C++</a></li>
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_Python">Python</a></li>	
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_Java">Java</a></li>
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_Csharp">C#</a></li>
</ul>
  
   
	

  <h3>Current chapter</h3>
  <p class="topless"><a href="../search_primitives.html"
                        title="previous chapter">5. Defining search primitives: the n-Queens Problem</a></p>
  <h3>Previous section</h3>
  <p class="topless"><a href="out_of_the_box_search_primitives.html"
                        title="previous chapter">5.6. Out of the box variables and values selection primitives</a></p>
  <h3>Next section</h3>
  <p class="topless"><a href="breaking_symmetry.html"
                        title="next chapter">5.8. Breaking symmetries with <tt class="docutils literal"><span class="pre">SymmetryBreaker</span></tt>s</a></p>
  <h3>Current section</a></h3>
  <ul>
<li><a class="reference internal" href="#">5.7. Customized search primitives: <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>s and <tt class="docutils literal"><span class="pre">Decision</span></tt>s</a><ul>
<li><a class="reference internal" href="#baseobject-and-revalloc">5.7.1. <tt class="docutils literal"><span class="pre">BaseObject</span></tt> and <tt class="docutils literal"><span class="pre">RevAlloc</span></tt></a></li>
<li><a class="reference internal" href="#the-basic-search-strategy-visualized">5.7.2. The basic search strategy visualized</a></li>
<li><a class="reference internal" href="#first-try-start-from-the-center-and-use-callbacks">5.7.3. First try: start from the center (and use callbacks)</a></li>
<li><a class="reference internal" href="#second-try-dynamic-variable-selection-and-define-our-own-decisionbuilder-class">5.7.4. Second try: dynamic variable selection (and define our own <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> class)</a></li>
<li><a class="reference internal" href="#how-to-customize-search-primitives">5.7.5. How to customize search primitives?</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="breaking_symmetry.html" title="5.8. Breaking symmetries with SymmetryBreakers"
             >next</a> |</li>
        <li class="right" >
          <a href="out_of_the_box_search_primitives.html" title="5.6. Out of the box variables and values selection primitives"
             >previous</a> |</li>
        <li><a href="../../index.html">or-tools User&#39;s Manual</a> &raquo;</li>
          <li><a href="../search_primitives.html" >5. Defining search primitives: the n-Queens Problem</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012-2014, Google.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>