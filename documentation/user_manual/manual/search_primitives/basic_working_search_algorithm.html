

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>5.3. Basic working of the solver: the search algorithm &mdash; or-tools User&#39;s Manual</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     'doc version 0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../_static/logo.ico"/>
    <link rel="top" title="or-tools User&#39;s Manual" href="../../index.html" />
    <link rel="up" title="5. Defining search primitives: the n-queens problem" href="../search_primitives.html" />
    <link rel="next" title="5.4. cpviz: how to visualize the search" href="cpviz.html" />
    <link rel="prev" title="5.2. Implementation of the basic model" href="basic_model_implementation.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="cpviz.html" title="5.4. cpviz: how to visualize the search"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="basic_model_implementation.html" title="5.2. Implementation of the basic model"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">or-tools User&#39;s Manual</a> &raquo;</li>
          <li><a href="../search_primitives.html" accesskey="U">5. Defining search primitives: the n-queens problem</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="basic-working-of-the-solver-the-search-algorithm">
<span id="basic-working-search-algorithm"></span><h1>5.3. Basic working of the solver: the search algorithm</h1>
<p>Basically, the CP solver consists of three main components:</p>
<ul class="simple">
<li>the <strong>main search algorithm</strong> that permits to traverse/construct the search tree and to call the callbacks at the right moments;</li>
<li>the <strong>Trail</strong> that is responsible for reversibility (when backtracking, you have to restore the previous states) and</li>
<li>the <strong>Queue</strong> where the propagation takes place thanks to the <tt class="docutils literal"><span class="pre">Demon</span></tt>s.</li>
</ul>
<p>In this section, we only discuss the main search algorithm.</p>
<p>We present a simplified version of the main search algorithm. Although far from being
complete, it gathers all the necessary basic elements and allows you to understand
when some of the callbacks of the <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt>s are called.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">We describe a simplified version of the main search algorithm.</p>
</div>
<p>The real implementation is more complex (and a little bit different!) and deals with other cases not mentioned here
(especially nested searches and restarting the search).</p>
<p>For the juicy details, we refer the reader to the chapter <a class="reference internal" href="../under_the_hood.html#chapter-under-the-hood"><em>Under the hood</em></a> or the source code itself.</p>
<div class="section" id="basic-definitions">
<span id="basic-definition"></span><h2>5.3.1. Basic definitions</h2>
<p>Let&#8217;s agree on some wording we will use throughout this chapter and the rest of the manual.</p>
<div class="section" id="search-trees">
<h3>5.3.1.1. Search trees</h3>
<p>A search tree represents the search space that the search algorithm will, implicitly or explicitly,
traverse or explore. Each node of the tree corresponds to a state of the search. Take an array of variables <img class="math" src="../../_images/math/3721871babf1d0ae999f03599154b5bc5f56adff.png" alt="x[]" style="vertical-align: -5px"/>
and a valid index <img class="math" src="../../_images/math/34857b3ba74ce5cd8607f3ebd23e9015908ada71.png" alt="i" style="vertical-align: 0px"/>.</p>
<p>At one node in the search tree, we divide the search space in two exclusive search subspaces by imposing
<img class="math" src="../../_images/math/1fb5e597525d6008ac2d935abb8d146f3ddc02f2.png" alt="x[i] = 2" style="vertical-align: -5px"/> at one branch and <img class="math" src="../../_images/math/4937591eda0b24f172fddd70dec6839a7f7e2761.png" alt="x[i] \neq 2" style="vertical-align: -5px"/> at another branch like in the Figure
<a class="reference internal" href="#search-space-divided-in-two"><em>The search space is divided in two search sub-trees</em></a>.</p>
<div class="figure align-center" id="search-space-divided-in-two">
<img alt="The search space is divided in two search sub-trees." src="../../_images/search_tree0.png" style="width: 200px;" />
<p class="caption">The search space is divided in two search sub-trees</p>
</div>
<p>Each subspace is now smaller and we hope easier to solve. We continue this divide and conquer mechanism until we
know that a subspace doesn&#8217;t contain a feasible solution or if we find all feasible solutions of a subtree.
The first node is called the root node and represent the complete search space.</p>
<p>When we divide the search space by applying a decision (<img class="math" src="../../_images/math/1fb5e597525d6008ac2d935abb8d146f3ddc02f2.png" alt="x[i] = 2" style="vertical-align: -5px"/>) in one branch and by refuting this
decision  (<img class="math" src="../../_images/math/4937591eda0b24f172fddd70dec6839a7f7e2761.png" alt="x[i] \neq 2" style="vertical-align: -5px"/>) in another, we obtain a binary search trees<a class="footnote-reference" href="#id2" id="id1">[1]</a>.
This way of dividing the search tree in two is basically the algorithm used by the CP solver to explore a search tree.</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Not to be confused with a binary search tree (BST) used to store ordered sets.</td></tr>
</tbody>
</table>
<p>The divide mechanism can be more complex. For instance by dividing a subspace in more than two subspaces. The subspaces don&#8217;t
need to be mutually exclusive, you can have different numbers of them at each node, etc.</p>
<div class="topic">
<p class="topic-title first">What exactly is a <em>search tree</em>?</p>
<p>A <em>search tree</em> is more a concept than a real object. It is made of nodes but these nodes don&#8217;t have to exist
and can be (and most of them will be) virtual. Sometimes we use the term <em>search tree</em> to denote the whole search
space, sometimes to denote only the visited nodes during a search or a part of the search space depending on the
context.</p>
</div>
</div>
<div class="section" id="callbacks">
<h3>5.3.1.2. Callbacks</h3>
<p>To customize the search, we use <strong>callbacks</strong>. A callback is a reference to a piece of executable code (like a function or an object)
that is passed as an argument to another code. This is a very common and handy way to pass high level code to low level code. For
example, the search algorithm is low level code. You don&#8217;t want to change this code but you would like to change the behaviour of the
search algorithm to your liking. How do you do this? Callbacks are to the rescue! At some places in the low level code,
some functions are called and you can redefine those functions. There are several techniques available. In this section, we redefine
some virtual functions of an abstract class. In section XXX, we will see another similar mechanism.</p>
<p>An example will clarify this mechanism. Take a <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt> class. If you want to implement your own search monitor, you
inherit from <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt> and you redefine the methods you need:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MySearchMonitor</span><span class="o">:</span> <span class="k">public</span> <span class="n">SearchMonitor</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="kt">void</span> <span class="n">EnterSearch</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">LG</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Search entered...&quot;</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>You then pass this <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt> to the solver:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Solver</span> <span class="nf">solver</span><span class="p">(</span><span class="s">&quot;Test my new SearchMonitor&quot;</span><span class="p">);</span>
<span class="n">MySearchMonitor</span><span class="o">*</span> <span class="k">const</span> <span class="n">sm</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MySearchMonitor</span><span class="p">(</span><span class="o">&amp;</span><span class="n">solver</span><span class="p">);</span>
<span class="n">DecisionBuilder</span><span class="o">*</span> <span class="k">const</span> <span class="n">db</span> <span class="o">=</span> <span class="p">...;</span>
<span class="n">solver</span><span class="p">.</span><span class="n">NewSearch</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="n">sm</span><span class="p">);</span>
<span class="k">delete</span> <span class="n">sm</span><span class="p">;</span>
</pre></div>
</div>
<p>At the beginning of a search, the solver calls the virtual method <tt class="docutils literal"><span class="pre">EnterSearch()</span></tt> i.e.
<em>your</em> <tt class="docutils literal"><span class="pre">EnterSearch()</span></tt> method. Don&#8217;t forget to delete your <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt> after use.
You can also use a smart pointer or even better, let the solver take ownership of the object with
the <tt class="docutils literal"><span class="pre">RevAlloc()</span></tt> method (see the subsection <a class="reference internal" href="breaking_symmetry.html#rev-alloc"><em>RevAlloc</em></a>).</p>
</div>
<div class="section" id="phases">
<h3>5.3.1.3. Phases</h3>
<p>The CP solver allows you to combine several searches, i.e. different types of <em>sub-searches</em>. You can search a subtree of the search tree
differently from the rest of your search. This is called <em>nested</em> search while the whole search is called a <em>top-level</em> search.
There are no limitations and you can nest as many searches as
you like. You can also restart a (top level or nested) search. In or-tools, each time you use a new <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>, we say you
are in a new <em>phase</em>. This is where the name <tt class="docutils literal"><span class="pre">MakePhase</span></tt> comes from.</p>
</div>
</div>
<div class="section" id="the-basic-idea">
<h2>5.3.2. The basic idea</h2>
<p>The basic idea<a class="footnote-reference" href="#basic-idea-search-algo-without-details" id="id3">[2]</a> is very simple yet effective.
A <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> is responsible to return a <tt class="docutils literal"><span class="pre">Decision</span></tt> at a node. A decision would be for instance, <img class="math" src="../../_images/math/dd9673e99b7dc9f400135bfffcaffadc4752d5ac.png" alt="x[4] = 3" style="vertical-align: -5px"/>.
We divide the sub search
tree at this node by applying this decision (left branch: <img class="math" src="../../_images/math/dd9673e99b7dc9f400135bfffcaffadc4752d5ac.png" alt="x[4] = 3" style="vertical-align: -5px"/>) and by refuting this decision (right branch:
<img class="math" src="../../_images/math/b2e14bcc31f47e204432c15290cbf9fdbfbaa0b5.png" alt="x[4] \neq 3" style="vertical-align: -5px"/>).</p>
<p>At the current node, the <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> of the current search returns
a <tt class="docutils literal"><span class="pre">Decision</span></tt>. The <tt class="docutils literal"><span class="pre">Decision</span></tt> class basically tells the solver what to do
going left (<tt class="docutils literal"><span class="pre">Apply()</span></tt>) or right (<tt class="docutils literal"><span class="pre">Refute()</span></tt>) as illustrated on the next figure.</p>
<div class="figure align-center">
<img alt="A Decision class Apply() or Refute()" src="../../_images/decision1.png" style="width: 150pt;" />
<p class="caption"><tt class="docutils literal"><span class="pre">Apply()</span></tt>: go left, <tt class="docutils literal"><span class="pre">Refute()</span></tt>: go right.</p>
</div>
<p>From the root node, we follow the left branch whenever possible and backtrack
to the first available right branch when needed. When you see a search tree
produced by the CP solver, you can easily track the search by following
a <em>preorder</em> traversal (see the box <em>What is a pre-order traversal of a binary tree?</em>)
of the binary search tree.</p>
<table class="docutils footnote" frame="void" id="basic-idea-search-algo-without-details" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td>The real code deals with a lots of subtleties
to implement different variants of the search algorithm.</td></tr>
</tbody>
</table>
<div class="topic">
<p class="topic-title first">What is a pre-order traversal of a binary tree?</p>
<p>The search tree depicted on the Figure <a class="reference internal" href="cpviz.html#search-tree-of-nqueens-with-n-equal-to-4"><em>The actual search tree of our search</em></a> has
its node numbered in the order given by a pre-order traversal. There are two other traversals:
<em>in-order</em> and <em>post-order</em>. We invite the curious reader to google <em>pre-order traversal of a tree</em>
to find more. There are a number of applets showing the different traversals.</p>
</div>
<p>There are basically two ways to ask the CP solver to find a solution (or solutions) as we
have seen in the chapter <a class="reference internal" href="../first_steps.html#chapter-first-steps"><em>First steps with or-tools: cryptarithmetic puzzles</em></a>.</p>
<p>Either
you configure <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt>s and you call the <tt class="docutils literal"><span class="pre">Solver</span></tt>&#8216;s <tt class="docutils literal"><span class="pre">Solve()</span></tt> method, either you use
the finer grained <tt class="docutils literal"><span class="pre">NewSearch()</span></tt> - <tt class="docutils literal"><span class="pre">NextSolution()</span></tt> - <tt class="docutils literal"><span class="pre">EndSearch()</span></tt> mechanism. In the
first case, you are not allowed to interfere with the search process while in the second case
you can act every time a solution is found. <tt class="docutils literal"><span class="pre">Solve()</span></tt> is implemented with this second mechanism:</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">bool</span> <span class="n">Solver</span><span class="o">::</span><span class="n">Solve</span><span class="p">(</span><span class="n">DecisionBuilder</span><span class="o">*</span> <span class="k">const</span> <span class="n">db</span><span class="p">,</span>
           <span class="n">SearchMonitor</span><span class="o">*</span> <span class="k">const</span> <span class="o">*</span> <span class="n">monitors</span><span class="p">,</span>
           <span class="kt">int</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">NewSearch</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="n">monitors</span><span class="p">,</span> <span class="n">size</span><span class="p">);</span>
  <span class="n">searches_</span><span class="p">.</span><span class="n">back</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">set_created_by_solve</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>  <span class="c1">// Overwrites default.</span>
  <span class="n">NextSolution</span><span class="p">();</span>
  <span class="k">const</span> <span class="kt">bool</span> <span class="n">solution_found</span> <span class="o">=</span> <span class="n">searches_</span><span class="p">.</span><span class="n">back</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">solution_counter</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">EndSearch</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">solution_found</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p><tt class="docutils literal"><span class="pre">searches_</span></tt> is an <tt class="docutils literal"><span class="pre">std::vector</span></tt> of <tt class="docutils literal"><span class="pre">Search</span></tt>es because we can nest our searches (i.e search differently in a subtree
using another <tt class="docutils literal"><span class="pre">phase</span></tt>/<tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>).
Here we take the current search (<tt class="docutils literal"><span class="pre">searches_.back()</span></tt>) and tell the solver that the search was initiated by a <tt class="docutils literal"><span class="pre">Solve()</span></tt>
call:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">searches_</span><span class="p">.</span><span class="n">back</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">set_created_by_solve</span><span class="p">(</span><span class="nb">true</span><span class="p">);</span>  <span class="c1">// Overwrites default.</span>
</pre></div>
</div>
<p>Indeed, the solver needs to know if it let you interfere during the search process or not.</p>
<p>You might wonder why there is only one call to <tt class="docutils literal"><span class="pre">NextSolution()</span></tt>? The reason is simple. If the search was initiated by the
caller (you) with the <tt class="docutils literal"><span class="pre">NewSearch()</span></tt> - <tt class="docutils literal"><span class="pre">NextSolution()</span></tt> - <tt class="docutils literal"><span class="pre">EndSearch()</span></tt> mechanism, the solver stops the search after
a <tt class="docutils literal"><span class="pre">NextSolution()</span></tt> call. If the search was initiated by a <tt class="docutils literal"><span class="pre">Solve()</span></tt> call, you tell the solver when to stop the search
with <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt>s. By default, the solver stops after the first solution found (if any). You can overwrite this
behaviour by implementing the <tt class="docutils literal"><span class="pre">AtSolution()</span></tt> callback of the <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt> class. If this method returns <tt class="docutils literal"><span class="pre">true</span></tt>, the
search continues, otherwise the solver ends it.</p>
</div>
<div class="section" id="the-basic-search-algorithm-and-the-callback-hooks-for-the-searchmonitors">
<span id="index-0"></span><h2>5.3.3. The basic search algorithm and the callback hooks for the <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt>s</h2>
<p><tt class="docutils literal"><span class="pre">SearchMonitor</span></tt>s contain a set of callbacks called on search tree events, such
as entering/exiting search, applying/refuting decisions, failing, accepting solutions...</p>
<p>In this section, we present the following callbacks of the <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt> class<a class="footnote-reference" href="#other-callbacks-searchmonitors" id="id4">[3]</a> and show you
exactly when they are called in the main search algorithm:</p>
<table border="1" class="docutils">
<caption>Basic search algorithm callbacks from the <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt> class.</caption>
<colgroup>
<col width="20%" />
<col width="80%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Methods</th>
<th class="head">Descriptions</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">EnterSearch()</span></tt></td>
<td>Beginning of the search.</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">ExitSearch()</span></tt></td>
<td>End of the search.</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">BeginNextDecision(DecisionBuilder*</span> <span class="pre">const</span> <span class="pre">b)</span></tt></td>
<td>Before calling <tt class="docutils literal"><span class="pre">DecisionBuilder::Next()</span></tt>.</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">EndNextDecision(DecisionBuilder*</span> <span class="pre">const</span> <span class="pre">b,</span> <span class="pre">Decision*</span> <span class="pre">const</span> <span class="pre">d)</span></tt></td>
<td>After calling <tt class="docutils literal"><span class="pre">DecisionBuilder::Next()</span></tt>, along with the returned decision.</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">ApplyDecision(Decision*</span> <span class="pre">const</span> <span class="pre">d)</span></tt></td>
<td>Before applying the <tt class="docutils literal"><span class="pre">Decision</span></tt>.</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">RefuteDecision(Decision*</span> <span class="pre">const</span> <span class="pre">d)</span></tt></td>
<td>Before refuting the <tt class="docutils literal"><span class="pre">Decision</span></tt>.</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">AfterDecision(Decision*</span> <span class="pre">const</span> <span class="pre">d,</span> <span class="pre">bool</span> <span class="pre">apply)</span></tt></td>
<td>Just after refuting or applying the <tt class="docutils literal"><span class="pre">Decision</span></tt>, <tt class="docutils literal"><span class="pre">apply</span></tt> is true after <tt class="docutils literal"><span class="pre">Apply()</span></tt>. This is called only if the <tt class="docutils literal"><span class="pre">Apply()</span></tt> or <tt class="docutils literal"><span class="pre">Refute()</span></tt> methods have <strong>not</strong> failed.</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">BeginFail()</span></tt></td>
<td>Just when the failure occurs.</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">EndFail()</span></tt></td>
<td>After completing the backtrack.</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">BeginInitialPropagation()</span></tt></td>
<td>Before the initial propagation.</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">EndInitialPropagation()</span></tt></td>
<td>After the initial propagation.</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">AcceptSolution()</span></tt></td>
<td>This method is called when a solution is found. It asserts if the solution is valid. A value of false indicates that the solution should be discarded.</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">AtSolution()</span></tt></td>
<td>This method is called when a valid solution is found. If the return value is true, then search will resume. If the result is false, then search will stop there.</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">NoMoreSolutions()</span></tt></td>
<td>When the search tree has been visited.</td>
</tr>
</tbody>
</table>
<br><table class="docutils footnote" frame="void" id="other-callbacks-searchmonitors" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[3]</a></td><td>There are a few more callbacks defined in a <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt>. See XXX.</td></tr>
</tbody>
</table>
<p>We draw again your attention to the fact that the algorithm shown here is
a simplified version of the search algorithm. In particular, we don&#8217;t show
how the nested searches and the restart of a search are implemented.
We find this so important that we reuse our warning box:</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">We describe a simplified version of the main loop of the search algorithm.</p>
</div>
<p>We use exceptions in our simplified version while the actual implementation uses
the more efficient (and cryptic) <tt class="docutils literal"><span class="pre">setjmp</span> <span class="pre">-</span> <span class="pre">longjmp</span></tt> mechanism.</p>
<p>We describe briefly what <em>nested searches</em> are in the section <a class="reference internal" href="basic_working_phases.html#nested-searches"><em>Nested searches</em></a> but you will have to wait until
the chapter <a class="reference internal" href="../under_the_hood.html#chapter-under-the-hood"><em>Under the hood</em></a> and the section <a class="reference internal" href="../under_the_hood/search.html#under-the-hood-nested-search"><em>Nested searches</em></a> to learn the juicy details<a class="footnote-reference" href="#wait-to-read-under-the-hood-nested-search" id="id5">[4]</a>.</p>
<table class="docutils footnote" frame="void" id="wait-to-read-under-the-hood-nested-search" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[4]</a></td><td>Of course, you can have a peak right now but some more background
will probably help you understand this mechanism better. Beside, you don&#8217;t need to understand the inner mechanism to
be able to use nested search!</td></tr>
</tbody>
</table>
<p>To follow the main search algorithm, it is best to know in what states the solver
can be. The <tt class="docutils literal"><span class="pre">enum</span></tt> <tt class="docutils literal"><span class="pre">SolverState</span></tt> enumerates the possibilities in the following table:</p>
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="74%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Value</th>
<th class="head">Meaning</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">OUTSIDE_SEARCH</span></tt></td>
<td>Before search, after search.</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">IN_ROOT_NODE</span></tt></td>
<td>Executing the root node.</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">IN_SEARCH</span></tt></td>
<td>Executing the search code.</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">AT_SOLUTION</span></tt></td>
<td>After successful <tt class="docutils literal"><span class="pre">NextSolution()</span></tt> and before <tt class="docutils literal"><span class="pre">EndSearch()</span></tt>.</td>
</tr>
<tr class="row-even"><td><tt class="docutils literal"><span class="pre">NO_MORE_SOLUTIONS</span></tt></td>
<td>After failed <tt class="docutils literal"><span class="pre">NextSolution()</span></tt> and before <tt class="docutils literal"><span class="pre">EndSearch()</span></tt>.</td>
</tr>
<tr class="row-odd"><td><tt class="docutils literal"><span class="pre">PROBLEM_INFEASIBLE</span></tt></td>
<td>After search, the model is infeasible.</td>
</tr>
</tbody>
</table>
<div class="section" id="newsearch">
<h3>5.3.3.1. <tt class="docutils literal"><span class="pre">NewSearch()</span></tt></h3>
<p>This is how the <tt class="docutils literal"><span class="pre">NewSearch()</span></tt> method might have looked in a simplified
version of the main search algorithm. The <tt class="docutils literal"><span class="pre">Search</span></tt> class is used
internally to monitor the search. Because the CP solver allows nested
searches, we take a pointer to the current search object each time we
call the <tt class="docutils literal"><span class="pre">NewSearch()</span></tt>, <tt class="docutils literal"><span class="pre">NextSolution()</span></tt> and <tt class="docutils literal"><span class="pre">EndSearch()</span></tt> methods.</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">void</span> <span class="n">Solver</span><span class="o">::</span><span class="n">NewSearch</span><span class="p">(</span><span class="n">DecisionBuilder</span><span class="o">*</span> <span class="k">const</span> <span class="n">db</span><span class="p">,</span>
                       <span class="n">SearchMonitor</span><span class="o">*</span> <span class="k">const</span> <span class="o">*</span> <span class="n">monitors</span><span class="p">,</span>
                       <span class="kt">int</span> <span class="n">size</span> <span class="p">{</span>

  <span class="n">Search</span><span class="o">*</span> <span class="k">const</span> <span class="n">search</span> <span class="o">=</span> <span class="n">searches_</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
  <span class="n">state_</span> <span class="o">=</span> <span class="n">OUTSIDE_SEARCH</span><span class="p">;</span>

  <span class="c1">// Init:</span>
  <span class="c1">// Install the main propagation monitor</span>
  <span class="c1">// Install DemonProfiler if needed</span>
  <span class="c1">// Install customer&#39;s SearchMonitors</span>
  <span class="c1">// Install DecisionBuilder&#39;s SearchMonitors</span>
  <span class="c1">// Install print trace if needed</span>
  <span class="p">...</span>

  <span class="n">search</span><span class="o">-&gt;</span><span class="n">EnterSearch</span><span class="p">();</span>  <span class="c1">// SEARCHMONITOR CALLBACK</span>

  <span class="c1">// Set decision builder.</span>
  <span class="n">search</span><span class="o">-&gt;</span><span class="n">set_decision_builder</span><span class="p">(</span><span class="n">db</span><span class="p">);</span>

  <span class="n">state_</span> <span class="o">=</span> <span class="n">IN_ROOT_NODE</span><span class="p">;</span>
  <span class="n">search</span><span class="o">-&gt;</span><span class="n">BeginInitialPropagation</span><span class="p">();</span>  <span class="c1">// SEARCHMONITOR CALLBACK</span>

  <span class="n">try</span> <span class="p">{</span>
    <span class="c1">//  Initial constraint propagation</span>
    <span class="n">ProcessConstraints</span><span class="p">();</span>
    <span class="n">search</span><span class="o">-&gt;</span><span class="n">EndInitialPropagation</span><span class="p">();</span>  <span class="c1">// SEARCHMONITOR CALLBACK</span>
    <span class="p">...</span>
    <span class="n">state_</span> <span class="o">=</span> <span class="n">IN_SEARCH</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">FailException</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">state_</span> <span class="o">=</span> <span class="n">PROBLEM_INFEASIBLE</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>The initialization part consists in installing the backtracking and
propagation mechanisms, the monitors and the print
trace if needed. If everything goes smoothly, the solver is in state
<tt class="docutils literal"><span class="pre">IN_SEARCH</span></tt>.</p>
</div>
<div class="section" id="nextsolution">
<h3>5.3.3.2. <tt class="docutils literal"><span class="pre">NextSolution()</span></tt></h3>
<p>The <tt class="docutils literal"><span class="pre">NextSolution()</span></tt> method returns <tt class="docutils literal"><span class="pre">true</span></tt> if if finds the next solution,
<tt class="docutils literal"><span class="pre">false</span></tt> otherwise. Notice that the statistics are not reset whatsoever from one call of <tt class="docutils literal"><span class="pre">NextSolution()</span></tt>
to the next one.</p>
<p>We present and discuss this algorithm below. <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt>&#8216;s callbacks are indicated by the
comment:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// SEARCHMONITOR CALLBACK</span>
</pre></div>
</div>
<p>Here is how it might have looked in a simplified version of the main search
algorithm:</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">bool</span> <span class="n">Solver</span><span class="o">::</span><span class="n">NextSolution</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Search</span><span class="o">*</span> <span class="k">const</span> <span class="n">search</span> <span class="o">=</span> <span class="n">searches_</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
  <span class="n">Decision</span><span class="o">*</span> <span class="n">fd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span><span class="c1">//  failed decision</span>

  <span class="c1">//  Take action following solver state</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">state_</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">PROBLEM_INFEASIBLE</span>:
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">NO_MORE_SOLUTIONS</span>:
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">AT_SOLUTION</span>: <span class="p">{</span><span class="c1">//  We need to backtrack</span>
      <span class="c1">// SEARCHMONITOR CALLBACK</span>
      <span class="c1">//  BacktrackOneLevel() calls search-&gt;EndFail()</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">BacktrackOneLevel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fd</span><span class="p">))</span> <span class="p">{</span><span class="c1">// No more solutions.</span>
        <span class="n">search</span><span class="o">-&gt;</span><span class="n">NoMoreSolutions</span><span class="p">();</span><span class="c1">// SEARCHMONITOR CALLBACKS</span>
        <span class="n">state_</span> <span class="o">=</span> <span class="n">NO_MORE_SOLUTIONS</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">state_</span> <span class="o">=</span> <span class="n">IN_SEARCH</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="n">OUTSIDE_SEARCH</span>: <span class="p">{</span>
      <span class="n">state_</span> <span class="o">=</span> <span class="n">IN_ROOT_NODE</span><span class="p">;</span>
      <span class="n">search</span><span class="o">-&gt;</span><span class="n">BeginInitialPropagation</span><span class="p">();</span><span class="c1">// SEARCHMONITOR CALLBACKS</span>
      <span class="n">try</span> <span class="p">{</span>
        <span class="n">ProcessConstraints</span><span class="p">();</span>
        <span class="n">search</span><span class="o">-&gt;</span><span class="n">EndInitialPropagation</span><span class="p">();</span><span class="c1">// SEARCHMONITOR CALLBACKS</span>
        <span class="p">...</span>
        <span class="n">state_</span> <span class="o">=</span> <span class="n">IN_SEARCH</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">catch</span><span class="p">(</span><span class="k">const</span> <span class="n">FailException</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
        <span class="n">state_</span> <span class="o">=</span> <span class="n">PROBLEM_INFEASIBLE</span><span class="p">;</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">case</span> <span class="n">IN_SEARCH</span>:
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">DecisionBuilder</span><span class="o">*</span> <span class="k">const</span> <span class="n">db</span> <span class="o">=</span> <span class="n">search</span><span class="o">-&gt;</span><span class="n">decision_builder</span><span class="p">();</span>

  <span class="c1">//  MAIN SEARCH LOOP TO FIND THE NEXT SOLUTION IF ANY</span>
  <span class="k">volatile</span> <span class="kt">bool</span> <span class="n">finish</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="k">volatile</span> <span class="kt">bool</span> <span class="n">result</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">finish</span><span class="p">)</span> <span class="p">{</span><span class="c1">//  Try to find next solution</span>
    <span class="n">try</span> <span class="p">{</span>
      <span class="c1">//  Explore right branch of the tree on backtrack</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">fd</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span><span class="c1">//  We have a right branch</span>
        <span class="p">...</span>
        <span class="n">search</span><span class="o">-&gt;</span><span class="n">RefuteDecision</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span><span class="c1">// SEARCHMONITOR CALLBACK</span>
        <span class="n">fd</span><span class="o">-&gt;</span><span class="n">Refute</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
        <span class="n">search</span><span class="o">-&gt;</span><span class="n">AfterDecision</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span><span class="c1">// SEARCHMONITOR CALLBACK</span>
        <span class="p">...</span>
        <span class="n">fd</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="c1">//  Explore left branches of the tree</span>
      <span class="n">Decision</span><span class="o">*</span> <span class="n">d</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">;</span>
      <span class="c1">//  Go left as often as possible</span>
      <span class="k">while</span> <span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span><span class="c1">// Trying to branch left</span>
        <span class="n">search</span><span class="o">-&gt;</span><span class="n">BeginNextDecision</span><span class="p">(</span><span class="n">db</span><span class="p">);</span><span class="c1">// SEARCHMONITOR CALLBACK</span>
        <span class="n">d</span> <span class="o">=</span> <span class="n">db</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
        <span class="n">search</span><span class="o">-&gt;</span><span class="n">EndNextDecision</span><span class="p">(</span><span class="n">db</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span><span class="c1">// SEARCHMONITOR CALLBACK</span>
        <span class="c1">//  Dead-end? This is a shortcut</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">==</span> <span class="n">fail_decision_</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">search</span><span class="o">-&gt;</span><span class="n">BeginFail</span><span class="p">();</span><span class="c1">// SEARCHMONITOR CALLBACK</span>
          <span class="c1">// fail now instead of after 2 branches.</span>
          <span class="k">throw</span> <span class="nf">FailException</span><span class="p">();</span>
        <span class="p">}</span>
        <span class="c1">//  Explore next left branch of the tree</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">search</span><span class="o">-&gt;</span><span class="n">ApplyDecision</span><span class="p">(</span><span class="n">d</span><span class="p">);</span><span class="c1">// SEARCHMONITOR CALLBACK</span>
          <span class="n">d</span><span class="o">-&gt;</span><span class="n">Apply</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>
          <span class="n">search</span><span class="o">-&gt;</span><span class="n">AfterDecision</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span><span class="c1">// SEARCHMONITOR CALLBACK</span>
          <span class="p">...</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span><span class="c1">//  No Decision left, the DecisionBuilder has finished</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span><span class="c1">//  while (true)</span>

      <span class="c1">//  We can not go further left... test Solution</span>
      <span class="c1">// SEARCHMONITOR CALLBACK</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">search</span><span class="o">-&gt;</span><span class="n">AcceptSolution</span><span class="p">())</span> <span class="p">{</span><span class="c1">//  Accept Solution</span>
        <span class="c1">// SEARCHMONITOR CALLBACK</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">search</span><span class="o">-&gt;</span><span class="n">AtSolution</span><span class="p">()</span> <span class="o">||</span> <span class="o">!</span><span class="n">CurrentlyInSolve</span><span class="p">())</span> <span class="p">{</span>
          <span class="n">result</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
          <span class="n">finish</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
          <span class="n">search</span><span class="o">-&gt;</span><span class="n">BeginFail</span><span class="p">();</span><span class="c1">// SEARCHMONITOR CALLBACK</span>
          <span class="k">throw</span> <span class="nf">FailException</span><span class="p">();</span>
        <span class="p">}</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">search</span><span class="o">-&gt;</span><span class="n">BeginFail</span><span class="p">();</span><span class="c1">// SEARCHMONITOR CALLBACK</span>
        <span class="k">throw</span> <span class="nf">FailException</span><span class="p">();</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">FailException</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">//  We must backtrack</span>
      <span class="c1">//  SEARCHMONITOR CALLBACK</span>
      <span class="c1">//  BacktrackOneLevel() calls search-&gt;EndFail()</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">BacktrackOneLevel</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fd</span><span class="p">))</span> <span class="p">{</span>  <span class="c1">// no more solutions.</span>
        <span class="n">search</span><span class="o">-&gt;</span><span class="n">NoMoreSolutions</span><span class="p">();</span><span class="c1">// SEARCHMONITOR CALLBACK</span>
        <span class="n">result</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
        <span class="n">finish</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
       <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span><span class="c1">//  while (!finish)</span>

  <span class="c1">//  Set solver current state</span>
  <span class="p">...</span>
  <span class="n">state_</span> <span class="o">=</span> <span class="p">...;</span>

  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>Let&#8217;s dissect the algorithm. First of all, you might wonder where does the propagation take place?
In a few words: <tt class="docutils literal"><span class="pre">Constraint</span></tt>s are responsible of attaching
<tt class="docutils literal"><span class="pre">Demon</span></tt>s to variables. These <tt class="docutils literal"><span class="pre">Demon</span></tt>s are on their turn responsible for implementing the
actual propagation. Whenever the domain of a variable changes, the corresponding <tt class="docutils literal"><span class="pre">Demon</span></tt>s are
triggered. In the main search algorithm, this happens twice: when we <tt class="docutils literal"><span class="pre">Apply()</span></tt> a <tt class="docutils literal"><span class="pre">Decision</span></tt> (line 75)
and when we <tt class="docutils literal"><span class="pre">Refute()</span></tt> a <tt class="docutils literal"><span class="pre">Decision</span></tt> (line 53).</p>
<p>Back to the algorithm. On line 2, the solver grabs the last search. Indeed, several searches can be nested
and queued.</p>
<p>The <tt class="docutils literal"><span class="pre">Search</span></tt> object is responsible of monitoring the search for one <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> (one phase) and triggers
the callbacks of the installed <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt>s at the right moments.</p>
<p>Following the solver&#8217;s state, some action  is needed (see lines 6-39). The case <tt class="docutils literal"><span class="pre">AT_SOLUTION</span></tt> is worth
an explanation. <tt class="docutils literal"><span class="pre">NextSolution()</span></tt> was called and the solver found a feasible solution.
The solver thus needs to backtrack (method <tt class="docutils literal"><span class="pre">BacktrackOneLevel()</span></tt> on line 14).
If a right branch exists, it is stored in the
<tt class="docutils literal"><span class="pre">Decision</span></tt> pointer <tt class="docutils literal"><span class="pre">fd</span></tt> (failed decision) and <tt class="docutils literal"><span class="pre">BacktrackOneLevel()</span></tt> returns <tt class="docutils literal"><span class="pre">false</span></tt>.
If there are no more right branches
to visit, the search tree has been exhausted and the method returns <tt class="docutils literal"><span class="pre">true</span></tt>. Next, the
corresponding <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> to the current search is kept on line 41.</p>
<p>We are now inside the main loop of the <tt class="docutils literal"><span class="pre">NextSolution()</span></tt> method. Two Boolean variables are defined<a class="footnote-reference" href="#two-bool-variables-playing-another-roles" id="id6">[5]</a></p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">finish</span></tt>: becomes <tt class="docutils literal"><span class="pre">true</span></tt> when the search is over;</li>
<li><tt class="docutils literal"><span class="pre">result</span></tt>: denotes if a feasible solution was indeed found or not.</li>
</ul>
</div></blockquote>
<p>These two variables are declared <tt class="docutils literal"><span class="pre">volatile</span></tt> to allow their use between <tt class="docutils literal"><span class="pre">setjmp</span></tt> and <tt class="docutils literal"><span class="pre">longjmp</span></tt>,
otherwise the compiler
might optimize certain portions of code away. Basically, it tells the compiler that these
variables can be changed from the <em>outside</em>.</p>
<table class="docutils footnote" frame="void" id="two-bool-variables-playing-another-roles" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[5]</a></td><td>These two variables play a role when
we use nested searches, restart or finish a search
but these possibilities are not shown here.</td></tr>
</tbody>
</table>
<p>This main loop starts at line 47 and ends at line 108.</p>
<p>The <tt class="docutils literal"><span class="pre">try</span> <span class="pre">-</span> <span class="pre">catch</span></tt> mechanism allows to easily explain the backtrack mechanism. Whenever we need to backtrack in the search, a
<tt class="docutils literal"><span class="pre">FailException</span></tt> is thrown<a class="footnote-reference" href="#try-catch-not-used" id="id7">[6]</a>.</p>
<table class="docutils footnote" frame="void" id="try-catch-not-used" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[6]</a></td><td>Did we already mention that the <tt class="docutils literal"><span class="pre">try</span> <span class="pre">-</span> <span class="pre">catch</span></tt> mechanism is <em>not</em> used in the production
code? ;-)</td></tr>
</tbody>
</table>
<p>If the <tt class="docutils literal"><span class="pre">Decision</span></tt> pointer <tt class="docutils literal"><span class="pre">fd</span></tt> is not <tt class="docutils literal"><span class="pre">NULL</span></tt>, this means that we have backtracked to the first available (non visited)
right branch in the search tree. This corresponds to refuting the decision (lines 50-57).</p>
<p>The solver now tries to explore as much as possible left branches and this is done in the <tt class="docutils literal"><span class="pre">while</span></tt> loop (line 62-81).</p>
<p>The <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> produces its next <tt class="docutils literal"><span class="pre">Decision</span></tt> on line 64. If it detects that this branch is a dead-end, it is allowed
to return a <tt class="docutils literal"><span class="pre">FailDecision</span></tt> which the solver tests at line 67.</p>
<p>If the search tree is empty, the <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> returns <tt class="docutils literal"><span class="pre">NULL</span></tt>. The solver tests this possibility on line 73. If the
<tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> found a next <tt class="docutils literal"><span class="pre">Decision</span></tt>, it is applied on line 75.</p>
<p>Whenever the solver cannot find a next left branch to explore, it exits the <tt class="docutils literal"><span class="pre">while(true)</span></tt> loop.</p>
<p>We are now ready to test if we have found a feasible solution at the leaf of a left branch.
This test is done one line 85. The
method <tt class="docutils literal"><span class="pre">AcceptSolution()</span></tt> decides if the <em>solution</em> is feasible or not.
After finding a feasible solution, the method <tt class="docutils literal"><span class="pre">AtSolution()</span></tt>
decides if we continue or stop the search.</p>
<p>You might recognize these two methods as callbacks of a <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt>.
These two methods call the corresponding methods of <strong>all</strong> installed <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt>s no
matter what they return, i.e. you are guaranteed that all <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt>s will be called.
If one <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt> has its method <tt class="docutils literal"><span class="pre">AcceptSolution()</span></tt> returning <tt class="docutils literal"><span class="pre">false</span></tt>,
<tt class="docutils literal"><span class="pre">search-&gt;AcceptSolution()</span></tt> returns <tt class="docutils literal"><span class="pre">false</span></tt>. On the
contrary, if only one <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt> has its <tt class="docutils literal"><span class="pre">AtSolution()</span></tt> method returning <tt class="docutils literal"><span class="pre">true</span></tt>, <tt class="docutils literal"><span class="pre">search-&gt;AtSolution()</span></tt> returns true.</p>
<p>The test on line 87 is a little bit complex:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">test</span> <span class="o">=</span> <span class="o">!</span><span class="n">search</span><span class="o">-&gt;</span><span class="n">AtSolution</span><span class="p">()</span> <span class="o">||</span> <span class="o">!</span><span class="n">CurrentlyInSolve</span><span class="p">()</span>
</pre></div>
</div>
<p>Remember that <tt class="docutils literal"><span class="pre">AtSolution()</span></tt> returns <tt class="docutils literal"><span class="pre">true</span></tt> if we want to resume the search (i.e. if at least one
<tt class="docutils literal"><span class="pre">SearchMonitor-&gt;AtSolution()</span></tt> returns <tt class="docutils literal"><span class="pre">true</span></tt>),
<tt class="docutils literal"><span class="pre">false</span></tt> otherwise. <tt class="docutils literal"><span class="pre">CurrentlyInSolve()</span></tt> returns
<tt class="docutils literal"><span class="pre">true</span></tt> if the solve process was called with the <tt class="docutils literal"><span class="pre">Solve()</span></tt> method and <tt class="docutils literal"><span class="pre">false</span></tt> if it was called with the <tt class="docutils literal"><span class="pre">NextSolution()</span></tt>
method.</p>
<p>Thus, <tt class="docutils literal"><span class="pre">test</span></tt> is <tt class="docutils literal"><span class="pre">true</span></tt> (and we stop the search in <tt class="docutils literal"><span class="pre">NextSolution()</span></tt>) if <strong>all</strong> <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt>s decided to stop the search
(<tt class="docutils literal"><span class="pre">search-&gt;AtSolution()</span></tt> returns then <tt class="docutils literal"><span class="pre">false</span></tt>) or if at least one <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt> decided to continue but
the solve process was
called by <tt class="docutils literal"><span class="pre">NextSolution()</span></tt>. Indeed, a user expects <tt class="docutils literal"><span class="pre">NextSolution()</span></tt> to stop whenever it encounters a feasible solution.</p>
<p>Whenever a backtrack is necessary, a <tt class="docutils literal"><span class="pre">FailException</span></tt> is caught and the solver backtracks to the next available right branch if possible.</p>
<p>Finally, the current state of the solver is set and the method <tt class="docutils literal"><span class="pre">NextSolution()</span></tt> returns if a solution has been found
and accepted by <strong>all</strong> <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt>s or there is no solution anymore. It then returns <tt class="docutils literal"><span class="pre">true</span></tt> if the <tt class="docutils literal"><span class="pre">test</span></tt> above
is <tt class="docutils literal"><span class="pre">true</span></tt>, <tt class="docutils literal"><span class="pre">false</span></tt> otherwise.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">A solution is defined as a leaf of the search tree with respect to the given <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>
for which there is no failure. What this means is that, contrary to
intuition, a solution may not have all variables of the model bound. It is
the responsibility of the <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> to keep returning decisions
until all variables are indeed bound. The most extreme counterexample is
calling <tt class="docutils literal"><span class="pre">Solve()</span></tt> with a trivial <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> whose <tt class="docutils literal"><span class="pre">Next()</span></tt> method always
returns <tt class="docutils literal"><span class="pre">NULL</span></tt>. In this case, <tt class="docutils literal"><span class="pre">Solve()</span></tt> immediately returns <tt class="docutils literal"><span class="pre">true</span></tt>, since not
assigning any variable to any value is a solution, unless the root node
propagation discovers that the model is infeasible.</p>
</div>
</div>
<div class="section" id="endsearch">
<h3>5.3.3.3. <tt class="docutils literal"><span class="pre">EndSearch()</span></tt></h3>
<p>The <tt class="docutils literal"><span class="pre">EndSearch()</span></tt> method <em>cleans</em> the solver and if required, writes the profile of the search
in a file. It also calls the <tt class="docutils literal"><span class="pre">ExitSearch()</span></tt> callbacks of all installed <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt>s.</p>
<p>Here is how it might have looked in a simplified version of the main search
algorithm.</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">void</span> <span class="n">Solver</span><span class="o">::</span><span class="n">EndSearch</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Search</span><span class="o">*</span> <span class="k">const</span> <span class="n">search</span> <span class="o">=</span> <span class="n">searches_</span><span class="p">.</span><span class="n">back</span><span class="p">();</span>
  <span class="p">...</span>
  <span class="n">search</span><span class="o">-&gt;</span><span class="n">ExitSearch</span><span class="p">();</span><span class="c1">// SEARCHMONITOR CALLBACK</span>
  <span class="n">search</span><span class="o">-&gt;</span><span class="n">Clear</span><span class="p">();</span>
  <span class="n">state_</span> <span class="o">=</span> <span class="n">OUTSIDE_SEARCH</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">FLAGS_cp_profile_file</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">LOG</span><span class="p">(</span><span class="n">INFO</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Exporting profile to &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">FLAGS_cp_profile_file</span><span class="p">;</span>
    <span class="n">ExportProfilingOverview</span><span class="p">(</span><span class="n">FLAGS_cp_profile_file</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<table>
<tr>
<td width="60"><img src="../../_static/logo.png" width="50" height="50"  alt="" /></td>
<td><p class="library_name">Google <a href="http://code.google.com/p/or-tools/"><strong>or-tools</strong></a><br>open source library</p></td>
</tr>
</table>
<h1>User's Manual</h1>

  
   



<h3>Google search</h3>

<form method="get" action="http://www.google.com/search">

<div style="padding:-1px;width:15em;">
<table border="0" cellpadding="0">
<tr><td>
<input type="text"   name="q" size="25"
 maxlength="255" value="" />
<input type="submit" value="Go" /></td></tr>
<tr><td align="center" style="font-size:80%">
Search:
<select name="sitesearch" width="125" style="width: 125px">
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/user_manual/" selected>user's manual</option>
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/faq/">faq</option>
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/reference_manual/or-tools/">reference manual</option>
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/">All or-tools doc</option>
</select>
</td></tr>
</table>
</div>

</form>
</br>




  <h3>Welcome</h3>
  
  <ul>
  	<li><a href="../../index.html">Content and foreword</a></li>
  	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html">Documentation's hub</a></li>
	<li><a href="http://code.google.com/p/or-tools/">The or-tools open source library</a></li></li>	
  </ul>
  
   
	


  <h3>Tutorial examples</h3>
  
  <ul>
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_C++">C++</a></li>
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_Python">Python</a></li>	
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_Java">Java</a></li>
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_Csharp">C#</a></li>
</ul>
  
   
	

  <h3>Current chapter</h3>
  <p class="topless"><a href="../search_primitives.html"
                        title="previous chapter">5. Defining search primitives: the n-queens problem</a></p>
  <h3>Previous section</h3>
  <p class="topless"><a href="basic_model_implementation.html"
                        title="previous chapter">5.2. Implementation of the basic model</a></p>
  <h3>Next section</h3>
  <p class="topless"><a href="cpviz.html"
                        title="next chapter">5.4. <strong class="program">cpviz</strong>: how to visualize the search</a></p>
  <h3>Current section</a></h3>
  <ul>
<li><a class="reference internal" href="#">5.3. Basic working of the solver: the search algorithm</a><ul>
<li><a class="reference internal" href="#basic-definitions">5.3.1. Basic definitions</a><ul>
<li><a class="reference internal" href="#search-trees">5.3.1.1. Search trees</a></li>
<li><a class="reference internal" href="#callbacks">5.3.1.2. Callbacks</a></li>
<li><a class="reference internal" href="#phases">5.3.1.3. Phases</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-basic-idea">5.3.2. The basic idea</a></li>
<li><a class="reference internal" href="#the-basic-search-algorithm-and-the-callback-hooks-for-the-searchmonitors">5.3.3. The basic search algorithm and the callback hooks for the <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt>s</a><ul>
<li><a class="reference internal" href="#newsearch">5.3.3.1. <tt class="docutils literal"><span class="pre">NewSearch()</span></tt></a></li>
<li><a class="reference internal" href="#nextsolution">5.3.3.2. <tt class="docutils literal"><span class="pre">NextSolution()</span></tt></a></li>
<li><a class="reference internal" href="#endsearch">5.3.3.3. <tt class="docutils literal"><span class="pre">EndSearch()</span></tt></a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="cpviz.html" title="5.4. cpviz: how to visualize the search"
             >next</a> |</li>
        <li class="right" >
          <a href="basic_model_implementation.html" title="5.2. Implementation of the basic model"
             >previous</a> |</li>
        <li><a href="../../index.html">or-tools User&#39;s Manual</a> &raquo;</li>
          <li><a href="../search_primitives.html" >5. Defining search primitives: the n-queens problem</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012-2014, Google.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>