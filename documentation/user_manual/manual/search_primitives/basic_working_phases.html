

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>5.5. Basic working of the solver: the phases &mdash; or-tools User&#39;s Manual</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     'doc version 0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../_static/logo.ico"/>
    <link rel="top" title="or-tools User&#39;s Manual" href="../../index.html" />
    <link rel="up" title="5. Defining search primitives: the n-Queens Problem" href="../search_primitives.html" />
    <link rel="next" title="5.6. Out of the box variables and values selection primitives" href="out_of_the_box_search_primitives.html" />
    <link rel="prev" title="5.4. cpviz: how to visualize the search" href="cpviz.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="out_of_the_box_search_primitives.html" title="5.6. Out of the box variables and values selection primitives"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="cpviz.html" title="5.4. cpviz: how to visualize the search"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">or-tools User&#39;s Manual</a> &raquo;</li>
          <li><a href="../search_primitives.html" accesskey="U">5. Defining search primitives: the n-Queens Problem</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="basic-working-of-the-solver-the-phases">
<span id="basic-working-phases"></span><h1>5.5. Basic working of the solver: the phases</h1>
<p>A <strong>phase</strong> corresponds to a type of (sub)search in the search tree<a class="footnote-reference" href="#phase-not-really-search" id="id1">[1]</a>. You can have several phases/searches in your quest
to find a feasible or optimal solution. In <em>or-tools</em>, a phase is constructed by and corresponds to a <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>.</p>
<table class="docutils footnote" frame="void" id="phase-not-really-search" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Well, sort of. Read on!</td></tr>
</tbody>
</table>
<p>We postpone the discussion on the <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>s and <tt class="docutils literal"><span class="pre">Decision</span></tt>s for scheduling until the
dedicated subsection
<a class="reference internal" href="../ls/scheduling_or_tools.html#scheduling-decisionbuilders-decision"><em>DecisionBuilders and Decisions for scheduling</em></a> in the next chapter.</p>
<p>To better understand how phases and <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>s work, we will implement our own <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>
and <tt class="docutils literal"><span class="pre">Decision</span></tt> classes in the section <a class="reference internal" href="customized_search_primitives.html#customized-search-primitives"><em>Customized search primitives</em></a>.
In this section, we show you how to use these primitives and some very basic examples<a class="footnote-reference" href="#all-decision-builders-hidden" id="id2">[2]</a>.</p>
<table class="docutils footnote" frame="void" id="all-decision-builders-hidden" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>s and <tt class="docutils literal"><span class="pre">Decision</span></tt>s are used internally and
you cannot access them directly. To use them, invoke the corresponding factory methods.</td></tr>
</tbody>
</table>
<div class="section" id="decisionbuilders-and-phases">
<span id="decision-builders-and-phases"></span><h2>5.5.1. <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>s and phases</h2>
<p><tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>s
(combined with <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt>s) are responsible of directing the search at the current node
in the search tree. The <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> class controls the search through its
main <tt class="docutils literal"><span class="pre">Next()</span></tt> method:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">virtual</span> <span class="n">Decision</span><span class="o">*</span> <span class="n">Next</span><span class="p">(</span><span class="n">Solver</span><span class="o">*</span> <span class="k">const</span> <span class="n">s</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>It is a pure virtual method, so it <strong>must</strong> be implemented in all derived <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> classes.</p>
<p>To notify the solver that the <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> has finished its job at the current node, let <tt class="docutils literal"><span class="pre">Next()</span></tt> return
<tt class="docutils literal"><span class="pre">NULL</span></tt>. The solver will then
pass the control to the next available <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> or stop the search at this node if there are no more
<tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>s left to deal with it.</p>
<p>We use <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>s
in two scenarios<a class="footnote-reference" href="#decision-builders-two-scenarios" id="id3">[3]</a>:</p>
<table class="docutils footnote" frame="void" id="decision-builders-two-scenarios" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>One could argue that these two scenarios are not really mutually exclusive.
Indeed, we divide the scenarios in two cases depending on whether the <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> returns a <tt class="docutils literal"><span class="pre">Decision</span></tt>
or not. Some <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>s delegate the creation process of <tt class="docutils literal"><span class="pre">Decision</span></tt>s to other <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>s.</td></tr>
</tbody>
</table>
<ol class="arabic">
<li><p class="first">The basic scenario is to
divide the search sub-tree in two (preferably non overlapping) search sub-trees. To do so, the <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>
returns a (pointer to a) <tt class="docutils literal"><span class="pre">Decision</span></tt> through its <tt class="docutils literal"><span class="pre">Next()</span></tt> method.</p>
<p>The <tt class="docutils literal"><span class="pre">Decision</span></tt> class tells the solver what to do on the left branch
(through its <tt class="docutils literal"><span class="pre">Apply()</span></tt> method) and the right branch (through its <tt class="docutils literal"><span class="pre">Refute()</span></tt> method).</p>
<p>Some available <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>s that divide the search sub-tree in two are:</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">BaseAssignVariables</span></tt>: the main <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> for <tt class="docutils literal"><span class="pre">IntVar</span></tt>s. It&#8217;s the basic <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>
used for assigning values to <tt class="docutils literal"><span class="pre">IntVar</span></tt> variables. When you invoke:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">DecisionBuilder</span> <span class="o">*</span> <span class="k">const</span> <span class="n">db</span> <span class="o">=</span> <span class="n">MakePhase</span><span class="p">(</span><span class="n">vars</span><span class="p">,</span>
                                <span class="n">Solver</span><span class="o">::</span><span class="n">CHOOSE_FIRST_UNBOUND</span><span class="p">,</span>
                                <span class="n">Solver</span><span class="o">::</span><span class="n">ASSIGN_MIN_VALUE</span><span class="p">);</span>
</pre></div>
</div>
<p>the returned (pointer to a) <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> object is a (pointer to a)
<tt class="docutils literal"><span class="pre">BaseAssignVariables</span></tt> object. See the subsection <a class="reference internal" href="#makephase-int-vars"><em>The MakePhase() method more in details</em></a> below.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">AssignVariablesFromAssignment</span></tt>: assigns values to variables from an <tt class="docutils literal"><span class="pre">Assignment</span></tt> and if needed passes the hand
to another <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> to continue the search. The factory method to create this <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> is
<tt class="docutils literal"><span class="pre">MakeDecisionBuilderFromAssignment()</span></tt>.</p>
</li>
<li><p class="first">...</p>
</li>
</ul>
<br><br></li>
<li><p class="first">A <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>
doesn&#8217;t have to split the search sub-tree in two: it can collect data about the search, modify the model, etc.
It also can solve the sub-tree with the help of other <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>s and allow for <em>nested searches</em>.</p>
<p>In this case, take the appropriate action in the <tt class="docutils literal"><span class="pre">Next()</span></tt> method and return <tt class="docutils literal"><span class="pre">NULL</span></tt> to notify the solver that
the <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> has finished its work at the current node.</p>
<p>Some examples of available <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>s that do some stuff at a node without splitting the search sub-tree
in two:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">StoreAssignment</span></tt> and <tt class="docutils literal"><span class="pre">RestoreAssignment</span></tt>: respectively store and restore <tt class="docutils literal"><span class="pre">Assignment</span></tt>s during the search.</li>
<li><tt class="docutils literal"><span class="pre">AddConstraintDecisionBuilder</span></tt>: adds a <tt class="docutils literal"><span class="pre">Constraint</span></tt> during the search.</li>
<li><tt class="docutils literal"><span class="pre">ApplyBranchSelector</span></tt>: changes the way the branches are selected. For instance, the left branch can become the right
branch and vice-versa. Have a look at the <tt class="docutils literal"><span class="pre">Solver::DecisionModification</span></tt> <tt class="docutils literal"><span class="pre">enum</span></tt> for more.</li>
<li><tt class="docutils literal"><span class="pre">LocalSearch</span></tt>: applies local search operators to find a solution.</li>
<li><tt class="docutils literal"><span class="pre">SolveOnce</span></tt>: stops the search as soon as it finds a solution with the help of another <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>.</li>
<li><tt class="docutils literal"><span class="pre">NestedOptimize</span></tt>: optimizes the search sub-tree with the help of another <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>.</li>
<li>...</li>
</ul>
</li>
</ol>
<p>For your (and our) convenience, three more methods can be implemented:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">virtual</span> <span class="pre">void</span> <span class="pre">AppendMonitors(Solver*</span> <span class="pre">const</span> <span class="pre">solver,</span> <span class="pre">std::vector&lt;SearchMonitor*&gt;*</span> <span class="pre">const</span> <span class="pre">extras)</span></tt>: to
add some extra <tt class="docutils literal"><span class="pre">SearchMonitors</span></tt> at the beginning of the search. Please note there are no
checks at this point for duplication.</li>
<li><tt class="docutils literal"><span class="pre">virtual</span> <span class="pre">string</span> <span class="pre">DebugString()</span> <span class="pre">const</span></tt>: the usual <tt class="docutils literal"><span class="pre">DebugString()</span></tt> method to give a name to your object.</li>
<li><tt class="docutils literal"><span class="pre">virtual</span> <span class="pre">void</span> <span class="pre">Accept(ModelVisitor*</span> <span class="pre">const</span> <span class="pre">visitor)</span> <span class="pre">const</span></tt>: the usual <tt class="docutils literal"><span class="pre">Accept()</span></tt> method to let you visit the model and take
appropriate actions.</li>
</ul>
</div>
<div class="section" id="decisions-and-decisionvisitors">
<span id="decisions"></span><h2>5.5.2. <tt class="docutils literal"><span class="pre">Decision</span></tt>s and <tt class="docutils literal"><span class="pre">DecisionVisitor</span></tt>s</h2>
<p>The <tt class="docutils literal"><span class="pre">Decision</span></tt> class together with the <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> class implement the <em>branching rules</em> of the search, i.e. how to branch (or divide the search sub-tree)
at a given node in the
search tree. Although a <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> could return several types of <tt class="docutils literal"><span class="pre">Decision</span></tt>s during a search,
we recommend to stick to
one <tt class="docutils literal"><span class="pre">Decision</span></tt> for a <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> per phase.</p>
<p><tt class="docutils literal"><span class="pre">DecisionVisitor</span></tt>s is a class whose methods are triggered just before a <tt class="docutils literal"><span class="pre">Decision</span></tt> is applied. Your are
notified of the concrete decision that will be applied and are thus able to take action.</p>
<div class="section" id="id4">
<h3>5.5.2.1. <tt class="docutils literal"><span class="pre">Decision</span></tt>s</h3>
<p>The <tt class="docutils literal"><span class="pre">Decision</span></tt> class is responsible to tell the solver what to do on left branches through its <tt class="docutils literal"><span class="pre">Apply()</span></tt>
method:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">virtual</span> <span class="kt">void</span> <span class="n">Apply</span><span class="p">(</span><span class="n">Solver</span><span class="o">*</span> <span class="k">const</span> <span class="n">s</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>and the right branch through its <tt class="docutils literal"><span class="pre">Refute()</span></tt> method:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">virtual</span> <span class="kt">void</span> <span class="n">Refute</span><span class="p">(</span><span class="n">Solver</span><span class="o">*</span> <span class="k">const</span> <span class="n">s</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>These two pure virtual  methods <strong>must</strong> be implemented in every <tt class="docutils literal"><span class="pre">Decision</span></tt> class.</p>
<p>A <tt class="docutils literal"><span class="pre">Decision</span></tt> object is returned by a <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>
through its <tt class="docutils literal"><span class="pre">Next()</span></tt> method.</p>
<p>Two more methods can be implemented:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">virtual</span> <span class="pre">string</span> <span class="pre">DebugString()</span> <span class="pre">const</span></tt>: the usual <tt class="docutils literal"><span class="pre">DebugString()</span></tt> method.</li>
<li><tt class="docutils literal"><span class="pre">virtual</span> <span class="pre">void</span> <span class="pre">Accept(DecisionVisitor*</span> <span class="pre">const</span> <span class="pre">visitor)</span> <span class="pre">const</span></tt>: accepts the given visitor.</li>
</ul>
<p>Several <tt class="docutils literal"><span class="pre">Decision</span></tt> classes are available. We enumerate the different strategies
implemented by the available <tt class="docutils literal"><span class="pre">Decision</span></tt> classes dealing with
<tt class="docutils literal"><span class="pre">IntVar</span></tt>s in the next section. In the next subsection, we detail a basic example.</p>
</div>
<div class="section" id="assignonevariablevalue-as-an-example">
<h3>5.5.2.2. <tt class="docutils literal"><span class="pre">AssignOneVariableValue</span></tt> as an example</h3>
<p>An obvious choice for a <tt class="docutils literal"><span class="pre">Decision</span></tt> class for <tt class="docutils literal"><span class="pre">IntVar</span></tt>s is probably <tt class="docutils literal"><span class="pre">AssignOneVariableValue</span></tt>.
This class assigns
a value to a variable in the left branch and forbids this assignment in the right branch.</p>
<p>The constructor takes the variable to branch on and the value to assign to it:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">AssignOneVariableValue</span><span class="p">(</span><span class="n">IntVar</span><span class="o">*</span> <span class="k">const</span> <span class="n">v</span><span class="p">,</span> <span class="n">int64</span> <span class="n">val</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">var_</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">value_</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">var_</span></tt> and <tt class="docutils literal"><span class="pre">value_</span></tt> are local <tt class="docutils literal"><span class="pre">private</span></tt> copies of the variable and the value.</p>
<p>The <tt class="docutils literal"><span class="pre">Apply()</span></tt> and <tt class="docutils literal"><span class="pre">Refute()</span></tt> methods are straithforward:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">Apply</span><span class="p">(</span><span class="n">Solver</span><span class="o">*</span> <span class="k">const</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">var_</span><span class="o">-&gt;</span><span class="n">SetValue</span><span class="p">(</span><span class="n">value_</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">Refute</span><span class="p">(</span><span class="n">Solver</span><span class="o">*</span> <span class="k">const</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">var_</span><span class="o">-&gt;</span><span class="n">RemoveValue</span><span class="p">(</span><span class="n">value_</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="decisionvisitors">
<h3>5.5.2.3. <tt class="docutils literal"><span class="pre">DecisionVisitor</span></tt>s</h3>
<p><tt class="docutils literal"><span class="pre">DecisionVisitor</span></tt>s are attached to <tt class="docutils literal"><span class="pre">Decision</span></tt>s. The corresponding methods of the <tt class="docutils literal"><span class="pre">DecisionVisitor</span></tt>
are triggered just before a <tt class="docutils literal"><span class="pre">Decision</span></tt> is applied<a class="footnote-reference" href="#decision-visitor-triggered" id="id5">[4]</a>.</p>
<table class="docutils footnote" frame="void" id="decision-visitor-triggered" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[4]</a></td><td>In this case, the methods are triggered when <tt class="docutils literal"><span class="pre">Decision</span></tt> objects
are created and these objects are created just before their <tt class="docutils literal"><span class="pre">Apply()</span></tt> method is called.
See the subsection <a class="reference internal" href="../under_the_hood/conventions.html#idiom-visitors"><em>Visitors</em></a> for more.</td></tr>
</tbody>
</table>
<p>When dealing with <tt class="docutils literal"><span class="pre">IntVar</span></tt>s, two possibilities can be audited:</p>
<ul>
<li><p class="first">when a variable will be assigned a value, implement the</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">virtual</span> <span class="kt">void</span> <span class="nf">VisitSetVariableValue</span><span class="p">(</span><span class="n">IntVar</span><span class="o">*</span> <span class="k">const</span> <span class="n">var</span><span class="p">,</span> <span class="n">int64</span> <span class="n">value</span><span class="p">);</span>
</pre></div>
</div>
<p>method.</p>
</li>
<li><p class="first">when a variable domain will be splitted in two by a given value, implement
the</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">virtual</span> <span class="kt">void</span> <span class="nf">VisitSplitVariableDomain</span><span class="p">(</span><span class="n">IntVar</span><span class="o">*</span> <span class="k">const</span> <span class="n">var</span><span class="p">,</span>
                                      <span class="n">int64</span> <span class="n">value</span><span class="p">,</span>
                                      <span class="kt">bool</span> <span class="n">start_with_lower_half</span><span class="p">);</span>
</pre></div>
</div>
<p>method. If <tt class="docutils literal"><span class="pre">start_with_lower_half</span></tt> is <tt class="docutils literal"><span class="pre">true</span></tt>, the decision to be applied is</p>
<div class="math">
<p><img src="../../_images/math/d2f2ed9f962cc2b1d3198d2e2a1df1f23a26f752.png" alt="\text{var} \leqslant value"/></p>
</div><p>otherwise it is</p>
<div class="math">
<p><img src="../../_images/math/30fc22790b234e7ab97c2311cc9282a0efcf4ade.png" alt="\text{var} &gt; value"/></p>
</div></li>
</ul>
<p>There is also a default option:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">virtual</span> <span class="kt">void</span> <span class="nf">VisitUnknownDecision</span><span class="p">();</span>
</pre></div>
</div>
<p>In the section <a class="reference internal" href="breaking_symmetry.html#search-primitives-breaking-symmetry"><em>Breaking symmetries with SymmetryBreakers</em></a>, we present a concept that uses <tt class="docutils literal"><span class="pre">DecisionVisitor</span></tt>s.</p>
</div>
</div>
<div class="section" id="combining-decisionbuilders">
<h2>5.5.3. Combining <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>s</h2>
<p>We propose two ways to combine <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>s:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">Compose()</span></tt>: combine sequential searches, i.e. <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>s are used one after the other;</li>
<li><tt class="docutils literal"><span class="pre">Try()</span></tt>: combine parallel searches, i.e. <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>s are used in parallel.</li>
</ul>
</div></blockquote>
<p>You can of course combine the two.</p>
<div class="section" id="compose">
<h3>5.5.3.1. <tt class="docutils literal"><span class="pre">Compose()</span></tt></h3>
<p>Creates a <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> which sequentially composes <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>s.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Solver</span> <span class="nf">s</span><span class="p">(...);</span>
<span class="p">...</span>
<span class="n">DecisionBuilder</span> <span class="o">*</span> <span class="k">const</span> <span class="n">db1</span> <span class="o">=</span> <span class="p">...;</span>
<span class="n">DecisionBuilder</span> <span class="o">*</span> <span class="k">const</span> <span class="n">db2</span> <span class="o">=</span> <span class="p">...;</span>
<span class="n">DecisionBuilder</span> <span class="o">*</span> <span class="k">const</span> <span class="n">db</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">Compose</span><span class="p">(</span><span class="n">db1</span><span class="p">,</span> <span class="n">db2</span><span class="p">);</span>
</pre></div>
</div>
<p>At each leaf of the search tree corresponding to the <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> <tt class="docutils literal"><span class="pre">db1</span></tt>, the second <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>
<tt class="docutils literal"><span class="pre">db2</span></tt> is called.</p>
<p>The <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> <tt class="docutils literal"><span class="pre">db</span></tt> search tree will be as follows:</p>
<img alt="../../_images/compose.png" class="align-center" src="../../_images/compose.png" style="width: 250pt;" />
<p>This composition of <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>s frequently happens in scheduling. For instance, in
the section <a class="reference internal" href="../ls/jobshop_implementation.html#jobshop-decision-builders-compose"><em>The DecisionBuilders</em></a> where we try to solve a Job-Shop Problem,
the solving process is done in two consecutive phases:
first we rank the tasks for each machine, then we schedule each task at its earliest start time.
To do so, we <tt class="docutils literal"><span class="pre">Compose()</span></tt> two <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>s.</p>
<p>You can <tt class="docutils literal"><span class="pre">Compose()</span></tt> more than two <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>s. There are two more specific methods to
<tt class="docutils literal"><span class="pre">Compose()</span></tt> three and even four <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>s. And if that is not enough, use</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">DecisionBuilder</span><span class="o">*</span> <span class="nf">Compose</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">DecisionBuilder</span><span class="o">*&gt;&amp;</span> <span class="n">dbs</span><span class="p">);</span>
</pre></div>
</div>
<p>where you can <tt class="docutils literal"><span class="pre">Compose()</span></tt> as many <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>s as you like!</p>
</div>
<div class="section" id="try">
<h3>5.5.3.2. <tt class="docutils literal"><span class="pre">Try()</span></tt></h3>
<p>Creates a <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> which tries <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>s in parallel.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Solver</span> <span class="nf">s</span><span class="p">(...);</span>
<span class="p">...</span>
<span class="n">DecisionBuilder</span> <span class="o">*</span> <span class="k">const</span> <span class="n">db1</span> <span class="o">=</span> <span class="p">...;</span>
<span class="n">DecisionBuilder</span> <span class="o">*</span> <span class="k">const</span> <span class="n">db2</span> <span class="o">=</span> <span class="p">...;</span>
<span class="n">DecisionBuilder</span> <span class="o">*</span> <span class="k">const</span> <span class="n">db</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">Try</span><span class="p">(</span><span class="n">db1</span><span class="p">,</span> <span class="n">db2</span><span class="p">);</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> <tt class="docutils literal"><span class="pre">db1</span></tt> and the <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> <tt class="docutils literal"><span class="pre">db2</span></tt> are each called from the top of the search tree
one after the other.</p>
<p>The <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> <tt class="docutils literal"><span class="pre">db</span></tt> search tree will be as follows:</p>
<img alt="../../_images/try.png" class="align-center" src="../../_images/try.png" style="width: 200pt;" />
<p>This combination is handy to try a <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> <tt class="docutils literal"><span class="pre">db1</span></tt> which partially explores the
search space. If it fails, you can use the <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> <tt class="docutils literal"><span class="pre">db2</span></tt> as a backup.</p>
<p>As with <tt class="docutils literal"><span class="pre">Compose()</span></tt>, you can <tt class="docutils literal"><span class="pre">Try()</span></tt> up to four <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>s and use</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">DecisionBuilder</span><span class="o">*</span> <span class="nf">Try</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">DecisionBuilder</span><span class="o">*&gt;&amp;</span> <span class="n">dbs</span><span class="p">);</span>
</pre></div>
</div>
<p>for more.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Beware that <tt class="docutils literal"><span class="pre">Try(db1,</span> <span class="pre">db2,</span> <span class="pre">db3,</span> <span class="pre">db4)</span></tt> will give an unbalanced tree to the right,
whereas <tt class="docutils literal"><span class="pre">Try(Try(db1,</span> <span class="pre">db2),</span> <span class="pre">Try(db3,</span> <span class="pre">db4))</span></tt> will give a balanced tree.</p>
</div>
</div>
</div>
<div class="section" id="nested-searches">
<span id="id6"></span><h2>5.5.4. Nested searches</h2>
<p><em>Nested searches</em> are searches in sub-trees that are initiated from a particular node in the global search tree.
Another way of looking at things is to say that nested searches collapse a search tree described by one or more
<tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>s
and sets of <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt>s and wrap it into a single node in the main search tree.</p>
<p>Local search (<tt class="docutils literal"><span class="pre">LocalSearch</span></tt>) is implemented as a nested search but we delay its description until the next chapter.</p>
<div class="section" id="solveonce">
<h3>5.5.4.1. <tt class="docutils literal"><span class="pre">SolveOnce</span></tt></h3>
<p><tt class="docutils literal"><span class="pre">SolveOnce</span></tt> is a <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> that searches a sub-tree with a given <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt> and a set of <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt>s
and returns the first solution encountered. If there are no solutions in this nested sub-tree, then <tt class="docutils literal"><span class="pre">SolveOnce</span></tt> will
fail.</p>
<p>The factory method is <tt class="docutils literal"><span class="pre">MakeSolveOnce()</span></tt>. You have to invoke it with another <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>. You can add none or up to
four <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt>s and if you want to use more than four <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt>s, use</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">DecisionBuilder</span><span class="o">*</span> <span class="nf">MakeSolveOnce</span><span class="p">(</span><span class="n">DecisionBuilder</span><span class="o">*</span> <span class="k">const</span> <span class="n">db</span><span class="p">,</span>
                       <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SearchMonitor</span><span class="o">*&gt;&amp;</span> <span class="n">monitors</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="nestedoptimize">
<h3>5.5.4.2. <tt class="docutils literal"><span class="pre">NestedOptimize</span></tt></h3>
<p><tt class="docutils literal"><span class="pre">NestedOptimize</span></tt> is similar to <tt class="docutils literal"><span class="pre">SolveOnce</span></tt> except that it seeks for an optimal solution instead of just a feasible solution.
If there are no solutions in this nested tree, it fails.</p>
<p>The factory method is <tt class="docutils literal"><span class="pre">MakeNestedOptimize()</span></tt>. Again, you can use none or up to four <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt>s
and use the version with an <tt class="docutils literal"><span class="pre">std::vector&lt;SearchMonitor*&gt;</span></tt>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">DecisionBuilder</span><span class="o">*</span> <span class="nf">MakeNestedOptimize</span><span class="p">(</span><span class="n">DecisionBuilder</span><span class="o">*</span> <span class="k">const</span> <span class="n">db</span><span class="p">,</span>
                       <span class="n">Assignment</span><span class="o">*</span> <span class="k">const</span> <span class="n">solution</span><span class="p">,</span>
                       <span class="kt">bool</span> <span class="n">maximize</span><span class="p">,</span>
                       <span class="n">int64</span> <span class="n">step</span><span class="p">,</span>
                       <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SearchMonitor</span><span class="o">*&gt;&amp;</span> <span class="n">monitors</span><span class="p">);</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">NestedOptimize</span></tt> is used for:</p>
<blockquote>
<div><ul class="simple">
<li>Testing.</li>
<li>Local search: see next chapter.</li>
<li>To control the backtracking.</li>
<li>...</li>
</ul>
</div></blockquote>
</div>
</div>
<div class="section" id="the-makephase-method-more-in-details">
<span id="makephase-int-vars"></span><h2>5.5.5. The <tt class="docutils literal"><span class="pre">MakePhase()</span></tt> method more in details</h2>
<p>We only discuss the <tt class="docutils literal"><span class="pre">MakePhase()</span></tt> methods for <tt class="docutils literal"><span class="pre">std::vector&lt;IntVar*&gt;</span></tt>. For <tt class="docutils literal"><span class="pre">std::vector&lt;IntervalVar*&gt;</span></tt>
and <tt class="docutils literal"><span class="pre">std::vector&lt;SequenceVar*&gt;</span></tt>, see the section <a class="reference internal" href="../ls/scheduling_or_tools.html#scheduling-or-tools"><em>Scheduling in or-tools</em></a> in the next chapter.</p>
<p>The <tt class="docutils literal"><span class="pre">MakePhase()</span></tt> method is overloaded with different arguments and we discuss most of them in this subsection.</p>
<div class="section" id="the-2-steps-approach">
<span id="make-phase-two-steps"></span><h3>5.5.5.1. The 2-steps approach</h3>
<p>Variables and values are chosen in two steps: first a variable is chosen and only then is a value chosen to be assigned
to this variable.</p>
<p>The basic version of the <tt class="docutils literal"><span class="pre">MakePhase()</span></tt> method is:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">DecisionBuilder</span><span class="o">*</span> <span class="nf">MakePhase</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IntVar</span><span class="o">*&gt;&amp;</span> <span class="n">vars</span><span class="p">,</span>
                                          <span class="n">IntVarStrategy</span> <span class="n">var_str</span><span class="p">,</span>
                                          <span class="n">IntValueStrategy</span> <span class="n">val_str</span><span class="p">);</span>
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">IntVarStrategy</span></tt> is an <tt class="docutils literal"><span class="pre">enum</span></tt> with different strategies to find
the next variable to branch on and <tt class="docutils literal"><span class="pre">IntValueStrategy</span></tt> is an <tt class="docutils literal"><span class="pre">enum</span></tt> with different strategies
to find the next value to assign to this variable. We detail the different available strategies in the next section.</p>
</div>
<div class="section" id="callbacks-to-the-rescue">
<h3>5.5.5.2. Callbacks to the rescue</h3>
<p>What if you want to use your own strategies? One way to do this is to develop your own <tt class="docutils literal"><span class="pre">Decision</span></tt>s and
<tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>s. Another way is to provide callbacks to the <tt class="docutils literal"><span class="pre">MakePhase()</span></tt> method. These callbacks evaluate
different variables and values you can assign to a chosen variable. The best choice is each time the one that
minimizes the values returned (through the <tt class="docutils literal"><span class="pre">Run()</span></tt> method) by the callbacks.</p>
<p>We will explore both ways in the section <a class="reference internal" href="customized_search_primitives.html#customized-search-primitives"><em>Customized search primitives</em></a>.</p>
<p>There are two types of callbacks<a class="footnote-reference" href="#callbacks-want-to-know-more" id="id7">[5]</a> accepted by <tt class="docutils literal"><span class="pre">MakePhase()</span></tt>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">typedef</span> <span class="n">ResultCallback1</span><span class="o">&lt;</span><span class="n">int64</span><span class="p">,</span> <span class="n">int64</span><span class="o">&gt;</span> <span class="n">IndexEvaluator1</span><span class="p">;</span>
<span class="k">typedef</span> <span class="n">ResultCallback2</span><span class="o">&lt;</span><span class="n">int64</span><span class="p">,</span> <span class="n">int64</span><span class="p">,</span> <span class="n">int64</span><span class="o">&gt;</span> <span class="n">IndexEvaluator2</span><span class="p">;</span>
</pre></div>
</div>
<table class="docutils footnote" frame="void" id="callbacks-want-to-know-more" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[5]</a></td><td>If you want to know more about callbacks, see the section
<a class="reference internal" href="../under_the_hood/conventions.html#idiom-callbacks"><em>Callbacks</em></a> in the chapter <a class="reference internal" href="../under_the_hood.html#chapter-under-the-hood"><em>Under the hood</em></a>.</td></tr>
</tbody>
</table>
<p><tt class="docutils literal"><span class="pre">IndexEvaluator1</span></tt> allows to evaluate the next variable to branch on by giving the index of this variable in the
<tt class="docutils literal"><span class="pre">std::vector&lt;IntVar*&gt;</span></tt> for unbounded variables. <tt class="docutils literal"><span class="pre">IndexEvaluator2</span></tt> allows to evaluate the available values
(second index) for the chosen variable (first index). In each case, the variable and the value chosen will
correspond to the smallest value returned by the evaluators. In case of a tie for the values,
the <strong>last</strong> value with the
minimum score will be chosen. You can also provide an <tt class="docutils literal"><span class="pre">IndexEvaluator1</span></tt> to break the tie between several
values. Last but not least, you can combine callbacks with the available <tt class="docutils literal"><span class="pre">IntVarStrategy</span></tt> or <tt class="docutils literal"><span class="pre">IntValueStrategy</span></tt>
strategies.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Ownership of the callbacks is always passed to the <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>.</p>
</div>
<p>We detail some combinations:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">DecisionBuilder</span><span class="o">*</span> <span class="nf">MakePhase</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IntVar</span><span class="o">*&gt;&amp;</span> <span class="n">vars</span><span class="p">,</span>
                           <span class="n">IndexEvaluator1</span><span class="o">*</span> <span class="n">var_evaluator</span><span class="p">,</span>
                           <span class="n">IndexEvaluator2</span><span class="o">*</span> <span class="n">val_eval</span><span class="p">);</span>
</pre></div>
</div>
<p>You provide both evaluators.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">DecisionBuilder</span><span class="o">*</span> <span class="nf">MakePhase</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IntVar</span><span class="o">*&gt;&amp;</span> <span class="n">vars</span><span class="p">,</span>
                           <span class="n">IntVarStrategy</span> <span class="n">var_str</span><span class="p">,</span>
                           <span class="n">IndexEvaluator2</span><span class="o">*</span> <span class="n">val_eval</span><span class="p">,</span>
                           <span class="n">IndexEvaluator1</span><span class="o">*</span> <span class="n">tie_breaker</span><span class="p">);</span>
</pre></div>
</div>
<p>You use a predefined <tt class="docutils literal"><span class="pre">IntVarStrategy</span></tt> strategy to find the next variable to branch on, provide your own
callback <tt class="docutils literal"><span class="pre">IndexEvaluator2</span></tt> to find the next value to give to this variable and an evaluator <tt class="docutils literal"><span class="pre">IndexEvaluator1</span></tt>
to break any
tie between different values.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">DecisionBuilder</span><span class="o">*</span> <span class="nf">MakePhase</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IntVar</span><span class="o">*&gt;&amp;</span> <span class="n">vars</span><span class="p">,</span>
                           <span class="n">IndexEvaluator1</span><span class="o">*</span> <span class="n">var_evaluator</span><span class="p">,</span>
                           <span class="n">IntValueStrategy</span> <span class="n">val_str</span><span class="p">);</span>
</pre></div>
</div>
<p>This time, you provide an evaluator <tt class="docutils literal"><span class="pre">IndexEvaluator1</span></tt> to find the next variable but rely
on a predefined <tt class="docutils literal"><span class="pre">IntValueStrategy</span></tt> strategy to find the next value.</p>
<p>Several other combinations are provided.</p>
</div>
<div class="section" id="when-the-2-steps-approach-isn-t-enough">
<h3>5.5.5.3. When the 2-steps approach isn&#8217;t enough</h3>
<p>Sometimes this 2-step approach isn&#8217;t satisfactory. You may want to test all combinations of variables/values.
We provide two versions of the <tt class="docutils literal"><span class="pre">MakePhase()</span></tt> method just to do that:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">DecisionBuilder</span><span class="o">*</span> <span class="nf">MakePhase</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IntVar</span><span class="o">*&gt;&amp;</span> <span class="n">vars</span><span class="p">,</span>
                           <span class="n">IndexEvaluator2</span><span class="o">*</span> <span class="n">evaluator</span><span class="p">,</span>
                           <span class="n">EvaluatorStrategy</span> <span class="n">str</span><span class="p">);</span>
</pre></div>
</div>
<p>and</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">DecisionBuilder</span><span class="o">*</span> <span class="nf">MakePhase</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IntVar</span><span class="o">*&gt;&amp;</span> <span class="n">vars</span><span class="p">,</span>
                           <span class="n">IndexEvaluator2</span><span class="o">*</span> <span class="n">evaluator</span><span class="p">,</span>
                           <span class="n">IndexEvaluator1</span><span class="o">*</span> <span class="n">tie_breaker</span><span class="p">,</span>
                           <span class="n">EvaluatorStrategy</span> <span class="n">str</span><span class="p">);</span>
</pre></div>
</div>
<p>You might wonder what the <tt class="docutils literal"><span class="pre">EvaluatorStrategy</span></tt> strategy is.
The selection is done by scanning every pair &lt;variable, possible value&gt;. The next selected pair is the best among
all possibilities, i.e. the pair with the smallest evaluation given by the <tt class="docutils literal"><span class="pre">IndexEvaluator2</span></tt>.
This approach is costly and therefore we offer two options given by the <tt class="docutils literal"><span class="pre">EvaluatorStrategy</span></tt> <tt class="docutils literal"><span class="pre">enum</span></tt>:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">CHOOSE_STATIC_GLOBAL_BEST</span></tt>:
<strong>Static evaluation</strong>: Pairs are compared at the first call of the selector, and results are
cached. Next calls to the selector use the previous computation, and are thus
not up-to-date, e.g. some &lt;variable, value&gt; pairs may not be possible
due to propagation since the first call.</li>
<li><tt class="docutils literal"><span class="pre">CHOOSE_DYNAMIC_GLOBAL_BEST</span></tt>:
<strong>Dynamic evaluation</strong>: Pairs are compared each time a variable is selected. That way all pairs
are relevant and evaluation is accurate.
This strategy runs in <img class="math" src="../../_images/math/8723ff4aa2be2ed47d9df95372afa7fe94b5cc1b.png" alt="O(\text{number-of-pairs})" style="vertical-align: -4px"/> at each variable selection,
versus <img class="math" src="../../_images/math/62d0effd6477f4244d585fc25f46a645378a4ceb.png" alt="O(1)" style="vertical-align: -4px"/> in the static version.</li>
</ul>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<table>
<tr>
<td width="60"><img src="../../_static/logo.png" width="50" height="50"  alt="" /></td>
<td><p class="library_name">Google <a href="http://code.google.com/p/or-tools/"><strong>or-tools</strong></a><br>open source library</p></td>
</tr>
</table>
<h1>User's Manual</h1>

  
   



<h3>Google search</h3>

<form method="get" action="http://www.google.com/search">

<div style="padding:-1px;width:15em;">
<table border="0" cellpadding="0">
<tr><td>
<input type="text"   name="q" size="25"
 maxlength="255" value="" />
<input type="submit" value="Go" /></td></tr>
<tr><td align="center" style="font-size:80%">
Search:
<select name="sitesearch" width="125" style="width: 125px">
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/user_manual/" selected>user's manual</option>
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/faq/">faq</option>
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/reference_manual/or-tools/">reference manual</option>
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/">All or-tools doc</option>
</select>
</td></tr>
</table>
</div>

</form>
</br>




  <h3>Welcome</h3>
  
  <ul>
  	<li><a href="../../index.html">Content and foreword</a></li>
  	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html">Documentation's hub</a></li>
	<li><a href="http://code.google.com/p/or-tools/">The or-tools open source library</a></li></li>	
  </ul>
  
   
	


  <h3>Tutorial examples</h3>
  
  <ul>
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_C++">C++</a></li>
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_Python">Python</a></li>	
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_Java">Java</a></li>
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_Csharp">C#</a></li>
</ul>
  
   
	

  <h3>Current chapter</h3>
  <p class="topless"><a href="../search_primitives.html"
                        title="previous chapter">5. Defining search primitives: the n-Queens Problem</a></p>
  <h3>Previous section</h3>
  <p class="topless"><a href="cpviz.html"
                        title="previous chapter">5.4. <strong class="program">cpviz</strong>: how to visualize the search</a></p>
  <h3>Next section</h3>
  <p class="topless"><a href="out_of_the_box_search_primitives.html"
                        title="next chapter">5.6. Out of the box variables and values selection primitives</a></p>
  <h3>Current section</a></h3>
  <ul>
<li><a class="reference internal" href="#">5.5. Basic working of the solver: the phases</a><ul>
<li><a class="reference internal" href="#decisionbuilders-and-phases">5.5.1. <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>s and phases</a></li>
<li><a class="reference internal" href="#decisions-and-decisionvisitors">5.5.2. <tt class="docutils literal"><span class="pre">Decision</span></tt>s and <tt class="docutils literal"><span class="pre">DecisionVisitor</span></tt>s</a><ul>
<li><a class="reference internal" href="#id4">5.5.2.1. <tt class="docutils literal"><span class="pre">Decision</span></tt>s</a></li>
<li><a class="reference internal" href="#assignonevariablevalue-as-an-example">5.5.2.2. <tt class="docutils literal"><span class="pre">AssignOneVariableValue</span></tt> as an example</a></li>
<li><a class="reference internal" href="#decisionvisitors">5.5.2.3. <tt class="docutils literal"><span class="pre">DecisionVisitor</span></tt>s</a></li>
</ul>
</li>
<li><a class="reference internal" href="#combining-decisionbuilders">5.5.3. Combining <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>s</a><ul>
<li><a class="reference internal" href="#compose">5.5.3.1. <tt class="docutils literal"><span class="pre">Compose()</span></tt></a></li>
<li><a class="reference internal" href="#try">5.5.3.2. <tt class="docutils literal"><span class="pre">Try()</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#nested-searches">5.5.4. Nested searches</a><ul>
<li><a class="reference internal" href="#solveonce">5.5.4.1. <tt class="docutils literal"><span class="pre">SolveOnce</span></tt></a></li>
<li><a class="reference internal" href="#nestedoptimize">5.5.4.2. <tt class="docutils literal"><span class="pre">NestedOptimize</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-makephase-method-more-in-details">5.5.5. The <tt class="docutils literal"><span class="pre">MakePhase()</span></tt> method more in details</a><ul>
<li><a class="reference internal" href="#the-2-steps-approach">5.5.5.1. The 2-steps approach</a></li>
<li><a class="reference internal" href="#callbacks-to-the-rescue">5.5.5.2. Callbacks to the rescue</a></li>
<li><a class="reference internal" href="#when-the-2-steps-approach-isn-t-enough">5.5.5.3. When the 2-steps approach isn&#8217;t enough</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="out_of_the_box_search_primitives.html" title="5.6. Out of the box variables and values selection primitives"
             >next</a> |</li>
        <li class="right" >
          <a href="cpviz.html" title="5.4. cpviz: how to visualize the search"
             >previous</a> |</li>
        <li><a href="../../index.html">or-tools User&#39;s Manual</a> &raquo;</li>
          <li><a href="../search_primitives.html" >5. Defining search primitives: the n-Queens Problem</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012-2014, Google.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>