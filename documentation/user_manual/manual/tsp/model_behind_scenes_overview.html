

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>9.5. The model behind the scenes: overview &mdash; or-tools User&#39;s Manual</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     'doc version 0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../_static/logo.ico"/>
    <link rel="top" title="or-tools User&#39;s Manual" href="../../index.html" />
    <link rel="up" title="9. Travelling Salesman Problems with constraints: the TSP with time windows" href="../TSP.html" />
    <link rel="next" title="9.6. The TSP in or-tools" href="first_tsp_implementation.html" />
    <link rel="prev" title="9.4. The model behind the scenes: the main decision variables" href="model_behind_scenes.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="first_tsp_implementation.html" title="9.6. The TSP in or-tools"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="model_behind_scenes.html" title="9.4. The model behind the scenes: the main decision variables"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">or-tools User&#39;s Manual</a> &raquo;</li>
          <li><a href="../TSP.html" accesskey="U">9. Travelling Salesman Problems with constraints: the TSP with time windows</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="the-model-behind-the-scenes-overview">
<span id="rl-model-behind-scenes-overview"></span><h1>9.5. The model behind the scenes: overview</h1>
<p>In this section, we give an overview of the main basic components of our model. Most of these
components will be detailed in this chapter and the next two chapters.
In the section <a class="reference internal" href="../under_the_hood/rl.html#hood-rl"><em>The Routing Library (RL)</em></a> of the chapter <a class="reference internal" href="../under_the_hood.html#chapter-under-the-hood"><em>Under the hood</em></a>,
we describe the inner mechanisms of the RL in details.</p>
<p>If you haven&#8217;t already read the section <a class="reference internal" href="model_behind_scenes.html#rl-model-behind-scenes-decision-v"><em>The model behind the scenes: the main decision variables</em></a>
about the main decision variables and the auxiliary graph, we strongly
recommend that you do so before reading this section.</p>
<div class="section" id="the-routingmodel-class">
<h2>9.5.1. The <tt class="docutils literal"><span class="pre">RoutingModel</span></tt> class</h2>
<p>All ingredients are defined within the <tt class="docutils literal"><span class="pre">RoutingModel</span></tt> <tt class="docutils literal"><span class="pre">class</span></tt>. This class is declared in the header
<tt class="file docutils literal"><span class="pre">constraint_solver/routing.h</span></tt>.</p>
<p>As already mentionned, the RL is a layer above the CP Solver and the <em>internal cabling</em> is accessible through
the underlying solver:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">RoutingModel</span> <span class="nf">routing</span><span class="p">(...);</span>
<span class="n">Solver</span><span class="o">*</span> <span class="k">const</span> <span class="n">solver</span> <span class="o">=</span> <span class="n">routing</span><span class="p">.</span><span class="n">solver</span><span class="p">();</span>
</pre></div>
</div>
<p>Most desirable features for an RL are directly accessible through the <tt class="docutils literal"><span class="pre">RoutingModel</span></tt> class though.
The <em>accessors</em> (getters and setters)
will be discussed throughout the third part of this manual. But it is good
to know that, as a last resort, you have a complete access (read <em>control</em>) to the internals of the RL.</p>
<p>Basically, two constructors are available depending on the number of depots:</p>
<ul>
<li><p class="first">if there is only one depot:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//  42 nodes and 7 routes/vehicles</span>
<span class="n">RoutingModel</span> <span class="nf">routing</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="mi">7</span><span class="p">);</span>
<span class="c1">//  depot is node with NodeIndex 5</span>
<span class="n">routing</span><span class="p">.</span><span class="n">SetDepot</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</pre></div>
</div>
</li>
<li><p class="first">if there are several start/end depots:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//  create multi depots</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">RoutingModel</span><span class="o">::</span><span class="n">NodeIndex</span><span class="p">,</span>
                               <span class="n">RoutingModel</span><span class="o">::</span><span class="n">NodeIndex</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">depots</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="n">depots</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">5</span><span class="p">);</span>
<span class="n">depots</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">7</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>

<span class="n">RoutingModel</span> <span class="nf">VRP</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="n">depots</span><span class="p">);</span>
</pre></div>
</div>
<p>Note that the space between the two ending <cite>&#8220;&gt;&#8221;</cite> in:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">RoutingModel</span><span class="o">::</span><span class="n">NodeIndex</span><span class="p">,</span>
                               <span class="n">RoutingModel</span><span class="o">::</span><span class="n">NodeIndex</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">depots</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
</pre></div>
</div>
<p>is mandatory.</p>
</li>
</ul>
</div>
<div class="section" id="variables">
<span id="var-defining-nodes-and-routes"></span><h2>9.5.2. Variables</h2>
<p>Basically, there are two type of variables:</p>
<blockquote>
<div><ul class="simple">
<li><strong>Path variables</strong>: the main decision variables and additional variables to describe the different routes and</li>
<li><strong>Dimension variables</strong>: these variables allow to add side constraints like time-windows, capacities, etc.
and denote some quantities (the <em>dimensions</em>) along the routes.</li>
</ul>
</div></blockquote>
<p>From now on in this section, we only use the internal <tt class="docutils literal"><span class="pre">int64</span></tt> indices except if the indices are explicitly
of type <tt class="docutils literal"><span class="pre">NodeIndex</span></tt>. This is worth a warning:</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">For the rest of this section, we only use the internal <tt class="docutils literal"><span class="pre">int64</span></tt> indices except if the indices are explicitly
of type <tt class="docutils literal"><span class="pre">RoutingModel::NodeIndex</span></tt>.</p>
</div>
<div class="section" id="path-variables">
<h3>9.5.2.1. Path variables</h3>
<p>Path variables describe the different routes. There are three types of path variables that can be accessed with
the following methods:</p>
<blockquote>
<div><ul class="simple">
<li><tt class="docutils literal"><span class="pre">NextVar(i)</span></tt>: the main decision variables. <tt class="docutils literal"><span class="pre">NextVar(i)</span> <span class="pre">==</span> <span class="pre">j</span></tt> is <tt class="docutils literal"><span class="pre">true</span></tt> if <tt class="docutils literal"><span class="pre">j</span></tt> is the node
immediately reached from node <tt class="docutils literal"><span class="pre">i</span></tt> in the solution.</li>
<li><tt class="docutils literal"><span class="pre">VehicleVar(i)</span></tt>: represents the vehicle/route index to which node <tt class="docutils literal"><span class="pre">i</span></tt> belongs in the solution.</li>
<li><tt class="docutils literal"><span class="pre">ActiveVar(i)</span></tt>: a Boolean variable that indicates if a node <tt class="docutils literal"><span class="pre">i</span></tt> is visited or not in the solution.</li>
</ul>
</div></blockquote>
<div class="section" id="main-decision-variables">
<h4>9.5.2.1.1. Main decision variables</h4>
<p>You can access the main variables with the method <tt class="docutils literal"><span class="pre">NextVar(int64)</span></tt>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">IntVar</span><span class="o">*</span> <span class="n">var</span> <span class="o">=</span> <span class="n">routing</span><span class="p">.</span><span class="n">NextVar</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">var</span></tt> is a pointer to the <tt class="docutils literal"><span class="pre">IntVar</span></tt> corresponding to the node with the <tt class="docutils literal"><span class="pre">int64</span></tt> 42 index.
In a solution <tt class="docutils literal"><span class="pre">solution</span></tt>, the value of this variable gives the <tt class="docutils literal"><span class="pre">int64</span></tt> index of the next node visited after this node:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Assignment</span> <span class="o">*</span> <span class="k">const</span> <span class="n">solution</span> <span class="o">=</span> <span class="n">routing</span><span class="p">.</span><span class="n">Solve</span><span class="p">();</span>
<span class="p">...</span>
<span class="n">int64</span> <span class="n">next_node</span> <span class="o">=</span> <span class="n">solution</span><span class="p">.</span><span class="n">Value</span><span class="p">(</span><span class="n">var</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="vehicles">
<h4>9.5.2.1.2. Vehicles</h4>
<p>Different routes/vehicles service different nodes. For each node <tt class="docutils literal"><span class="pre">i</span></tt>, <tt class="docutils literal"><span class="pre">VehicleVar(i)</span></tt> represents the <tt class="docutils literal"><span class="pre">IntVar*</span></tt> that
represents the <tt class="docutils literal"><span class="pre">int</span></tt> index of the route/vehicle servicing node <tt class="docutils literal"><span class="pre">i</span></tt> in the solution:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">route_number</span> <span class="o">=</span> <span class="n">solution</span><span class="o">-&gt;</span><span class="n">Value</span><span class="p">(</span><span class="n">routing</span><span class="p">.</span><span class="n">VehicleVar</span><span class="p">(</span><span class="n">i</span><span class="p">));</span>
</pre></div>
</div>
<p>Taking a shortcut in the notation, we have that:</p>
<blockquote>
<div>if <tt class="docutils literal"><span class="pre">NextVar(i)</span> <span class="pre">==</span> <span class="pre">j</span></tt> then <tt class="docutils literal"><span class="pre">VehicleVar(j)</span> <span class="pre">==</span> <span class="pre">VehicleVar(i)</span></tt>.</div></blockquote>
<p>That is, both nodes <tt class="docutils literal"><span class="pre">i</span></tt> and <tt class="docutils literal"><span class="pre">j</span></tt> are serviced by the same vehicle.</p>
<p>To grab the first and last node (starting and ending depot) of a route/vehicle <tt class="docutils literal"><span class="pre">route_number</span></tt>,
you can use the <tt class="docutils literal"><span class="pre">Start()</span></tt> and <tt class="docutils literal"><span class="pre">End()</span></tt> methods that we discussed previously:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">int64</span> <span class="n">starting_depot</span> <span class="o">=</span> <span class="n">routing</span><span class="p">.</span><span class="n">Start</span><span class="p">(</span><span class="n">route_number</span><span class="p">);</span>
<span class="n">int64</span> <span class="n">ending_depot</span> <span class="o">=</span> <span class="n">routing</span><span class="p">.</span><span class="n">End</span><span class="p">(</span><span class="n">route_number</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="disjunctions-and-optional-nodes">
<h4>9.5.2.1.3. <tt class="docutils literal"><span class="pre">Disjunction</span></tt>s and optional nodes</h4>
<p>A node doesn&#8217;t have to be visited. Nodes can be optional or part of a <tt class="docutils literal"><span class="pre">Disjunction</span></tt>, i.e. part of a subset
of nodes out of which at most one node can be visited in a solution.</p>
<p><tt class="docutils literal"><span class="pre">ActiveVar(i)</span></tt> returns a boolean <tt class="docutils literal"><span class="pre">IntVar*</span></tt> (a <tt class="docutils literal"><span class="pre">IntVar</span></tt> variable with a {0, 1} domain) indicating if the node <tt class="docutils literal"><span class="pre">i</span></tt>
is visited or not in the solution. The way to describe a node that is not visited is to make its <tt class="docutils literal"><span class="pre">NextVar(i)</span></tt> points
to itself. Thus, and again with an abuse of notation, we have:</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">ActiveVar(i)</span> <span class="pre">==</span> <span class="pre">(NextVar(i)</span> <span class="pre">!=</span> <span class="pre">i)</span></tt>.</div></blockquote>
<p>We&#8217;ll discuss <tt class="docutils literal"><span class="pre">Disjunction</span></tt>s and optional nodes  in details in the
section <em class="xref std std-ref">disjunctions</em> when we will transform
a Cumulative Chinese Postman Problem (CCPP) into a <em>Generalized TSP</em> (GTSP). A GTSP is similar to a TSP except that you have
clusters of nodes you want to visit, i.e. you only want to visit 1 node in each cluster.</p>
</div>
</div>
<div class="section" id="dimension-variables">
<h3>9.5.2.2. Dimension variables</h3>
<p>Dimension variables are used to accumulate quantities (or <em>dimensions</em>) along the routes.
To denote a <em>dimension</em>, we use an <tt class="docutils literal"><span class="pre">std::string</span> <span class="pre">d</span></tt>. There are three types
of dimension variables:</p>
<blockquote>
<div><ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">CumulVar(i,</span> <span class="pre">d)</span></tt>: variables representing the quantity of dimension <tt class="docutils literal"><span class="pre">d</span></tt> when
arriving at the node <tt class="docutils literal"><span class="pre">i</span></tt>.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">TransitVar(i,</span> <span class="pre">d)</span></tt>: variables representing the quantity of dimension <tt class="docutils literal"><span class="pre">d</span></tt> added
after visiting the node <tt class="docutils literal"><span class="pre">i</span></tt>.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">SlackVar(i,</span> <span class="pre">d)</span></tt>: non negative slack variables such that (with the same abuse of notation as above):</p>
<blockquote>
<div><p>if <tt class="docutils literal"><span class="pre">NextVar(i)</span> <span class="pre">==</span> <span class="pre">j</span></tt> then <tt class="docutils literal"><span class="pre">CumulVar(j)</span> <span class="pre">=</span> <span class="pre">CumulVar(i)</span> <span class="pre">+</span> <span class="pre">TransitVar(i)</span> <span class="pre">+</span> <span class="pre">SlackVar(i)</span></tt>.</p>
</div></blockquote>
<p>For a time dimension, you can think of waiting times.</p>
</li>
</ul>
</div></blockquote>
<p>You can add as many dimensions as you want<a class="footnote-reference" href="#dimensions-limit" id="id1">[1]</a>.</p>
<table class="docutils footnote" frame="void" id="dimensions-limit" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>Well, as many as your memory allows...</td></tr>
</tbody>
</table>
<p>The transit values can be constant, defined with callbacks, vectors or matrices.
You can represent any quantities along routes with <em>dimensions</em> but not only. For instance, <em>capacities</em> and
<em>time windows</em> can be modelled with <em>dimensions</em>.
We&#8217;ll play with dimensions at the end of this chapter when we&#8217;ll try to solve
<a class="reference internal" href="first_tsptw_implementation.html#first-tsptw-implementation"><em>The Travelling Salesman Problem with Time Windows in or-tools</em></a>.</p>
</div>
</div>
<div class="section" id="constraints">
<h2>9.5.3. Constraints</h2>
<p>In addition to the basics constraints that we discussed in the previous sub-section, the RL uses constraints to avoid cycles,
constraints to model the <tt class="docutils literal"><span class="pre">Disjunction</span></tt>s and <em>pick-up and delivery</em> constraints.</p>
<div class="section" id="no-cycle-constraint">
<h3>9.5.3.1. No cycle constraint</h3>
<p>One of the most difficult constraint to model is a constraint to
avoid cycles in the solutions. For one tour, we don&#8217;t want to revisit some nodes.
Often, we get partial solutions like the one depicted on figure (a):</p>
<img alt="../../_images/cycles.png" class="align-center" src="../../_images/cycles.png" style="width: 400px;" />
<p>It is often easy to obtain optimal solutions when we allow cycles (like in figure (a)) but difficult to obtain
a real solution (like in figure (b)), i.e. without cycles. Several constraints have been proposed in the scientific literature,
each with its cons and pros. Sometimes, we can avoid this constraint by modelling the problem in such a way that only
solutions without cycles can be produced but then we have to deal with huge and often numerically
(and theoretically<a class="footnote-reference" href="#theoretically-unstable-models" id="id2">[2]</a>) unstable models.</p>
<p>In the RL, we use our dedicated <tt class="docutils literal"><span class="pre">NoCycle</span></tt> constraint (defined in <tt class="file docutils literal"><span class="pre">constraint_solver/constraints.cc</span></tt>) in
combination with an <tt class="docutils literal"><span class="pre">AllDifferent</span></tt> constraint on the <tt class="docutils literal"><span class="pre">NextVar()</span></tt> variables. The <tt class="docutils literal"><span class="pre">NoCycle</span></tt> constraint is implicitly
added to the model.</p>
<p>The <tt class="docutils literal"><span class="pre">NoCycle</span></tt> constructor has the following signature:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">NoCycle</span><span class="p">(</span><span class="n">Solver</span><span class="o">*</span> <span class="k">const</span> <span class="n">s</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">IntVar</span><span class="o">*</span> <span class="k">const</span><span class="o">*</span> <span class="n">nexts</span><span class="p">,</span>
        <span class="kt">int</span> <span class="n">size</span><span class="p">,</span>
        <span class="k">const</span> <span class="n">IntVar</span><span class="o">*</span> <span class="k">const</span><span class="o">*</span> <span class="n">active</span><span class="p">,</span>
        <span class="n">ResultCallback1</span><span class="o">&lt;</span><span class="kt">bool</span><span class="p">,</span> <span class="n">int64</span><span class="o">&gt;*</span> <span class="n">sink_handler</span><span class="p">,</span>
        <span class="kt">bool</span> <span class="n">owner</span><span class="p">,</span>
        <span class="kt">bool</span> <span class="n">assume_paths</span><span class="p">);</span>
</pre></div>
</div>
<p>We will not spend too much time on the different arguments. The <tt class="docutils literal"><span class="pre">nexts</span></tt> and <tt class="docutils literal"><span class="pre">active</span></tt> arrays
are what their names imply. The <tt class="docutils literal"><span class="pre">sink_handler</span></tt> is just a callback that indicates if a node is a sink or not.
Sinks represent the depots, i.e. the nodes where paths start and end.</p>
<p>The <tt class="docutils literal"><span class="pre">bool</span></tt> <tt class="docutils literal"><span class="pre">owner</span></tt> allows the solver to take ownership of the callback or not and the <tt class="docutils literal"><span class="pre">bool</span></tt>
<tt class="docutils literal"><span class="pre">assume_paths</span></tt> indicates if we deal with real paths or with a forest (paths don&#8217;t necessarily end)
in the auxiliary graph.</p>
<p>The constraint essentially performs two actions:</p>
<ul class="simple">
<li>forbid partial paths from looping back to themselves and</li>
<li>ensure each variable/node can be connected to a sink.</li>
</ul>
<p>We refer the reader to the subsection
<a class="reference internal" href="../under_the_hood/rl.html#uth-nocycle-constraint"><em>NoCycle constraint</em></a> for
a detailed description of our internal <tt class="docutils literal"><span class="pre">NoCycle</span></tt> constraint.</p>
<table class="docutils footnote" frame="void" id="theoretically-unstable-models" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td>For the specialists: for instance, primal and dual degenerate linear models.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="disjunction-constraints">
<h3>9.5.3.2. <tt class="docutils literal"><span class="pre">Disjunction</span></tt> constraints</h3>
<p><tt class="docutils literal"><span class="pre">Disjunction</span></tt>s on a group of nodes allow to visit at most one of the nodes in this group. If you want to visit
<strong>exactly one</strong> node in a <tt class="docutils literal"><span class="pre">Disjunction</span></tt>, use:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">AddDisjunction</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">NodeIndex</span><span class="o">&gt;&amp;</span> <span class="n">nodes</span><span class="p">);</span>
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">nodes</span></tt> represents the group of nodes. This constraint is equivalent to:</p>
<div class="math">
<p><img src="../../_images/math/aa978851f4e9bd4281fd741f5cc42c985ce1909c.png" alt="\sum_{i \in \text{Disjunction}} \text{ActiveVar}(i) = 1."/></p>
</div><p>You might want to use <em>optional</em> <tt class="docutils literal"><span class="pre">Disjunction</span></tt>s, i.e. a group of nodes
out of which <strong>at most one</strong> node
can be visited.
This time, use:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">AddDisjunction</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">NodeIndex</span><span class="o">&gt;&amp;</span> <span class="n">nodes</span><span class="p">,</span>
                    <span class="n">int64</span> <span class="n">penalty</span><span class="p">);</span>
</pre></div>
</div>
<p>This constraint is equivalent to:</p>
<div class="math">
<p><img src="../../_images/math/42e31e8661e3349f3530398cb2c7d597a6b29a88.png" alt="p \ + \sum_{i \in \text{Disjunction}} \text{ActiveVar}(i) = 1"/></p>
</div><p>where <tt class="docutils literal"><span class="pre">p</span></tt> is a boolean variable corresponding to the <tt class="docutils literal"><span class="pre">Disjunction</span></tt> and the objective function has an added <tt class="docutils literal"><span class="pre">(p</span> <span class="pre">*</span> <span class="pre">penalty)</span></tt> term.
If none of the variables in the <tt class="docutils literal"><span class="pre">Disjunction</span></tt> is visited
(<img class="math" src="../../_images/math/9b99e12e3bf0539741f85c847a228bd6c930864a.png" alt="\sum_{i \in \text{Disjunction}} \text{ActiveVar}(i) = 0" style="vertical-align: -8px"/>), <tt class="docutils literal"><span class="pre">p</span></tt> must be equal to one and the penalty
is added to the objective function.</p>
<p>To be optional, the penalty <tt class="docutils literal"><span class="pre">penalty</span></tt> attributed to the <tt class="docutils literal"><span class="pre">Disjunction</span></tt>
must be <em>non-negative</em> (<img class="math" src="../../_images/math/8301c6fd93f20a80f3f7904c5f7902e92b4759db.png" alt="\geqslant 0" style="vertical-align: -3px"/>), otherwise the RL uses a simple <tt class="docutils literal"><span class="pre">Disjunction</span></tt>, i.e. exactly one
node in the <tt class="docutils literal"><span class="pre">Disjunction</span></tt> will be visited in the solutions.</p>
</div>
<div class="section" id="pick-up-and-delivery-constraints">
<h3>9.5.3.3. Pick-up and delivery constraints</h3>
<p>These constraints ensure that two nodes belong
to the same route.
For instance, if nodes <tt class="docutils literal"><span class="pre">i</span></tt> and <tt class="docutils literal"><span class="pre">j</span></tt> must be visited/delivered by the same vehicle, use:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">AddPickupAndDelivery</span><span class="p">(</span><span class="n">NodeIndex</span> <span class="n">i</span><span class="p">,</span> <span class="n">NodeIndex</span> <span class="n">j</span><span class="p">);</span>
</pre></div>
</div>
<p>Whenever you have an equality constraint linking
the vehicle variables of two nodes, i.e. you want to force the two nodes to be visited by the same vehicle,
you should add (because it speeds up the search process!) the <tt class="docutils literal"><span class="pre">PickupAndDelivery</span></tt> constraint:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Solver</span><span class="o">*</span> <span class="k">const</span> <span class="n">solver</span> <span class="o">=</span> <span class="n">routing</span><span class="p">.</span><span class="n">solver</span><span class="p">();</span>
<span class="n">solver</span><span class="o">-&gt;</span><span class="n">AddConstraint</span><span class="p">(</span><span class="n">solver</span><span class="o">-&gt;</span><span class="n">MakeEquality</span><span class="p">(</span>
                   <span class="n">routing</span><span class="p">.</span><span class="n">VehicleVar</span><span class="p">(</span><span class="n">routing</span><span class="p">.</span><span class="n">NodeToIndex</span><span class="p">(</span><span class="n">i</span><span class="p">)),</span>
                   <span class="n">routing</span><span class="p">.</span><span class="n">VehicleVar</span><span class="p">(</span><span class="n">routing</span><span class="p">.</span><span class="n">NodeToIndex</span><span class="p">(</span><span class="n">j</span><span class="p">))));</span>
<span class="n">routing</span><span class="p">.</span><span class="n">AddPickupAndDelivery</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
</pre></div>
</div>
<p>This constraint is counter-intuitive in a least two ways:</p>
<ol class="arabic simple">
<li>It is not modelled by a real constraint: this pair of nodes is used
to filter out solutions. <tt class="docutils literal"><span class="pre">PathOperator</span></tt>s take them into account in the
Local Search and</li>
<li>It doesn&#8217;t specify an order on the &#8220;ordered&#8221; pair <tt class="docutils literal"><span class="pre">(i,j)</span></tt> of nodes: node <tt class="docutils literal"><span class="pre">j</span></tt> could be visited before node <tt class="docutils literal"><span class="pre">i</span></tt>.</li>
</ol>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">The implementation of the <tt class="docutils literal"><span class="pre">PickupAndDelivery</span></tt> constraint in the RL is a little counter-intuitive.</p>
</div>
</div>
<div class="section" id="the-closemodel-method">
<h3>9.5.3.4. The <tt class="docutils literal"><span class="pre">CloseModel()</span></tt> method</h3>
<p>Because we don&#8217;t completely define the model when we construct the <tt class="docutils literal"><span class="pre">RoutingModel</span></tt> class, most
of the (implicit or explicit) constraints<a class="footnote-reference" href="#only-all-different-defined-in-routingmodel-constructor" id="id3">[3]</a>  and
the objective function are added in a special <tt class="docutils literal"><span class="pre">CloseModel()</span></tt> method.
This method is automatically called before a call to <tt class="docutils literal"><span class="pre">Solve()</span></tt> but if you want to inspect the model before, you need to
call this method explicitly. This method is also automatically called when you deal with <tt class="docutils literal"><span class="pre">Assignment</span></tt>s. In particular,
it is called by</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">ReadAssignment()</span></tt>;</li>
<li><tt class="docutils literal"><span class="pre">RestoreAssignment()</span></tt> and</li>
<li><tt class="docutils literal"><span class="pre">ReadAssignmentFromRoutes()</span></tt>.</li>
</ul>
<table class="docutils footnote" frame="void" id="only-all-different-defined-in-routingmodel-constructor" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>Actually, only an <tt class="docutils literal"><span class="pre">AllDifferent</span></tt> constraint on the
<tt class="docutils literal"><span class="pre">NextVar</span></tt>s is added in the constructor of the <tt class="docutils literal"><span class="pre">RoutingModel</span></tt> class. This constraint reinforces the fact that
you cannot visit a node twice.</td></tr>
</tbody>
</table>
</div>
</div>
<div class="section" id="the-objective-function">
<h2>9.5.4. The objective function</h2>
<p>The objective function is defined by an <tt class="docutils literal"><span class="pre">IntVar</span></tt>. To get access to it, call <tt class="docutils literal"><span class="pre">CostVar()</span></tt>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">IntVar</span><span class="o">*</span> <span class="k">const</span> <span class="n">obj</span> <span class="o">=</span> <span class="n">routing</span><span class="p">.</span><span class="n">CostVar</span><span class="p">();</span>
</pre></div>
</div>
<p>The RL solver tries to minimize this <tt class="docutils literal"><span class="pre">obj</span></tt> variable. The value of the objective function is the sum of:</p>
<ul class="simple">
<li>the costs of the arcs in each path;</li>
<li>a fixed cost of each route/vehicle;</li>
<li>the penalty costs for not visiting optional <tt class="docutils literal"><span class="pre">Disjunction</span></tt>s.</li>
</ul>
<p>We detail each of these costs.</p>
<div class="section" id="the-costs-of-the-arcs">
<h3>9.5.4.1. The costs of the arcs</h3>
<p>To set the cost of each arc, use a <tt class="docutils literal"><span class="pre">NodeEvaluator2</span></tt> callback to return the cost of each <tt class="docutils literal"><span class="pre">(i,j)</span></tt> arc:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">SetCost</span><span class="p">(</span><span class="n">NodeEvaluator2</span><span class="o">*</span> <span class="n">evaluator</span><span class="p">);</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">NodeEvaluator2</span></tt> is simply<a class="footnote-reference" href="#nodeevaluator2-cplusplus-jargon" id="id4">[4]</a> a <tt class="docutils literal"><span class="pre">typedef</span></tt> for a
<tt class="docutils literal"><span class="pre">ResultCallback2&lt;int64,</span> <span class="pre">NodeIndex,</span> <span class="pre">NodeIndex&gt;</span></tt>, i.e. a class that defines
an <tt class="docutils literal"><span class="pre">int64</span> <span class="pre">Run(NodeIndex</span> <span class="pre">i,</span> <span class="pre">NodeIndex</span> <span class="pre">j)</span></tt> or  method. If you already have a class that defines a distance method on
pairs of <tt class="docutils literal"><span class="pre">NodeIndex</span></tt>es, you can transform this class into a <tt class="docutils literal"><span class="pre">NodeEvaluator2</span></tt> with <tt class="docutils literal"><span class="pre">NewPermanentCallback()</span></tt>.</p>
<p>First, the class that computes the distances:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">ComputeDistances</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="n">int64</span> <span class="n">Distance</span><span class="p">(</span><span class="n">RoutingModel</span><span class="o">::</span><span class="n">NodeIndex</span> <span class="n">from</span><span class="p">,</span>
                 <span class="n">RoutingModel</span><span class="o">::</span><span class="n">NodeIndex</span> <span class="n">to</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">...;</span>
  <span class="p">}</span>
<span class="p">...</span>
<span class="p">;</span>
</pre></div>
</div>
<p>Then, the use of a <tt class="docutils literal"><span class="pre">NodeEvaluator2</span></tt> callback with <tt class="docutils literal"><span class="pre">NewPermanentCallback()</span></tt>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">RoutingModel</span> <span class="nf">routing</span><span class="p">(....);</span>
<span class="n">ComputeDistances</span> <span class="nf">my_distances_class</span><span class="p">(...);</span>
<span class="n">routing</span><span class="p">.</span><span class="n">SetCost</span><span class="p">(</span><span class="n">NewPermanentCallback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">my_distances_class</span><span class="p">,</span>
                                     <span class="o">&amp;</span><span class="n">ComputeDistances</span><span class="o">::</span><span class="n">Distance</span><span class="p">));</span>
</pre></div>
</div>
<p>You can also use a function:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">int64</span> <span class="nf">distance</span><span class="p">(</span><span class="n">RoutingModel</span><span class="o">::</span><span class="n">NodeIndex</span> <span class="n">i</span><span class="p">,</span>
               <span class="n">RoutingModel</span><span class="o">::</span><span class="n">NodeIndex</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">...;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>and use again <tt class="docutils literal"><span class="pre">NewPermanentCallback()</span></tt>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">routing</span><span class="p">.</span><span class="n">SetCost</span><span class="p">(</span><span class="n">NewPermanentCallback</span><span class="p">(</span><span class="o">&amp;</span><span class="n">distance</span><span class="p">));</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">NewPermanentCallback()</span></tt> is a (set of) function(s) that returns the appropriate callback class made from its arguments.
Some template magic might be involved too. <tt class="docutils literal"><span class="pre">ResultCallback2</span></tt> and <tt class="docutils literal"><span class="pre">NewPermanentCallback()</span></tt> are defined in the
header <tt class="file docutils literal"><span class="pre">base/callback.h</span></tt>. If you are curious about the callback mechanism and the use of <tt class="docutils literal"><span class="pre">NewPermanentCallback()</span></tt>,
read the sub-section <a class="reference internal" href="../under_the_hood/classes.html#under-the-hood-callbacks"><em>Callbacks</em></a>.</p>
<table class="docutils footnote" frame="void" id="nodeevaluator2-cplusplus-jargon" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>What follows is clearly C++ jargon. Basically, let&#8217;s say that you need a method or a
function that returns the distances of the arcs. To pass it as argument to the <tt class="docutils literal"><span class="pre">SetCost()</span></tt> method, wrap it in
a <tt class="docutils literal"><span class="pre">NewPermanentCallback()</span></tt> &#8220;call&#8221;.</td></tr>
</tbody>
</table>
</div>
<div class="section" id="a-fixed-cost-for-each-of-the-existing-routes">
<h3>9.5.4.2. A fixed cost for each of the existing routes</h3>
<p>Routes/Vehicles don&#8217;t all have to be used. It might cost less not to use a route/vehicle. To add a fixed cost
for each route/vehicle, use:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">SetRouteFixedCost</span><span class="p">(</span><span class="n">int64</span> <span class="n">cost</span><span class="p">);</span>
</pre></div>
</div>
<p>This <tt class="docutils literal"><span class="pre">int64</span></tt> cost will only be added for each route that contains at least one visited node, i.e. a different node
than the start and end nodes of the route.</p>
</div>
<div class="section" id="a-penalty-cost-for-missed-disjunctions">
<h3>9.5.4.3. A penalty cost for missed <tt class="docutils literal"><span class="pre">Disjunction</span></tt>s</h3>
<p>We have already seen the penalty costs for optional <tt class="docutils literal"><span class="pre">Disjunction</span></tt>s above. The penalty cost is only added to the
objective function for a missed <tt class="docutils literal"><span class="pre">Disjunction</span></tt>: the solution doesn&#8217;t visit any node of the <tt class="docutils literal"><span class="pre">Disjunction</span></tt>. If the given
penalty cost is negative for an optional <tt class="docutils literal"><span class="pre">Disjunction</span></tt>, this <tt class="docutils literal"><span class="pre">Disjunction</span></tt> becomes mandatory and the penalty is set to
zero. The penalty cost can be zero for optional <tt class="docutils literal"><span class="pre">Disjunction</span></tt> and you can model optional nodes by using
singletons for
each <tt class="docutils literal"><span class="pre">Disjunction</span></tt>.</p>
</div>
<div class="section" id="different-types-of-vehicles">
<h3>9.5.4.4. Different types of vehicles</h3>
<p>The cost for the arcs and the used routes/vehicles can be customized for each route/vehicle.</p>
<p>To customize the costs of the arcs, use:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">SetVehicleCost</span><span class="p">(</span><span class="kt">int</span> <span class="n">vehicle</span><span class="p">,</span> <span class="n">NodeEvaluator2</span><span class="o">*</span> <span class="n">evaluator</span><span class="p">);</span>
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">vehicle</span></tt> is the number of the route/vehicle.</p>
<p>To customize the fixed costs of the routes/vehicles, use:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">SetVehicleFixedCost</span><span class="p">(</span><span class="kt">int</span> <span class="n">vehicle</span><span class="p">,</span> <span class="n">int64</span> <span class="n">cost</span><span class="p">);</span>
</pre></div>
</div>
</div>
<div class="section" id="lower-bounds">
<h3>9.5.4.5. Lower bounds</h3>
<p>You can ask the RL to compute a <em>lower bound</em> on the objective function of your routing model by calling:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">int64</span> <span class="n">RoutingModel</span><span class="o">::</span><span class="n">ComputeLowerBound</span><span class="p">();</span>
</pre></div>
</div>
<p>This method does the following.</p>
<p>A <em>bipartite graph</em> is created with left nodes representing the nodes of the
routing problem and right nodes representing possible node successors. An
arc between a left node <tt class="docutils literal"><span class="pre">l</span></tt> and a right node <tt class="docutils literal"><span class="pre">r</span></tt> is created if <tt class="docutils literal"><span class="pre">r</span></tt> can be the
node following <tt class="docutils literal"><span class="pre">l</span></tt> in a route (<tt class="docutils literal"><span class="pre">NextVar(l)</span> <span class="pre">=</span> <span class="pre">r</span></tt>). The cost of the arc is the transit
cost between <tt class="docutils literal"><span class="pre">l</span></tt> and <tt class="docutils literal"><span class="pre">r</span></tt> in the routing problem. Solving a <em>Linear Assignment Problem</em>
(minimum-cost perfect bipartite matching) returns a lower bound. Did you get it? Let&#8217;s draw a figure.</p>
<img alt="../../_images/lb_assignment_problem.png" class="align-center" src="../../_images/lb_assignment_problem.png" style="width: 400pt;" />
<p>On the left (figure (a)), we have an original graph with two depots: a starting depot <img class="math" src="../../_images/math/dce34f4dfb2406144304ad0d6106c5382ddd1446.png" alt="1" style="vertical-align: -1px"/> and an ending depot
<img class="math" src="../../_images/math/79069377f91364c2f87a64e5f9f562a091c8a6c1.png" alt="5" style="vertical-align: 0px"/> and three transit nodes <img class="math" src="../../_images/math/e776ea524ca7e92dff794b92acf711ed57cd9367.png" alt="2,3" style="vertical-align: -4px"/> and <img class="math" src="../../_images/math/c7cab1a05e1e0c1d51a6a219d96577a16b7abf9d.png" alt="4" style="vertical-align: -1px"/>. On the right (figure (b)), we have a bipartite
graph<a class="footnote-reference" href="#bipartite-graph-not-really" id="id5">[5]</a> with the same number of left and right nodes. The cost on an arc <tt class="docutils literal"><span class="pre">(l,r)</span></tt> is
the real
transit cost from <tt class="docutils literal"><span class="pre">l</span></tt> to <tt class="docutils literal"><span class="pre">r</span></tt>. The Linear Assignment Problem consists in finding a perfect matching of minimum cost, i.e.
a bijection along the arcs between the two sets of nodes of the bipartite graph for a minimum cost. On figure (b), such
an optimal solution is depicted in thick blue dashed lines. As is the case here, this solution doesn&#8217;t
necessarily produce a (set of) closed route(s) from a starting depot to an
ending depot.</p>
<table class="docutils footnote" frame="void" id="bipartite-graph-not-really" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td>This bipartite graph is not really the one used by the CP solver but it&#8217;s close enough
to get the idea.</td></tr>
</tbody>
</table>
<p>The routing model must be closed before calling this method.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Routing Problems with <em>node disjunction constraints</em> (including optional
nodes) and <em>non-homogenous costs</em> are not supported yet (the method returns 0 in
these cases).</p>
</div>
<p>If your model is <em>linear</em>, you also can use the <em>linear relaxation</em> of your model.</p>
<p>We will explore these and other lower bounds in the section <em class="xref std std-ref">lower_bounds</em> when we&#8217;ll try to solve the Cumulative
Chinese Postman Problem.</p>
</div>
</div>
<div class="section" id="miscellaneous">
<h2>9.5.5. Miscellaneous</h2>
<p>We discuss here several improvements and conveniences of the RL.</p>
<div class="section" id="cache">
<h3>9.5.5.1. Cache</h3>
<p>[TO BE WRITTEN]</p>
</div>
<div class="section" id="light-constraints">
<h3>9.5.5.2. Light constraints</h3>
<p>To speed up the search, it is sometimes better to only propagate on the bounds instead of
the whole domains for the basic constraints. These &#8220;light&#8221; constraints are &#8220;checking&#8221; constraints,
only triggered on <tt class="docutils literal"><span class="pre">WhenBound()</span></tt> events. They provide very little (or no) domain filtering.</p>
<p>Basically, these constraints ensure that the variables are respecting the equalities of the basic
constraints. They only perform bound reduction on the variables when these variables are bound.</p>
<p>You can trigger the use of these light constraints with the following flag:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">DEFINE_bool</span><span class="p">(</span><span class="n">routing_use_light_propagation</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span>
       <span class="s">&quot;Use constraints with light propagation in routing model.&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>When <tt class="docutils literal"><span class="pre">false</span></tt>, the RL uses the regular constraints seen in the previous parts of this manual.
Try it, sometimes
you can get a serious speed up. These light constraints are especially useful in Local Search.</p>
</div>
<div class="section" id="locks">
<h3>9.5.5.3. Locks</h3>
<p>Often during the search, you find what appears to be good sub-solutions, i.e.
partial routes that seem promising and that you want to keep fixed for a while during the search. This can
easily be achieved by using <em>locks</em>.</p>
<p>A lock is simply an <tt class="docutils literal"><span class="pre">std::vector&lt;int64&gt;</span></tt> that represents a partial route. Using this <tt class="docutils literal"><span class="pre">lock</span></tt> ensures that</p>
<blockquote>
<div><tt class="docutils literal"><span class="pre">NextVar(lock[i])</span> <span class="pre">==</span> <span class="pre">lock[i+1]</span></tt></div></blockquote>
<p>is <tt class="docutils literal"><span class="pre">true</span></tt> in the current solution.</p>
<p>We will use locks in the section <em class="xref std std-ref">partial_routes</em> when we will try to solve the Cumulative Chinese Postman
Problem.</p>
</div>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<table>
<tr>
<td width="60"><img src="../../_static/logo.png" width="50" height="50"  alt="" /></td>
<td><p class="library_name">Google <a href="http://code.google.com/p/or-tools/"><strong>or-tools</strong></a><br>open source library</p></td>
</tr>
</table>
<h1>User's Manual</h1>

  
   



<h3>Google search</h3>

<form method="get" action="http://www.google.com/search">

<div style="padding:-1px;width:15em;">
<table border="0" cellpadding="0">
<tr><td>
<input type="text"   name="q" size="25"
 maxlength="255" value="" />
<input type="submit" value="Go" /></td></tr>
<tr><td align="center" style="font-size:80%">
Search:
<select name="sitesearch" width="125" style="width: 125px">
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/user_manual/" selected>user's manual</option>
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/faq/">faq</option>
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/reference_manual/or-tools/">reference manual</option>
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/">All or-tools doc</option>
</select>
</td></tr>
</table>
</div>

</form>
</br>




  <h3>Welcome</h3>
  
  <ul>
  	<li><a href="../../index.html">Content and foreword</a></li>
  	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html">Documentation's hub</a></li>
	<li><a href="http://code.google.com/p/or-tools/">The or-tools open source library</a></li></li>	
  </ul>
  
   
	


  <h3>Tutorial examples</h3>
  
  <ul>
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_C++">C++</a></li>
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_Python">Python</a></li>	
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_Java">Java</a></li>
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_Csharp">C#</a></li>
</ul>
  
   
	

  <h3>Current chapter</h3>
  <p class="topless"><a href="../TSP.html"
                        title="previous chapter">9. Travelling Salesman Problems with constraints: the TSP with time windows</a></p>
  <h3>Previous section</h3>
  <p class="topless"><a href="model_behind_scenes.html"
                        title="previous chapter">9.4. The model behind the scenes: the main decision variables</a></p>
  <h3>Next section</h3>
  <p class="topless"><a href="first_tsp_implementation.html"
                        title="next chapter">9.6. The TSP in or-tools</a></p>
  <h3>Current section</a></h3>
  <ul>
<li><a class="reference internal" href="#">9.5. The model behind the scenes: overview</a><ul>
<li><a class="reference internal" href="#the-routingmodel-class">9.5.1. The <tt class="docutils literal"><span class="pre">RoutingModel</span></tt> class</a></li>
<li><a class="reference internal" href="#variables">9.5.2. Variables</a><ul>
<li><a class="reference internal" href="#path-variables">9.5.2.1. Path variables</a><ul>
<li><a class="reference internal" href="#main-decision-variables">9.5.2.1.1. Main decision variables</a></li>
<li><a class="reference internal" href="#vehicles">9.5.2.1.2. Vehicles</a></li>
<li><a class="reference internal" href="#disjunctions-and-optional-nodes">9.5.2.1.3. <tt class="docutils literal"><span class="pre">Disjunction</span></tt>s and optional nodes</a></li>
</ul>
</li>
<li><a class="reference internal" href="#dimension-variables">9.5.2.2. Dimension variables</a></li>
</ul>
</li>
<li><a class="reference internal" href="#constraints">9.5.3. Constraints</a><ul>
<li><a class="reference internal" href="#no-cycle-constraint">9.5.3.1. No cycle constraint</a></li>
<li><a class="reference internal" href="#disjunction-constraints">9.5.3.2. <tt class="docutils literal"><span class="pre">Disjunction</span></tt> constraints</a></li>
<li><a class="reference internal" href="#pick-up-and-delivery-constraints">9.5.3.3. Pick-up and delivery constraints</a></li>
<li><a class="reference internal" href="#the-closemodel-method">9.5.3.4. The <tt class="docutils literal"><span class="pre">CloseModel()</span></tt> method</a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-objective-function">9.5.4. The objective function</a><ul>
<li><a class="reference internal" href="#the-costs-of-the-arcs">9.5.4.1. The costs of the arcs</a></li>
<li><a class="reference internal" href="#a-fixed-cost-for-each-of-the-existing-routes">9.5.4.2. A fixed cost for each of the existing routes</a></li>
<li><a class="reference internal" href="#a-penalty-cost-for-missed-disjunctions">9.5.4.3. A penalty cost for missed <tt class="docutils literal"><span class="pre">Disjunction</span></tt>s</a></li>
<li><a class="reference internal" href="#different-types-of-vehicles">9.5.4.4. Different types of vehicles</a></li>
<li><a class="reference internal" href="#lower-bounds">9.5.4.5. Lower bounds</a></li>
</ul>
</li>
<li><a class="reference internal" href="#miscellaneous">9.5.5. Miscellaneous</a><ul>
<li><a class="reference internal" href="#cache">9.5.5.1. Cache</a></li>
<li><a class="reference internal" href="#light-constraints">9.5.5.2. Light constraints</a></li>
<li><a class="reference internal" href="#locks">9.5.5.3. Locks</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="first_tsp_implementation.html" title="9.6. The TSP in or-tools"
             >next</a> |</li>
        <li class="right" >
          <a href="model_behind_scenes.html" title="9.4. The model behind the scenes: the main decision variables"
             >previous</a> |</li>
        <li><a href="../../index.html">or-tools User&#39;s Manual</a> &raquo;</li>
          <li><a href="../TSP.html" >9. Travelling Salesman Problems with constraints: the TSP with time windows</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012-2014, Google.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>