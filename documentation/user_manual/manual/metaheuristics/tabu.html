

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>7.4. Tabu Search (TS) &mdash; or-tools User&#39;s Manual</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     'doc version 0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../_static/logo.ico"/>
    <link rel="top" title="or-tools User&#39;s Manual" href="../../index.html" />
    <link rel="up" title="7. Meta-heuristics: several previous problems" href="../metaheuristics.html" />
    <link rel="next" title="7.5. Simulated Annealing (SA)" href="SA.html" />
    <link rel="prev" title="7.3. Meta-heuristics in or-tools" href="metaheuristics.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="SA.html" title="7.5. Simulated Annealing (SA)"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="metaheuristics.html" title="7.3. Meta-heuristics in or-tools"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">or-tools User&#39;s Manual</a> &raquo;</li>
          <li><a href="../metaheuristics.html" accesskey="U">7. Meta-heuristics: several previous problems</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="tabu-search-ts">
<span id="tabu"></span><h1>7.4. Tabu Search (TS)</h1>
<p>This meta-heuristic was invented in the eighties and has been quite successful to produce very good solutions for most
problems. Well implemented, it can be very efficient. We describe here our generic and therefor simple implementation. We&#8217;ll again
develop and discuss the whole code. Not only will you know exactly what to expect from our implementation but it can also serve as an example
for your own implementation of a meta-heuristic with the <strong>or-tools</strong> library.</p>
<div class="section" id="the-basic-idea">
<h2>7.4.1. The basic idea<a class="footnote-reference" href="#tabu-search-basic-idea" id="id1">[1]</a></h2>
<p>The basic idea is to avoid
being trapped in a local optimum by making some <em>features</em> of a solution <em>tabu</em>:
we don&#8217;t want to produce any solution with these features for a certain period of time.
This period of time is called a <strong>tenure</strong>. If we choose these features well, not only do we have the guarantee
that we will not reproduce the local optimum again (because it has these features) but we might get out of the vicinity of this local
optimum and explore more promising neighborhoods. This is called the <strong>diversification</strong> phase: we seek to find solutions with different
features than previously obtained. Once you find a good solution, you might want
to explore solutions &#8220;close&#8221; to it. If you manage to find what features is important for a solution, you might want to keep them to explore similar solutions.
This is called the <strong>intensification</strong> phase: we seek to find solutions with similar (or the same) features to a (or several) given solution(s). We keep two lists: one for forbidden features and one for features to keep in the next solutions.
The Tabu Search oscillates between these two phases: <em>diversification</em> to avoid being trapped in local optima and also explore other parts of the search space and <em>intensification</em> to search more in details a
promising neighborhood.</p>
<p>We only have scratched the surface of the Tabu Search meta-heuristic. If you want to know more about TS, the classical book by Glover and Laguna <a class="reference internal" href="#glover1997">[Glover1997]</a> is still a good reference. Another good reference is <a class="reference internal" href="#gendreau2005">[Gendreau2005]</a>. To have an up to date account on this topic, search the Internet: there are <em>plenty</em> of documents about TS.</p>
</div>
<div class="section" id="our-implementation">
<h2>7.4.2. Our implementation</h2>
<p>Our implementation only deals with <tt class="docutils literal"><span class="pre">IntVar</span></tt> variables. Because our implementation is quite generic and can be used with any <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt> and any problem, the features of a solution we consider are the given <tt class="docutils literal"><span class="pre">IntVar</span></tt> variables and their values. In <em>intensification</em> mode, we will keep certain
variables fixed, i.e. bounded to a certain value and in <em>diversification</em> mode, we will forbid some variables to take some values.  Actually, we mix both modes: we use two <em>tenures</em>: <tt class="docutils literal"><span class="pre">keep_tenure</span></tt> and <tt class="docutils literal"><span class="pre">forbid_tenure</span></tt>. We also keep two lists of variables:
<tt class="docutils literal"><span class="pre">keep_tabu_list_</span></tt> and <tt class="docutils literal"><span class="pre">forbid_tabu_list_</span></tt>: variables in the <tt class="docutils literal"><span class="pre">keep_tabu_list_</span></tt>  must keep their values and variables in the <tt class="docutils literal"><span class="pre">forbid_tabu_list_</span></tt> can not use the corresponding values. To see what variables are selected and added to those lists, you have to look at the code below. They will be kept in the lists for a certain <em>tenure</em>. The <em>tenure</em> can be seen as a certain amount of time or a certain number
of iterations. In our case, we consider each time a new neighbor (candidate solution) is selected by the Local Search algorithm. We keep a variable <tt class="docutils literal"><span class="pre">stamp_</span></tt> that counts the number of iterations. Because we only start the Tabu Search after the <em>first</em> optimum is reached, this variable is at 0 until the first local optimum is reached. After that,
every time a candidate solution is selected (including the starting solution when the Local Search starts again after finding a local optimum), this variable is incremented.</p>
<p>Our <em>aspiration</em> criterion is simple: a solution is accepted no matter what <strong>if</strong> it is better than any other solution encountered so far.
Because of this aspiration criterion, our <tt class="docutils literal"><span class="pre">TabuSearch</span></tt> <tt class="docutils literal"><span class="pre">Metaheuristic</span></tt> only add constraints. No variable has its domain skimmed or its value fixed. These additional constraints always allow for a better solution to be accepted. To do so, we use a Boolean <tt class="docutils literal"><span class="pre">IntVar</span></tt> <tt class="docutils literal"><span class="pre">aspiration</span></tt> variable and a Boolean <tt class="docutils literal"><span class="pre">IntVar</span></tt> <tt class="docutils literal"><span class="pre">tabu</span></tt> variable: one of the two has to be equal to 1.</p>
<div class="section" id="some-helpers">
<h3>7.4.2.1. Some helpers</h3>
<p>To know what a given variable should keep as value or not and how long, we define a simple <tt class="docutils literal"><span class="pre">VarValue</span></tt> <tt class="docutils literal"><span class="pre">struct</span></tt>:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">VarValue</span> <span class="p">{</span>
  <span class="n">VarValue</span><span class="p">(</span><span class="n">IntVar</span><span class="o">*</span> <span class="k">const</span> <span class="n">var</span><span class="p">,</span> <span class="n">int64</span> <span class="n">value</span><span class="p">,</span> <span class="n">int64</span> <span class="n">stamp</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">var_</span><span class="p">(</span><span class="n">var</span><span class="p">),</span> <span class="n">value_</span><span class="p">(</span><span class="n">value</span><span class="p">),</span> <span class="n">stamp_</span><span class="p">(</span><span class="n">stamp</span><span class="p">)</span> <span class="p">{}</span>
  <span class="n">IntVar</span><span class="o">*</span> <span class="k">const</span> <span class="n">var_</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">int64</span> <span class="n">value_</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">int64</span> <span class="n">stamp_</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Our lists will be declared as:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">VarValue</span><span class="o">&gt;</span> <span class="n">TabuList</span><span class="p">;</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">std::list</span></tt> can be used as a FIFO list, i.e. a queue<a class="footnote-reference" href="#fifo-list-as-queue" id="id4">[2]</a>. You can add an element at the beginning of the queue/list with its <tt class="docutils literal"><span class="pre">push_front()</span></tt> method and retrieve an element at the end of the queue/list with its <tt class="docutils literal"><span class="pre">pop_back()</span></tt> method.
To update a list with respect to the time/iterations/tenures, we chop off the tail of the list whenever an element is outdated:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">AgeList</span><span class="p">(</span><span class="n">int64</span> <span class="n">tenure</span><span class="p">,</span> <span class="n">TabuList</span><span class="o">*</span> <span class="n">list</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">list</span><span class="o">-&gt;</span><span class="n">empty</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">list</span><span class="o">-&gt;</span><span class="n">back</span><span class="p">().</span><span class="n">stamp_</span> <span class="o">&lt;</span> <span class="n">stamp_</span> <span class="o">-</span> <span class="n">tenure</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">list</span><span class="o">-&gt;</span><span class="n">pop_back</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The real method called is <tt class="docutils literal"><span class="pre">AgeLists()</span></tt> because it updates both lists and increment the <tt class="docutils literal"><span class="pre">stamp_</span></tt> variable.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">AgeLists</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">AgeList</span><span class="p">(</span><span class="n">keep_tenure_</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">keep_tabu_list_</span><span class="p">);</span>
  <span class="n">AgeList</span><span class="p">(</span><span class="n">forbid_tenure_</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">forbid_tabu_list_</span><span class="p">);</span>
  <span class="o">++</span><span class="n">stamp_</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="the-constructor-and-the-variables">
<h3>7.4.2.2. The constructor and the variables</h3>
<p>Let&#8217;s start with the (private) variables of the <tt class="docutils literal"><span class="pre">TabuSearch</span></tt> class:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IntVar</span><span class="o">*&gt;</span> <span class="n">vars_</span><span class="p">;</span>
<span class="n">Assignment</span> <span class="n">assignment_</span><span class="p">;</span>
<span class="n">int64</span> <span class="n">last_</span><span class="p">;</span>
<span class="n">TabuList</span> <span class="n">keep_tabu_list_</span><span class="p">;</span>
<span class="n">int64</span> <span class="n">keep_tenure_</span><span class="p">;</span>
<span class="n">TabuList</span> <span class="n">forbid_tabu_list_</span><span class="p">;</span>
<span class="n">int64</span> <span class="n">forbid_tenure_</span><span class="p">;</span>
<span class="kt">double</span> <span class="n">tabu_factor_</span><span class="p">;</span>
<span class="n">int64</span> <span class="n">stamp_</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">found_initial_solution_</span><span class="p">;</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">vars_</span></tt> are the variables to use in
both Tabu lists. Because of the genericity of our implementation, these variables <strong>must</strong> be used (changed) by the <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt><a class="footnote-reference" href="#tabu-vars-must-be-changed-by-local-search-operator" id="id5">[3]</a>.
We keep an <tt class="docutils literal"><span class="pre">Assignment</span></tt> with the last found solution and store its objective value in the <tt class="docutils literal"><span class="pre">last_</span></tt> variable. With the variables inherited from the <tt class="docutils literal"><span class="pre">Metaheuristic</span></tt> class, this will allow us to play with
the <tt class="docutils literal"><span class="pre">last_</span></tt>, <tt class="docutils literal"><span class="pre">current_</span></tt> and <tt class="docutils literal"><span class="pre">best_</span></tt> values.</p>
<p>Both Tabu lists and corresponding tenures have quite explicit names: <tt class="docutils literal"><span class="pre">keep_tabu_list_</span></tt> and <tt class="docutils literal"><span class="pre">keep_tenure_</span></tt> for the to be kept features list and <tt class="docutils literal"><span class="pre">forbid_tabu_list_</span></tt> and <tt class="docutils literal"><span class="pre">forbid_tenure_</span></tt> for the
forbidden features list.</p>
<p>The <tt class="docutils literal"><span class="pre">tabu_factor_</span></tt> variable is a percentage of the number of variables that are following the Tabu guidelines.  If equal to 1.0, it means that <strong>all</strong> variables must follow the Tabu guidelines or in other words, no violation of the Tabu criteria is allowed (except when the aspiration criterion kicks in). If equal to 0.0, <strong>no</strong> variable must follow the Tabu guidelines or in other words, the Tabu criteria can be fully violated.</p>
<p><tt class="docutils literal"><span class="pre">stamp_</span></tt> is a counter with the number of iterations. Until the Tabu Search is really launched, this counter stays at 0. Finally, <tt class="docutils literal"><span class="pre">found_initial_solution_</span></tt> is a Boolean that indicates if an initial
solution has been found or not.</p>
<p>The constructor is quite straightforward:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">TabuSearch</span><span class="p">(</span><span class="n">Solver</span><span class="o">*</span> <span class="k">const</span> <span class="n">s</span><span class="p">,</span>
           <span class="kt">bool</span> <span class="n">maximize</span><span class="p">,</span>
           <span class="n">IntVar</span><span class="o">*</span> <span class="n">objective</span><span class="p">,</span>
           <span class="n">int64</span> <span class="n">step</span><span class="p">,</span>
           <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IntVar</span><span class="o">*&gt;&amp;</span> <span class="n">vars</span><span class="p">,</span>
           <span class="n">int64</span> <span class="n">keep_tenure</span><span class="p">,</span>
           <span class="n">int64</span> <span class="n">forbid_tenure</span><span class="p">,</span>
           <span class="kt">double</span> <span class="n">tabu_factor</span><span class="p">)</span>
</pre></div>
</div>
<p><tt class="docutils literal"><span class="pre">step</span></tt> denotes the decrease/increase of the objective value sought after each found feasible solution. Because it is not dynamically changed, you probably want to keep this variable at 1. This value is kept
in the inherited variable <tt class="docutils literal"><span class="pre">step_</span></tt>.</p>
<p>Now that we have met the variables and helpers, we can discuss the callbacks of the <tt class="docutils literal"><span class="pre">TabuSearch</span></tt> class. We ordered them below in a way to gradually have a big picture of our algorithmic implementation, <strong>not</strong>
in the order they are called.</p>
</div>
<div class="section" id="localoptimum">
<h3>7.4.2.3. <tt class="docutils literal"><span class="pre">LocalOptimum()</span></tt></h3>
<p>The <tt class="docutils literal"><span class="pre">LocalOptimum()</span></tt> method is called whenever a nested Local Search is finished. If one <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt> returns <tt class="docutils literal"><span class="pre">true</span></tt> in its <tt class="docutils literal"><span class="pre">LocalOptimum</span></tt> callback, the Local Search is restarted and the search continues.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="nf">LocalOptimum</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">AgeLists</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">maximize_</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">current_</span> <span class="o">=</span> <span class="n">kint64min</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">current_</span> <span class="o">=</span> <span class="n">kint64max</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">found_initial_solution_</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This method launches the Tabu Search. Indeed, by calling <tt class="docutils literal"><span class="pre">AgeLists()</span></tt>, the <tt class="docutils literal"><span class="pre">stamp_</span></tt> variable is incremented and all the code in the <tt class="docutils literal"><span class="pre">if</span> <span class="pre">(0</span> <span class="pre">!=</span> <span class="pre">stamp_)</span></tt> condition (see below) can be executed. As the Local Search will be relaunched, this method also updates the <tt class="docutils literal"><span class="pre">current_</span></tt> variable. Finally, if an initial solution has been found, the method returns <tt class="docutils literal"><span class="pre">True</span></tt> to continue the Local Search. If no solution has been
previously found, the search is aborted.</p>
</div>
<div class="section" id="acceptneighbor">
<h3>7.4.2.4. <tt class="docutils literal"><span class="pre">AcceptNeighbor()</span></tt></h3>
<p>The <tt class="docutils literal"><span class="pre">AcceptNeighbor()</span></tt> method is called whenever a candidate solution is selected  to be the next solution in the Local Search algorithm<a class="footnote-reference" href="#accepted-solution-in-ls" id="id6">[4]</a>.
More precisely, it is called in the <tt class="docutils literal"><span class="pre">Next()</span></tt> method of the <tt class="docutils literal"><span class="pre">FindOneNeighbor</span></tt> <tt class="docutils literal"><span class="pre">DecisionBuilder</span></tt>. This is called an iteration in the Local Search.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">TabuSearch</span><span class="o">::</span><span class="n">AcceptNeighbor</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">!=</span> <span class="n">stamp_</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">AgeLists</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We age both lists and increment the <tt class="docutils literal"><span class="pre">stamp_</span></tt> variable to acknowledge the iteration <strong>if</strong> we have already obtained a local optimum in the Local Search.</p>
</div>
<div class="section" id="atsolution">
<h3>7.4.2.5. <tt class="docutils literal"><span class="pre">AtSolution()</span></tt></h3>
<p>The <tt class="docutils literal"><span class="pre">AtSolution()</span></tt> method is called whenever a solution is found and accepted in the Local Search. It called in the <tt class="docutils literal"><span class="pre">NextSolution()</span></tt> method of the current search of the CP Solver.</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">bool</span> <span class="nf">AtSolution</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Metaheuristic</span><span class="o">::</span><span class="n">AtSolution</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">found_initial_solution_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="n">last_</span> <span class="o">=</span> <span class="n">current_</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">!=</span> <span class="n">stamp_</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vars_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">IntVar</span><span class="o">*</span> <span class="k">const</span> <span class="n">var</span> <span class="o">=</span> <span class="n">vars_</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
      <span class="k">const</span> <span class="n">int64</span> <span class="n">old_value</span> <span class="o">=</span> <span class="n">assignment_</span><span class="p">.</span><span class="n">Value</span><span class="p">(</span><span class="n">var</span><span class="p">);</span>
      <span class="k">const</span> <span class="n">int64</span> <span class="n">new_value</span> <span class="o">=</span> <span class="n">var</span><span class="o">-&gt;</span><span class="n">Value</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">old_value</span> <span class="o">!=</span> <span class="n">new_value</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">VarValue</span> <span class="n">keep_value</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">new_value</span><span class="p">,</span> <span class="n">stamp_</span><span class="p">);</span>
        <span class="n">keep_tabu_list_</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="n">keep_value</span><span class="p">);</span>
        <span class="n">VarValue</span> <span class="n">forbid_value</span><span class="p">(</span><span class="n">var</span><span class="p">,</span> <span class="n">old_value</span><span class="p">,</span> <span class="n">stamp_</span><span class="p">);</span>
        <span class="n">forbid_tabu_list_</span><span class="p">.</span><span class="n">push_front</span><span class="p">(</span><span class="n">forbid_value</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="n">assignment_</span><span class="p">.</span><span class="n">Store</span><span class="p">();</span>

  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>On lines 2 to 6, we update the <tt class="docutils literal"><span class="pre">current_</span></tt>, <tt class="docutils literal"><span class="pre">last_</span></tt> and <tt class="docutils literal"><span class="pre">best_</span></tt> values. We also set <tt class="docutils literal"><span class="pre">found_initial_solution_</span></tt> since we have a solution and hence an initial solution.
On line 21 we store the current solution. This allows us to keep the values of the variables and compare them with a new solution as we do in the lines 8 to 20. These lines are only
processed if we have reached our first local optimum (<tt class="docutils literal"><span class="pre">if</span> <span class="pre">(stamp_</span> <span class="pre">!=</span> <span class="pre">0)</span> <span class="pre">{...}</span></tt>). If this is the case, we consider among the variables given to the constructor, those that have changed since last
solution (<tt class="docutils literal"><span class="pre">if</span> <span class="pre">(old_value</span> <span class="pre">!=</span> <span class="pre">new_value)</span> <span class="pre">{}</span></tt>). We force those variables to keep their new values for <tt class="docutils literal"><span class="pre">keep_tenure</span></tt> iterations and forbid them to take their old value for <tt class="docutils literal"><span class="pre">forbid_tenure</span></tt> iterations.
Depending on the value of <tt class="docutils literal"><span class="pre">forbid_tenure</span></tt>, you can forbid a variable to take several values.</p>
<p>Because we want the search to resume, we return <tt class="docutils literal"><span class="pre">true</span></tt>.</p>
</div>
<div class="section" id="applydecision">
<h3>7.4.2.6. <tt class="docutils literal"><span class="pre">ApplyDecision()</span></tt></h3>
<p>The <tt class="docutils literal"><span class="pre">ApplyDecision()</span></tt> method is called when a <tt class="docutils literal"><span class="pre">Decision</span></tt> is about to be applied. This is the place to add the constraints.</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">void</span> <span class="n">TabuSearch</span><span class="o">::</span><span class="n">ApplyDecision</span><span class="p">(</span><span class="n">Decision</span><span class="o">*</span> <span class="k">const</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Solver</span><span class="o">*</span> <span class="k">const</span> <span class="n">s</span> <span class="o">=</span> <span class="n">solver</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">==</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">balancing_decision</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">IntVar</span><span class="o">*</span> <span class="n">aspiration</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">MakeBoolVar</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">maximize_</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">AddConstraint</span><span class="p">(</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">MakeIsGreaterOrEqualCstCt</span><span class="p">(</span><span class="n">objective_</span><span class="p">,</span> <span class="n">best_</span> <span class="o">+</span> <span class="n">step_</span><span class="p">,</span>
                                                           <span class="n">aspiration</span><span class="p">));</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">AddConstraint</span><span class="p">(</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">MakeIsLessOrEqualCstCt</span><span class="p">(</span><span class="n">objective_</span><span class="p">,</span> <span class="n">best_</span> <span class="o">-</span> <span class="n">step_</span><span class="p">,</span>
                                                           <span class="n">aspiration</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IntVar</span><span class="o">*&gt;</span> <span class="n">tabu_vars</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">VarValue</span><span class="o">&amp;</span> <span class="n">vv</span> <span class="o">:</span> <span class="n">keep_tabu_list_</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">IntVar</span><span class="o">*</span> <span class="n">tabu_var</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">MakeBoolVar</span><span class="p">();</span>
    <span class="n">Constraint</span><span class="o">*</span> <span class="n">keep_cst</span> <span class="o">=</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">MakeIsEqualCstCt</span><span class="p">(</span><span class="n">vv</span><span class="p">.</span><span class="n">var_</span><span class="p">,</span> <span class="n">vv</span><span class="p">.</span><span class="n">value_</span><span class="p">,</span> <span class="n">tabu_var</span><span class="p">);</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">AddConstraint</span><span class="p">(</span><span class="n">keep_cst</span><span class="p">);</span>
    <span class="n">tabu_vars</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tabu_var</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="n">VarValue</span><span class="o">&amp;</span> <span class="n">vv</span> <span class="o">:</span> <span class="n">forbid_tabu_list_</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">IntVar</span><span class="o">*</span> <span class="n">tabu_var</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">MakeBoolVar</span><span class="p">();</span>
    <span class="n">Constraint</span><span class="o">*</span> <span class="n">forbid_cst</span> <span class="o">=</span>
        <span class="n">s</span><span class="o">-&gt;</span><span class="n">MakeIsDifferentCstCt</span><span class="p">(</span><span class="n">vv</span><span class="p">.</span><span class="n">var_</span><span class="p">,</span> <span class="n">vv</span><span class="p">.</span><span class="n">value_</span><span class="p">,</span> <span class="n">tabu_var</span><span class="p">);</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">AddConstraint</span><span class="p">(</span><span class="n">forbid_cst</span><span class="p">);</span>
    <span class="n">tabu_vars</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tabu_var</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">tabu_vars</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">IntVar</span><span class="o">*</span> <span class="n">tabu</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">MakeBoolVar</span><span class="p">();</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">AddConstraint</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">MakeIsGreaterOrEqualCstCt</span><span class="p">(</span>
                                        <span class="n">s</span><span class="o">-&gt;</span><span class="n">MakeSum</span><span class="p">(</span><span class="n">tabu_vars</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Var</span><span class="p">(),</span>
                                        <span class="n">tabu_vars</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">*</span> <span class="n">tabu_factor_</span><span class="p">,</span>
                                        <span class="n">tabu</span><span class="p">));</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">AddConstraint</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">MakeGreaterOrEqual</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">MakeSum</span><span class="p">(</span><span class="n">aspiration</span><span class="p">,</span> <span class="n">tabu</span><span class="p">),</span>
                                           <span class="mi">1LL</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">maximize_</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">int64</span> <span class="n">bound</span> <span class="o">=</span> <span class="p">(</span><span class="n">current_</span> <span class="o">&gt;</span> <span class="n">kint64min</span><span class="p">)</span> <span class="o">?</span>
                                            <span class="n">current_</span> <span class="o">+</span> <span class="n">step_</span> <span class="o">:</span> <span class="n">current_</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">AddConstraint</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">MakeGreaterOrEqual</span><span class="p">(</span><span class="n">objective_</span><span class="p">,</span> <span class="n">bound</span><span class="p">));</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">int64</span> <span class="n">bound</span> <span class="o">=</span> <span class="p">(</span><span class="n">current_</span> <span class="o">&lt;</span> <span class="n">kint64max</span><span class="p">)</span> <span class="o">?</span>
                                            <span class="n">current_</span> <span class="o">-</span> <span class="n">step_</span> <span class="o">:</span> <span class="n">current_</span><span class="p">;</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">AddConstraint</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">MakeLessOrEqual</span><span class="p">(</span><span class="n">objective_</span><span class="p">,</span> <span class="n">bound</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">found_initial_solution_</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">s</span><span class="o">-&gt;</span><span class="n">AddConstraint</span><span class="p">(</span><span class="n">s</span><span class="o">-&gt;</span><span class="n">MakeNonEquality</span><span class="p">(</span><span class="n">objective_</span><span class="p">,</span> <span class="n">last_</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>After quickly screening the content of this method, you might be curious about why we didn&#8217;t encapsulate any code in a <tt class="docutils literal"><span class="pre">if</span> <span class="pre">(0</span> <span class="pre">!=</span> <span class="pre">stamp_)</span> <span class="pre">{...}</span></tt>. The reason is simple, we need to be able
to &#8220;revert&#8221; to &#8220;any&#8221; solution at any time <strong>if</strong> the aspiration criteria is used. At the same time (lines 43 to 51), we force the solver to produce better solutions as an <tt class="docutils literal"><span class="pre">OptimizeVar</span></tt> <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt> would<a class="footnote-reference" href="#optimize-var-does-not-add-constraint" id="id7">[5]</a>. We also add (lines 53 to 55) a constraint to forbid obtaining solutions with the same values and thus avoid plateaus (i.e. solutions with the exact same objective value
one after the other).
Let&#8217;s discuss the other lines.</p>
<p>Lines 3 to 5 are technical. Whenever we have the unique <tt class="docutils literal"><span class="pre">BalancingDecision</span></tt>, we know that we shouldn&#8217;t do anything and let it pass. Lines 7 to 16 is about our aspiration criterion: we accept
a neighbor (candidate solution) if it improves the best solution found so far. These constraints allow to accept solutions that will be found in the future and are considered Tabu. Lines 18 to 41 are dedicated to add the corresponding
constraints for the Tabu Search mechanism. First (lines 19 to 25) to store some features then (lines 26 to 32) to forbid some other features. Each time, a <tt class="docutils literal"><span class="pre">BoolVar</span></tt> variable corresponding to the added equality (lines 21 to 23) or inequality (lines 28 to 30) is created and added to the <tt class="docutils literal"><span class="pre">std::vector&lt;IntVar*&gt;</span></tt>  <tt class="docutils literal"><span class="pre">tabu_vars</span></tt> list.
This list is then used (lines 35 to 38) to control how many of these variables (<tt class="docutils literal"><span class="pre">tabu_vars.size()</span> <span class="pre">*</span> <span class="pre">tabu_factor_</span></tt>) should really
follow or not the Tabu criteria. Finally, line 39 adds a constraint to balance the Tabu and aspiration criteria.</p>
</div>
</div>
<div class="section" id="first-results">
<span id="tabu-search-first-results"></span><h2>7.4.3. First results</h2>
<div class="files-sidebar container">
<ol>
  <li>C++ code:
    <ol>
      <li><a href="../../../tutorials/cplusplus/chap7/jobshop.h">jobshop.h</a></li>
      <li><a href="../../../tutorials/cplusplus/chap7/jobshop_ls.h">jobshop_ls.h</a></li>
      <li><a href="../../../tutorials/cplusplus/chap7/limits.h">limits.h</a></li>
      <li><a href="../../../tutorials/cplusplus/chap7/jobshop_ts1.cc">jobshop_ts1.cc</a></li>
      <li><a href="../../../tutorials/cplusplus/chap7/jobshop_ts2.cc">jobshop_ts2.cc</a></li>
    </ol>
  </li>
  <li>Data file:
    <ol>
      <li><a href="../../../tutorials/cplusplus/chap6/abz9">abz9</a></li>
    </ol>
  </li>

</ol></div>
<p>The code found in the file <tt class="file docutils literal"><span class="pre">jobshop_ts1.cc</span></tt> is very similar to the code in <tt class="file docutils literal"><span class="pre">jobshop_ls1.cc</span></tt> from the previous chapter.
We only use the <tt class="docutils literal"><span class="pre">SwapIntervals</span></tt> <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt> in the Local Search to solve the Job-Shop Problem<a class="footnote-reference" href="#dont-know-jobshop-problem" id="id8">[6]</a> because we want to quickly reach a Local Optimum and
compare both Local Searches with and without Tabu Search.</p>
<p>As in <tt class="file docutils literal"><span class="pre">jobshop_ls1.cc</span></tt>, we don&#8217;t devise any specialized search strategy and we use the basic <tt class="docutils literal"><span class="pre">Solver::CHOOSE_RANDOM_RANK_FORWARD</span></tt> strategy to rank all tasks and then the basic
<tt class="docutils literal"><span class="pre">Solver::CHOOSE_FIRST_UNBOUND</span></tt> with <tt class="docutils literal"><span class="pre">Solver::ASSIGN_MIN_VALUE</span></tt> to schedule each task at its earliest start time.</p>
<p>One main difference with the code in <tt class="file docutils literal"><span class="pre">jobshop_ls1.cc</span></tt> is that we <em>don&#8217;t</em> use an <tt class="docutils literal"><span class="pre">OptimizeVar</span></tt> <tt class="docutils literal"><span class="pre">SearchOperator</span></tt> but rely on the <tt class="docutils literal"><span class="pre">TabuSearch</span></tt> <tt class="docutils literal"><span class="pre">Metaheuristic</span></tt> to minimize the <tt class="docutils literal"><span class="pre">objective_var</span></tt>
<tt class="docutils literal"><span class="pre">IntVar</span></tt> variable.</p>
<p>What are the variables we will use with the <tt class="docutils literal"><span class="pre">TabuSearch</span></tt> class? As it only accepts (pointers to) <tt class="docutils literal"><span class="pre">IntVar</span></tt>s, we will use the associated <tt class="docutils literal"><span class="pre">IntVar</span></tt> that represents the “ranking” of the <tt class="docutils literal"><span class="pre">IntervalVar</span></tt>s
in the ranked sequence<a class="footnote-reference" href="#sequence-vars-explained" id="id9">[7]</a>. This is exactly what the <tt class="docutils literal"><span class="pre">Next()</span></tt> method of the <tt class="docutils literal"><span class="pre">SequenceVar</span></tt> class returns:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IntVar</span><span class="o">*&gt;</span> <span class="n">tabu_vars</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">seq</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">seq</span> <span class="o">&lt;</span> <span class="n">all_sequences</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">seq</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">SequenceVar</span> <span class="o">*</span> <span class="n">seq_var</span> <span class="o">=</span> <span class="n">all_sequences</span><span class="p">[</span><span class="n">seq</span><span class="p">];</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">interval</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">interval</span> <span class="o">&lt;</span> <span class="n">seq_var</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">interval</span> <span class="p">)</span> <span class="p">{</span>
    <span class="n">IntVar</span> <span class="o">*</span> <span class="n">next</span> <span class="o">=</span> <span class="n">seq_var</span><span class="o">-&gt;</span><span class="n">Next</span><span class="p">(</span><span class="n">interval</span><span class="p">);</span>
    <span class="n">tabu_vars</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">next</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To create a <tt class="docutils literal"><span class="pre">TabuSearch</span></tt> instance, there is the following factory method:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">SearchMonitor</span><span class="o">*</span> <span class="n">Solver</span><span class="o">::</span><span class="n">MakeTabuSearch</span><span class="p">(</span><span class="kt">bool</span> <span class="n">maximize</span><span class="p">,</span> <span class="n">IntVar</span><span class="o">*</span> <span class="k">const</span> <span class="n">v</span><span class="p">,</span>
                           <span class="n">int64</span> <span class="n">step</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IntVar</span><span class="o">*&gt;&amp;</span> <span class="n">vars</span><span class="p">,</span>
                           <span class="n">int64</span> <span class="n">keep_tenure</span><span class="p">,</span> <span class="n">int64</span> <span class="n">forbid_tenure</span><span class="p">,</span>
                           <span class="kt">double</span> <span class="n">tabu_factor</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">RevAlloc</span><span class="p">(</span><span class="k">new</span> <span class="n">TabuSearch</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">maximize</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">vars</span><span class="p">,</span>
                                   <span class="n">keep_tenure</span><span class="p">,</span> <span class="n">forbid_tenure</span><span class="p">,</span>
                                   <span class="n">tabu_factor</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We use it like so:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">SearchMonitor</span> <span class="o">*</span> <span class="n">tabu_search</span> <span class="o">=</span> <span class="n">solver</span><span class="p">.</span><span class="n">MakeTabuSearch</span><span class="p">(</span><span class="nb">false</span><span class="p">,</span>
                                                    <span class="n">objective_var</span><span class="p">,</span>
                                                    <span class="mi">1</span><span class="p">,</span>
                                                    <span class="n">tabu_vars</span><span class="p">,</span>
                                                    <span class="n">FLAGS_keep_tenure</span><span class="p">,</span>
                                                    <span class="n">FLAGS_forbid_tenure</span><span class="p">,</span>
                                                    <span class="n">FLAGS_tabu_factor</span><span class="p">);</span>
</pre></div>
</div>
<p>Let&#8217;s compare the results of <tt class="file docutils literal"><span class="pre">jobshop_ls1.cc</span></tt> and <tt class="file docutils literal"><span class="pre">jobshop_ts1.cc</span></tt> for different parameters of the Tabu Search on the problem defined in file <tt class="file docutils literal"><span class="pre">abz9</span></tt>. But first, recall that the Local Search in <tt class="file docutils literal"><span class="pre">jobshop_ls1.cc</span></tt>,
found a Local Optimum (26 <sup>th</sup> solution, after 35 seconds<a class="footnote-reference" href="#only-35-seconds-jobshop-problem-local-optimum" id="id10">[8]</a>) with a value of <tt class="docutils literal"><span class="pre">1051</span></tt> (and the Local Search stops there). For the file <tt class="file docutils literal"><span class="pre">abz9</span></tt>, we have 300 Tabu variables.</p>
<p>We now use the Tabu Search to try to improve this result. Whenever the Local Search will reach this local optimum, the Tabu Search will kick in and hopefully get us out of this local optimum trap.
We use the <tt class="docutils literal"><span class="pre">NoImprovementLimit</span></tt> <tt class="docutils literal"><span class="pre">SearchLimit</span></tt> with the number of solutions accepted without any improvement in the objective value set to 30 and infinite time.</p>
<p>The next table compares some results obtained with different Tabu parameters to solve the problem in file <tt class="file docutils literal"><span class="pre">abz9</span></tt>.</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="8%" />
<col width="8%" />
<col width="13%" />
<col width="15%" />
<col width="13%" />
<col width="10%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">K</th>
<th class="head">F</th>
<th class="head">TF</th>
<th class="head">#Sol</th>
<th class="head">Time(s)</th>
<th class="head">#Best</th>
<th class="head">value</th>
<th class="head">Time (s)</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>10</td>
<td>5</td>
<td>1.0</td>
<td>123</td>
<td>202,235</td>
<td>92</td>
<td>948</td>
<td>145,135</td>
</tr>
<tr class="row-odd"><td>10</td>
<td>10</td>
<td>1.0</td>
<td>123</td>
<td>199,682</td>
<td>93</td>
<td>948</td>
<td>143,416</td>
</tr>
<tr class="row-even"><td>5</td>
<td>10</td>
<td>1.0</td>
<td>157</td>
<td>294,816</td>
<td>127</td>
<td>987</td>
<td>249,965</td>
</tr>
<tr class="row-odd"><td>15</td>
<td>10</td>
<td>1.0</td>
<td>123</td>
<td>289,651</td>
<td>93</td>
<td>948</td>
<td>237,480</td>
</tr>
<tr class="row-even"><td>10</td>
<td>0</td>
<td>1.0</td>
<td>123</td>
<td>154,212</td>
<td>92</td>
<td>948</td>
<td>119,058</td>
</tr>
<tr class="row-odd"><td>10</td>
<td>30</td>
<td>1.0</td>
<td>77</td>
<td>199,009</td>
<td>46</td>
<td>1025</td>
<td>62,842</td>
</tr>
<tr class="row-even"><td>10</td>
<td>30</td>
<td>0.6</td>
<td>61</td>
<td>90,186</td>
<td>30</td>
<td>1049</td>
<td>40,498</td>
</tr>
<tr class="row-odd"><td>10</td>
<td>10</td>
<td>0.6</td>
<td>61</td>
<td>106,086</td>
<td>30</td>
<td>1049</td>
<td>40,574</td>
</tr>
<tr class="row-even"><td>10</td>
<td>10</td>
<td>0.2</td>
<td>61</td>
<td>92,421</td>
<td>30</td>
<td>1049</td>
<td>40,576</td>
</tr>
<tr class="row-odd"><td>10</td>
<td>10</td>
<td>0.0</td>
<td>57</td>
<td>87,766</td>
<td>26</td>
<td>1051</td>
<td>35,517</td>
</tr>
</tbody>
</table>
<p>The three first columns show the following Tabu parameters: K represents the <tt class="docutils literal"><span class="pre">keep_tenure</span></tt> value, F the <tt class="docutils literal"><span class="pre">forbid_tenure</span></tt> and TF the <tt class="docutils literal"><span class="pre">tabu_factor</span></tt>. The next two columns give respectively the the total number of solution generated (#Sol) and total time (Time(s) in seconds) that the corresponding algorithm took (when stopped by our <tt class="docutils literal"><span class="pre">SearchLimit</span></tt>). The last three columns are about the best solution found: its number (#Best), value (value) and the
number of seconds needed to find it (Time (s)).</p>
<p>Some preliminary comments. First of all, the Tabu Search improves the search in most cases, a good sign. The only case (last line) where it doesn&#8217;t improve the search is when we use a <tt class="docutils literal"><span class="pre">tabu_factor</span></tt> of <tt class="docutils literal"><span class="pre">0.0</span></tt>: no Tabu criterion needs to be fulfilled. The Tabu Search relaunches the Local Search without any improvement and the <tt class="docutils literal"><span class="pre">NoImprovementLimit</span></tt> kicks in after 30 more solutions. Second, the Tabu Search is quite
robust. The first five lines give similar results for similar parameters. It seems that keeping some features of a solution is more important than forbidding some. Third, softening the Tabu criterion
(<tt class="docutils literal"><span class="pre">tabu_factor</span> <span class="pre">&lt;</span> <span class="pre">1</span></tt>) doesn&#8217;t seem to work in this particular case.</p>
<p>Can we do better than our best Local Search described in <tt class="file docutils literal"><span class="pre">jobshop_ls3.cc</span></tt>? The best objective value was 931. You can read all about in the section <a class="reference internal" href="../ls/jobshop_ls.html#results-jobshop-ls3"><em>Results</em></a>.</p>
<p>We added a Tabu Search method in file <tt class="file docutils literal"><span class="pre">jobshop_ts2.cc</span></tt> to complete the code in <tt class="file docutils literal"><span class="pre">jobshop_ls3.cc</span></tt><a class="footnote-reference" href="#jobshop-tabu-search-with-optimize-var" id="id11">[9]</a>. With the default parameters and the following Tabu parameters <tt class="docutils literal"><span class="pre">keep_tenure=10</span></tt>, <tt class="docutils literal"><span class="pre">forbid_tenure=5</span></tt> and <tt class="docutils literal"><span class="pre">tabu_factor=1.0</span></tt>, we obtain an objective value of 924 (in 201,604 seconds). Much better than 931 but still very far from the optimal value of 679. And we had roughly to work twice as hard to go from 931 to 924. This is typical. To get even better results, one must implement specialized algorithms.</p>
<h4>Footnotes</h4><table class="docutils footnote" frame="void" id="tabu-search-basic-idea" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>We only give a you a very basic idea barely enough to understand our implementation. Actually, some Tabu Search experts might even not agree with our presentation of the main idea.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="fifo-list-as-queue" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[2]</a></td><td>FIFO stands for <strong>F</strong>irst <strong>I</strong>n, <strong>F</strong>irst <strong>O</strong>ut. Basically, a <em>queue</em> is a data structure that allows you to add elements and retrieve them in their order of appearance.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="tabu-vars-must-be-changed-by-local-search-operator" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[3]</a></td><td>Variables that are not changed by the <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt> will not enter any Tabu list.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="accepted-solution-in-ls" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[4]</a></td><td><p class="first">I.e. filtered and accepted, see the section <a class="reference internal" href="../ls/basic_working_local_search.html#basic-local-search-algorithm-and-the-callback-hooks"><em>The basic Local Search algorithm and the callback hooks for the SearchMonitors</em></a> if needed.</p>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="optimize-var-does-not-add-constraint" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id7">[5]</a></td><td>Although the <tt class="docutils literal"><span class="pre">OptimizeVar</span></tt> <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt> does <strong>not</strong> add constraints.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="dont-know-jobshop-problem" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[6]</a></td><td>If you don&#8217;t remember anything about the Job-Shop Problem, don&#8217;t panic. You can read about it in the previous chapter and if you prefer you can completely skip the
problem definition and our implementation to solve it (but not the use of <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>s as our implementation only works with Local Search). We only discuss here
the use of the <tt class="docutils literal"><span class="pre">TabuSearch</span></tt> meta-heuristic.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="sequence-vars-explained" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[7]</a></td><td><p class="first">You might want to reread the section <a class="reference internal" href="../ls/scheduling_or_tools.html#scheduling-variables-in-ortools"><em>Variables</em></a> about variables used for scheduling in <strong>or-tools</strong>.</p>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="only-35-seconds-jobshop-problem-local-optimum" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[8]</a></td><td>You might be surprised by these 35 seconds if you compare them to the 51 seconds needed in the previous chapter. Of course, we used another computer.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="jobshop-tabu-search-with-optimize-var" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[9]</a></td><td>We use an <tt class="docutils literal"><span class="pre">OptimizeVar</span></tt> in file <tt class="file docutils literal"><span class="pre">jobshop_ts2.cc</span></tt> because the initial solution is found by Local Search. This <tt class="docutils literal"><span class="pre">OptimizeVar</span></tt> variable is not
used in the Tabu Search.</td></tr>
</tbody>
</table>
<h4>Bibliography</h4><table class="docutils citation" frame="void" id="glover1997" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[Glover1997]</a></td><td><ol class="first last upperalpha simple" start="6">
<li>Glover and M. Laguna. <em>Tabu Search</em>, Kluwer Academic Publishers, 1997.</li>
</ol>
</td></tr>
</tbody>
</table>
<table class="docutils citation" frame="void" id="gendreau2005" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[Gendreau2005]</a></td><td>M. Gendreau and J.-Y. Potvin. <em>Tabu search</em>. In E. K. Burke and G. Kendall, editors, <em>Search Methodologies: Introductory Tutorials in Optimization and Decision Support Techniques</em>.
Springer-Verlag, 2005</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<table>
<tr>
<td width="60"><img src="../../_static/logo.png" width="50" height="50"  alt="" /></td>
<td><p class="library_name">Google <a href="http://code.google.com/p/or-tools/"><strong>or-tools</strong></a><br>open source library</p></td>
</tr>
</table>
<h1>User's Manual</h1>

  
   



<h3>Google search</h3>

<form method="get" action="http://www.google.com/search">

<div style="padding:-1px;width:15em;">
<table border="0" cellpadding="0">
<tr><td>
<input type="text"   name="q" size="25"
 maxlength="255" value="" />
<input type="submit" value="Go" /></td></tr>
<tr><td align="center" style="font-size:80%">
Search:
<select name="sitesearch" width="125" style="width: 125px">
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/user_manual/" selected>user's manual</option>
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/faq/">faq</option>
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/reference_manual/or-tools/">reference manual</option>
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/">All or-tools doc</option>
</select>
</td></tr>
</table>
</div>

</form>
</br>




  <h3>Welcome</h3>
  
  <ul>
  	<li><a href="../../index.html">Content and foreword</a></li>
  	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html">Documentation's hub</a></li>
	<li><a href="http://code.google.com/p/or-tools/">The or-tools open source library</a></li></li>	
  </ul>
  
   
	


  <h3>Tutorial examples</h3>
  
  <ul>
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_C++">C++</a></li>
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_Python">Python</a></li>	
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_Java">Java</a></li>
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_Csharp">C#</a></li>
</ul>
  
   
	

  <h3>Current chapter</h3>
  <p class="topless"><a href="../metaheuristics.html"
                        title="previous chapter">7. Meta-heuristics: several previous problems</a></p>
  <h3>Previous section</h3>
  <p class="topless"><a href="metaheuristics.html"
                        title="previous chapter">7.3. Meta-heuristics in <strong>or-tools</strong></a></p>
  <h3>Next section</h3>
  <p class="topless"><a href="SA.html"
                        title="next chapter">7.5. Simulated Annealing (SA)</a></p>
  <h3>Current section</a></h3>
  <ul>
<li><a class="reference internal" href="#">7.4. Tabu Search (TS)</a><ul>
<li><a class="reference internal" href="#the-basic-idea">7.4.1. The basic idea</a></li>
<li><a class="reference internal" href="#our-implementation">7.4.2. Our implementation</a><ul>
<li><a class="reference internal" href="#some-helpers">7.4.2.1. Some helpers</a></li>
<li><a class="reference internal" href="#the-constructor-and-the-variables">7.4.2.2. The constructor and the variables</a></li>
<li><a class="reference internal" href="#localoptimum">7.4.2.3. <tt class="docutils literal"><span class="pre">LocalOptimum()</span></tt></a></li>
<li><a class="reference internal" href="#acceptneighbor">7.4.2.4. <tt class="docutils literal"><span class="pre">AcceptNeighbor()</span></tt></a></li>
<li><a class="reference internal" href="#atsolution">7.4.2.5. <tt class="docutils literal"><span class="pre">AtSolution()</span></tt></a></li>
<li><a class="reference internal" href="#applydecision">7.4.2.6. <tt class="docutils literal"><span class="pre">ApplyDecision()</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#first-results">7.4.3. First results</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="SA.html" title="7.5. Simulated Annealing (SA)"
             >next</a> |</li>
        <li class="right" >
          <a href="metaheuristics.html" title="7.3. Meta-heuristics in or-tools"
             >previous</a> |</li>
        <li><a href="../../index.html">or-tools User&#39;s Manual</a> &raquo;</li>
          <li><a href="../metaheuristics.html" >7. Meta-heuristics: several previous problems</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012-2015, Google.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>