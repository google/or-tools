

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>7.6. Guided Local Search (GLS) &mdash; or-tools User&#39;s Manual</title>
    
    <link rel="stylesheet" href="../../_static/default.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     'doc version 0.0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <link rel="shortcut icon" href="../../_static/logo.ico"/>
    <link rel="top" title="or-tools User&#39;s Manual" href="../../index.html" />
    <link rel="up" title="7. Meta-heuristics: several previous problems" href="../metaheuristics.html" />
    <link rel="next" title="7.7. Large neighborhood search (LNS): the Job-Shop Problem" href="jobshop_lns.html" />
    <link rel="prev" title="7.5. Simulated Annealing (SA)" href="SA.html" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="jobshop_lns.html" title="7.7. Large neighborhood search (LNS): the Job-Shop Problem"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="SA.html" title="7.5. Simulated Annealing (SA)"
             accesskey="P">previous</a> |</li>
        <li><a href="../../index.html">or-tools User&#39;s Manual</a> &raquo;</li>
          <li><a href="../metaheuristics.html" accesskey="U">7. Meta-heuristics: several previous problems</a> &raquo;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body">
            
  <div class="section" id="guided-local-search-gls">
<span id="guided-local-search"></span><h1>7.6. Guided Local Search (GLS)</h1>
<p>Guided Local Search is another successful meta-heuristic that emerged in the &#8216;90. It has been successfully applied to a large number of difficult problems and has been particularly successful in
Routing Problems.</p>
<p>Our Guided Local Search implementation is especially tailored for the Routing Library. It uses a callback to a cost function that takes two <tt class="docutils literal"><span class="pre">int64</span></tt> indices corresponding to <strong>2</strong> nodes<a class="footnote-reference" href="#gls-2-indices-or-3" id="id1">[1]</a>, i.e. the cost
of traversing an arc. If you can successfully translate the cost of using two variables <img class="math" src="../../_images/math/34857b3ba74ce5cd8607f3ebd23e9015908ada71.png" alt="i" style="vertical-align: 0px"/> and <img class="math" src="../../_images/math/8122aa89ea6e80784c6513d22787ad86e36ad0cc.png" alt="j" style="vertical-align: -4px"/> one after the other in your objective function for your specific problem, then you can use
our implementation out of the box. Otherwise, you&#8217;ll have to create your own version. We hope that after reading this section you&#8217;ll have a better idea on how you can do it. The last sub-section gives you some hints if you want to adapt our implementation to solve your problem.</p>
<div class="admonition warning">
<p class="first admonition-title">Warning</p>
<p class="last">Our Guided Local Search implementation is especially tailored for the Routing Library</p>
</div>
<p>Along the way, we&#8217;ll give you enough information to fully understand (almost) all the code and understand the Routing Library (RL) conventions<a class="footnote-reference" href="#rl-real-conventions" id="id2">[2]</a>.</p>
<p>Among the three implemented meta-heuristics implemented in <strong>or-tools</strong>, GLS has certainly the most refined and efficient (and thus complicated) implementation.</p>
<div class="section" id="the-basic-idea">
<h2>7.6.1. The basic idea</h2>
<p>The GLS is a penalty-based method that sits on top of a Local Search. Its originality and efficiency stems from the way it penalizes some features of a solution along the search. We assume <em>minimization</em>.</p>
<div class="section" id="the-augmented-objective-function">
<h3>7.6.1.1. The augmented objective function</h3>
<p>Denote by <img class="math" src="../../_images/math/841fb80920b214cd9f8ccb4af360b4891402c0e3.png" alt="I_i" style="vertical-align: -3px"/> the following
indicator function:</p>
<div class="math">
<p><img src="../../_images/math/e2644f5aef88a86a47a52798705d58eb6ce1c6e0.png" alt="I_i(x) =
\begin{cases}
  1 &amp; \text{if solution } x \text{ has feature } i \\
  0  &amp; \text{otherwise}.
\end{cases}"/></p>
</div><p>The GLS meta-heuristic penalizes some features of a local optimum. Let <img class="math" src="../../_images/math/245a5501248a6ea24f520f76d4140cedf08e1674.png" alt="p_i" style="vertical-align: -4px"/> be a penalty attached to a feature <img class="math" src="../../_images/math/34857b3ba74ce5cd8607f3ebd23e9015908ada71.png" alt="i" style="vertical-align: 0px"/> and <img class="math" src="../../_images/math/bb2c93730dbb48558bb3c4738c956c4e8f816437.png" alt="f" style="vertical-align: -4px"/> denote the original objective function.
The GLS meta-heuristic uses the following augmented objective function <img class="math" src="../../_images/math/311cabda3a9b09f0dde217303ca9d1cd9201dcf6.png" alt="g" style="vertical-align: -4px"/>:</p>
<div class="math">
<p><img src="../../_images/math/a91c19d517b8ce8720b4bdc36551378c4ceb8d54.png" alt="g(x) = f(x) + \lambda \sum_i \left( I_i(x) \cdot p_i \right)"/></p>
</div><p>The idea is to let the Local Search find solutions with this new augmented objective function. <img class="math" src="../../_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda" style="vertical-align: 0px"/> is called the <em>penalty factor</em> and can be used to tune the search to find similar solutions (a low <img class="math" src="../../_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda" style="vertical-align: 0px"/> value,
intensification)
or completely different solutions (a high <img class="math" src="../../_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda" style="vertical-align: 0px"/> value, diversification).</p>
</div>
<div class="section" id="the-penalties-and-their-modifications">
<h3>7.6.1.2. The penalties and their modifications</h3>
<p>Penalties usually start with a <img class="math" src="../../_images/math/bc1f9d9bf8a1b606a4188b5ce9a2af1809e27a89.png" alt="0" style="vertical-align: 0px"/> value and are incremented by <img class="math" src="../../_images/math/dce34f4dfb2406144304ad0d6106c5382ddd1446.png" alt="1" style="vertical-align: -1px"/> with each local optimum. The originality and efficiency of the GLS is that a feature is only penalized <strong>if</strong> its <em>utility</em> is large enough.
The idea is to penalize costly features but not penalize them too much if they often show up. The <strong>utility</strong> function for a feature <img class="math" src="../../_images/math/34857b3ba74ce5cd8607f3ebd23e9015908ada71.png" alt="i" style="vertical-align: 0px"/> in a solution <img class="math" src="../../_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" style="vertical-align: 0px"/> is defined as follows:</p>
<div class="math">
<p><img src="../../_images/math/21c81928c3120c88c86d6921521b0c7b30ba4fcc.png" alt="u_i(x) = I_i(x) \frac{c_i(x)}{1 + p_i}."/></p>
</div><p>where <img class="math" src="../../_images/math/9a741b899afcd7fe00da0afec6c45b63a0028329.png" alt="c_i()" style="vertical-align: -4px"/> denotes the cost associated with feature <img class="math" src="../../_images/math/34857b3ba74ce5cd8607f3ebd23e9015908ada71.png" alt="i" style="vertical-align: 0px"/> in solution <img class="math" src="../../_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" style="vertical-align: 0px"/>.
If a feature <img class="math" src="../../_images/math/34857b3ba74ce5cd8607f3ebd23e9015908ada71.png" alt="i" style="vertical-align: 0px"/> is not present in a solution <img class="math" src="../../_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" style="vertical-align: 0px"/>, its utility for this solution is <img class="math" src="../../_images/math/bc1f9d9bf8a1b606a4188b5ce9a2af1809e27a89.png" alt="0" style="vertical-align: 0px"/> (<img class="math" src="../../_images/math/e53c2367082d26bd66ac95de4aa8118daf060a6a.png" alt="I_i(x) = 0" style="vertical-align: -4px"/>). Otherwise, the utility is proportional to the cost <img class="math" src="../../_images/math/efe54ded8ebbe64b98214f34ab44d7f3ad54d337.png" alt="c_i(x)" style="vertical-align: -4px"/> of this feature in the solution
<img class="math" src="../../_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" style="vertical-align: 0px"/> <strong>but</strong> tends
to disappear whenever this feature <img class="math" src="../../_images/math/34857b3ba74ce5cd8607f3ebd23e9015908ada71.png" alt="i" style="vertical-align: 0px"/> is often penalized. A feature that shows up regularly in local optima might be part of a good solution.</p>
</div>
</div>
<div class="section" id="our-implementation">
<h2>7.6.2. Our implementation</h2>
<p>Our implementation is at the same time specific for Routing Problems but also generic for any Routing Problem. The chosen features of a solution is the fact that an arc <tt class="docutils literal"><span class="pre">(i,j)</span></tt> is traversed or not for
this solution. So, we will speak of a <tt class="docutils literal"><span class="pre">(i,j)</span></tt> <tt class="docutils literal"><span class="pre">Arc</span></tt> feature (and talk about <img class="math" src="../../_images/math/be3f6c55e39366ad7956d6cd4d84583e894b661a.png" alt="c_{ij}" style="vertical-align: -6px"/>, <img class="math" src="../../_images/math/ccca2c46f98ac4992c543dcd5aab7c897d2c9f8a.png" alt="u_{ij}" style="vertical-align: -6px"/> and <img class="math" src="../../_images/math/79220e9b9f82ca92de037d2a8a6bc00ac0f9a0e0.png" alt="p_{ij}" style="vertical-align: -6px"/>).</p>
<p>Our implementation is practically following the basic GLS guidelines by the book.</p>
<p>Let&#8217;s denote by <img class="math" src="../../_images/math/4fe72f28a9fe0a456173c9287d7a195c663e171b.png" alt="d_{ij}" style="vertical-align: -6px"/> the cost of traversing an arc <img class="math" src="../../_images/math/887919dfbc86eebc29e0373f98f97dbf23a0ae23.png" alt="(i,j)" style="vertical-align: -4px"/> in a given solution. In our case, this is given by the cost of the objective function for that arc and we have <img class="math" src="../../_images/math/2b2c91b7bf7514e1e910f722cd4138d1a9980ede.png" alt="c_{ij} = d_{ij}" style="vertical-align: -6px"/>. This cost can depend on the type of vehicle used if we use different types of vehicles.</p>
<p>Our augmented objective function is given by</p>
<div class="math">
<p><img src="../../_images/math/f792693f4651f9955977b4130f938061c901d2e3.png" alt="g(x) = \sum_{(i,j)} d_{ij}(x) + \lambda \sum_{(i.j)} \left( I_{ij}(x) \cdot p_{ij} \cdot c_{ij}(x) \right)"/></p>
</div><p>Within the Routing Library, the penalty factor <img class="math" src="../../_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda" style="vertical-align: 0px"/> is given by the <strong class="program">gflags</strong> command line flag <tt class="docutils literal"><span class="pre">routing_guided_local_search_lambda_coefficient</span></tt> and is set to the value 0,1 by default.</p>
</div>
<div class="section" id="guidedlocalsearchpenalties">
<h2>7.6.3. <tt class="docutils literal"><span class="pre">GuidedLocalSearchPenalties</span></tt></h2>
<p>Penalties are stored in a <tt class="docutils literal"><span class="pre">GuidedLocalSearchPenalties</span></tt> class. This class is abstract and two implementations exist depending on the data structure to store the penalties:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">GuidedLocalSearchPenaltiesTable</span></tt>: for dense GLS penalties using a matrix <tt class="docutils literal"><span class="pre">std::vector&lt;std::vector&lt;int64&gt;</span> <span class="pre">&gt;</span></tt> and</li>
<li><tt class="docutils literal"><span class="pre">GuidedLocalSearchPenaltiesMap</span></tt>: for sparse GLS penalties using a <tt class="docutils literal"><span class="pre">hash_map</span></tt><a class="footnote-reference" href="#hash-map-compiler-dependant" id="id3">[3]</a>.</li>
</ul>
<p>By default, the dense version is used but you can switch to the sparse version by setting the <tt class="docutils literal"><span class="pre">cp_use_sparse_gls_penalties</span></tt> flag to <tt class="docutils literal"><span class="pre">true</span></tt> on the command line.</p>
<p>Here is the skeleton of the abstract class:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">GuidedLocalSearchPenalties</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">GuidedLocalSearchPenalties</span><span class="p">()</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">HasValues</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Increment</span><span class="p">(</span><span class="k">const</span> <span class="n">Arc</span><span class="o">&amp;</span> <span class="n">arc</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="n">int64</span> <span class="n">Value</span><span class="p">(</span><span class="k">const</span> <span class="n">Arc</span><span class="o">&amp;</span> <span class="n">arc</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">Reset</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>An <tt class="docutils literal"><span class="pre">Arc</span></tt> is simply a <tt class="docutils literal"><span class="pre">(from,to)</span></tt> pair:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">int64</span><span class="p">,</span> <span class="n">int64</span><span class="o">&gt;</span> <span class="n">Arc</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="the-abstract-guidedlocalsearch-class">
<h2>7.6.4. The abstract <tt class="docutils literal"><span class="pre">GuidedLocalSearch</span></tt> class</h2>
<p>The <tt class="docutils literal"><span class="pre">GuidedLocalSearch</span></tt> class is a pure abstract base class. Two specialized implementations exist:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">BinaryGuidedLocalSearch</span></tt> (2-indices version): when all vehicles have the same cost to traverse any arc <img class="math" src="../../_images/math/887919dfbc86eebc29e0373f98f97dbf23a0ae23.png" alt="(i,j)" style="vertical-align: -4px"/> and</li>
<li><tt class="docutils literal"><span class="pre">TernaryGuidedLocalSearch</span></tt> (3-indices version): when the cost of traversing an arc <img class="math" src="../../_images/math/887919dfbc86eebc29e0373f98f97dbf23a0ae23.png" alt="(i,j)" style="vertical-align: -4px"/> also depends on the type of vehicle <img class="math" src="../../_images/math/8c325612684d41304b9751c175df7bcc0f61f64f.png" alt="k" style="vertical-align: 0px"/>.</li>
</ul>
<p>We discuss these two classes in details later on.</p>
<div class="section" id="to-compare-two-arcs">
<h3>7.6.4.1. To compare two <tt class="docutils literal"><span class="pre">Arc</span></tt>s</h3>
<p>To compare two arcs, we use the following comparator:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Comparator</span> <span class="p">{</span>
  <span class="kt">bool</span> <span class="k">operator</span><span class="p">()(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Arc</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;&amp;</span> <span class="n">i</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Arc</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;&amp;</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">i</span><span class="p">.</span><span class="n">second</span> <span class="o">&gt;</span> <span class="n">j</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>This <tt class="docutils literal"><span class="pre">struct</span></tt> is called a <em>functor</em> (or <em>function object</em>) and is basically a function call encapsulated in a <tt class="docutils literal"><span class="pre">class</span></tt> (or a <tt class="docutils literal"><span class="pre">struct</span></tt>). This is done by overloading the
<em>function call operator</em> (<tt class="docutils literal"><span class="pre">operator()</span></tt>) of the class (or <tt class="docutils literal"><span class="pre">struct</span></tt>)<a class="footnote-reference" href="#functor-idiom-in-cplusplus" id="id4">[4]</a>.</p>
<p>Notice that we compare the <tt class="docutils literal"><span class="pre">double</span></tt> values attached to each <tt class="docutils literal"><span class="pre">Arc</span></tt>s in the <tt class="docutils literal"><span class="pre">(Arc,</span> <span class="pre">double)</span></tt> pairs.
We&#8217;ll use this <tt class="docutils literal"><span class="pre">Comparator</span></tt> <tt class="docutils literal"><span class="pre">struct</span></tt> to compare
utilities attached to <tt class="docutils literal"><span class="pre">Arc</span></tt>s.</p>
</div>
<div class="section" id="the-variables-and-the-constructor">
<h3>7.6.4.2. The variables and the constructor</h3>
<p>Let&#8217;s start with the (protected) variables of the <tt class="docutils literal"><span class="pre">GuidedLocalSearch</span></tt> class:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">IntVar</span><span class="o">*</span> <span class="n">penalized_objective_</span><span class="p">;</span>
<span class="n">Assignment</span> <span class="n">assignment_</span><span class="p">;</span>
<span class="n">int64</span> <span class="n">assignment_penalized_value_</span><span class="p">;</span>
<span class="n">int64</span> <span class="n">old_penalized_value_</span><span class="p">;</span>
<span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IntVar</span><span class="o">*&gt;</span> <span class="n">vars_</span><span class="p">;</span>
<span class="n">hash_map</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">IntVar</span><span class="o">*</span><span class="p">,</span> <span class="n">int64</span><span class="o">&gt;</span> <span class="n">indices_</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">double</span> <span class="n">penalty_factor_</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">GuidedLocalSearchPenalties</span><span class="o">&gt;</span> <span class="n">penalties_</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">int64</span><span class="p">[]</span><span class="o">&gt;</span> <span class="n">current_penalized_values_</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">int64</span><span class="p">[]</span><span class="o">&gt;</span> <span class="n">delta_cache_</span><span class="p">;</span>
<span class="kt">bool</span> <span class="n">incremental_</span><span class="p">;</span>
</pre></div>
</div>
<p>We cover the most interesting variables.</p>
<p>The <tt class="docutils literal"><span class="pre">penalized_objective_</span></tt> <tt class="docutils literal"><span class="pre">IntVar</span></tt> represents the penalized part of the penalized objective function: <img class="math" src="../../_images/math/89bd49c9ca0568bc2d7eb7de1c6dbbe837fbe77e.png" alt="\lambda \sum_{(i.j)} \left( I_{ij}(x) \cdot p_{ij} \cdot c_{ij}(x) \right)" style="vertical-align: -8px"/>. When there are no
penalties, the pointer <tt class="docutils literal"><span class="pre">penalized_objective_</span></tt> is set to <tt class="docutils literal"><span class="pre">nullptr</span></tt>. Actually, the expression of <tt class="docutils literal"><span class="pre">penalized_objective_</span></tt> is a little bit more complicated than that because of our choice of added constraints.
See the <tt class="docutils literal"><span class="pre">ApplyDecision()</span></tt> method below for more details.</p>
<p>We keep the current solution in <tt class="docutils literal"><span class="pre">assignment_</span></tt> as usual.</p>
<p><tt class="docutils literal"><span class="pre">assignment_penalized_value_</span></tt> is the value of the expression <img class="math" src="../../_images/math/89bd49c9ca0568bc2d7eb7de1c6dbbe837fbe77e.png" alt="\lambda \sum_{(i.j)} \left( I_{ij}(x) \cdot p_{ij} \cdot c_{ij}(x) \right)" style="vertical-align: -8px"/> for the current solution.
<tt class="docutils literal"><span class="pre">old_penalized_value_</span></tt> is used to update the penalized value incrementally in the <tt class="docutils literal"><span class="pre">AcceptDelta</span></tt> method.</p>
<p><tt class="docutils literal"><span class="pre">vars_</span></tt> is an <tt class="docutils literal"><span class="pre">std::vector</span></tt> with our node variables.</p>
<p><tt class="docutils literal"><span class="pre">indices_</span></tt> is a <tt class="docutils literal"><span class="pre">hash_map</span></tt> to quickly find the index of a variable given as <tt class="docutils literal"><span class="pre">IntVar*</span></tt>.</p>
<p><tt class="docutils literal"><span class="pre">penalty_factor</span></tt> is the penalty factor <img class="math" src="../../_images/math/ce4588fd900d02afcbd260bc07f54cce49a7dc4a.png" alt="\lambda" style="vertical-align: 0px"/>.</p>
<p>The penalties computed during the search are stored in a <tt class="docutils literal"><span class="pre">GuidedLocalSearchPenalties</span></tt> object pointed to by the <tt class="docutils literal"><span class="pre">penalties_</span></tt> variable: for an <tt class="docutils literal"><span class="pre">Arc</span></tt> <tt class="docutils literal"><span class="pre">arc</span></tt>,  <tt class="docutils literal"><span class="pre">penalties_-&gt;Value(arc)</span></tt> returns its current penalty.</p>
<p>Finally, the three last variables are used to update the penalized costs incrementally in the <tt class="docutils literal"><span class="pre">AcceptDelta()</span></tt> method. We&#8217;ll discuss this method in details below.</p>
<p>The constructor is quite straightforward:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">GuidedLocalSearch</span><span class="p">(</span><span class="n">Solver</span><span class="o">*</span> <span class="k">const</span> <span class="n">s</span><span class="p">,</span> <span class="n">IntVar</span><span class="o">*</span> <span class="n">objective</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">maximize</span><span class="p">,</span>
                  <span class="n">int64</span> <span class="n">step</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IntVar</span><span class="o">*&gt;&amp;</span> <span class="n">vars</span><span class="p">,</span>
                  <span class="kt">double</span> <span class="n">penalty_factor</span><span class="p">);</span>
</pre></div>
</div>
<p>where <tt class="docutils literal"><span class="pre">step</span></tt> is the usual step used to force the objective function to improve.</p>
</div>
<div class="section" id="the-pure-virtual-methods-and-the-helpers">
<h3>7.6.4.3. The pure virtual methods and the helpers</h3>
<p>The pure virtual methods that <strong>must</strong> be defined in a specialized <tt class="docutils literal"><span class="pre">GuidedLocalSearch</span></tt> class are:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">virtual</span> <span class="n">int64</span> <span class="n">AssignmentElementPenalty</span><span class="p">(</span><span class="k">const</span> <span class="n">Assignment</span><span class="o">&amp;</span> <span class="n">assignment</span><span class="p">,</span>
                                       <span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">virtual</span> <span class="n">int64</span> <span class="n">AssignmentPenalty</span><span class="p">(</span><span class="k">const</span> <span class="n">Assignment</span><span class="o">&amp;</span> <span class="n">assignment</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span>
                                <span class="n">int64</span> <span class="n">next</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">virtual</span> <span class="kt">bool</span> <span class="n">EvaluateElementValue</span><span class="p">(</span><span class="k">const</span> <span class="n">Assignment</span><span class="o">::</span><span class="n">IntContainer</span><span class="o">&amp;</span>
                                                              <span class="n">container</span><span class="p">,</span>
                                  <span class="n">int64</span> <span class="n">index</span><span class="p">,</span> <span class="kt">int</span><span class="o">*</span> <span class="n">container_index</span><span class="p">,</span>
                                  <span class="n">int64</span><span class="o">*</span> <span class="n">penalty</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">virtual</span> <span class="n">IntExpr</span><span class="o">*</span> <span class="n">MakeElementPenalty</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>The used of 2 indices (in the signature of <tt class="docutils literal"><span class="pre">AssignmentPenalty</span></tt>) indicates that our <tt class="docutils literal"><span class="pre">GuidedLocalSearch</span></tt> class is really tailored to deal with arcs. The best way to understand what these methods are supposed to do is to study their implementations in details.</p>
<ul>
<li><p class="first"><tt class="docutils literal"><span class="pre">AssignmentElementPenalty()</span></tt> returns the penalized value associated to the arc leaving node <img class="math" src="../../_images/math/34857b3ba74ce5cd8607f3ebd23e9015908ada71.png" alt="i" style="vertical-align: 0px"/> in a given solution <tt class="docutils literal"><span class="pre">assignment</span></tt>.
This penalized value is (for minimization) equal to <img class="math" src="../../_images/math/fa12ea8eec45b790e08bc47803bab83a155b7d52.png" alt="\lambda \cdot p_{ij}(x) \cdot c_{ij}(x)" style="vertical-align: -6px"/> for a given solution <img class="math" src="../../_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" style="vertical-align: 0px"/>.</p>
<p>We need to do do a little incursion in the Routing Library (RL) before we can go on.</p>
<p>The RL (Routing Library) encodes the traversing of an arc <img class="math" src="../../_images/math/887919dfbc86eebc29e0373f98f97dbf23a0ae23.png" alt="(i,j)" style="vertical-align: -4px"/> in a solution with <tt class="docutils literal"><span class="pre">vars_[i]</span> <span class="pre">=</span> <span class="pre">j</span></tt>, i.e. from node <img class="math" src="../../_images/math/34857b3ba74ce5cd8607f3ebd23e9015908ada71.png" alt="i" style="vertical-align: 0px"/> go to node <img class="math" src="../../_images/math/8122aa89ea6e80784c6513d22787ad86e36ad0cc.png" alt="j" style="vertical-align: -4px"/> where <tt class="docutils literal"><span class="pre">vars_[i]</span></tt> denotes the <tt class="docutils literal"><span class="pre">IntVar</span></tt>
variable corresponding
to node <img class="math" src="../../_images/math/34857b3ba74ce5cd8607f3ebd23e9015908ada71.png" alt="i" style="vertical-align: 0px"/> and <tt class="docutils literal"><span class="pre">vars_</span></tt> is an <tt class="docutils literal"><span class="pre">std::vector</span></tt> of such variables. Back to <tt class="docutils literal"><span class="pre">AssignmentElementPenalty</span></tt>.</p>
<p>Here is the implementation of this method for the <tt class="docutils literal"><span class="pre">BinaryGuidedLocalSearch</span></tt> class:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">int64</span> <span class="nf">AssignmentElementPenalty</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">Assignment</span><span class="o">&amp;</span> <span class="n">assignment</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">PenalizedValue</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">assignment</span><span class="p">.</span><span class="n">Value</span><span class="p">(</span><span class="n">vars_</span><span class="p">[</span><span class="n">index</span><span class="p">]));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>where the <tt class="docutils literal"><span class="pre">PenalizedValue(int64</span> <span class="pre">i,</span> <span class="pre">int64</span> <span class="pre">j)</span></tt> helper method computes the penalized value for a given arc <img class="math" src="../../_images/math/887919dfbc86eebc29e0373f98f97dbf23a0ae23.png" alt="(i,j)" style="vertical-align: -4px"/>:</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">int64</span> <span class="nf">PenalizedValue</span><span class="p">(</span><span class="n">int64</span> <span class="n">i</span><span class="p">,</span> <span class="n">int64</span> <span class="n">j</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">Arc</span> <span class="n">arc</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
  <span class="k">const</span> <span class="n">int64</span> <span class="n">penalty</span> <span class="o">=</span> <span class="n">penalties_</span><span class="o">-&gt;</span><span class="n">Value</span><span class="p">(</span><span class="n">arc</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">penalty</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">int64</span> <span class="n">penalized_value</span> <span class="o">=</span>
        <span class="n">penalty_factor_</span> <span class="o">*</span> <span class="n">penalty</span> <span class="o">*</span> <span class="n">objective_function_</span><span class="o">-&gt;</span><span class="n">Run</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">maximize_</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">-</span><span class="n">penalized_value</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">penalized_value</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>The test <tt class="docutils literal"><span class="pre">if</span> <span class="pre">(penalty</span> <span class="pre">!=</span> <span class="pre">0)</span></tt> on line 4 is simply to avoid costly <tt class="docutils literal"><span class="pre">objective_function_-&gt;Run(i,</span> <span class="pre">j)</span></tt> calls.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">AssignmentPenalty()</span></tt> returns the cost of traversing an arc <img class="math" src="../../_images/math/887919dfbc86eebc29e0373f98f97dbf23a0ae23.png" alt="(i,j)" style="vertical-align: -4px"/> in a given solution <tt class="docutils literal"><span class="pre">assignment</span></tt>. It is the cost <img class="math" src="../../_images/math/be3f6c55e39366ad7956d6cd4d84583e894b661a.png" alt="c_{ij}" style="vertical-align: -6px"/> for a solution to have arc (feature) <img class="math" src="../../_images/math/887919dfbc86eebc29e0373f98f97dbf23a0ae23.png" alt="(i,j)" style="vertical-align: -4px"/>.
<img class="math" src="../../_images/math/34857b3ba74ce5cd8607f3ebd23e9015908ada71.png" alt="i" style="vertical-align: 0px"/> is given by the <tt class="docutils literal"><span class="pre">index</span></tt>
of the <tt class="docutils literal"><span class="pre">IntVar</span></tt> variable corresponding to node <img class="math" src="../../_images/math/34857b3ba74ce5cd8607f3ebd23e9015908ada71.png" alt="i" style="vertical-align: 0px"/> and <tt class="docutils literal"><span class="pre">next</span></tt> is the node index corresponding to node <tt class="docutils literal"><span class="pre">j</span></tt>. For the <tt class="docutils literal"><span class="pre">BinaryGuidedLocalSearch</span></tt>, this method is defined as:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">int64</span> <span class="nf">AssignmentPenalty</span><span class="p">(</span><span class="k">const</span> <span class="n">Assignment</span><span class="o">&amp;</span> <span class="n">assignment</span><span class="p">,</span>
                                          <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">int64</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">objective_function_</span><span class="o">-&gt;</span><span class="n">Run</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">next</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This cost is the same for all vehicles. In the case of the <tt class="docutils literal"><span class="pre">TernaryGuidedLocalSearch</span></tt> class, we need to take the type of vehicle traversing the arc <img class="math" src="../../_images/math/887919dfbc86eebc29e0373f98f97dbf23a0ae23.png" alt="(i,j)" style="vertical-align: -4px"/> into account.
We added a reference to a given <tt class="docutils literal"><span class="pre">Assignment</span></tt> <tt class="docutils literal"><span class="pre">assignment</span></tt> to induce from this solution <tt class="docutils literal"><span class="pre">assignment</span></tt> what the type of vehicle
traversing arc <img class="math" src="../../_images/math/887919dfbc86eebc29e0373f98f97dbf23a0ae23.png" alt="(i,j)" style="vertical-align: -4px"/> is. The type of vehicle traversing from node <img class="math" src="../../_images/math/34857b3ba74ce5cd8607f3ebd23e9015908ada71.png" alt="i" style="vertical-align: 0px"/> is given by the <tt class="docutils literal"><span class="pre">secondary_vars_[i]</span></tt> variable:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">int64</span> <span class="nf">AssignmentPenalty</span><span class="p">(</span><span class="k">const</span> <span class="n">Assignment</span><span class="o">&amp;</span> <span class="n">assignment</span><span class="p">,</span>
                                          <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">int64</span> <span class="n">next</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">objective_function_</span><span class="o">-&gt;</span><span class="n">Run</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">next</span><span class="p">,</span>
                       <span class="n">assignment</span><span class="p">.</span><span class="n">Value</span><span class="p">(</span><span class="n">secondary_vars_</span><span class="p">[</span><span class="n">index</span><span class="p">]));</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">EvaluateElementValue()</span></tt> evaluates the penalized value of a given arc <img class="math" src="../../_images/math/887919dfbc86eebc29e0373f98f97dbf23a0ae23.png" alt="(i,j)" style="vertical-align: -4px"/>. It does so by using a shortcut to <tt class="docutils literal"><span class="pre">Assignment::IntContainer</span></tt>s instead of <tt class="docutils literal"><span class="pre">Assignment</span></tt>s and <tt class="docutils literal"><span class="pre">IntVarElement</span></tt>s
instead of <tt class="docutils literal"><span class="pre">IntVar</span></tt>s for efficiency. It also tests if a node is part of a solution. In the Routing Library, one can <em>disable</em> a node, i.e. make this node disappear as it never existed. If the node is
not disabled, i.e. <em>active</em>, the penalized value is stored in a variable pointed to by <tt class="docutils literal"><span class="pre">penalty</span></tt> and the method returns <tt class="docutils literal"><span class="pre">true</span></tt>, otherwise it returns <tt class="docutils literal"><span class="pre">false</span></tt>.</p>
<p>Here is the implementation for the <tt class="docutils literal"><span class="pre">BinaryGuidedLocalSearch</span></tt> class:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="nf">EvaluateElementValue</span><span class="p">(</span>
    <span class="k">const</span> <span class="n">Assignment</span><span class="o">::</span><span class="n">IntContainer</span><span class="o">&amp;</span> <span class="n">container</span><span class="p">,</span>
    <span class="n">int64</span> <span class="n">index</span><span class="p">,</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">container_index</span><span class="p">,</span>
    <span class="n">int64</span><span class="o">*</span> <span class="n">penalty</span><span class="p">)</span> <span class="p">{</span>
<span class="k">const</span> <span class="n">IntVarElement</span><span class="o">&amp;</span> <span class="n">element</span> <span class="o">=</span> <span class="n">container</span><span class="p">.</span><span class="n">Element</span><span class="p">(</span><span class="o">*</span><span class="n">container_index</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">element</span><span class="p">.</span><span class="n">Activated</span><span class="p">())</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">penalty</span> <span class="o">=</span> <span class="n">PenalizedValue</span><span class="p">(</span><span class="n">index</span><span class="p">,</span> <span class="n">element</span><span class="p">.</span><span class="n">Value</span><span class="p">());</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">EvaluateElementValue()</span></tt> method is only used in the <tt class="docutils literal"><span class="pre">Evaluate()</span></tt> helper of the <tt class="docutils literal"><span class="pre">GuidedLocalSearch</span></tt>:</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre></div></td><td class="code"><div class="highlight"><pre><span class="n">int64</span> <span class="nf">Evaluate</span><span class="p">(</span><span class="k">const</span> <span class="n">Assignment</span><span class="o">*</span> <span class="n">delta</span><span class="p">,</span>
               <span class="n">int64</span> <span class="n">current_penalty</span><span class="p">,</span>
               <span class="k">const</span> <span class="n">int64</span><span class="o">*</span> <span class="k">const</span> <span class="n">out_values</span><span class="p">,</span>
               <span class="kt">bool</span> <span class="n">cache_delta_values</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">int64</span> <span class="n">penalty</span> <span class="o">=</span> <span class="n">current_penalty</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">Assignment</span><span class="o">::</span><span class="n">IntContainer</span><span class="o">&amp;</span> <span class="n">container</span> <span class="o">=</span>
                                       <span class="n">delta</span><span class="o">-&gt;</span><span class="n">IntVarContainer</span><span class="p">();</span>
  <span class="k">const</span> <span class="kt">int</span> <span class="n">size</span> <span class="o">=</span> <span class="n">container</span><span class="p">.</span><span class="n">Size</span><span class="p">();</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">IntVarElement</span><span class="o">&amp;</span> <span class="n">new_element</span> <span class="o">=</span> <span class="n">container</span><span class="p">.</span><span class="n">Element</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="n">IntVar</span><span class="o">*</span> <span class="n">var</span> <span class="o">=</span> <span class="n">new_element</span><span class="p">.</span><span class="n">Var</span><span class="p">();</span>
    <span class="n">int64</span> <span class="n">index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">FindCopy</span><span class="p">(</span><span class="n">indices_</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">index</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">penalty</span> <span class="o">-=</span> <span class="n">out_values</span><span class="p">[</span><span class="n">index</span><span class="p">];</span>
      <span class="n">int64</span> <span class="n">new_penalty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">EvaluateElementValue</span><span class="p">(</span><span class="n">container</span><span class="p">,</span>
                               <span class="n">index</span><span class="p">,</span>
                               <span class="o">&amp;</span><span class="n">i</span><span class="p">,</span>
                               <span class="o">&amp;</span><span class="n">new_penalty</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">penalty</span> <span class="o">+=</span> <span class="n">new_penalty</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cache_delta_values</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">delta_cache_</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_penalty</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">penalty</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>This method updates the penalty of the whole solution given by a <tt class="docutils literal"><span class="pre">delta</span></tt> <tt class="docutils literal"><span class="pre">Assignment</span></tt> and is only called in <tt class="docutils literal"><span class="pre">AcceptDelta()</span></tt>. Recall that this <tt class="docutils literal"><span class="pre">delta</span></tt> is the difference between the last accepted solution <img class="math" src="../../_images/math/67bc6daa9d6b964201d6cef60cbeb1ac5fd26ead.png" alt="x_i" style="vertical-align: -3px"/> of the Local Search
and the candidate solution we are currently testing. We will not go into all the details. Just notice how the penalized value (variable <tt class="docutils literal"><span class="pre">penalty</span></tt>) is updated on lines 14 and 20.</p>
</li>
<li><p class="first"><tt class="docutils literal"><span class="pre">MakeElementPenalty()</span></tt> returns an <tt class="docutils literal"><span class="pre">IntExpr</span></tt> (pointer) to an <tt class="docutils literal"><span class="pre">Element</span></tt> expression (pointer) that can be casted to an <tt class="docutils literal"><span class="pre">IntVar</span></tt> (pointer). We use these variables to
compute the penalized part of the augmented objective function in such a way that we can add constraints with this expression.</p>
<p>For the <tt class="docutils literal"><span class="pre">BinaryGuidedLocalSearch</span></tt> the <tt class="docutils literal"><span class="pre">Element</span></tt> variable is computed as follows:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">IntExpr</span><span class="o">*</span> <span class="nf">MakeElementPenalty</span><span class="p">(</span><span class="kt">int</span> <span class="n">index</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">solver</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">MakeElement</span><span class="p">(</span>
  <span class="n">NewPermanentCallback</span><span class="p">(</span><span class="k">this</span><span class="p">,</span>
                       <span class="o">&amp;</span><span class="n">BinaryGuidedLocalSearch</span><span class="o">::</span><span class="n">PenalizedValue</span><span class="p">,</span>
                       <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">int64</span><span class="o">&gt;</span><span class="p">(</span><span class="n">index</span><span class="p">)),</span>
  <span class="n">vars_</span><span class="p">[</span><span class="n">index</span><span class="p">]);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In <tt class="docutils literal"><span class="pre">MakeElementPenalty()</span></tt>, <tt class="docutils literal"><span class="pre">NewPermanentCallback()</span></tt> with its second parameter <tt class="docutils literal"><span class="pre">static_cast&lt;int64&gt;(index)</span></tt> sets the first parameter of <tt class="docutils literal"><span class="pre">PenalizedValue()</span></tt> to <tt class="docutils literal"><span class="pre">index</span></tt>, i.e. we use
a callback that returns the cost associated to have an arc outgoing from node <img class="math" src="../../_images/math/34857b3ba74ce5cd8607f3ebd23e9015908ada71.png" alt="i" style="vertical-align: 0px"/> in a solution. The generated expression ensures that we compute the right penalized value for a given solution.</p>
</li>
</ul>
<p>Let&#8217;s now review the implemented <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt> callbacks for the <tt class="docutils literal"><span class="pre">GuidedLocalSearch</span></tt> class. The chosen order of presentation is pedagogical. Remember that the code is generic and is used for the 2- and 3-indices versions.</p>
</div>
<div class="section" id="entersearch">
<h3>7.6.4.4. <tt class="docutils literal"><span class="pre">EnterSearch()</span></tt></h3>
<p>This is where you initialize your code before a search is launched.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">EnterSearch</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Metaheuristic</span><span class="o">::</span><span class="n">EnterSearch</span><span class="p">();</span>
  <span class="n">penalized_objective_</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
  <span class="n">assignment_penalized_value_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">old_penalized_value_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">...</span>
  <span class="n">penalties_</span><span class="o">-&gt;</span><span class="n">Reset</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>This is a basic initialization. Of particular interest, notice how we set <tt class="docutils literal"><span class="pre">penalized_objective_</span></tt> to <tt class="docutils literal"><span class="pre">nullptr</span></tt>. We do this each time there are no penalties and later we can test <tt class="docutils literal"><span class="pre">if</span> <span class="pre">(penalized_objective_</span> <span class="pre">!=</span> <span class="pre">nullptr)</span></tt>.</p>
</div>
<div class="section" id="localoptimum">
<h3>7.6.4.5. <tt class="docutils literal"><span class="pre">LocalOptimum()</span></tt></h3>
<p>The <tt class="docutils literal"><span class="pre">LocalOptimum()</span></tt> method is called whenever a nested Local Search has finished. If one <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt> returns true in its <tt class="docutils literal"><span class="pre">LocalOptimum()</span></tt> callback, the Local Search is restarted and the search continues.
In this method, we penalize the features of the local optimum solution according to their utility. Recall that the feature used here is whether the solution traverses an arc <img class="math" src="../../_images/math/887919dfbc86eebc29e0373f98f97dbf23a0ae23.png" alt="(i,j)" style="vertical-align: -4px"/> or not.
We use the utility function described earlier:</p>
<div class="math">
<p><img src="../../_images/math/67efd4ce7260acbbb9e4e190abfff4eb58ee8b28.png" alt="u_{ij}(x) = \begin{cases} \frac{c_{ij}(x)}{1 + p_{ij}} &amp;\text{if arc } (i,j) \text{ is used;} \\
         0 &amp; \text{otherwise}. \end{cases}"/></p>
</div><p>and penalize the most expensive used arcs <img class="math" src="../../_images/math/887919dfbc86eebc29e0373f98f97dbf23a0ae23.png" alt="(i,j)" style="vertical-align: -4px"/> according to their utility.</p>
<p>Let&#8217;s recall the way the RL (Routing Library) encodes the traversing of an arc <img class="math" src="../../_images/math/887919dfbc86eebc29e0373f98f97dbf23a0ae23.png" alt="(i,j)" style="vertical-align: -4px"/> in a solution with <tt class="docutils literal"><span class="pre">vars_[i]</span> <span class="pre">=</span> <span class="pre">j</span></tt>, i.e. from node <img class="math" src="../../_images/math/34857b3ba74ce5cd8607f3ebd23e9015908ada71.png" alt="i" style="vertical-align: 0px"/> go to node <img class="math" src="../../_images/math/8122aa89ea6e80784c6513d22787ad86e36ad0cc.png" alt="j" style="vertical-align: -4px"/> where <tt class="docutils literal"><span class="pre">vars_[i]</span></tt> denotes the <tt class="docutils literal"><span class="pre">IntVar</span></tt> variable corresponding to node <img class="math" src="../../_images/math/34857b3ba74ce5cd8607f3ebd23e9015908ada71.png" alt="i" style="vertical-align: 0px"/>. If no arc is traversed from node <img class="math" src="../../_images/math/34857b3ba74ce5cd8607f3ebd23e9015908ada71.png" alt="i" style="vertical-align: 0px"/> (for instance node <img class="math" src="../../_images/math/34857b3ba74ce5cd8607f3ebd23e9015908ada71.png" alt="i" style="vertical-align: 0px"/> is an arrival depot or is not visited at all in a solution), RL&#8217;s convention is to set <tt class="docutils literal"><span class="pre">vars_[i]</span> <span class="pre">=</span> <span class="pre">i</span></tt>.</p>
<p>Because we only update the penalties in this callback, notice that the GLS is only triggered <strong>after</strong> a local optimum has been found.</p>
<p>We are now ready to read the code:</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">bool</span> <span class="nf">LocalOptimum</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Arc</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">utility</span><span class="p">(</span><span class="n">vars_</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vars_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">assignment_</span><span class="p">.</span><span class="n">Bound</span><span class="p">(</span><span class="n">vars_</span><span class="p">[</span><span class="n">i</span><span class="p">]))</span> <span class="p">{</span>
      <span class="c1">// Never synced with a solution, problem infeasible.</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">const</span> <span class="n">int64</span> <span class="n">var_value</span> <span class="o">=</span> <span class="n">assignment_</span><span class="p">.</span><span class="n">Value</span><span class="p">(</span><span class="n">vars_</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="k">const</span> <span class="n">int64</span> <span class="n">value</span> <span class="o">=</span>
    <span class="p">(</span><span class="n">var_value</span> <span class="o">!=</span> <span class="n">i</span><span class="p">)</span> <span class="o">?</span> <span class="n">AssignmentPenalty</span><span class="p">(</span><span class="n">assignment_</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">var_value</span><span class="p">)</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">Arc</span> <span class="n">arc</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">var_value</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">int64</span> <span class="n">penalty</span> <span class="o">=</span> <span class="n">penalties_</span><span class="o">-&gt;</span><span class="n">Value</span><span class="p">(</span><span class="n">arc</span><span class="p">);</span>
    <span class="n">utility</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">Arc</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arc</span><span class="p">,</span> <span class="n">value</span> <span class="o">/</span> <span class="p">(</span><span class="n">penalty</span> <span class="o">+</span> <span class="mf">1.0</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="n">Comparator</span> <span class="n">comparator</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">stable_sort</span><span class="p">(</span><span class="n">utility</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">utility</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">comparator</span><span class="p">);</span>
  <span class="n">int64</span> <span class="n">utility_value</span> <span class="o">=</span> <span class="n">utility</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">second</span><span class="p">;</span>
  <span class="n">penalties_</span><span class="o">-&gt;</span><span class="n">Increment</span><span class="p">(</span><span class="n">utility</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">first</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">utility</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
                              <span class="n">utility_value</span> <span class="o">==</span> <span class="n">utility</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">penalties_</span><span class="o">-&gt;</span><span class="n">Increment</span><span class="p">(</span><span class="n">utility</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">maximize_</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">current_</span> <span class="o">=</span> <span class="n">kint64min</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">current_</span> <span class="o">=</span> <span class="n">kint64max</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>The method is divided in 3 sections: lines 2 to 14 to compute the utilities, lines 15 to 22 to penalize the arcs according to their utilities and finally lines 23 to 28 to reset the value of the
<tt class="docutils literal"><span class="pre">current_</span></tt> variable that we use to bound our solutions in the Local Search.</p>
<p>In the first section (lines 2 to 14), we compute the utilities as follow. The utility of each variable <tt class="docutils literal"><span class="pre">vars_[i]</span></tt> is stored in the <tt class="docutils literal"><span class="pre">std::vector&lt;std::pair&lt;Arc,</span> <span class="pre">double&gt;</span> <span class="pre">&gt;</span></tt> <tt class="docutils literal"><span class="pre">utility</span></tt> array.
As you can read, we have to test if the solution if feasible, i.e. if each of its variable is bounded or not. This is done on lines 4 to 7.
For an arc <img class="math" src="../../_images/math/887919dfbc86eebc29e0373f98f97dbf23a0ae23.png" alt="(i,j)" style="vertical-align: -4px"/> (<tt class="docutils literal"><span class="pre">(i,</span> <span class="pre">var_value)</span></tt>), we compute its cost <tt class="docutils literal"><span class="pre">value</span></tt>: 0 if the arc is not traversed in the solution or <tt class="docutils literal"><span class="pre">AssignmentPenalty(assignment_,</span> <span class="pre">i,</span> <span class="pre">var_value)</span></tt> otherwise, i.e. the cost
to traverse arc <img class="math" src="../../_images/math/887919dfbc86eebc29e0373f98f97dbf23a0ae23.png" alt="(i,j)" style="vertical-align: -4px"/> in the solution. On line 13, the utility <img class="math" src="../../_images/math/e0d1ad74677466d8ab0a46eb34e1e710d5be06d6.png" alt="\frac{c_{ij}}{p_{ij} + 1}" style="vertical-align: -10px"/> is computed for the outgoing arc <img class="math" src="../../_images/math/887919dfbc86eebc29e0373f98f97dbf23a0ae23.png" alt="(i,j)" style="vertical-align: -4px"/>.</p>
<p>In the second section (lines 15 to 22), we only penalize arcs with the highest utility. First, we sort the utilities in descending order with the help of our <tt class="docutils literal"><span class="pre">Comparator</span></tt> in lines 15 and 16. On lines
17 and 18, we penalize the arc with the highest utility. The <tt class="docutils literal"><span class="pre">for</span></tt> loop on lines 19 to 22, penalize only the arcs with the same utility (<tt class="docutils literal"><span class="pre">utility_value</span> <span class="pre">==</span> <span class="pre">utility[i].second</span></tt>).</p>
<p>The third section (lines 23 to 28) is by now no surprise. We reset the value of the <tt class="docutils literal"><span class="pre">current_</span></tt> variable such that we can bound the solutions in the Local Search by a higher value than for instance
the value of the best solution: this allows the meta-heuristic to escape local optima.</p>
</div>
<div class="section" id="atsolution">
<h3>7.6.4.6. <tt class="docutils literal"><span class="pre">AtSolution()</span></tt></h3>
<p>The <tt class="docutils literal"><span class="pre">AtSolution()</span></tt> method is called whenever a solution is found and accepted in the Local Search</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="nf">AtSolution</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Metaheuristic</span><span class="o">::</span><span class="n">AtSolution</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">penalized_objective_</span> <span class="o">!=</span> <span class="n">nullptr</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// no move has been found</span>
    <span class="n">current_</span> <span class="o">+=</span> <span class="n">penalized_objective_</span><span class="o">-&gt;</span><span class="n">Value</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="n">assignment_</span><span class="p">.</span><span class="n">Store</span><span class="p">();</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>We update the best solution (<tt class="docutils literal"><span class="pre">Metaheuristic::AtSolution()</span></tt>) and the augmented objective function <img class="math" src="../../_images/math/311cabda3a9b09f0dde217303ca9d1cd9201dcf6.png" alt="g" style="vertical-align: -4px"/>. This is done as follow: first we update the <tt class="docutils literal"><span class="pre">current_</span></tt> variable with the current objective value (again in
Metaheuristic::AtSolution()) and then we add the &#8220;penalized part&#8221; <img class="math" src="../../_images/math/89bd49c9ca0568bc2d7eb7de1c6dbbe837fbe77e.png" alt="\lambda \sum_{(i.j)} \left( I_{ij}(x) \cdot p_{ij} \cdot c_{ij}(x) \right)" style="vertical-align: -8px"/> from <tt class="docutils literal"><span class="pre">penalized_objective_-&gt;Value()</span></tt>. We also store the current solution.</p>
</div>
<div class="section" id="applydecision">
<h3>7.6.4.7. <tt class="docutils literal"><span class="pre">ApplyDecision()</span></tt></h3>
<p>The <tt class="docutils literal"><span class="pre">ApplyDecision()</span></tt> method is called when a <tt class="docutils literal"><span class="pre">Decision</span></tt> is about to be applied. This is the place to add the constraints.</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">ApplyDecision</span><span class="p">(</span><span class="n">Decision</span><span class="o">*</span> <span class="k">const</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">==</span> <span class="n">solver</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">balancing_decision</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IntVar</span><span class="o">*&gt;</span> <span class="n">elements</span><span class="p">;</span>
  <span class="n">assignment_penalized_value_</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">penalties_</span><span class="o">-&gt;</span><span class="n">HasValues</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vars_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">IntExpr</span><span class="o">*</span> <span class="n">expr</span> <span class="o">=</span> <span class="n">MakeElementPenalty</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
      <span class="n">elements</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">expr</span><span class="o">-&gt;</span><span class="n">Var</span><span class="p">());</span>
      <span class="k">const</span> <span class="n">int64</span> <span class="n">penalty</span> <span class="o">=</span> <span class="n">AssignmentElementPenalty</span><span class="p">(</span><span class="n">assignment_</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
      <span class="n">current_penalized_values_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">penalty</span><span class="p">;</span>
      <span class="n">delta_cache_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">penalty</span><span class="p">;</span>
      <span class="n">assignment_penalized_value_</span> <span class="o">+=</span> <span class="n">penalty</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">old_penalized_value_</span> <span class="o">=</span> <span class="n">assignment_penalized_value_</span><span class="p">;</span>
    <span class="n">incremental_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
    <span class="n">penalized_objective_</span> <span class="o">=</span> <span class="n">solver</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">MakeSum</span><span class="p">(</span><span class="n">elements</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Var</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">maximize_</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">IntExpr</span><span class="o">*</span> <span class="n">min_pen_exp</span> <span class="o">=</span>
      <span class="n">solver</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">MakeDifference</span><span class="p">(</span><span class="n">current_</span> <span class="o">+</span> <span class="n">step_</span><span class="p">,</span> <span class="n">penalized_objective_</span><span class="p">);</span>
      <span class="n">IntVar</span><span class="o">*</span> <span class="n">min_exp</span> <span class="o">=</span>
                   <span class="n">solver</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">MakeMin</span><span class="p">(</span><span class="n">min_pen_exp</span><span class="p">,</span> <span class="n">best_</span> <span class="o">+</span> <span class="n">step_</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Var</span><span class="p">();</span>
      <span class="n">solver</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">AddConstraint</span><span class="p">(</span>
          <span class="n">solver</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">MakeGreaterOrEqual</span><span class="p">(</span><span class="n">objective_</span><span class="p">,</span> <span class="n">min_exp</span><span class="p">));</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">IntExpr</span><span class="o">*</span> <span class="n">max_pen_exp</span> <span class="o">=</span>
      <span class="n">solver</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">MakeDifference</span><span class="p">(</span><span class="n">current_</span> <span class="o">-</span> <span class="n">step_</span><span class="p">,</span> <span class="n">penalized_objective_</span><span class="p">);</span>
      <span class="n">IntVar</span><span class="o">*</span> <span class="n">max_exp</span> <span class="o">=</span>
                   <span class="n">solver</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">MakeMax</span><span class="p">(</span><span class="n">max_pen_exp</span><span class="p">,</span> <span class="n">best_</span> <span class="o">-</span> <span class="n">step_</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">Var</span><span class="p">();</span>
      <span class="n">solver</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">AddConstraint</span><span class="p">(</span><span class="n">solver</span><span class="p">()</span>
                                <span class="o">-&gt;</span><span class="n">MakeLessOrEqual</span><span class="p">(</span><span class="n">objective_</span><span class="p">,</span> <span class="n">max_exp</span><span class="p">));</span>
    <span class="p">}</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">penalized_objective_</span> <span class="o">=</span> <span class="n">nullptr</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">maximize_</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">const</span> <span class="n">int64</span> <span class="n">bound</span> <span class="o">=</span>
                   <span class="p">(</span><span class="n">current_</span> <span class="o">&gt;</span> <span class="n">kint64min</span><span class="p">)</span> <span class="o">?</span> <span class="n">current_</span> <span class="o">+</span> <span class="n">step_</span> <span class="o">:</span> <span class="n">current_</span><span class="p">;</span>
      <span class="n">objective_</span><span class="o">-&gt;</span><span class="n">SetMin</span><span class="p">(</span><span class="n">bound</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">const</span> <span class="n">int64</span> <span class="n">bound</span> <span class="o">=</span>
                   <span class="p">(</span><span class="n">current_</span> <span class="o">&lt;</span> <span class="n">kint64max</span><span class="p">)</span> <span class="o">?</span> <span class="n">current_</span> <span class="o">-</span> <span class="n">step_</span> <span class="o">:</span> <span class="n">current_</span><span class="p">;</span>
      <span class="n">objective_</span><span class="o">-&gt;</span><span class="n">SetMax</span><span class="p">(</span><span class="n">bound</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>Basically, this method adds the following constraint:</p>
<ul>
<li><dl class="first docutils">
<dt>when minimizing:</dt>
<dd><dl class="first last docutils">
<dt>objective &lt;= Max(current penalized cost - penalized_objective - step,</dt>
<dd><p class="first last">best solution cost - step)</p>
</dd>
</dl>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>when maximizing:</dt>
<dd><dl class="first last docutils">
<dt>objective &gt;= Min(current penalized cost - penalized_objective + step,</dt>
<dd><p class="first last">best solution cost + step)</p>
</dd>
</dl>
</dd>
</dl>
</li>
</ul>
<p>where &#8220;current penalized cost&#8221; is the augmented objective function value <img class="math" src="../../_images/math/659a6a2610357101d77dbae8eb9bf0b3100c08fd.png" alt="g(x)" style="vertical-align: -4px"/> of the current solution <img class="math" src="../../_images/math/26eeb5258ca5099acf8fe96b2a1049c48c89a5e6.png" alt="x" style="vertical-align: 0px"/> and &#8220;penalized_objective&#8221; - despite its name - corresponds to the penalized part of the
augmented objective function <strong>but</strong> expressed as an <tt class="docutils literal"><span class="pre">IntExpr</span></tt>.</p>
<p>Let&#8217;s dig into the code. As usual, we have to disregard the <tt class="docutils literal"><span class="pre">BalancingDecision</span></tt> on lines 2 to 4. Then we test if we have penalties on line 7. If not (lines 34 to 45), we simply add - in case of minimization -
the constraint <tt class="docutils literal"><span class="pre">objective</span> <span class="pre">&lt;=</span> <span class="pre">current_</span> <span class="pre">-</span> <span class="pre">step_</span></tt> but we do it like an <tt class="docutils literal"><span class="pre">ObjectiveVar</span></tt> by modifying the upper bound on the domain of the <tt class="docutils literal"><span class="pre">objective</span></tt> variable. This avoids one more constraint and is perfectly in line with our aspiration criterion to accept better solution.</p>
<p>The test <tt class="docutils literal"><span class="pre">penalties_-&gt;HasValues()</span></tt> on line 7 is <tt class="docutils literal"><span class="pre">true</span></tt> if there is at least one arc with a positive penalty.</p>
<p>If there is one or more penalties, we enter the code on the lines 8 to 32. For each arc <img class="math" src="../../_images/math/887919dfbc86eebc29e0373f98f97dbf23a0ae23.png" alt="(i,j)" style="vertical-align: -4px"/> (<tt class="docutils literal"><span class="pre">(i,</span> <span class="pre">assignment_.Value(vars_[i]))</span></tt>) , we create an <tt class="docutils literal"><span class="pre">Element</span></tt> expression corresponding to the <tt class="docutils literal"><span class="pre">Element</span></tt> constraint for the corresponding penalty on line 9. All these <tt class="docutils literal"><span class="pre">Element</span></tt> expressions are collected into a sum stored in the variable <tt class="docutils literal"><span class="pre">penalized_objective_</span></tt> on line 18. Lines 11 to 14 compute and store the
penalized part of the augmented objective function individually for each node. We skip lines 16 and 17 as they update variables to use with the deltas. Finally, we add the constraint mentioned right after the code in lines 19 to 33. Notice that the part &#8220;objective &lt;= current penalized cost - penalized_objective - step&#8221; of this constraint for the current solution reduces to &#8220;objective &lt;= objective - step&#8221; and that the second part allows us to accept better solutions (aspiration criterion).</p>
</div>
<div class="section" id="acceptdelta">
<h3>7.6.4.8. <tt class="docutils literal"><span class="pre">AcceptDelta()</span></tt></h3>
<p>This meta-heuristic is coded efficiently and uses the <tt class="docutils literal"><span class="pre">delta</span></tt> and <tt class="docutils literal"><span class="pre">deltadelta</span></tt> of the <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt>s. A quick reminder:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">delta</span></tt>: the difference between the initial solution that defines the neighborhood and the current candidate solution.</li>
<li><tt class="docutils literal"><span class="pre">deltadelta</span></tt>: the difference between the current candidate solution and the previous candidate solution. We say that the <tt class="docutils literal"><span class="pre">LocalSearchOperator</span></tt> is <tt class="docutils literal"><span class="pre">incremental</span></tt>.</li>
</ul>
<p>The <tt class="docutils literal"><span class="pre">AcceptDelta()</span></tt> method of a <tt class="docutils literal"><span class="pre">SearchMonitor</span></tt> can accept or refuse a candidate solution. It is <em>filtering</em> the solutions and the result of this callback in the main Local Search algorithm
(see the sub-section <a class="reference internal" href="../ls/basic_working_local_search.html#basic-local-search-algorithm-and-the-callback-hooks"><em>The basic Local Search algorithm and the callback hooks for the SearchMonitors</em></a>) is stored in a variable that has a very interesting name: <tt class="docutils literal"><span class="pre">meta_heuristics_filter</span></tt>.</p>
<p>The <tt class="docutils literal"><span class="pre">AcceptDelta()</span></tt> callback from the <tt class="docutils literal"><span class="pre">GuidedLocalSearch</span></tt> class computes the penalized value corresponding to the deltas and modifies their objective bound accordingly.</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">bool</span> <span class="nf">AcceptDelta</span><span class="p">(</span><span class="n">Assignment</span><span class="o">*</span> <span class="n">delta</span><span class="p">,</span> <span class="n">Assignment</span><span class="o">*</span> <span class="n">deltadelta</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">delta</span> <span class="o">!=</span> <span class="n">nullptr</span> <span class="o">||</span> <span class="n">deltadelta</span> <span class="o">!=</span> <span class="n">nullptr</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
                                              <span class="n">penalties_</span><span class="o">-&gt;</span><span class="n">HasValues</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">int64</span> <span class="n">penalty</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">deltadelta</span><span class="o">-&gt;</span><span class="n">Empty</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">incremental_</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">penalty</span> <span class="o">=</span> <span class="n">Evaluate</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span>
                           <span class="n">assignment_penalized_value_</span><span class="p">,</span>
                           <span class="n">current_penalized_values_</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span>
                           <span class="nb">true</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">penalty</span> <span class="o">=</span> <span class="n">Evaluate</span><span class="p">(</span><span class="n">deltadelta</span><span class="p">,</span>
                           <span class="n">old_penalized_value_</span><span class="p">,</span>
                           <span class="n">delta_cache_</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span>
                           <span class="nb">true</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="n">incremental_</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">incremental_</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vars_</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">delta_cache_</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">current_penalized_values_</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="n">old_penalized_value_</span> <span class="o">=</span> <span class="n">assignment_penalized_value_</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">incremental_</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
      <span class="n">penalty</span> <span class="o">=</span> <span class="n">Evaluate</span><span class="p">(</span><span class="n">delta</span><span class="p">,</span>
                         <span class="n">assignment_penalized_value_</span><span class="p">,</span>
                         <span class="n">current_penalized_values_</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span>
                         <span class="nb">false</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">old_penalized_value_</span> <span class="o">=</span> <span class="n">penalty</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">delta</span><span class="o">-&gt;</span><span class="n">HasObjective</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">delta</span><span class="o">-&gt;</span><span class="n">AddObjective</span><span class="p">(</span><span class="n">objective_</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">delta</span><span class="o">-&gt;</span><span class="n">Objective</span><span class="p">()</span> <span class="o">==</span> <span class="n">objective_</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">maximize_</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">delta</span><span class="o">-&gt;</span><span class="n">SetObjectiveMin</span><span class="p">(</span>
          <span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">current_</span> <span class="o">+</span> <span class="n">step_</span> <span class="o">-</span> <span class="n">penalty</span><span class="p">,</span> <span class="n">best_</span> <span class="o">+</span> <span class="n">step_</span><span class="p">),</span>
                <span class="n">delta</span><span class="o">-&gt;</span><span class="n">ObjectiveMin</span><span class="p">()));</span>
      <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">delta</span><span class="o">-&gt;</span><span class="n">SetObjectiveMax</span><span class="p">(</span>
          <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">max</span><span class="p">(</span><span class="n">current_</span> <span class="o">-</span> <span class="n">step_</span> <span class="o">-</span> <span class="n">penalty</span><span class="p">,</span> <span class="n">best_</span> <span class="o">-</span> <span class="n">step_</span><span class="p">),</span>
                <span class="n">delta</span><span class="o">-&gt;</span><span class="n">ObjectiveMax</span><span class="p">()));</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>This method returns <tt class="docutils literal"><span class="pre">true</span></tt> on line 47 as it accepts every <tt class="docutils literal"><span class="pre">delta</span></tt>. The whole update can only be applied if at least a <tt class="docutils literal"><span class="pre">delta</span></tt> is present and if penalties exist. This is precisely the test on lines 2 and 3.
The code on lines 4 to 31 updates the penalized value of the candidate solution. The code is a little bit intricate because it has to be generic: we test the presence of the <tt class="docutils literal"><span class="pre">deltadelta</span></tt> and <tt class="docutils literal"><span class="pre">delta</span></tt> data structures and update the <tt class="docutils literal"><span class="pre">incremental_</span></tt> parameter accordingly. When then use the best (aka most efficient) method to update this penalized value with a call to <tt class="docutils literal"><span class="pre">Evaluate()</span></tt>. On lines 35 to 45, we update
the bound of <tt class="docutils literal"><span class="pre">delta</span></tt>: this can speed up the process to accept or reject this candidate solution.</p>
</div>
</div>
<div class="section" id="the-real-classes">
<h2>7.6.5. The real classes</h2>
<p><tt class="docutils literal"><span class="pre">GuidedLocalSearch</span></tt> classes come in two flavors:</p>
<ul class="simple">
<li><tt class="docutils literal"><span class="pre">BinaryGuidedLocalSearch</span></tt>:</li>
<li><tt class="docutils literal"><span class="pre">TernaryGuidedLocalSearch</span></tt>:</li>
</ul>
<div class="section" id="binaryguidedlocalsearch">
<h3>7.6.5.1. <tt class="docutils literal"><span class="pre">BinaryGuidedLocalSearch</span></tt></h3>
<p>The <tt class="docutils literal"><span class="pre">BinaryGuidedLocalSearch</span></tt> class is used for Routing Problems where the traversing of an edge doesn&#8217;t depend on the type of vehicles, i.e. the cost is the same for <strong>all</strong> vehicles.</p>
<p>Here is the constructor:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">BinaryGuidedLocalSearch</span><span class="o">::</span><span class="n">BinaryGuidedLocalSearch</span><span class="p">(</span>
    <span class="n">Solver</span><span class="o">*</span> <span class="k">const</span> <span class="n">solver</span><span class="p">,</span>
    <span class="n">IntVar</span><span class="o">*</span> <span class="k">const</span> <span class="n">objective</span><span class="p">,</span>
    <span class="n">Solver</span><span class="o">::</span><span class="n">IndexEvaluator2</span><span class="o">*</span> <span class="n">objective_function</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">maximize</span><span class="p">,</span>
    <span class="n">int64</span> <span class="n">step</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IntVar</span><span class="o">*&gt;&amp;</span> <span class="n">vars</span><span class="p">,</span>
    <span class="kt">double</span> <span class="n">penalty_factor</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">GuidedLocalSearch</span><span class="p">(</span><span class="n">solver</span><span class="p">,</span>
                        <span class="n">objective</span><span class="p">,</span>
                        <span class="n">maximize</span><span class="p">,</span>
                        <span class="n">step</span><span class="p">,</span>
                        <span class="n">vars</span><span class="p">,</span>
                        <span class="n">penalty_factor</span><span class="p">),</span>
      <span class="n">objective_function_</span><span class="p">(</span><span class="n">objective_function</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">objective_function_</span><span class="o">-&gt;</span><span class="n">CheckIsRepeatable</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The variables <tt class="docutils literal"><span class="pre">vars</span></tt> are the main variables corresponding to the nodes. The objective function is a callback that takes two <tt class="docutils literal"><span class="pre">int64</span></tt> and returns an <tt class="docutils literal"><span class="pre">int64</span></tt>. Basically, it&#8217;s the cost of traversing
the arc <img class="math" src="../../_images/math/887919dfbc86eebc29e0373f98f97dbf23a0ae23.png" alt="(i,j)" style="vertical-align: -4px"/>.</p>
<p>The corresponding factory method is:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">SearchMonitor</span><span class="o">*</span> <span class="n">Solver</span><span class="o">::</span><span class="n">MakeGuidedLocalSearch</span><span class="p">(</span>
    <span class="kt">bool</span> <span class="n">maximize</span><span class="p">,</span>
    <span class="n">IntVar</span><span class="o">*</span> <span class="k">const</span> <span class="n">objective</span><span class="p">,</span>
    <span class="n">ResultCallback2</span><span class="o">&lt;</span><span class="n">int64</span><span class="p">,</span> <span class="n">int64</span><span class="p">,</span> <span class="n">int64</span><span class="o">&gt;*</span> <span class="n">objective_function</span><span class="p">,</span>
    <span class="n">int64</span> <span class="n">step</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IntVar</span><span class="o">*&gt;&amp;</span> <span class="n">vars</span><span class="p">,</span>
    <span class="kt">double</span> <span class="n">penalty_factor</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">RevAlloc</span><span class="p">(</span><span class="k">new</span> <span class="n">BinaryGuidedLocalSearch</span><span class="p">(</span><span class="k">this</span><span class="p">,</span>
                                              <span class="n">objective</span><span class="p">,</span>
                                              <span class="n">objective_function</span><span class="p">,</span>
                                              <span class="n">maximize</span><span class="p">,</span>
                                              <span class="n">step</span><span class="p">,</span>
                                              <span class="n">vars</span><span class="p">,</span>
                                              <span class="n">penalty_factor</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="ternaryguidedlocalsearch">
<h3>7.6.5.2. <tt class="docutils literal"><span class="pre">TernaryGuidedLocalSearch</span></tt></h3>
<p>This version was especially made to deal with heterogeneous costs for different vehicles in the Routing Library: the cost of an arc also depends on the
vehicle used. At the initialization of the Routing Solver, the <tt class="docutils literal"><span class="pre">GuidedLocalSearch</span></tt> meta-heuristic is created as follow:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">...</span>
<span class="k">switch</span> <span class="p">(</span><span class="n">metaheuristic</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">ROUTING_GUIDED_LOCAL_SEARCH</span>:
    <span class="k">if</span> <span class="p">(</span><span class="n">CostsAreHomogeneousAcrossVehicles</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">optimize</span> <span class="o">=</span> <span class="n">solver_</span><span class="o">-&gt;</span><span class="n">MakeGuidedLocalSearch</span><span class="p">(</span>
        <span class="nb">false</span><span class="p">,</span> <span class="n">cost_</span><span class="p">,</span>
        <span class="n">NewPermanentCallback</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">RoutingModel</span><span class="o">::</span><span class="n">GetHomogeneousCost</span><span class="p">),</span>
        <span class="n">FLAGS_routing_optimization_step</span><span class="p">,</span> <span class="n">nexts_</span><span class="p">,</span>
        <span class="n">FLAGS_routing_guided_local_search_lambda_coefficient</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">optimize</span> <span class="o">=</span> <span class="n">solver_</span><span class="o">-&gt;</span><span class="n">MakeGuidedLocalSearch</span><span class="p">(</span>
        <span class="nb">false</span><span class="p">,</span> <span class="n">cost_</span><span class="p">,</span>
        <span class="n">NewPermanentCallback</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">RoutingModel</span><span class="o">::</span><span class="n">GetArcCostForVehicle</span><span class="p">),</span>
        <span class="n">FLAGS_routing_optimization_step</span><span class="p">,</span> <span class="n">nexts_</span><span class="p">,</span> <span class="n">vehicle_vars_</span><span class="p">,</span>
        <span class="n">FLAGS_routing_guided_local_search_lambda_coefficient</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">break</span><span class="p">;</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If the costs are the same for all vehicles, we use the <tt class="docutils literal"><span class="pre">int64</span> <span class="pre">RoutingModel::GetHomogeneousCost(int64</span> <span class="pre">i,</span> <span class="pre">int64</span> <span class="pre">j)</span></tt> costs.
This method takes two <tt class="docutils literal"><span class="pre">int64</span></tt>: the index of the first node <tt class="docutils literal"><span class="pre">i</span></tt> and the index of the second node <tt class="docutils literal"><span class="pre">j</span></tt>. If on the contrary, the costs depend on the vehicle traversing an arc <tt class="docutils literal"><span class="pre">(i,</span> <span class="pre">j)</span></tt>, we use the
<tt class="docutils literal"><span class="pre">int64</span> <span class="pre">RoutingModel::GetArcCostForVehicle(int64</span> <span class="pre">i,</span> <span class="pre">int64</span> <span class="pre">j,</span> <span class="pre">int64</span> <span class="pre">k)</span></tt> costs: the third <tt class="docutils literal"><span class="pre">int64</span></tt> <tt class="docutils literal"><span class="pre">k</span></tt> corresponds to the index of the vehicle type used to traverse the arc <tt class="docutils literal"><span class="pre">(i,</span> <span class="pre">j)</span></tt>.</p>
<p>The corresponding factory method is:</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">SearchMonitor</span><span class="o">*</span> <span class="n">Solver</span><span class="o">::</span><span class="n">MakeGuidedLocalSearch</span><span class="p">(</span>
    <span class="kt">bool</span> <span class="n">maximize</span><span class="p">,</span>
    <span class="n">IntVar</span><span class="o">*</span> <span class="k">const</span> <span class="n">objective</span><span class="p">,</span>
    <span class="n">ResultCallback3</span><span class="o">&lt;</span><span class="n">int64</span><span class="p">,</span> <span class="n">int64</span><span class="p">,</span> <span class="n">int64</span><span class="p">,</span> <span class="n">int64</span><span class="o">&gt;*</span> <span class="n">objective_function</span><span class="p">,</span>
    <span class="n">int64</span> <span class="n">step</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IntVar</span><span class="o">*&gt;&amp;</span> <span class="n">vars</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">IntVar</span><span class="o">*&gt;&amp;</span> <span class="n">secondary_vars</span><span class="p">,</span>
    <span class="kt">double</span> <span class="n">penalty_factor</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">RevAlloc</span><span class="p">(</span><span class="k">new</span> <span class="n">TernaryGuidedLocalSearch</span><span class="p">(</span><span class="k">this</span><span class="p">,</span>
                                               <span class="n">objective</span><span class="p">,</span>
                                               <span class="n">objective_function</span><span class="p">,</span>
                                               <span class="n">maximize</span><span class="p">,</span>
                                               <span class="n">step</span><span class="p">,</span>
                                               <span class="n">vars</span><span class="p">,</span>
                                               <span class="n">secondary_vars</span><span class="p">,</span>
                                               <span class="n">penalty_factor</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The secondary <tt class="docutils literal"><span class="pre">secondary_vars</span></tt> variables are simply the variables corresponding to the vehicles.</p>
</div>
</div>
<div class="section" id="guidelines-to-write-your-own-gls">
<h2>7.6.6. Guidelines to write your own GLS</h2>
<p>GLS is a good meta-heuristic and it might be worth to give it a try to solve your problem.</p>
<p>As we have seen, our implementation of the GLS is heavily optimized: not only do we use GLS filtering (<tt class="docutils literal"><span class="pre">AcceptDelta()</span></tt>) but the implementation is especially tailored
for Routing Problems and objective functions of the form <img class="math" src="../../_images/math/82a9f44bc51ca08a5320765c38c0bc2f888e5c03.png" alt="\sum_{(i,j)} c_{ij}" style="vertical-align: -8px"/>. What if you have a problem that doesn&#8217;t fit into this canvas? Create your own version of the GLS!</p>
<p>We give you some hints on how to do that in this sub-section.</p>
<p>First, you have to change the call to a 2-indices or 3-indices callbacks to compute the objective function value.</p>
<p>Second, if you look carefully at the code of the abstract <tt class="docutils literal"><span class="pre">GuidedLocalSearch</span></tt> class,
you&#8217;ll find that the only method that really depends on 2 indices is the <tt class="docutils literal"><span class="pre">AssignmentPenalty()</span></tt> method. This method is only used in the <tt class="docutils literal"><span class="pre">LocalOptimum()</span></tt> callback.</p>
<p>Third, you have to adapt all 2- and 3-indices data structures such as for instance the <tt class="docutils literal"><span class="pre">GuidedLocalSearchPenalties</span></tt> classes.</p>
<p>Finally, you have to decide if you need GLS filtering or not.</p>
<p>All in all, the <tt class="docutils literal"><span class="pre">GuidedLocalSearch</span></tt>, <tt class="docutils literal"><span class="pre">BinaryGuidedLocalSearch</span></tt>, <tt class="docutils literal"><span class="pre">TernaryGuidedLocalSearch</span></tt> and <tt class="docutils literal"><span class="pre">GuidedLocalSearchPenalties</span></tt>, <tt class="docutils literal"><span class="pre">GuidedLocalSearchPenaltiesTable</span></tt>, <tt class="docutils literal"><span class="pre">GuidedLocalSearchPenaltiesMap</span></tt> classes
give you a good example on how to implement your own GLS.</p>
<h4>Footnotes</h4><table class="docutils footnote" frame="void" id="gls-2-indices-or-3" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>There is also a version with 3 indices <img class="math" src="../../_images/math/34857b3ba74ce5cd8607f3ebd23e9015908ada71.png" alt="i" style="vertical-align: 0px"/>, <img class="math" src="../../_images/math/8122aa89ea6e80784c6513d22787ad86e36ad0cc.png" alt="j" style="vertical-align: -4px"/> and <img class="math" src="../../_images/math/8c325612684d41304b9751c175df7bcc0f61f64f.png" alt="k" style="vertical-align: 0px"/> where the cost function returns the cost of traversing an arc <img class="math" src="../../_images/math/887919dfbc86eebc29e0373f98f97dbf23a0ae23.png" alt="(i,j)" style="vertical-align: -4px"/> with a vehicle <img class="math" src="../../_images/math/8c325612684d41304b9751c175df7bcc0f61f64f.png" alt="k" style="vertical-align: 0px"/>, i.e.
the cost of traversing an arc depends on the type of vehicles used. Read on.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="rl-real-conventions" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><p class="first">See the sections <a class="reference internal" href="../tsp/model_behind_scenes_overview.html#rl-model-behind-scenes-overview"><em>The model behind the scene: overview</em></a> and <a class="reference internal" href="../under_the_hood/rl.html#hood-rl"><em>The Routing Library (RL)</em></a> to understand the juicy details. We omit these details here as they are not important to understand the GLS algorithm.</p>
</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="hash-map-compiler-dependant" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td>The <tt class="docutils literal"><span class="pre">hash_map</span></tt> data structure is compiler dependent but it is exactly what its name says: a hash map.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="functor-idiom-in-cplusplus" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td>This is a very common idiom in <tt class="docutils literal"><span class="pre">C++</span></tt>. Not only does it allow to construct more robust code (you can use functions and/or classes) and use the <tt class="docutils literal"><span class="pre">STL</span></tt>
(Standard Template Library) but it also allows you to use <em>states</em> (variables) and most compilers can do some tricks to speed up the code. See <a class="reference external" href="http://en.wikipedia.org/wiki/Function_object#In_C_and_C.2B.2B">http://en.wikipedia.org/wiki/Function_object#In_C_and_C.2B.2B</a> for more.</td></tr>
</tbody>
</table>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar">
        <div class="sphinxsidebarwrapper">
<table>
<tr>
<td width="60"><img src="../../_static/logo.png" width="50" height="50"  alt="" /></td>
<td><p class="library_name">Google <a href="http://code.google.com/p/or-tools/"><strong>or-tools</strong></a><br>open source library</p></td>
</tr>
</table>
<h1>User's Manual</h1>

  
   



<h3>Google search</h3>

<form method="get" action="http://www.google.com/search">

<div style="padding:-1px;width:15em;">
<table border="0" cellpadding="0">
<tr><td>
<input type="text"   name="q" size="25"
 maxlength="255" value="" />
<input type="submit" value="Go" /></td></tr>
<tr><td align="center" style="font-size:80%">
Search:
<select name="sitesearch" width="125" style="width: 125px">
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/user_manual/" selected>user's manual</option>
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/faq/">faq</option>
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/reference_manual/or-tools/">reference manual</option>
<option value="http://or-tools.googlecode.com/svn/trunk/documentation/">All or-tools doc</option>
</select>
</td></tr>
</table>
</div>

</form>
</br>




  <h3>Welcome</h3>
  
  <ul>
  	<li><a href="../../index.html">Content and foreword</a></li>
  	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html">Documentation's hub</a></li>
	<li><a href="http://code.google.com/p/or-tools/">The or-tools open source library</a></li></li>	
  </ul>
  
   
	


  <h3>Tutorial examples</h3>
  
  <ul>
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_C++">C++</a></li>
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_Python">Python</a></li>	
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_Java">Java</a></li>
	<li><a href="http://or-tools.googlecode.com/svn/trunk/documentation/documentation_hub.html#tutorial_Csharp">C#</a></li>
</ul>
  
   
	

  <h3>Current chapter</h3>
  <p class="topless"><a href="../metaheuristics.html"
                        title="previous chapter">7. Meta-heuristics: several previous problems</a></p>
  <h3>Previous section</h3>
  <p class="topless"><a href="SA.html"
                        title="previous chapter">7.5. Simulated Annealing (SA)</a></p>
  <h3>Next section</h3>
  <p class="topless"><a href="jobshop_lns.html"
                        title="next chapter">7.7. Large neighborhood search (LNS): the Job-Shop Problem</a></p>
  <h3>Current section</a></h3>
  <ul>
<li><a class="reference internal" href="#">7.6. Guided Local Search (GLS)</a><ul>
<li><a class="reference internal" href="#the-basic-idea">7.6.1. The basic idea</a><ul>
<li><a class="reference internal" href="#the-augmented-objective-function">7.6.1.1. The augmented objective function</a></li>
<li><a class="reference internal" href="#the-penalties-and-their-modifications">7.6.1.2. The penalties and their modifications</a></li>
</ul>
</li>
<li><a class="reference internal" href="#our-implementation">7.6.2. Our implementation</a></li>
<li><a class="reference internal" href="#guidedlocalsearchpenalties">7.6.3. <tt class="docutils literal"><span class="pre">GuidedLocalSearchPenalties</span></tt></a></li>
<li><a class="reference internal" href="#the-abstract-guidedlocalsearch-class">7.6.4. The abstract <tt class="docutils literal"><span class="pre">GuidedLocalSearch</span></tt> class</a><ul>
<li><a class="reference internal" href="#to-compare-two-arcs">7.6.4.1. To compare two <tt class="docutils literal"><span class="pre">Arc</span></tt>s</a></li>
<li><a class="reference internal" href="#the-variables-and-the-constructor">7.6.4.2. The variables and the constructor</a></li>
<li><a class="reference internal" href="#the-pure-virtual-methods-and-the-helpers">7.6.4.3. The pure virtual methods and the helpers</a></li>
<li><a class="reference internal" href="#entersearch">7.6.4.4. <tt class="docutils literal"><span class="pre">EnterSearch()</span></tt></a></li>
<li><a class="reference internal" href="#localoptimum">7.6.4.5. <tt class="docutils literal"><span class="pre">LocalOptimum()</span></tt></a></li>
<li><a class="reference internal" href="#atsolution">7.6.4.6. <tt class="docutils literal"><span class="pre">AtSolution()</span></tt></a></li>
<li><a class="reference internal" href="#applydecision">7.6.4.7. <tt class="docutils literal"><span class="pre">ApplyDecision()</span></tt></a></li>
<li><a class="reference internal" href="#acceptdelta">7.6.4.8. <tt class="docutils literal"><span class="pre">AcceptDelta()</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#the-real-classes">7.6.5. The real classes</a><ul>
<li><a class="reference internal" href="#binaryguidedlocalsearch">7.6.5.1. <tt class="docutils literal"><span class="pre">BinaryGuidedLocalSearch</span></tt></a></li>
<li><a class="reference internal" href="#ternaryguidedlocalsearch">7.6.5.2. <tt class="docutils literal"><span class="pre">TernaryGuidedLocalSearch</span></tt></a></li>
</ul>
</li>
<li><a class="reference internal" href="#guidelines-to-write-your-own-gls">7.6.6. Guidelines to write your own GLS</a></li>
</ul>
</li>
</ul>

        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="jobshop_lns.html" title="7.7. Large neighborhood search (LNS): the Job-Shop Problem"
             >next</a> |</li>
        <li class="right" >
          <a href="SA.html" title="7.5. Simulated Annealing (SA)"
             >previous</a> |</li>
        <li><a href="../../index.html">or-tools User&#39;s Manual</a> &raquo;</li>
          <li><a href="../metaheuristics.html" >7. Meta-heuristics: several previous problems</a> &raquo;</li> 
      </ul>
    </div>
    <div class="footer">
        &copy; Copyright 2012-2015, Google.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>