// Copyright 2010-2024 Google LLC
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Protocol buffer used to parametrize an iterated local search (ILS) approach.
// ILS is an iterative metaheuristic in which every iteration consists in
// performing a perturbation followed by an improvement step on a reference
// solution to generate a neighbor solution.
// The neighbor solution is accepted as the new reference solution according
// to an acceptance criterion.
// The best found solution is eventually returned.

syntax = "proto3";

option java_package = "com.google.ortools.routing";
option java_multiple_files = true;
option csharp_namespace = "Google.OrTools.Routing";

import "ortools/routing/enums.proto";

package operations_research;

// Ruin strategy that removes a number of spatially close routes.
message SpatiallyCloseRoutesRuinStrategy {
  // Number of spatially close routes ruined at each ruin application.
  optional uint32 num_ruined_routes = 3;
}

// Ruin strategy that removes a number of customers by performing a random walk
// on the underlying routing solution. More precisely, starting from a randomly
// selected seed visit, the walk is extended by either moving within the
// same route or by jumping to a visit served by a different neighboring
// route. Every active visit encountered along this random walk is made
// unperformed.
message RandomWalkRuinStrategy {
  // Number of visits removed during a ruin application defined on visits.
  // Note that pickup and delivery pairs are considered as a single entity,
  // i.e., the removal of a pickup (respectively delivery) causes the removal of
  // the associated delivery (respectively pickup) and it counts as a single
  // removal.
  optional uint32 num_removed_visits = 7;
}

// Ruin strategies, used in perturbation based on ruin and recreate approaches.
message RuinStrategy {
  oneof strategy {
    SpatiallyCloseRoutesRuinStrategy spatially_close_routes = 1;
    RandomWalkRuinStrategy random_walk = 2;
  }
}

// The ruin composition strategies specifies how ruin are selected at every ILS
// iteration.
message RuinCompositionStrategy {
  enum Value {
    // Unspecified value.
    UNSET = 0;

    // Execute all ruin strategies sequentially in the same order provided in
    // input.
    RUN_ALL_SEQUENTIALLY = 1;

    // Execute all ruin strategies in a random order.
    RUN_ALL_RANDOMLY = 2;

    // Execute a randomly selected ruin.
    RUN_ONE_RANDOMLY = 3;
  }
}

// Parameters to configure a perturbation based on a ruin and recreate approach.
message RuinRecreateParameters {
  // List of ruin strategies determining how a reference solution is ruined.
  repeated RuinStrategy ruin_strategies = 1;

  // The composition strategy to use when combining the given 'ruin_strategies'.
  // Has no effect when ruin_strategies is composed of a single strategy.
  RuinCompositionStrategy.Value ruin_composition_strategy = 2;

  // Strategy defining how a reference solution is recreated.
  FirstSolutionStrategy.Value recreate_strategy = 3;

  // Ratio in [0, 1] of non start/end nodes to consider as neighbors for the
  // identification of routes spatially close to a non start/end seed node.
  //
  // In particular, given a non start/end seed node s served by route r, we say
  // that a route r' is spatially close to the seed node s if there is at
  // least one non start/end node s' among the neighbors of s, such that s' is
  // served by r'.
  //
  // The neighbors_ratio is coupled with the corresponding min_neighbors and
  // max_neighbors values, defining the minimum and maximum number of neighbor
  // nodes considered for a given seed node:
  // num_neighbors = min(max_neighbors,
  //          max(min_neighbors, neighbors_ratio * NUM_NON_START_END_NODES))
  //
  // Neighbors ratio, and minimum and maximum number of non start/end neighbor
  // nodes for the identification of spatially close routes.
  optional double route_selection_neighbors_ratio = 4;
  optional uint32 route_selection_min_neighbors = 5;
  optional uint32 route_selection_max_neighbors = 6;
}

// Defines how a reference solution is perturbed.
message PerturbationStrategy {
  enum Value {
    // Unspecified value.
    UNSET = 0;

    // Performs a perturbation in a ruin and recreate fashion.
    RUIN_AND_RECREATE = 1;
  }
}

// The cooling schedule strategy defines how to compute the current simulated
// annealing temperature t given
// - the initial temperature t0
// - the final temperature t1
// - the current search progress 0 <= p <= 1
//
// The value of t0 and t1 is defined by the initial_temperature and
// final_temperature in SimulatedAnnealingParameters, respectively.
//
// The search progress p is derived, at any given time, by the search limits.
// In particular, p measures how far we are in the search process w.r.t. to the
// number of explored solutions and the time limit.
//
// The temperature t, computed according to one of the strategies defined below,
// together with the selected AcceptanceStrategy, is used to guide the search
// trajectory. In particular, given a neighbor solution S', generated by the
// the application of the perturbation and improvement step to a reference
// solution S, we have that S will be replaced by S' iff
//                  cost(S') + t * log(U(0, 1)) < cost(S)
// where U(0, 1) is a random number sampled from a uniform distribution of real
// numbers in [0, 1].
message CoolingScheduleStrategy {
  enum Value {
    // Unspecified value.
    UNSET = 0;

    // Exponentially decreases the temperature as the search progresses.
    // More precisely, t = t0 * (t1/t0)^p.
    EXPONENTIAL = 1;

    // Linearly decreases the temperature as the search progresses.
    // More precisely, t = t0 - p * (t0 - t1).
    LINEAR = 2;
  }
}

// Specifies the behavior of a simulated annealing acceptance strategy.
message SimulatedAnnealingParameters {
  // Determines the speed at which the temperature changes from initial to
  // final.
  CoolingScheduleStrategy.Value cooling_schedule_strategy = 1;

  // The initial temperature. See CoolingScheduleStrategy for its usage.
  optional double initial_temperature = 2;

  // The final temperature. See CoolingScheduleStrategy for its usage.
  optional double final_temperature = 3;

  // Automatically define the value for the temperatures as follows.
  // First, a  reference temperature t is defined as
  //           w1 * c1 + w2 * c2 + ... + wK * cK
  // where 0 < wJ <= 1 is the fraction of vehicles of cost class J and cJ is the
  // average arc cost for the cost class J.
  // The value of cJ is identified by randomly sampling N arc costs for the cost
  // class J, where N is equal to the number of instance nodes.
  // The initial and final temperatures are then defined as
  // - initial_temperature: 0.1 * t
  // - final_temperature: 0.001 * t
  optional bool automatic_temperatures = 4;
}

// Determines when a neighbor solution, obtained by the application of a
// perturbation and improvement step to a reference solution, is used to
// replace the reference solution.
message AcceptanceStrategy {
  enum Value {
    // Unspecified value.
    UNSET = 0;

    // Accepts only solutions that are improving with respect to the reference
    // one.
    GREEDY_DESCENT = 1;

    // Accepts a candidate solution with a probability that depends on its
    // quality and on the current state of the search.
    SIMULATED_ANNEALING = 2;
  }
}

// Specifies the behavior of a search based on ILS.
message IteratedLocalSearchParameters {
  // Determines how a reference solution S is perturbed to obtain a neighbor
  // solution S'.
  PerturbationStrategy.Value perturbation_strategy = 1;

  // Parameters to customize a ruin and recreate perturbation.
  RuinRecreateParameters ruin_recreate_parameters = 2;

  // Determines whether solution S', obtained from the perturbation, should be
  // optimized with a local search application.
  optional bool improve_perturbed_solution = 3;

  // Determines when the neighbor solution S', possibly improved if
  // `improve_perturbed_solution` is true, replaces the reference solution S.
  AcceptanceStrategy.Value acceptance_strategy = 4;

  // Parameters to customize a simulated annealing acceptance strategy. These
  // parameters are required iff the acceptance_strategy is SIMULATED_ANNEALING.
  SimulatedAnnealingParameters simulated_annealing_parameters = 5;
}
