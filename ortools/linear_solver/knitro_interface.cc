// ADD HEADER

#include <algorithm>
#include <clocale>
#include <cmath>
#include <fstream>
#include <iostream>
#include <istream>
#include <limits>
#include <memory>
#include <mutex>
#include <string>

#include "absl/status/status.h"
#include "absl/strings/str_format.h"
#include "ortools/base/logging.h"
#include "ortools/base/timer.h"
#include "ortools/knitro/environment.h"
#include "ortools/linear_solver/linear_solver.h"

#define CHECK_STATUS(s)    \
  do {                     \
    int const status_ = s; \
    CHECK_EQ(0, status_);  \
  } while (0)

namespace operations_research {

/**
 * Knitro does not support inf values
 * so it is mandatory to convert them into
 * KN_INFINITY
 * @param value the evaluated value
 * @return KN_INFINITY if the value is inf otherwise value
 */
inline double redefine_infinity_double(double value) {
  if (std::isinf(value)) {
    return value > 0 ? KN_INFINITY : -KN_INFINITY;
  }
  return value;
}

// static std::map<std::string, int>& getMapParam() {
//   static std::map<std::string, int> mapControls = {
//       {"KN_PARAM_NEWPOINT", KN_PARAM_NEWPOINT},
//       {"KN_NEWPOINT_NONE", KN_NEWPOINT_NONE},
//       {"KN_NEWPOINT_SAVEONE", KN_NEWPOINT_SAVEONE},
//       {"KN_NEWPOINT_SAVEALL", KN_NEWPOINT_SAVEALL},
//       {"KN_PARAM_HONORBNDS", KN_PARAM_HONORBNDS},
//       {"KN_HONORBNDS_AUTO", KN_HONORBNDS_AUTO},
//       {"KN_HONORBNDS_NO", KN_HONORBNDS_NO},
//       {"KN_HONORBNDS_ALWAYS", KN_HONORBNDS_ALWAYS},
//       {"KN_HONORBNDS_INITPT", KN_HONORBNDS_INITPT},
//       {"KN_PARAM_ALGORITHM", KN_PARAM_ALGORITHM},
//       {"KN_PARAM_ALG", KN_PARAM_ALG},
//       {"KN_ALG_AUTOMATIC", KN_ALG_AUTOMATIC},
//       {"KN_ALG_AUTO", KN_ALG_AUTO},
//       {"KN_ALG_BAR_DIRECT", KN_ALG_BAR_DIRECT},
//       {"KN_ALG_BAR_CG", KN_ALG_BAR_CG},
//       {"KN_ALG_ACT_CG", KN_ALG_ACT_CG},
//       {"KN_ALG_ACT_SQP", KN_ALG_ACT_SQP},
//       {"KN_ALG_MULTI", KN_ALG_MULTI},
//       {"KN_PARAM_BAR_MURULE", KN_PARAM_BAR_MURULE},
//       {"KN_BAR_MURULE_AUTOMATIC", KN_BAR_MURULE_AUTOMATIC},
//       {"KN_BAR_MURULE_AUTO", KN_BAR_MURULE_AUTO},
//       {"KN_BAR_MURULE_MONOTONE", KN_BAR_MURULE_MONOTONE},
//       {"KN_BAR_MURULE_ADAPTIVE", KN_BAR_MURULE_ADAPTIVE},
//       {"KN_BAR_MURULE_PROBING", KN_BAR_MURULE_PROBING},
//       {"KN_BAR_MURULE_DAMPMPC", KN_BAR_MURULE_DAMPMPC},
//       {"KN_BAR_MURULE_FULLMPC", KN_BAR_MURULE_FULLMPC},
//       {"KN_BAR_MURULE_QUALITY", KN_BAR_MURULE_QUALITY},
//       {"KN_PARAM_BAR_FEASIBLE", KN_PARAM_BAR_FEASIBLE},
//       {"KN_BAR_FEASIBLE_NO", KN_BAR_FEASIBLE_NO},
//       {"KN_BAR_FEASIBLE_STAY", KN_BAR_FEASIBLE_STAY},
//       {"KN_BAR_FEASIBLE_GET", KN_BAR_FEASIBLE_GET},
//       {"KN_BAR_FEASIBLE_GET_STAY", KN_BAR_FEASIBLE_GET_STAY},
//       {"KN_PARAM_GRADOPT", KN_PARAM_GRADOPT},
//       {"KN_GRADOPT_EXACT", KN_GRADOPT_EXACT},
//       {"KN_GRADOPT_FORWARD", KN_GRADOPT_FORWARD},
//       {"KN_GRADOPT_CENTRAL", KN_GRADOPT_CENTRAL},
//       {"KN_GRADOPT_USER_FORWARD", KN_GRADOPT_USER_FORWARD},
//       {"KN_GRADOPT_USER_CENTRAL", KN_GRADOPT_USER_CENTRAL},
//       {"KN_PARAM_HESSOPT", KN_PARAM_HESSOPT},
//       {"KN_HESSOPT_AUTO", KN_HESSOPT_AUTO},
//       {"KN_HESSOPT_EXACT", KN_HESSOPT_EXACT},
//       {"KN_HESSOPT_BFGS", KN_HESSOPT_BFGS},
//       {"KN_HESSOPT_SR1", KN_HESSOPT_SR1},
//       {"KN_HESSOPT_PRODUCT_FINDIFF", KN_HESSOPT_PRODUCT_FINDIFF},
//       {"KN_HESSOPT_PRODUCT", KN_HESSOPT_PRODUCT},
//       {"KN_HESSOPT_LBFGS", KN_HESSOPT_LBFGS},
//       {"KN_HESSOPT_GAUSS_NEWTON", KN_HESSOPT_GAUSS_NEWTON},
//       {"KN_PARAM_BAR_INITPT", KN_PARAM_BAR_INITPT},
//       {"KN_BAR_INITPT_AUTO", KN_BAR_INITPT_AUTO},
//       {"KN_BAR_INITPT_CONVEX", KN_BAR_INITPT_CONVEX},
//       {"KN_BAR_INITPT_NEARBND", KN_BAR_INITPT_NEARBND},
//       {"KN_BAR_INITPT_CENTRAL", KN_BAR_INITPT_CENTRAL},
//       {"KN_PARAM_ACT_LPSOLVER", KN_PARAM_ACT_LPSOLVER},
//       {"KN_ACT_LPSOLVER_INTERNAL", KN_ACT_LPSOLVER_INTERNAL},
//       {"KN_ACT_LPSOLVER_CPLEX", KN_ACT_LPSOLVER_CPLEX},
//       {"KN_ACT_LPSOLVER_XPRESS", KN_ACT_LPSOLVER_XPRESS},
//       {"KN_PARAM_CG_MAXIT", KN_PARAM_CG_MAXIT},
//       {"KN_PARAM_MAXIT", KN_PARAM_MAXIT},
//       {"KN_PARAM_OUTLEV", KN_PARAM_OUTLEV},
//       {"KN_OUTLEV_NONE", KN_OUTLEV_NONE},
//       {"KN_OUTLEV_SUMMARY", KN_OUTLEV_SUMMARY},
//       {"KN_OUTLEV_ITER_10", KN_OUTLEV_ITER_10},
//       {"KN_OUTLEV_ITER", KN_OUTLEV_ITER},
//       {"KN_OUTLEV_ITER_VERBOSE", KN_OUTLEV_ITER_VERBOSE},
//       {"KN_OUTLEV_ITER_X", KN_OUTLEV_ITER_X},
//       {"KN_OUTLEV_ALL", KN_OUTLEV_ALL},
//       {"KN_PARAM_OUTMODE", KN_PARAM_OUTMODE},
//       {"KN_OUTMODE_SCREEN", KN_OUTMODE_SCREEN},
//       {"KN_OUTMODE_FILE", KN_OUTMODE_FILE},
//       {"KN_OUTMODE_BOTH", KN_OUTMODE_BOTH},
//       {"KN_PARAM_SCALE", KN_PARAM_SCALE},
//       {"KN_SCALE_NEVER", KN_SCALE_NEVER},
//       {"KN_SCALE_NO", KN_SCALE_NO},
//       {"KN_SCALE_USER_INTERNAL", KN_SCALE_USER_INTERNAL},
//       {"KN_SCALE_USER_NONE", KN_SCALE_USER_NONE},
//       {"KN_SCALE_INTERNAL", KN_SCALE_INTERNAL},
//       {"KN_PARAM_SOC", KN_PARAM_SOC},
//       {"KN_SOC_NO", KN_SOC_NO},
//       {"KN_SOC_MAYBE", KN_SOC_MAYBE},
//       {"KN_SOC_YES", KN_SOC_YES},
//       {"KN_PARAM_DELTA", KN_PARAM_DELTA},
//       {"KN_PARAM_BAR_FEASMODETOL", KN_PARAM_BAR_FEASMODETOL},
//       {"KN_PARAM_FEASTOL", KN_PARAM_FEASTOL},
//       {"KN_PARAM_FEASTOLABS", KN_PARAM_FEASTOLABS},
//       {"KN_PARAM_MAXTIMECPU", KN_PARAM_MAXTIMECPU},
//       {"KN_PARAM_BAR_INITMU", KN_PARAM_BAR_INITMU},
//       {"KN_PARAM_OBJRANGE", KN_PARAM_OBJRANGE},
//       {"KN_PARAM_OPTTOL", KN_PARAM_OPTTOL},
//       {"KN_PARAM_OPTTOLABS", KN_PARAM_OPTTOLABS},
//       {"KN_PARAM_LINSOLVER_PIVOTTOL", KN_PARAM_LINSOLVER_PIVOTTOL},
//       {"KN_PARAM_XTOL", KN_PARAM_XTOL},
//       {"KN_PARAM_DEBUG", KN_PARAM_DEBUG},
//       {"KN_DEBUG_NONE", KN_DEBUG_NONE},
//       {"KN_DEBUG_PROBLEM", KN_DEBUG_PROBLEM},
//       {"KN_DEBUG_EXECUTION", KN_DEBUG_EXECUTION},
//       {"KN_PARAM_MULTISTART", KN_PARAM_MULTISTART},
//       {"KN_PARAM_MSENABLE", KN_PARAM_MSENABLE},
//       {"KN_PARAM_MS_ENABLE", KN_PARAM_MS_ENABLE},
//       {"KN_MULTISTART_NO", KN_MULTISTART_NO},
//       {"KN_MS_ENABLE_NO", KN_MS_ENABLE_NO},
//       {"KN_MULTISTART_YES", KN_MULTISTART_YES},
//       {"KN_MS_ENABLE_YES", KN_MS_ENABLE_YES},
//       {"KN_PARAM_MSMAXSOLVES", KN_PARAM_MSMAXSOLVES},
//       {"KN_PARAM_MS_MAXSOLVES", KN_PARAM_MS_MAXSOLVES},
//       {"KN_PARAM_MSMAXBNDRANGE", KN_PARAM_MSMAXBNDRANGE},
//       {"KN_PARAM_MS_MAXBNDRANGE", KN_PARAM_MS_MAXBNDRANGE},
//       {"KN_PARAM_MSMAXTIMECPU", KN_PARAM_MSMAXTIMECPU},
//       {"KN_PARAM_MS_MAXTIMECPU", KN_PARAM_MS_MAXTIMECPU},
//       {"KN_PARAM_MSMAXTIMEREAL", KN_PARAM_MSMAXTIMEREAL},
//       {"KN_PARAM_MS_MAXTIMEREAL", KN_PARAM_MS_MAXTIMEREAL},
//       {"KN_PARAM_LMSIZE", KN_PARAM_LMSIZE},
//       {"KN_PARAM_BAR_MAXCROSSIT", KN_PARAM_BAR_MAXCROSSIT},
//       {"KN_PARAM_MAXTIMEREAL", KN_PARAM_MAXTIMEREAL},
//       {"KN_PARAM_CG_PRECOND", KN_PARAM_CG_PRECOND},
//       {"KN_CG_PRECOND_NONE", KN_CG_PRECOND_NONE},
//       {"KN_CG_PRECOND_CHOL", KN_CG_PRECOND_CHOL},
//       {"KN_PARAM_BLASOPTION", KN_PARAM_BLASOPTION},
//       {"KN_BLASOPTION_AUTO", KN_BLASOPTION_AUTO},
//       {"KN_BLASOPTION_KNITRO", KN_BLASOPTION_KNITRO},
//       {"KN_BLASOPTION_INTEL", KN_BLASOPTION_INTEL},
//       {"KN_BLASOPTION_DYNAMIC", KN_BLASOPTION_DYNAMIC},
//       {"KN_BLASOPTION_BLIS", KN_BLASOPTION_BLIS},
//       {"KN_BLASOPTION_APPLE", KN_BLASOPTION_APPLE},
//       {"KN_PARAM_BAR_MAXREFACTOR", KN_PARAM_BAR_MAXREFACTOR},
//       {"KN_PARAM_LINESEARCH_MAXTRIALS", KN_PARAM_LINESEARCH_MAXTRIALS},
//       {"KN_PARAM_BLASOPTIONLIB", KN_PARAM_BLASOPTIONLIB},
//       {"KN_PARAM_OUTAPPEND", KN_PARAM_OUTAPPEND},
//       {"KN_OUTAPPEND_NO", KN_OUTAPPEND_NO},
//       {"KN_OUTAPPEND_YES", KN_OUTAPPEND_YES},
//       {"KN_PARAM_OUTDIR", KN_PARAM_OUTDIR},
//       {"KN_PARAM_CPLEXLIB", KN_PARAM_CPLEXLIB},
//       {"KN_PARAM_BAR_PENRULE", KN_PARAM_BAR_PENRULE},
//       {"KN_BAR_PENRULE_AUTO", KN_BAR_PENRULE_AUTO},
//       {"KN_BAR_PENRULE_SINGLE", KN_BAR_PENRULE_SINGLE},
//       {"KN_BAR_PENRULE_FLEX", KN_BAR_PENRULE_FLEX},
//       {"KN_PARAM_BAR_PENCONS", KN_PARAM_BAR_PENCONS},
//       {"KN_BAR_PENCONS_AUTO", KN_BAR_PENCONS_AUTO},
//       {"KN_BAR_PENCONS_NONE", KN_BAR_PENCONS_NONE},
//       {"KN_BAR_PENCONS_ALL", KN_BAR_PENCONS_ALL},
//       {"KN_BAR_PENCONS_EQUALITIES", KN_BAR_PENCONS_EQUALITIES},
//       {"KN_BAR_PENCONS_INFEAS", KN_BAR_PENCONS_INFEAS},
//       {"KN_PARAM_MSNUMTOSAVE", KN_PARAM_MSNUMTOSAVE},
//       {"KN_PARAM_MS_NUMTOSAVE", KN_PARAM_MS_NUMTOSAVE},
//       {"KN_PARAM_MSSAVETOL", KN_PARAM_MSSAVETOL},
//       {"KN_PARAM_MS_SAVETOL", KN_PARAM_MS_SAVETOL},
//       {"KN_PARAM_PRESOLVEDEBUG", KN_PARAM_PRESOLVEDEBUG},
//       {"KN_PRESOLVEDBG_NONE", KN_PRESOLVEDBG_NONE},
//       {"KN_PRESOLVEDBG_BASIC", KN_PRESOLVEDBG_BASIC},
//       {"KN_PRESOLVEDBG_VERBOSE", KN_PRESOLVEDBG_VERBOSE},
//       {"KN_PRESOLVEDBG_DETAIL", KN_PRESOLVEDBG_DETAIL},
//       {"KN_PARAM_MSTERMINATE", KN_PARAM_MSTERMINATE},
//       {"KN_PARAM_MS_TERMINATE", KN_PARAM_MS_TERMINATE},
//       {"KN_MSTERMINATE_MAXSOLVES", KN_MSTERMINATE_MAXSOLVES},
//       {"KN_MS_TERMINATE_MAXSOLVES", KN_MS_TERMINATE_MAXSOLVES},
//       {"KN_MSTERMINATE_OPTIMAL", KN_MSTERMINATE_OPTIMAL},
//       {"KN_MS_TERMINATE_OPTIMAL", KN_MS_TERMINATE_OPTIMAL},
//       {"KN_MSTERMINATE_FEASIBLE", KN_MSTERMINATE_FEASIBLE},
//       {"KN_MS_TERMINATE_FEASIBLE", KN_MS_TERMINATE_FEASIBLE},
//       {"KN_MSTERMINATE_ANY", KN_MSTERMINATE_ANY},
//       {"KN_MS_TERMINATE_ANY", KN_MS_TERMINATE_ANY},
//       {"KN_MSTERMINATE_RULEBASED", KN_MSTERMINATE_RULEBASED},
//       {"KN_MS_TERMINATE_RULEBASED", KN_MS_TERMINATE_RULEBASED},
//       {"KN_PARAM_MSSTARTPTRANGE", KN_PARAM_MSSTARTPTRANGE},
//       {"KN_PARAM_MS_STARTPTRANGE", KN_PARAM_MS_STARTPTRANGE},
//       {"KN_PARAM_INFEASTOL", KN_PARAM_INFEASTOL},
//       {"KN_PARAM_LINSOLVER", KN_PARAM_LINSOLVER},
//       {"KN_LINSOLVER_AUTO", KN_LINSOLVER_AUTO},
//       {"KN_LINSOLVER_INTERNAL", KN_LINSOLVER_INTERNAL},
//       {"KN_LINSOLVER_HYBRID", KN_LINSOLVER_HYBRID},
//       {"KN_LINSOLVER_DENSEQR", KN_LINSOLVER_DENSEQR},
//       {"KN_LINSOLVER_MA27", KN_LINSOLVER_MA27},
//       {"KN_LINSOLVER_MA57", KN_LINSOLVER_MA57},
//       {"KN_LINSOLVER_MKLPARDISO", KN_LINSOLVER_MKLPARDISO},
//       {"KN_LINSOLVER_MA97", KN_LINSOLVER_MA97},
//       {"KN_LINSOLVER_MA86", KN_LINSOLVER_MA86},
//       {"KN_PARAM_BAR_DIRECTINTERVAL", KN_PARAM_BAR_DIRECTINTERVAL},
//       {"KN_PARAM_PRESOLVE", KN_PARAM_PRESOLVE},
//       {"KN_PRESOLVE_NO", KN_PRESOLVE_NO},
//       {"KN_PRESOLVE_NONE", KN_PRESOLVE_NONE},
//       {"KN_PRESOLVE_YES", KN_PRESOLVE_YES},
//       {"KN_PRESOLVE_BASIC", KN_PRESOLVE_BASIC},
//       {"KN_PRESOLVE_ADVANCED", KN_PRESOLVE_ADVANCED},
//       {"KN_PARAM_PRESOLVE_TOL", KN_PARAM_PRESOLVE_TOL},
//       {"KN_PARAM_BAR_SWITCHRULE", KN_PARAM_BAR_SWITCHRULE},
//       {"KN_BAR_SWITCHRULE_AUTO", KN_BAR_SWITCHRULE_AUTO},
//       {"KN_BAR_SWITCHRULE_NEVER", KN_BAR_SWITCHRULE_NEVER},
//       {"KN_BAR_SWITCHRULE_MODERATE", KN_BAR_SWITCHRULE_MODERATE},
//       {"KN_BAR_SWITCHRULE_AGGRESSIVE", KN_BAR_SWITCHRULE_AGGRESSIVE},
//       {"KN_PARAM_HESSIAN_NO_F", KN_PARAM_HESSIAN_NO_F},
//       {"KN_HESSIAN_NO_F_FORBID", KN_HESSIAN_NO_F_FORBID},
//       {"KN_HESSIAN_NO_F_ALLOW", KN_HESSIAN_NO_F_ALLOW},
//       {"KN_PARAM_MA_TERMINATE", KN_PARAM_MA_TERMINATE},
//       {"KN_MA_TERMINATE_ALL", KN_MA_TERMINATE_ALL},
//       {"KN_MA_TERMINATE_OPTIMAL", KN_MA_TERMINATE_OPTIMAL},
//       {"KN_MA_TERMINATE_FEASIBLE", KN_MA_TERMINATE_FEASIBLE},
//       {"KN_MA_TERMINATE_ANY", KN_MA_TERMINATE_ANY},
//       {"KN_PARAM_MA_MAXTIMECPU", KN_PARAM_MA_MAXTIMECPU},
//       {"KN_PARAM_MA_MAXTIMEREAL", KN_PARAM_MA_MAXTIMEREAL},
//       {"KN_PARAM_MSSEED", KN_PARAM_MSSEED},
//       {"KN_PARAM_MS_SEED", KN_PARAM_MS_SEED},
//       {"KN_PARAM_MA_OUTSUB", KN_PARAM_MA_OUTSUB},
//       {"KN_MA_OUTSUB_NONE", KN_MA_OUTSUB_NONE},
//       {"KN_MA_OUTSUB_YES", KN_MA_OUTSUB_YES},
//       {"KN_PARAM_MS_OUTSUB", KN_PARAM_MS_OUTSUB},
//       {"KN_MS_OUTSUB_NONE", KN_MS_OUTSUB_NONE},
//       {"KN_MS_OUTSUB_YES", KN_MS_OUTSUB_YES},
//       {"KN_PARAM_XPRESSLIB", KN_PARAM_XPRESSLIB},
//       {"KN_PARAM_TUNER", KN_PARAM_TUNER},
//       {"KN_TUNER_OFF", KN_TUNER_OFF},
//       {"KN_TUNER_ON", KN_TUNER_ON},
//       {"KN_PARAM_TUNER_OPTIONSFILE", KN_PARAM_TUNER_OPTIONSFILE},
//       {"KN_PARAM_TUNER_MAXTIMECPU", KN_PARAM_TUNER_MAXTIMECPU},
//       {"KN_PARAM_TUNER_MAXTIMEREAL", KN_PARAM_TUNER_MAXTIMEREAL},
//       {"KN_PARAM_TUNER_OUTSUB", KN_PARAM_TUNER_OUTSUB},
//       {"KN_TUNER_OUTSUB_NONE", KN_TUNER_OUTSUB_NONE},
//       {"KN_TUNER_OUTSUB_SUMMARY", KN_TUNER_OUTSUB_SUMMARY},
//       {"KN_TUNER_OUTSUB_ALL", KN_TUNER_OUTSUB_ALL},
//       {"KN_PARAM_TUNER_TERMINATE", KN_PARAM_TUNER_TERMINATE},
//       {"KN_TUNER_TERMINATE_ALL", KN_TUNER_TERMINATE_ALL},
//       {"KN_TUNER_TERMINATE_OPTIMAL", KN_TUNER_TERMINATE_OPTIMAL},
//       {"KN_TUNER_TERMINATE_FEASIBLE", KN_TUNER_TERMINATE_FEASIBLE},
//       {"KN_TUNER_TERMINATE_ANY", KN_TUNER_TERMINATE_ANY},
//       {"KN_PARAM_LINSOLVER_OOC", KN_PARAM_LINSOLVER_OOC},
//       {"KN_LINSOLVER_OOC_NO", KN_LINSOLVER_OOC_NO},
//       {"KN_LINSOLVER_OOC_MAYBE", KN_LINSOLVER_OOC_MAYBE},
//       {"KN_LINSOLVER_OOC_YES", KN_LINSOLVER_OOC_YES},
//       {"KN_PARAM_BAR_RELAXCONS", KN_PARAM_BAR_RELAXCONS},
//       {"KN_BAR_RELAXCONS_NONE", KN_BAR_RELAXCONS_NONE},
//       {"KN_BAR_RELAXCONS_EQS", KN_BAR_RELAXCONS_EQS},
//       {"KN_BAR_RELAXCONS_INEQS", KN_BAR_RELAXCONS_INEQS},
//       {"KN_BAR_RELAXCONS_ALL", KN_BAR_RELAXCONS_ALL},
//       {"KN_PARAM_MSDETERMINISTIC", KN_PARAM_MSDETERMINISTIC},
//       {"KN_PARAM_MS_DETERMINISTIC", KN_PARAM_MS_DETERMINISTIC},
//       {"KN_MSDETERMINISTIC_NO", KN_MSDETERMINISTIC_NO},
//       {"KN_MS_DETERMINISTIC_NO", KN_MS_DETERMINISTIC_NO},
//       {"KN_MSDETERMINISTIC_YES", KN_MSDETERMINISTIC_YES},
//       {"KN_MS_DETERMINISTIC_YES", KN_MS_DETERMINISTIC_YES},
//       {"KN_PARAM_BAR_REFINEMENT", KN_PARAM_BAR_REFINEMENT},
//       {"KN_BAR_REFINEMENT_NO", KN_BAR_REFINEMENT_NO},
//       {"KN_BAR_REFINEMENT_YES", KN_BAR_REFINEMENT_YES},
//       {"KN_PARAM_DERIVCHECK", KN_PARAM_DERIVCHECK},
//       {"KN_DERIVCHECK_NONE", KN_DERIVCHECK_NONE},
//       {"KN_DERIVCHECK_FIRST", KN_DERIVCHECK_FIRST},
//       {"KN_DERIVCHECK_SECOND", KN_DERIVCHECK_SECOND},
//       {"KN_DERIVCHECK_ALL", KN_DERIVCHECK_ALL},
//       {"KN_PARAM_DERIVCHECK_TYPE", KN_PARAM_DERIVCHECK_TYPE},
//       {"KN_DERIVCHECK_FORWARD", KN_DERIVCHECK_FORWARD},
//       {"KN_DERIVCHECK_CENTRAL", KN_DERIVCHECK_CENTRAL},
//       {"KN_PARAM_DERIVCHECK_TOL", KN_PARAM_DERIVCHECK_TOL},
//       {"KN_PARAM_LINSOLVER_INEXACT", KN_PARAM_LINSOLVER_INEXACT},
//       {"KN_LINSOLVER_INEXACT_NO", KN_LINSOLVER_INEXACT_NO},
//       {"KN_LINSOLVER_INEXACT_YES", KN_LINSOLVER_INEXACT_YES},
//       {"KN_PARAM_LINSOLVER_INEXACTTOL", KN_PARAM_LINSOLVER_INEXACTTOL},
//       {"KN_PARAM_MAXFEVALS", KN_PARAM_MAXFEVALS},
//       {"KN_PARAM_FSTOPVAL", KN_PARAM_FSTOPVAL},
//       {"KN_PARAM_DATACHECK", KN_PARAM_DATACHECK},
//       {"KN_DATACHECK_NO", KN_DATACHECK_NO},
//       {"KN_DATACHECK_YES", KN_DATACHECK_YES},
//       {"KN_PARAM_DERIVCHECK_TERMINATE", KN_PARAM_DERIVCHECK_TERMINATE},
//       {"KN_DERIVCHECK_STOPERROR", KN_DERIVCHECK_STOPERROR},
//       {"KN_DERIVCHECK_STOPALWAYS", KN_DERIVCHECK_STOPALWAYS},
//       {"KN_PARAM_BAR_WATCHDOG", KN_PARAM_BAR_WATCHDOG},
//       {"KN_BAR_WATCHDOG_NO", KN_BAR_WATCHDOG_NO},
//       {"KN_BAR_WATCHDOG_YES", KN_BAR_WATCHDOG_YES},
//       {"KN_PARAM_FTOL", KN_PARAM_FTOL},
//       {"KN_PARAM_FTOL_ITERS", KN_PARAM_FTOL_ITERS},
//       {"KN_PARAM_ACT_QPALG", KN_PARAM_ACT_QPALG},
//       {"KN_ACT_QPALG_AUTO", KN_ACT_QPALG_AUTO},
//       {"KN_ACT_QPALG_BAR_DIRECT", KN_ACT_QPALG_BAR_DIRECT},
//       {"KN_ACT_QPALG_BAR_CG", KN_ACT_QPALG_BAR_CG},
//       {"KN_ACT_QPALG_ACT_CG", KN_ACT_QPALG_ACT_CG},
//       {"KN_PARAM_BAR_INITPI_MPEC", KN_PARAM_BAR_INITPI_MPEC},
//       {"KN_PARAM_XTOL_ITERS", KN_PARAM_XTOL_ITERS},
//       {"KN_PARAM_LINESEARCH", KN_PARAM_LINESEARCH},
//       {"KN_LINESEARCH_AUTO", KN_LINESEARCH_AUTO},
//       {"KN_LINESEARCH_BACKTRACK", KN_LINESEARCH_BACKTRACK},
//       {"KN_LINESEARCH_INTERPOLATE", KN_LINESEARCH_INTERPOLATE},
//       {"KN_LINESEARCH_WEAKWOLFE", KN_LINESEARCH_WEAKWOLFE},
//       {"KN_PARAM_OUT_CSVINFO", KN_PARAM_OUT_CSVINFO},
//       {"KN_OUT_CSVINFO_NO", KN_OUT_CSVINFO_NO},
//       {"KN_OUT_CSVINFO_YES", KN_OUT_CSVINFO_YES},
//       {"KN_PARAM_INITPENALTY", KN_PARAM_INITPENALTY},
//       {"KN_PARAM_ACT_LPFEASTOL", KN_PARAM_ACT_LPFEASTOL},
//       {"KN_PARAM_CG_STOPTOL", KN_PARAM_CG_STOPTOL},
//       {"KN_PARAM_RESTARTS", KN_PARAM_RESTARTS},
//       {"KN_PARAM_RESTARTS_MAXIT", KN_PARAM_RESTARTS_MAXIT},
//       {"KN_PARAM_BAR_SLACKBOUNDPUSH", KN_PARAM_BAR_SLACKBOUNDPUSH},
//       {"KN_PARAM_CG_PMEM", KN_PARAM_CG_PMEM},
//       {"KN_PARAM_BAR_SWITCHOBJ", KN_PARAM_BAR_SWITCHOBJ},
//       {"KN_BAR_SWITCHOBJ_NONE", KN_BAR_SWITCHOBJ_NONE},
//       {"KN_BAR_SWITCHOBJ_SCALARPROX", KN_BAR_SWITCHOBJ_SCALARPROX},
//       {"KN_BAR_SWITCHOBJ_DIAGPROX", KN_BAR_SWITCHOBJ_DIAGPROX},
//       {"KN_PARAM_OUTNAME", KN_PARAM_OUTNAME},
//       {"KN_PARAM_OUT_CSVNAME", KN_PARAM_OUT_CSVNAME},
//       {"KN_PARAM_ACT_PARAMETRIC", KN_PARAM_ACT_PARAMETRIC},
//       {"KN_ACT_PARAMETRIC_NO", KN_ACT_PARAMETRIC_NO},
//       {"KN_ACT_PARAMETRIC_MAYBE", KN_ACT_PARAMETRIC_MAYBE},
//       {"KN_ACT_PARAMETRIC_YES", KN_ACT_PARAMETRIC_YES},
//       {"KN_PARAM_ACT_LPDUMPMPS", KN_PARAM_ACT_LPDUMPMPS},
//       {"KN_ACT_LPDUMPMPS_NO", KN_ACT_LPDUMPMPS_NO},
//       {"KN_ACT_LPDUMPMPS_YES", KN_ACT_LPDUMPMPS_YES},
//       {"KN_PARAM_ACT_LPALG", KN_PARAM_ACT_LPALG},
//       {"KN_ACT_LPALG_DEFAULT", KN_ACT_LPALG_DEFAULT},
//       {"KN_ACT_LPALG_PRIMAL", KN_ACT_LPALG_PRIMAL},
//       {"KN_ACT_LPALG_DUAL", KN_ACT_LPALG_DUAL},
//       {"KN_ACT_LPALG_BARRIER", KN_ACT_LPALG_BARRIER},
//       {"KN_PARAM_ACT_LPPRESOLVE", KN_PARAM_ACT_LPPRESOLVE},
//       {"KN_ACT_LPPRESOLVE_OFF", KN_ACT_LPPRESOLVE_OFF},
//       {"KN_ACT_LPPRESOLVE_ON", KN_ACT_LPPRESOLVE_ON},
//       {"KN_PARAM_ACT_LPPENALTY", KN_PARAM_ACT_LPPENALTY},
//       {"KN_ACT_LPPENALTY_ALL", KN_ACT_LPPENALTY_ALL},
//       {"KN_ACT_LPPENALTY_NONLINEAR", KN_ACT_LPPENALTY_NONLINEAR},
//       {"KN_ACT_LPPENALTY_DYNAMIC", KN_ACT_LPPENALTY_DYNAMIC},
//       {"KN_PARAM_BNDRANGE", KN_PARAM_BNDRANGE},
//       {"KN_PARAM_BAR_CONIC_ENABLE", KN_PARAM_BAR_CONIC_ENABLE},
//       {"KN_BAR_CONIC_ENABLE_AUTO", KN_BAR_CONIC_ENABLE_AUTO},
//       {"KN_BAR_CONIC_ENABLE_NONE", KN_BAR_CONIC_ENABLE_NONE},
//       {"KN_BAR_CONIC_ENABLE_SOC", KN_BAR_CONIC_ENABLE_SOC},
//       {"KN_PARAM_CONVEX", KN_PARAM_CONVEX},
//       {"KN_CONVEX_AUTO", KN_CONVEX_AUTO},
//       {"KN_CONVEX_NO", KN_CONVEX_NO},
//       {"KN_CONVEX_YES", KN_CONVEX_YES},
//       {"KN_PARAM_OUT_HINTS", KN_PARAM_OUT_HINTS},
//       {"KN_OUT_HINTS_NO", KN_OUT_HINTS_NO},
//       {"KN_OUT_HINTS_YES", KN_OUT_HINTS_YES},
//       {"KN_PARAM_EVAL_FCGA", KN_PARAM_EVAL_FCGA},
//       {"KN_EVAL_FCGA_NO", KN_EVAL_FCGA_NO},
//       {"KN_EVAL_FCGA_YES", KN_EVAL_FCGA_YES},
//       {"KN_PARAM_BAR_MAXCORRECTORS", KN_PARAM_BAR_MAXCORRECTORS},
//       {"KN_PARAM_STRAT_WARM_START", KN_PARAM_STRAT_WARM_START},
//       {"KN_STRAT_WARM_START_NO", KN_STRAT_WARM_START_NO},
//       {"KN_STRAT_WARM_START_YES", KN_STRAT_WARM_START_YES},
//       {"KN_PARAM_FINDIFF_TERMINATE", KN_PARAM_FINDIFF_TERMINATE},
//       {"KN_FINDIFF_TERMINATE_NONE", KN_FINDIFF_TERMINATE_NONE},
//       {"KN_FINDIFF_TERMINATE_ERREST", KN_FINDIFF_TERMINATE_ERREST},
//       {"KN_PARAM_CPUPLATFORM", KN_PARAM_CPUPLATFORM},
//       {"KN_CPUPLATFORM_AUTO", KN_CPUPLATFORM_AUTO},
//       {"KN_CPUPLATFORM_COMPATIBLE", KN_CPUPLATFORM_COMPATIBLE},
//       {"KN_CPUPLATFORM_SSE2", KN_CPUPLATFORM_SSE2},
//       {"KN_CPUPLATFORM_AVX", KN_CPUPLATFORM_AVX},
//       {"KN_CPUPLATFORM_AVX2", KN_CPUPLATFORM_AVX2},
//       {"KN_CPUPLATFORM_AVX512", KN_CPUPLATFORM_AVX512},
//       {"KN_PARAM_PRESOLVE_PASSES", KN_PARAM_PRESOLVE_PASSES},
//       {"KN_PARAM_PRESOLVE_LEVEL", KN_PARAM_PRESOLVE_LEVEL},
//       {"KN_PRESOLVE_LEVEL_AUTO", KN_PRESOLVE_LEVEL_AUTO},
//       {"KN_PRESOLVE_LEVEL_1", KN_PRESOLVE_LEVEL_1},
//       {"KN_PRESOLVE_LEVEL_2", KN_PRESOLVE_LEVEL_2},
//       {"KN_PARAM_FINDIFF_RELSTEPSIZE", KN_PARAM_FINDIFF_RELSTEPSIZE},
//       {"KN_PARAM_INFEASTOL_ITERS", KN_PARAM_INFEASTOL_ITERS},
//       {"KN_PARAM_PRESOLVEOP_TIGHTEN", KN_PARAM_PRESOLVEOP_TIGHTEN},
//       {"KN_PRESOLVEOP_TIGHTEN_AUTO", KN_PRESOLVEOP_TIGHTEN_AUTO},
//       {"KN_PRESOLVEOP_TIGHTEN_NONE", KN_PRESOLVEOP_TIGHTEN_NONE},
//       {"KN_PRESOLVEOP_TIGHTEN_VARBND", KN_PRESOLVEOP_TIGHTEN_VARBND},
//       {"KN_PRESOLVEOP_TIGHTEN_COEF", KN_PRESOLVEOP_TIGHTEN_COEF},
//       {"KN_PRESOLVEOP_TIGHTEN_ALL", KN_PRESOLVEOP_TIGHTEN_ALL},
//       {"KN_PARAM_BAR_LINSYS", KN_PARAM_BAR_LINSYS},
//       {"KN_BAR_LINSYS_AUTO", KN_BAR_LINSYS_AUTO},
//       {"KN_BAR_LINSYS_FULL", KN_BAR_LINSYS_FULL},
//       {"KN_BAR_LINSYS_COMPACT1", KN_BAR_LINSYS_COMPACT1},
//       {"KN_BAR_LINSYS_ELIMINATE_SLACKS", KN_BAR_LINSYS_ELIMINATE_SLACKS},
//       {"KN_BAR_LINSYS_COMPACT2", KN_BAR_LINSYS_COMPACT2},
//       {"KN_BAR_LINSYS_ELIMINATE_BOUNDS", KN_BAR_LINSYS_ELIMINATE_BOUNDS},
//       {"KN_BAR_LINSYS_ELIMINATE_INEQS", KN_BAR_LINSYS_ELIMINATE_INEQS},
//       {"KN_PARAM_PRESOLVE_INITPT", KN_PARAM_PRESOLVE_INITPT},
//       {"KN_PRESOLVE_INITPT_AUTO", KN_PRESOLVE_INITPT_AUTO},
//       {"KN_PRESOLVE_INITPT_NOSHIFT", KN_PRESOLVE_INITPT_NOSHIFT},
//       {"KN_PRESOLVE_INITPT_LINSHIFT", KN_PRESOLVE_INITPT_LINSHIFT},
//       {"KN_PRESOLVE_INITPT_ANYSHIFT", KN_PRESOLVE_INITPT_ANYSHIFT},
//       {"KN_PARAM_ACT_QPPENALTY", KN_PARAM_ACT_QPPENALTY},
//       {"KN_ACT_QPPENALTY_AUTO", KN_ACT_QPPENALTY_AUTO},
//       {"KN_ACT_QPPENALTY_NONE", KN_ACT_QPPENALTY_NONE},
//       {"KN_ACT_QPPENALTY_ALL", KN_ACT_QPPENALTY_ALL},
//       {"KN_PARAM_BAR_LINSYS_STORAGE", KN_PARAM_BAR_LINSYS_STORAGE},
//       {"KN_BAR_LINSYS_STORAGE_AUTO", KN_BAR_LINSYS_STORAGE_AUTO},
//       {"KN_BAR_LINSYS_STORAGE_LOWMEM", KN_BAR_LINSYS_STORAGE_LOWMEM},
//       {"KN_BAR_LINSYS_STORAGE_NORMAL", KN_BAR_LINSYS_STORAGE_NORMAL},
//       {"KN_PARAM_LINSOLVER_MAXITREF", KN_PARAM_LINSOLVER_MAXITREF},
//       {"KN_PARAM_BFGS_SCALING", KN_PARAM_BFGS_SCALING},
//       {"KN_BFGS_SCALING_DYNAMIC", KN_BFGS_SCALING_DYNAMIC},
//       {"KN_BFGS_SCALING_INVHESS", KN_BFGS_SCALING_INVHESS},
//       {"KN_BFGS_SCALING_HESS", KN_BFGS_SCALING_HESS},
//       {"KN_PARAM_BAR_INITSHIFTTOL", KN_PARAM_BAR_INITSHIFTTOL},
//       {"KN_PARAM_NUMTHREADS", KN_PARAM_NUMTHREADS},
//       {"KN_PARAM_CONCURRENT_EVALS", KN_PARAM_CONCURRENT_EVALS},
//       {"KN_CONCURRENT_EVALS_NO", KN_CONCURRENT_EVALS_NO},
//       {"KN_CONCURRENT_EVALS_YES", KN_CONCURRENT_EVALS_YES},
//       {"KN_PARAM_BLAS_NUMTHREADS", KN_PARAM_BLAS_NUMTHREADS},
//       {"KN_PARAM_LINSOLVER_NUMTHREADS", KN_PARAM_LINSOLVER_NUMTHREADS},
//       {"KN_PARAM_MS_NUMTHREADS", KN_PARAM_MS_NUMTHREADS},
//       {"KN_PARAM_CONIC_NUMTHREADS", KN_PARAM_CONIC_NUMTHREADS},
//       {"KN_PARAM_NCVX_QCQP_INIT", KN_PARAM_NCVX_QCQP_INIT},
//       {"KN_NCVX_QCQP_INIT_AUTO", KN_NCVX_QCQP_INIT_AUTO},
//       {"KN_NCVX_QCQP_INIT_NONE", KN_NCVX_QCQP_INIT_NONE},
//       {"KN_NCVX_QCQP_INIT_LINEAR", KN_NCVX_QCQP_INIT_LINEAR},
//       {"KN_NCVX_QCQP_INIT_HYBRID", KN_NCVX_QCQP_INIT_HYBRID},
//       {"KN_NCVX_QCQP_INIT_PENALTY", KN_NCVX_QCQP_INIT_PENALTY},
//       {"KN_NCVX_QCQP_INIT_CVXQUAD", KN_NCVX_QCQP_INIT_CVXQUAD},
//       {"KN_PARAM_FINDIFF_ESTNOISE", KN_PARAM_FINDIFF_ESTNOISE},
//       {"KN_FINDIFF_ESTNOISE_NO", KN_FINDIFF_ESTNOISE_NO},
//       {"KN_FINDIFF_ESTNOISE_YES", KN_FINDIFF_ESTNOISE_YES},
//       {"KN_FINDIFF_ESTNOISE_WITHCURV", KN_FINDIFF_ESTNOISE_WITHCURV},
//       {"KN_PARAM_FINDIFF_NUMTHREADS", KN_PARAM_FINDIFF_NUMTHREADS},
//       {"KN_PARAM_BAR_MPEC_HEURISTIC", KN_PARAM_BAR_MPEC_HEURISTIC},
//       {"KN_BAR_MPEC_HEURISTIC_NO", KN_BAR_MPEC_HEURISTIC_NO},
//       {"KN_BAR_MPEC_HEURISTIC_YES", KN_BAR_MPEC_HEURISTIC_YES},
//       {"KN_PARAM_PRESOLVEOP_REDUNDANT", KN_PARAM_PRESOLVEOP_REDUNDANT},
//       {"KN_PRESOLVEOP_REDUNDANT_NONE", KN_PRESOLVEOP_REDUNDANT_NONE},
//       {"KN_PRESOLVEOP_REDUNDANT_DUPCON", KN_PRESOLVEOP_REDUNDANT_DUPCON},
//       {"KN_PRESOLVEOP_REDUNDANT_DEPCON", KN_PRESOLVEOP_REDUNDANT_DEPCON},
//       {"KN_PARAM_LINSOLVER_ORDERING", KN_PARAM_LINSOLVER_ORDERING},
//       {"KN_LINSOLVER_ORDERING_AUTO", KN_LINSOLVER_ORDERING_AUTO},
//       {"KN_LINSOLVER_ORDERING_BEST", KN_LINSOLVER_ORDERING_BEST},
//       {"KN_LINSOLVER_ORDERING_AMD", KN_LINSOLVER_ORDERING_AMD},
//       {"KN_LINSOLVER_ORDERING_METIS", KN_LINSOLVER_ORDERING_METIS},
//       {"KN_PARAM_LINSOLVER_NODEAMALG", KN_PARAM_LINSOLVER_NODEAMALG},
//       {"KN_PARAM_PRESOLVEOP_SUBSTITUTION", KN_PARAM_PRESOLVEOP_SUBSTITUTION},
//       {"KN_PRESOLVEOP_SUBSTITUTION_AUTO", KN_PRESOLVEOP_SUBSTITUTION_AUTO},
//       {"KN_PRESOLVEOP_SUBSTITUTION_NONE", KN_PRESOLVEOP_SUBSTITUTION_NONE},
//       {"KN_PRESOLVEOP_SUBSTITUTION_SIMPLE", KN_PRESOLVEOP_SUBSTITUTION_SIMPLE},
//       {"KN_PRESOLVEOP_SUBSTITUTION_ALL", KN_PRESOLVEOP_SUBSTITUTION_ALL},
//       {"KN_PARAM_PRESOLVEOP_SUBSTITUTION_TOL",
//        KN_PARAM_PRESOLVEOP_SUBSTITUTION_TOL},
//       {"KN_PARAM_MS_INITPT_CLUSTER", KN_PARAM_MS_INITPT_CLUSTER},
//       {"KN_MS_INITPT_CLUSTER_NONE", KN_MS_INITPT_CLUSTER_NONE},
//       {"KN_MS_INITPT_CLUSTER_SL", KN_MS_INITPT_CLUSTER_SL},
//       {"KN_PARAM_SCALE_VARS", KN_PARAM_SCALE_VARS},
//       {"KN_SCALE_VARS_NONE", KN_SCALE_VARS_NONE},
//       {"KN_SCALE_VARS_BNDS", KN_SCALE_VARS_BNDS},
//       {"KN_PARAM_BAR_MAXMU", KN_PARAM_BAR_MAXMU},
//       {"KN_PARAM_BAR_GLOBALIZE", KN_PARAM_BAR_GLOBALIZE},
//       {"KN_BAR_GLOBALIZE_NONE", KN_BAR_GLOBALIZE_NONE},
//       {"KN_BAR_GLOBALIZE_KKT", KN_BAR_GLOBALIZE_KKT},
//       {"KN_BAR_GLOBALIZE_FILTER", KN_BAR_GLOBALIZE_FILTER},
//       {"KN_PARAM_LINSOLVER_SCALING", KN_PARAM_LINSOLVER_SCALING},
//       {"KN_LINSOLVER_SCALING_NONE", KN_LINSOLVER_SCALING_NONE},
//       {"KN_LINSOLVER_SCALING_ALWAYS", KN_LINSOLVER_SCALING_ALWAYS},
//       {"KN_PARAM_MIP_METHOD", KN_PARAM_MIP_METHOD},
//       {"KN_MIP_METHOD_AUTO", KN_MIP_METHOD_AUTO},
//       {"KN_MIP_METHOD_BB", KN_MIP_METHOD_BB},
//       {"KN_MIP_METHOD_HQG", KN_MIP_METHOD_HQG},
//       {"KN_MIP_METHOD_MISQP", KN_MIP_METHOD_MISQP},
//       {"KN_PARAM_MIP_BRANCHRULE", KN_PARAM_MIP_BRANCHRULE},
//       {"KN_MIP_BRANCH_AUTO", KN_MIP_BRANCH_AUTO},
//       {"KN_MIP_BRANCH_MOSTFRAC", KN_MIP_BRANCH_MOSTFRAC},
//       {"KN_MIP_BRANCH_PSEUDOCOST", KN_MIP_BRANCH_PSEUDOCOST},
//       {"KN_MIP_BRANCH_STRONG", KN_MIP_BRANCH_STRONG},
//       {"KN_PARAM_MIP_SELECTRULE", KN_PARAM_MIP_SELECTRULE},
//       {"KN_MIP_SEL_AUTO", KN_MIP_SEL_AUTO},
//       {"KN_MIP_SEL_DEPTHFIRST", KN_MIP_SEL_DEPTHFIRST},
//       {"KN_MIP_SEL_BESTBOUND", KN_MIP_SEL_BESTBOUND},
//       {"KN_MIP_SEL_COMBO_1", KN_MIP_SEL_COMBO_1},
//       {"KN_PARAM_MIP_INTGAPABS", KN_PARAM_MIP_INTGAPABS},
//       {"KN_PARAM_MIP_OPTGAPABS", KN_PARAM_MIP_OPTGAPABS},
//       {"KN_PARAM_MIP_INTGAPREL", KN_PARAM_MIP_INTGAPREL},
//       {"KN_PARAM_MIP_OPTGAPREL", KN_PARAM_MIP_OPTGAPREL},
//       {"KN_PARAM_MIP_MAXTIMECPU", KN_PARAM_MIP_MAXTIMECPU},
//       {"KN_PARAM_MIP_MAXTIMEREAL", KN_PARAM_MIP_MAXTIMEREAL},
//       {"KN_PARAM_MIP_MAXSOLVES", KN_PARAM_MIP_MAXSOLVES},
//       {"KN_PARAM_MIP_INTEGERTOL", KN_PARAM_MIP_INTEGERTOL},
//       {"KN_PARAM_MIP_OUTLEVEL", KN_PARAM_MIP_OUTLEVEL},
//       {"KN_MIP_OUTLEVEL_NONE", KN_MIP_OUTLEVEL_NONE},
//       {"KN_MIP_OUTLEVEL_ITERS", KN_MIP_OUTLEVEL_ITERS},
//       {"KN_MIP_OUTLEVEL_ITERSTIME", KN_MIP_OUTLEVEL_ITERSTIME},
//       {"KN_MIP_OUTLEVEL_ROOT", KN_MIP_OUTLEVEL_ROOT},
//       {"KN_PARAM_MIP_OUTINTERVAL", KN_PARAM_MIP_OUTINTERVAL},
//       {"KN_PARAM_MIP_OUTSUB", KN_PARAM_MIP_OUTSUB},
//       {"KN_MIP_OUTSUB_NONE", KN_MIP_OUTSUB_NONE},
//       {"KN_MIP_OUTSUB_YES", KN_MIP_OUTSUB_YES},
//       {"KN_MIP_OUTSUB_YESPROB", KN_MIP_OUTSUB_YESPROB},
//       {"KN_PARAM_MIP_DEBUG", KN_PARAM_MIP_DEBUG},
//       {"KN_MIP_DEBUG_NONE", KN_MIP_DEBUG_NONE},
//       {"KN_MIP_DEBUG_ALL", KN_MIP_DEBUG_ALL},
//       {"KN_PARAM_MIP_IMPLICATNS", KN_PARAM_MIP_IMPLICATNS},
//       {"KN_PARAM_MIP_IMPLICATIONS", KN_PARAM_MIP_IMPLICATIONS},
//       {"KN_MIP_IMPLICATNS_NO", KN_MIP_IMPLICATNS_NO},
//       {"KN_MIP_IMPLICATIONS_NO", KN_MIP_IMPLICATIONS_NO},
//       {"KN_MIP_IMPLICATNS_YES", KN_MIP_IMPLICATNS_YES},
//       {"KN_MIP_IMPLICATIONS_YES", KN_MIP_IMPLICATIONS_YES},
//       {"KN_PARAM_MIP_GUB_BRANCH", KN_PARAM_MIP_GUB_BRANCH},
//       {"KN_MIP_GUB_BRANCH_NO", KN_MIP_GUB_BRANCH_NO},
//       {"KN_MIP_GUB_BRANCH_YES", KN_MIP_GUB_BRANCH_YES},
//       {"KN_PARAM_MIP_KNAPSACK", KN_PARAM_MIP_KNAPSACK},
//       {"KN_MIP_KNAPSACK_AUTO", KN_MIP_KNAPSACK_AUTO},
//       {"KN_MIP_KNAPSACK_NO", KN_MIP_KNAPSACK_NO},
//       {"KN_MIP_KNAPSACK_NONE", KN_MIP_KNAPSACK_NONE},
//       {"KN_MIP_KNAPSACK_ROOT", KN_MIP_KNAPSACK_ROOT},
//       {"KN_MIP_KNAPSACK_TREE", KN_MIP_KNAPSACK_TREE},
//       {"KN_MIP_KNAPSACK_INEQ", KN_MIP_KNAPSACK_INEQ},
//       {"KN_MIP_KNAPSACK_LIFTED", KN_MIP_KNAPSACK_LIFTED},
//       {"KN_MIP_KNAPSACK_ALL", KN_MIP_KNAPSACK_ALL},
//       {"KN_PARAM_MIP_ROUNDING", KN_PARAM_MIP_ROUNDING},
//       {"KN_MIP_ROUND_AUTO", KN_MIP_ROUND_AUTO},
//       {"KN_MIP_ROUND_NONE", KN_MIP_ROUND_NONE},
//       {"KN_MIP_ROUND_HEURISTIC", KN_MIP_ROUND_HEURISTIC},
//       {"KN_MIP_ROUND_NLP_SOME", KN_MIP_ROUND_NLP_SOME},
//       {"KN_MIP_ROUND_NLP_ALWAYS", KN_MIP_ROUND_NLP_ALWAYS},
//       {"KN_PARAM_MIP_ROOTALG", KN_PARAM_MIP_ROOTALG},
//       {"KN_MIP_ROOTALG_AUTO", KN_MIP_ROOTALG_AUTO},
//       {"KN_MIP_ROOTALG_BAR_DIRECT", KN_MIP_ROOTALG_BAR_DIRECT},
//       {"KN_MIP_ROOTALG_BAR_CG", KN_MIP_ROOTALG_BAR_CG},
//       {"KN_MIP_ROOTALG_ACT_CG", KN_MIP_ROOTALG_ACT_CG},
//       {"KN_MIP_ROOTALG_ACT_SQP", KN_MIP_ROOTALG_ACT_SQP},
//       {"KN_MIP_ROOTALG_MULTI", KN_MIP_ROOTALG_MULTI},
//       {"KN_PARAM_MIP_LPALG", KN_PARAM_MIP_LPALG},
//       {"KN_MIP_LPALG_AUTO", KN_MIP_LPALG_AUTO},
//       {"KN_MIP_LPALG_BAR_DIRECT", KN_MIP_LPALG_BAR_DIRECT},
//       {"KN_MIP_LPALG_BAR_CG", KN_MIP_LPALG_BAR_CG},
//       {"KN_MIP_LPALG_ACT_CG", KN_MIP_LPALG_ACT_CG},
//       {"KN_PARAM_MIP_TERMINATE", KN_PARAM_MIP_TERMINATE},
//       {"KN_MIP_TERMINATE_OPTIMAL", KN_MIP_TERMINATE_OPTIMAL},
//       {"KN_MIP_TERMINATE_FEASIBLE", KN_MIP_TERMINATE_FEASIBLE},
//       {"KN_PARAM_MIP_MAXNODES", KN_PARAM_MIP_MAXNODES},
//       {"KN_PARAM_MIP_HEURISTIC", KN_PARAM_MIP_HEURISTIC},
//       {"KN_MIP_HEURISTIC_AUTO", KN_MIP_HEURISTIC_AUTO},
//       {"KN_MIP_HEURISTIC_NONE", KN_MIP_HEURISTIC_NONE},
//       {"KN_MIP_HEURISTIC_FEASPUMP", KN_MIP_HEURISTIC_FEASPUMP},
//       {"KN_MIP_HEURISTIC_MPEC", KN_MIP_HEURISTIC_MPEC},
//       {"KN_MIP_HEURISTIC_DIVING", KN_MIP_HEURISTIC_DIVING},
//       {"KN_PARAM_MIP_HEUR_MAXIT", KN_PARAM_MIP_HEUR_MAXIT},
//       {"KN_PARAM_MIP_HEUR_MAXTIMECPU", KN_PARAM_MIP_HEUR_MAXTIMECPU},
//       {"KN_PARAM_MIP_HEUR_MAXTIMEREAL", KN_PARAM_MIP_HEUR_MAXTIMEREAL},
//       {"KN_PARAM_MIP_PSEUDOINIT", KN_PARAM_MIP_PSEUDOINIT},
//       {"KN_MIP_PSEUDOINIT_AUTO", KN_MIP_PSEUDOINIT_AUTO},
//       {"KN_MIP_PSEUDOINIT_AVE", KN_MIP_PSEUDOINIT_AVE},
//       {"KN_MIP_PSEUDOINIT_STRONG", KN_MIP_PSEUDOINIT_STRONG},
//       {"KN_PARAM_MIP_STRONG_MAXIT", KN_PARAM_MIP_STRONG_MAXIT},
//       {"KN_PARAM_MIP_STRONG_CANDLIM", KN_PARAM_MIP_STRONG_CANDLIM},
//       {"KN_PARAM_MIP_STRONG_LEVEL", KN_PARAM_MIP_STRONG_LEVEL},
//       {"KN_PARAM_MIP_INTVAR_STRATEGY", KN_PARAM_MIP_INTVAR_STRATEGY},
//       {"KN_MIP_INTVAR_STRATEGY_NONE", KN_MIP_INTVAR_STRATEGY_NONE},
//       {"KN_MIP_INTVAR_STRATEGY_RELAX", KN_MIP_INTVAR_STRATEGY_RELAX},
//       {"KN_MIP_INTVAR_STRATEGY_MPEC", KN_MIP_INTVAR_STRATEGY_MPEC},
//       {"KN_PARAM_MIP_RELAXABLE", KN_PARAM_MIP_RELAXABLE},
//       {"KN_MIP_RELAXABLE_NONE", KN_MIP_RELAXABLE_NONE},
//       {"KN_MIP_RELAXABLE_ALL", KN_MIP_RELAXABLE_ALL},
//       {"KN_PARAM_MIP_NODEALG", KN_PARAM_MIP_NODEALG},
//       {"KN_MIP_NODEALG_AUTO", KN_MIP_NODEALG_AUTO},
//       {"KN_MIP_NODEALG_BAR_DIRECT", KN_MIP_NODEALG_BAR_DIRECT},
//       {"KN_MIP_NODEALG_BAR_CG", KN_MIP_NODEALG_BAR_CG},
//       {"KN_MIP_NODEALG_ACT_CG", KN_MIP_NODEALG_ACT_CG},
//       {"KN_MIP_NODEALG_ACT_SQP", KN_MIP_NODEALG_ACT_SQP},
//       {"KN_MIP_NODEALG_MULTI", KN_MIP_NODEALG_MULTI},
//       {"KN_PARAM_MIP_HEUR_TERMINATE", KN_PARAM_MIP_HEUR_TERMINATE},
//       {"KN_MIP_HEUR_TERMINATE_FEASIBLE", KN_MIP_HEUR_TERMINATE_FEASIBLE},
//       {"KN_MIP_HEUR_TERMINATE_LIMIT", KN_MIP_HEUR_TERMINATE_LIMIT},
//       {"KN_PARAM_MIP_SELECTDIR", KN_PARAM_MIP_SELECTDIR},
//       {"KN_MIP_SELECTDIR_DOWN", KN_MIP_SELECTDIR_DOWN},
//       {"KN_MIP_SELECTDIR_UP", KN_MIP_SELECTDIR_UP},
//       {"KN_PARAM_MIP_CUTFACTOR", KN_PARAM_MIP_CUTFACTOR},
//       {"KN_PARAM_MIP_ZEROHALF", KN_PARAM_MIP_ZEROHALF},
//       {"KN_MIP_ZEROHALF_AUTO", KN_MIP_ZEROHALF_AUTO},
//       {"KN_MIP_ZEROHALF_NONE", KN_MIP_ZEROHALF_NONE},
//       {"KN_MIP_ZEROHALF_ROOT", KN_MIP_ZEROHALF_ROOT},
//       {"KN_MIP_ZEROHALF_TREE", KN_MIP_ZEROHALF_TREE},
//       {"KN_MIP_ZEROHALF_ALL", KN_MIP_ZEROHALF_ALL},
//       {"KN_PARAM_MIP_MIR", KN_PARAM_MIP_MIR},
//       {"KN_MIP_MIR_AUTO", KN_MIP_MIR_AUTO},
//       {"KN_MIP_MIR_NONE", KN_MIP_MIR_NONE},
//       {"KN_MIP_MIR_ROOT", KN_MIP_MIR_ROOT},
//       {"KN_MIP_MIR_TREE", KN_MIP_MIR_TREE},
//       {"KN_MIP_MIR_NLP", KN_MIP_MIR_NLP},
//       {"KN_PARAM_MIP_CLIQUE", KN_PARAM_MIP_CLIQUE},
//       {"KN_MIP_CLIQUE_AUTO", KN_MIP_CLIQUE_AUTO},
//       {"KN_MIP_CLIQUE_NONE", KN_MIP_CLIQUE_NONE},
//       {"KN_MIP_CLIQUE_ROOT", KN_MIP_CLIQUE_ROOT},
//       {"KN_MIP_CLIQUE_TREE", KN_MIP_CLIQUE_TREE},
//       {"KN_MIP_CLIQUE_ALL", KN_MIP_CLIQUE_ALL},
//       {"KN_PARAM_MIP_HEUR_STRATEGY", KN_PARAM_MIP_HEUR_STRATEGY},
//       {"KN_MIP_HEUR_STRATEGY_AUTO", KN_MIP_HEUR_STRATEGY_AUTO},
//       {"KN_MIP_HEUR_STRATEGY_NONE", KN_MIP_HEUR_STRATEGY_NONE},
//       {"KN_MIP_HEUR_STRATEGY_BASIC", KN_MIP_HEUR_STRATEGY_BASIC},
//       {"KN_MIP_HEUR_STRATEGY_ADVANCED", KN_MIP_HEUR_STRATEGY_ADVANCED},
//       {"KN_MIP_HEUR_STRATEGY_EXTENSIVE", KN_MIP_HEUR_STRATEGY_EXTENSIVE},
//       {"KN_PARAM_MIP_HEUR_FEASPUMP", KN_PARAM_MIP_HEUR_FEASPUMP},
//       {"KN_MIP_HEUR_FEASPUMP_AUTO", KN_MIP_HEUR_FEASPUMP_AUTO},
//       {"KN_MIP_HEUR_FEASPUMP_OFF", KN_MIP_HEUR_FEASPUMP_OFF},
//       {"KN_MIP_HEUR_FEASPUMP_ON", KN_MIP_HEUR_FEASPUMP_ON},
//       {"KN_PARAM_MIP_HEUR_MPEC", KN_PARAM_MIP_HEUR_MPEC},
//       {"KN_MIP_HEUR_MPEC_AUTO", KN_MIP_HEUR_MPEC_AUTO},
//       {"KN_MIP_HEUR_MPEC_OFF", KN_MIP_HEUR_MPEC_OFF},
//       {"KN_MIP_HEUR_MPEC_ON", KN_MIP_HEUR_MPEC_ON},
//       {"KN_PARAM_MIP_HEUR_DIVING", KN_PARAM_MIP_HEUR_DIVING},
//       {"KN_PARAM_MIP_CUTTINGPLANE", KN_PARAM_MIP_CUTTINGPLANE},
//       {"KN_MIP_CUTTINGPLANE_NONE", KN_MIP_CUTTINGPLANE_NONE},
//       {"KN_MIP_CUTTINGPLANE_ROOT", KN_MIP_CUTTINGPLANE_ROOT},
//       {"KN_PARAM_MIP_CUTOFF", KN_PARAM_MIP_CUTOFF},
//       {"KN_PARAM_MIP_HEUR_LNS", KN_PARAM_MIP_HEUR_LNS},
//       {"KN_PARAM_MIP_MULTISTART", KN_PARAM_MIP_MULTISTART},
//       {"KN_MIP_MULTISTART_OFF", KN_MIP_MULTISTART_OFF},
//       {"KN_MIP_MULTISTART_ON", KN_MIP_MULTISTART_ON},
//       {"KN_PARAM_MIP_LIFTPROJECT", KN_PARAM_MIP_LIFTPROJECT},
//       {"KN_MIP_LIFTPROJECT_AUTO", KN_MIP_LIFTPROJECT_AUTO},
//       {"KN_MIP_LIFTPROJECT_NONE", KN_MIP_LIFTPROJECT_NONE},
//       {"KN_MIP_LIFTPROJECT_ROOT", KN_MIP_LIFTPROJECT_ROOT},
//       {"KN_PARAM_MIP_NUMTHREADS", KN_PARAM_MIP_NUMTHREADS},
//       {"KN_PARAM_MIP_HEUR_MISQP", KN_PARAM_MIP_HEUR_MISQP},
//       {"KN_MIP_HEUR_MISQP_AUTO", KN_MIP_HEUR_MISQP_AUTO},
//       {"KN_MIP_HEUR_MISQP_OFF", KN_MIP_HEUR_MISQP_OFF},
//       {"KN_MIP_HEUR_MISQP_ON", KN_MIP_HEUR_MISQP_ON},
//       {"KN_PARAM_MIP_RESTART", KN_PARAM_MIP_RESTART},
//       {"KN_MIP_RESTART_OFF", KN_MIP_RESTART_OFF},
//       {"KN_MIP_RESTART_ON", KN_MIP_RESTART_ON},
//       {"KN_PARAM_MIP_GOMORY", KN_PARAM_MIP_GOMORY},
//       {"KN_MIP_GOMORY_AUTO", KN_MIP_GOMORY_AUTO},
//       {"KN_MIP_GOMORY_NONE", KN_MIP_GOMORY_NONE},
//       {"KN_MIP_GOMORY_ROOT", KN_MIP_GOMORY_ROOT},
//       {"KN_MIP_GOMORY_TREE", KN_MIP_GOMORY_TREE},
//       {"KN_PARAM_MIP_CUT_PROBING", KN_PARAM_MIP_CUT_PROBING},
//       {"KN_MIP_CUT_PROBING_AUTO", KN_MIP_CUT_PROBING_AUTO},
//       {"KN_MIP_CUT_PROBING_NONE", KN_MIP_CUT_PROBING_NONE},
//       {"KN_MIP_CUT_PROBING_ROOT", KN_MIP_CUT_PROBING_ROOT},
//       {"KN_MIP_CUT_PROBING_TREE", KN_MIP_CUT_PROBING_TREE},
//       {"KN_PARAM_MIP_CUT_FLOWCOVER", KN_PARAM_MIP_CUT_FLOWCOVER},
//       {"KN_MIP_CUT_FLOWCOVER_AUTO", KN_MIP_CUT_FLOWCOVER_AUTO},
//       {"KN_MIP_CUT_FLOWCOVER_NONE", KN_MIP_CUT_FLOWCOVER_NONE},
//       {"KN_MIP_CUT_FLOWCOVER_ROOT", KN_MIP_CUT_FLOWCOVER_ROOT},
//       {"KN_MIP_CUT_FLOWCOVER_TREE", KN_MIP_CUT_FLOWCOVER_TREE},
//       {"KN_PARAM_MIP_HEUR_LOCALSEARCH", KN_PARAM_MIP_HEUR_LOCALSEARCH},
//       {"KN_MIP_HEUR_LOCALSEARCH_AUTO", KN_MIP_HEUR_LOCALSEARCH_AUTO},
//       {"KN_MIP_HEUR_LOCALSEARCH_OFF", KN_MIP_HEUR_LOCALSEARCH_OFF},
//       {"KN_MIP_HEUR_LOCALSEARCH_ON", KN_MIP_HEUR_LOCALSEARCH_ON},
//       {"KN_PARAM_PAR_NUMTHREADS", KN_PARAM_PAR_NUMTHREADS},
//       {"KN_PARAM_PAR_CONCURRENT_EVALS", KN_PARAM_PAR_CONCURRENT_EVALS},
//       {"KN_PAR_CONCURRENT_EVALS_NO", KN_PAR_CONCURRENT_EVALS_NO},
//       {"KN_PAR_CONCURRENT_EVALS_YES", KN_PAR_CONCURRENT_EVALS_YES},
//       {"KN_PARAM_PAR_BLASNUMTHREADS", KN_PARAM_PAR_BLASNUMTHREADS},
//       {"KN_PARAM_PAR_LSNUMTHREADS", KN_PARAM_PAR_LSNUMTHREADS},
//       {"KN_PARAM_PAR_MSNUMTHREADS", KN_PARAM_PAR_MSNUMTHREADS},
//       {"KN_PAR_MSNUMTHREADS_AUTO", KN_PAR_MSNUMTHREADS_AUTO},
//       {"KN_PARAM_PAR_CONICNUMTHREADS", KN_PARAM_PAR_CONICNUMTHREADS},
//   };
//   return mapControls;
// }

/*------------KnitroInterface Definition------------*/

class KnitroInterface : public MPSolverInterface {
 public:
  explicit KnitroInterface(MPSolver* solver, bool mip);
  ~KnitroInterface() override;

  MPSolver::ResultStatus Solve(const MPSolverParameters& param) override;

  // TODO : A voir si on override
  // std::optional<MPSolutionResponse> DirectlySolveProto(
  //     const MPModelRequest& request, std::atomic<bool>* interrupt) override;

  void Write(const std::string& filename) override;
  void Reset() override;

  double infinity() override { return KN_INFINITY; };

  void SetOptimizationDirection(bool maximize) override;
  void SetVariableBounds(int var_index, double lb, double ub) override;
  void SetVariableInteger(int var_index, bool integer) override;
  void SetConstraintBounds(int row_index, double lb, double ub) override;

  void AddRowConstraint(MPConstraint* ct) override;
  void AddVariable(MPVariable* var) override;
  void SetCoefficient(MPConstraint* constraint, const MPVariable* variable,
                      double new_value, double old_value) override;
  void ClearConstraint(MPConstraint* constraint) override;
  void SetObjectiveCoefficient(const MPVariable* variable,
                               double coefficient) override;
  void SetObjectiveOffset(double value) override;
  void ClearObjective() override;
  void BranchingPriorityChangedForVariable(int var_index) override;

  int64_t iterations() const override;
  int64_t nodes() const override;

  MPSolver::BasisStatus row_status(int constraint_index) const override {
    LOG(DFATAL) << "Not Supported by Knitro ! ";
    return MPSolver::FREE;
  }
  MPSolver::BasisStatus column_status(int variable_index) const override {
    LOG(DFATAL) << "Not Supported by Knitro ! ";
    return MPSolver::FREE;
  }

  bool IsContinuous() const override { return !mip_; }
  bool IsLP() const override { return !mip_; }
  bool IsMIP() const override { return mip_; }

  void ExtractNewVariables() override;
  void ExtractNewConstraints() override;
  void ExtractObjective() override;

  std::string SolverVersion() const override;

  void* underlying_solver() override { return reinterpret_cast<void*>(kc_); }

  virtual double ComputeExactConditionNumber() const override {
    LOG(DFATAL) << "ComputeExactConditionNumber not implemented for"
                << " Knitro Programming";
    return 0.0;
  };

  void SetCallback(MPCallback* mp_callback) override;
  bool SupportsCallbacks() const override { return true; }

 private:
  void SetParameters(const MPSolverParameters& param) override;
  void SetRelativeMipGap(double value) override;
  void SetPrimalTolerance(double value) override;
  void SetDualTolerance(double value) override;
  void SetPresolveMode(int presolve) override;
  void SetScalingMode(int scaling) override;
  void SetLpAlgorithm(int lp_algorithm) override;

  absl::Status SetNumThreads(int num_threads) override;

  bool SetSolverSpecificParametersAsString(
      const std::string& parameters) override;

  void AddSolutionHintToOptimizer();
  void SetSolution();

  KN_context* kc_;
  bool mip_;
  bool no_obj_;
  MPCallback* callback_ = nullptr;
  // std::map<std::string, int> param_map_;
};

/*------------Knitro CallBack Context------------*/

/**
 * Knitro's MPCallbackContext derived class
 *
 * Stores the values x and lambda provided by Knitro MIP Callback functions
 * eventhough lambda can't be used with the current MPCallbackContext definition
 *
 * Return code from Knitro solver's cuts can't be retrieved neither
 */
class KnitroMPCallbackContext : public MPCallbackContext {
  friend class KnitroInterface;

 public:
  KnitroMPCallbackContext(KN_context_ptr* kc, MPCallbackEvent event,
                          const double* const x, const double* const lambda)
      : kc_ptr_(kc), event_(event), var_val(x), lambda(lambda){};

  // Implementation of the interface.
  MPCallbackEvent Event() override { return event_; };
  bool CanQueryVariableValues() override;
  double VariableValue(const MPVariable* variable) override;

  // Knitro supports cuts and lazy constraints only
  void AddCut(const LinearRange& cutting_plane) override;
  void AddLazyConstraint(const LinearRange& lazy_constraint) override;
  double SuggestSolution(
      const absl::flat_hash_map<const MPVariable*, double>& solution) override {
    LOG(WARNING) << "SuggestSolution is not implemented in Knitro interface";
    return NAN;
  }

  int64_t NumExploredNodes() override;

 private:
  KN_context_ptr* kc_ptr_;
  MPCallbackEvent event_;
  const double* const var_val;
  // lambda is not used
  const double* const lambda;
};

bool KnitroMPCallbackContext::CanQueryVariableValues() {
  switch (event_) {
    case MPCallbackEvent::kMipSolution:
    case MPCallbackEvent::kMipNode:
      return true;
    default:
      return false;
  }
}

double KnitroMPCallbackContext::VariableValue(const MPVariable* variable) {
  return var_val[variable->index()];
}

int64_t KnitroMPCallbackContext::NumExploredNodes() {
  int num_nodes;
  CHECK_STATUS(KN_get_mip_number_nodes(*kc_ptr_, &num_nodes));
  return num_nodes;
}

/**
 * Constraint generator for callback methods.
 * Add new linear constraint to Knitro model as Knitro
 * generate cuts from lazy constraints using the same method.
 * @param kn the Knitro model
 * @param linear_range the constraint
 */
void GenerateConstraint(KN_context* kc, const LinearRange& linear_range) {
  std::vector<int> variable_indices;
  std::vector<double> variable_coefficients;
  const int num_terms = linear_range.linear_expr().terms().size();
  variable_indices.reserve(num_terms);
  variable_coefficients.reserve(num_terms);
  for (const auto& var_coef_pair : linear_range.linear_expr().terms()) {
    variable_indices.push_back(var_coef_pair.first->index());
    variable_coefficients.push_back(var_coef_pair.second);
  }
  int cb_con;
  CHECK_STATUS(KN_add_con(kc, &cb_con));
  CHECK_STATUS(KN_set_con_lobnd(
      kc, cb_con, redefine_infinity_double(linear_range.lower_bound())));
  CHECK_STATUS(KN_set_con_upbnd(
      kc, cb_con, redefine_infinity_double(linear_range.upper_bound())));
  CHECK_STATUS(KN_add_con_linear_struct_one(kc, num_terms, cb_con,
                                            variable_indices.data(),
                                            variable_coefficients.data()));
}

void KnitroMPCallbackContext::AddCut(const LinearRange& cutting_plane) {
  CHECK(event_ == MPCallbackEvent::kMipNode);
  GenerateConstraint(*kc_ptr_, cutting_plane);
}

void KnitroMPCallbackContext::AddLazyConstraint(
    const LinearRange& lazy_constraint) {
  CHECK(event_ == MPCallbackEvent::kMipNode ||
        event_ == MPCallbackEvent::kMipSolution);
  GenerateConstraint(*kc_ptr_, lazy_constraint);
}

struct MPCallBackWithEvent {
  MPCallbackEvent event;
  MPCallback* callback;
};

/**
 * Call-back called by Knitro that needs this type signature.
 */
int KNITRO_API CallBackFn(KN_context_ptr kc, const double* const x,
                          const double* const lambda, void* const userParams) {
  MPCallBackWithEvent* const callback_with_event =
      static_cast<MPCallBackWithEvent*>(userParams);
  CHECK(callback_with_event != nullptr);
  std::unique_ptr<KnitroMPCallbackContext> cb_context;
  cb_context = std::make_unique<KnitroMPCallbackContext>(
      &kc, callback_with_event->event, x, lambda);
  callback_with_event->callback->RunCallback(cb_context.get());
  return 0;
}

/*------------Knitro Interface Implem ------------*/

KnitroInterface::KnitroInterface(MPSolver* solver, bool mip)
    : MPSolverInterface(solver), kc_(nullptr), mip_(mip), no_obj_(true) {
  KnitroIsCorrectlyInstalled();
  CHECK_STATUS(KN_new(&kc_));
}

/**
 * Cleans the Knitro problem using Knitro free method.
 */
KnitroInterface::~KnitroInterface() { CHECK_STATUS(KN_free(&kc_)); }

// ------ Model modifications and extraction -----

void KnitroInterface::Reset() {
  // Instead of explicitly clearing all model objects we
  // just delete the problem object and allocate a new one.
  std::cout << "Reset Called" << std::endl;
  CHECK_STATUS(KN_free(&kc_));
  no_obj_ = true;
  int status;
  status = KN_new(&kc_);
  CHECK_STATUS(status);
  DCHECK(kc_ != nullptr);  // should not be NULL if status=0
  ResetExtractionInformation();
}

void KnitroInterface::Write(const std::string& filename) {
  ExtractModel();
  VLOG(1) << "Writing Knitro MPS \"" << filename << "\".";
  const int status = KN_write_mps_file(kc_, filename.c_str());
  if (status) {
    LOG(ERROR) << "Knitro: Failed to write MPS!";
  }
}

void KnitroInterface::SetOptimizationDirection(bool maximize) {
  InvalidateSolutionSynchronization();
  CHECK_STATUS(KN_set_obj_goal(
      kc_, (maximize) ? KN_OBJGOAL_MAXIMIZE : KN_OBJGOAL_MINIMIZE));
}

void KnitroInterface::SetVariableBounds(int var_index, double lb, double ub) {
  InvalidateSolutionSynchronization();
  // the "extracted" check is done upstream for now
  // but it should be done here
  if (variable_is_extracted(var_index)) {
    // Not cached if the variable has been extracted.
    DCHECK_LT(var_index, last_variable_index_);
    CHECK_STATUS(
        KN_set_var_lobnd(kc_, var_index, redefine_infinity_double(lb)));
    CHECK_STATUS(
        KN_set_var_upbnd(kc_, var_index, redefine_infinity_double(ub)));
  } else {
    sync_status_ = MUST_RELOAD;
  }
}

void KnitroInterface::SetVariableInteger(int var_index, bool integer) {
  InvalidateSolutionSynchronization();
  if (mip_) {
    // the "extracted" check is done upstream for now
    // but it should be done here
    if (variable_is_extracted(var_index)) {
      DCHECK_LT(var_index, last_variable_index_);
      CHECK_STATUS(KN_set_var_type(
          kc_, var_index,
          integer ? KN_VARTYPE_INTEGER : KN_VARTYPE_CONTINUOUS));
    } else {
      sync_status_ = MUST_RELOAD;
    }
  } else {
    LOG(DFATAL) << "Attempt to change variable to integer in non-MIP problem!";
  }
}

void KnitroInterface::SetConstraintBounds(int row_index, double lb, double ub) {
  InvalidateSolutionSynchronization();
  // the "extracted" check is done upstream for now
  // but it should be done here
  if (constraint_is_extracted(row_index)) {
    DCHECK_LT(row_index, last_constraint_index_);
    CHECK_STATUS(
        KN_set_con_lobnd(kc_, row_index, redefine_infinity_double(lb)));
    CHECK_STATUS(
        KN_set_con_upbnd(kc_, row_index, redefine_infinity_double(ub)));
  } else {
    sync_status_ = MUST_RELOAD;
  }
}

void KnitroInterface::SetCoefficient(MPConstraint* constraint,
                                     const MPVariable* variable,
                                     double new_value, double old_value) {
  InvalidateSolutionSynchronization();
  int var_index = variable->index(), row_index = constraint->index();
  if (variable_is_extracted(var_index) && constraint_is_extracted(row_index)) {
    DCHECK_LT(row_index, last_constraint_index_);
    DCHECK_LT(var_index, last_variable_index_);
    CHECK_STATUS(KN_chg_con_linear_term(kc_, row_index, var_index, new_value));
    CHECK_STATUS(KN_update(kc_));
  } else {
    sync_status_ = MUST_RELOAD;
  }
}

void KnitroInterface::ClearConstraint(MPConstraint* constraint) {
  InvalidateSolutionSynchronization();

  int const row = constraint->index();

  if (!constraint_is_extracted(row)) return;

  int const len = constraint->coefficients_.size();
  std::unique_ptr<int[]> var_ind(new int[len]);
  int j = 0;
  const auto& coeffs = constraint->coefficients_;
  for (auto coeff : coeffs) {
    int const col = coeff.first->index();
    // if the variable has been extracted,
    // then its linear coefficient exists
    if (variable_is_extracted(col)) {
      var_ind[j] = col;
      ++j;
    }
  }
  if (j > 0) {
    // delete all coefficients of constraint's linear structure
    CHECK_STATUS(KN_del_con_linear_struct_one(kc_, j, row, var_ind.get()));
    CHECK_STATUS(KN_update(kc_));
  }
}

void KnitroInterface::SetObjectiveCoefficient(const MPVariable* variable,
                                              double coefficient) {
  sync_status_ = MUST_RELOAD;
}

void KnitroInterface::SetObjectiveOffset(double value) {
  sync_status_ = MUST_RELOAD;
}

void KnitroInterface::ClearObjective() {
  // if the model does not have objective, return
  if (no_obj_) return;
  if (solver_->Objective().offset()) CHECK_STATUS(KN_del_obj_constant(kc_));
  InvalidateSolutionSynchronization();
  int const cols = solver_->objective_->coefficients_.size();
  std::unique_ptr<int[]> ind(new int[cols]);
  int j = 0;
  const auto& coeffs = solver_->objective_->coefficients_;
  for (auto coeff : coeffs) {
    int const idx = coeff.first->index();
    // We only need to reset variables that have been extracted.
    if (variable_is_extracted(idx)) {
      DCHECK_LT(idx, cols);
      ind[j] = idx;
      ++j;
    }
  }
  if (j > 0) {
    CHECK_STATUS(KN_del_obj_linear_struct(kc_, j, ind.get()));
    CHECK_STATUS(KN_update(kc_));
  }
  no_obj_ = true;
}

void KnitroInterface::BranchingPriorityChangedForVariable(int var_index) {
  InvalidateSolutionSynchronization();
  if (mip_) {
    if (variable_is_extracted(var_index)) {
      DCHECK_LT(var_index, last_variable_index_);
      int const priority = solver_->variables_[var_index]->branching_priority();
      CHECK_STATUS(KN_set_mip_branching_priority(kc_, var_index, priority));
    } else {
      sync_status_ = MUST_RELOAD;
    }
  } else {
    LOG(DFATAL) << "Attempt to change branching priority of variable in "
                   "non-MIP problem!";
  }
}

void KnitroInterface::AddRowConstraint(MPConstraint* ct) {
  sync_status_ = MUST_RELOAD;
}

void KnitroInterface::AddVariable(MPVariable* var) {
  sync_status_ = MUST_RELOAD;
}

void KnitroInterface::ExtractNewVariables() {
  std::cout << "Extracting Variables " << std::endl;
  int const total_num_vars = solver_->variables_.size();
  if (total_num_vars > last_variable_index_) {
    int const len = total_num_vars - last_variable_index_;
    // for init and def basic properties
    std::unique_ptr<int[]> idx_vars(new int[len]);
    std::unique_ptr<double[]> lb(new double[len]);
    std::unique_ptr<double[]> ub(new double[len]);
    std::unique_ptr<int[]> types(new int[len]);
    // // lambda fn to destroy the array of names
    // auto deleter = [len](char** ptr) {
    //   for (int i = 0; i < len; ++i) {
    //     delete[] ptr[i];
    //   }
    //   delete[] ptr;
    // };
    // std::unique_ptr<char*[], decltype(deleter)> names(new char*[len], deleter);
    // for priority properties
    std::unique_ptr<int[]> prior(new int[len]);
    std::unique_ptr<int[]> prior_idx(new int[len]);
    int prior_nb = 0;
    std::cout << "Variables' Containers created" << std::endl;
    // Define new variables
    for (int j = 0, var_index = last_variable_index_; j < len;
         ++j, ++var_index) {
      MPVariable* const var = solver_->variables_[var_index];
      DCHECK(!variable_is_extracted(var_index));
      set_variable_as_extracted(var_index, true);
      idx_vars[j] = var_index;
      lb[j] = redefine_infinity_double(var->lb());
      ub[j] = redefine_infinity_double(var->ub());
      // Def buffer size at 256 for variables' name
      // names[j] = new char[256];
      // strcpy(names[j], var->name().c_str());
      types[j] =
          (mip_ && var->integer()) ? KN_VARTYPE_INTEGER : KN_VARTYPE_CONTINUOUS;
      if (var->integer() && (var->branching_priority() != 0)) {
        prior_idx[prior_nb] = var_index;
        prior[prior_nb] = var->branching_priority();
        prior_nb++;
      }
    }
    std::cout << "Variables' Containers filled" << std::endl;
    CHECK_STATUS(KN_add_vars(kc_, len, NULL));
    CHECK_STATUS(KN_set_var_lobnds(kc_, len, idx_vars.get(), lb.get()));
    CHECK_STATUS(KN_set_var_upbnds(kc_, len, idx_vars.get(), ub.get()));
    CHECK_STATUS(KN_set_var_types(kc_, len, idx_vars.get(), types.get()));
    // CHECK_STATUS(KN_set_var_names(kc_, len, idx_vars.get(), names.get()));
    CHECK_STATUS(KN_set_mip_branching_priorities(kc_, prior_nb, prior_idx.get(),
                                                 prior.get()));
    std::cout << "Variables added to the Knitro Context" << std::endl;
    // Add new variables to existing constraints.
    for (int i = 0; i < last_constraint_index_; i++) {
      MPConstraint* const ct = solver_->constraints_[i];
      for (const auto& entry : ct->coefficients_) {
        const int var_index = entry.first->index();
        DCHECK(variable_is_extracted(var_index));
        if (var_index >= last_variable_index_) {
          // The variable is new, so we know the previous coefficient
          // value was 0 and we can directly add the coefficient.
          CHECK_STATUS(KN_add_con_linear_term(kc_, i, var_index, entry.second));
        }
      }
    }
  }
  std::cout << "Extracting Variables End" << std::endl;
}

void KnitroInterface::ExtractNewConstraints() {
  std::cout << "Extracting Constraints " << std::endl;
  int const total_num_cons = solver_->constraints_.size();
  int const total_num_vars = solver_->variables_.size();
  std::cout << "Sizes extracted" << std::endl;
  if (total_num_cons > last_constraint_index_) {
    int const len = total_num_cons - last_constraint_index_;
    std::unique_ptr<int[]> idx_cons(new int[len]);
    std::unique_ptr<double[]> lb(new double[len]);
    std::unique_ptr<double[]> ub(new double[len]);
    std::unique_ptr<int[]> lin_idx_cons(new int[len * total_num_vars]);
    std::unique_ptr<int[]> lin_idx_vars(new int[len * total_num_vars]);
    std::unique_ptr<double[]> lin_coefs(new double[len * total_num_vars]);
    // // std::cout << "Creating Char deleter lambda exp" << std::endl;
    // // lambda fn to destroy the array of names
    // auto deleter = [len](char** ptr) {
    //   for (int i = 0; i < len; ++i) {
    //     delete[] ptr[i];
    //   }
    //   delete[] ptr;
    // };
    // std::unique_ptr<char*[], decltype(deleter)> names(new char*[len], deleter);
    std::cout << "Constraints' Containers created" << std::endl;
    int idx_lin_term = 0;
    // Define new constraints
    for (int j = 0, con_index = last_constraint_index_; j < len;
         ++j, ++con_index) {
      MPConstraint* const ct = solver_->constraints_[con_index];
      DCHECK(!constraint_is_extracted(con_index));
      set_constraint_as_extracted(con_index, true);
      idx_cons[j] = con_index;
      lb[j] = redefine_infinity_double(ct->lb());
      ub[j] = redefine_infinity_double(ct->ub());
      for (int i = 0; i < total_num_vars; ++i) {
        lin_idx_cons[idx_lin_term] = con_index;
        lin_idx_vars[idx_lin_term] = i;
        lin_coefs[idx_lin_term] = ct->GetCoefficient(solver_->variables_[i]);
        idx_lin_term++;
      }
      // // Def buffer size at 256 for variables' name
      // names[j] = new char[256];
      // strcpy(names[j], ct->name().c_str());
    }
    std::cout << "Constraints' Containers filled" << std::endl;
    CHECK_STATUS(KN_add_cons(kc_, len, NULL));
    CHECK_STATUS(KN_set_con_lobnds(kc_, len, idx_cons.get(), lb.get()));
    CHECK_STATUS(KN_set_con_upbnds(kc_, len, idx_cons.get(), ub.get()));

    // CHECK_STATUS(KN_set_con_names(kc_, len, idx_cons.get(), names.get()));
    if (idx_lin_term) {
      CHECK_STATUS(
          KN_add_con_linear_struct(kc_, idx_lin_term, lin_idx_cons.get(),
                                   lin_idx_vars.get(), lin_coefs.get()));
      KN_update(kc_);
    }
    std::cout << "Constraints added to the Knitro Context" << std::endl;
  }
  std::cout << "Extracting Constraints End" << std::endl;
}

void KnitroInterface::ExtractObjective() {
  std::cout << "Extracting Objective Function " << std::endl;
  int const len = solver_->variables_.size();

  if (len) {
    std::unique_ptr<int[]> ind(new int[len]);
    std::unique_ptr<double[]> val(new double[len]);
    std::cout << "Objective's Containers created" << std::endl;
    for (int j = 0; j < len; ++j) {
      ind[j] = j;
      val[j] = 0.0;
    }

    const auto& coeffs = solver_->objective_->coefficients_;
    for (auto coeff : coeffs) {
      int const idx = coeff.first->index();
      if (variable_is_extracted(idx)) {
        DCHECK_LT(idx, len);
        ind[idx] = idx;
        val[idx] = coeff.second;
      }
    }
    std::cout << "Objective's Containers filled" << std::endl;
    // if a init solve occured, remove prev coef to add the new ones
    if (!no_obj_) {
      CHECK_STATUS(KN_chg_obj_linear_struct(kc_, len, ind.get(), val.get()));
      CHECK_STATUS(KN_chg_obj_constant(kc_, solver_->Objective().offset()));
    } else {
      CHECK_STATUS(KN_add_obj_linear_struct(kc_, len, ind.get(), val.get()));
      CHECK_STATUS(KN_add_obj_constant(kc_, solver_->Objective().offset()));
    }

    CHECK_STATUS(KN_update(kc_));
    no_obj_ = false;
  }
  std::cout << "Objective added into the Knitro Context" << std::endl;

  // Extra check on the optimization direction
  SetOptimizationDirection(maximize_);
}

// ------ Parameters  -----

void KnitroInterface::SetParameters(const MPSolverParameters& param) {
  SetCommonParameters(param);
  SetScalingMode(param.GetIntegerParam(MPSolverParameters::SCALING));
  if (mip_) SetMIPParameters(param);
}

#define setParamIfPossible_MACRO(target_map, setter, converter)          \
  {                                                                      \
    auto matchingParamIter = (target_map).find(paramAndValuePair.first); \
    if (matchingParamIter != (target_map).end()) {                       \
      const auto convertedValue = converter(paramAndValuePair.second);   \
      VLOG(1) << "Setting parameter " << paramAndValuePair.first         \
              << " to value " << convertedValue << std::endl;            \
      setter(mLp, matchingParamIter->second, convertedValue);            \
      continue;                                                          \
    }                                                                    \
  }

bool KnitroInterface::SetSolverSpecificParametersAsString(
    const std::string& parameters) {
  if (parameters.empty()) {
    return true;
  }

  // std::vector<std::pair<std::string, std::string> > paramAndValuePairList;

  // std::stringstream ss(parameters);
  // std::string paramName;
  // while (std::getline(ss, paramName, ' ')) {
  //   std::string paramValue;
  //   if (std::getline(ss, paramValue, ' ')) {
  //     paramAndValuePairList.push_back(std::make_pair(paramName, paramValue));
  //   } else {
  //     LOG(ERROR) << "No value for parameter " << paramName << " : function "
  //                << __FUNCTION__ << std::endl;
  //     return false;
  //   }
  // }

  // ScopedLocale locale;
  // for (auto& paramAndValuePair : paramAndValuePairList) {
  //   setParamIfPossible_MACRO(mapIntegerControls_, XPRSsetintcontrol, std::stoi);
  //   setParamIfPossible_MACRO(mapDoubleControls_, XPRSsetdblcontrol, std::stod);
  //   setParamIfPossible_MACRO(mapStringControls_, XPRSsetstrcontrol,
  //                            stringToCharPtr);
  //   setParamIfPossible_MACRO(mapInteger64Controls_, XPRSsetintcontrol64,
  //                            std::stoll);
  //   LOG(ERROR) << "Unknown parameter " << paramName << " : function "
  //              << __FUNCTION__ << std::endl;
  //   return false;
  // }
  // return true;
  if (KN_load_param_file(kc_, parameters.c_str()) == 0) {
    return true;
  }
  return false;
}

void KnitroInterface::SetRelativeMipGap(double value) {
  /**
   * This method should be called by SetMIPParameters() only
   * so there is no mip_ check here
   */
  CHECK_STATUS(KN_set_double_param(kc_, KN_PARAM_MIP_OPTGAPREL, value));
}

void KnitroInterface::SetPrimalTolerance(double value) {
  CHECK_STATUS(KN_set_double_param(kc_, KN_PARAM_FEASTOL, value));
}

void KnitroInterface::SetDualTolerance(double value) {
  CHECK_STATUS(KN_set_double_param(kc_, KN_PARAM_OPTTOL, value));
}

void KnitroInterface::SetPresolveMode(int value) {
  auto const presolve = static_cast<MPSolverParameters::PresolveValues>(value);

  switch (presolve) {
    case MPSolverParameters::PRESOLVE_OFF:
      CHECK_STATUS(KN_set_int_param(kc_, KN_PARAM_PRESOLVE, KN_PRESOLVE_NO));
      return;
    case MPSolverParameters::PRESOLVE_ON:
      CHECK_STATUS(KN_set_int_param(kc_, KN_PARAM_PRESOLVE, KN_PRESOLVE_YES));
      return;
    default:
      SetIntegerParamToUnsupportedValue(MPSolverParameters::PRESOLVE, value);
      return;
  }
}

void KnitroInterface::SetScalingMode(int value) {
  auto const scaling = static_cast<MPSolverParameters::ScalingValues>(value);

  switch (scaling) {
    case MPSolverParameters::SCALING_OFF:
      CHECK_STATUS(KN_set_int_param(kc_, KN_PARAM_LINSOLVER_SCALING,
                                    KN_LINSOLVER_SCALING_NONE));
      break;
    case MPSolverParameters::SCALING_ON:
      CHECK_STATUS(KN_set_int_param(kc_, KN_PARAM_LINSOLVER_SCALING,
                                    KN_LINSOLVER_SCALING_ALWAYS));
      break;
  }
}

void KnitroInterface::SetLpAlgorithm(int value) {
  auto const algorithm =
      static_cast<MPSolverParameters::LpAlgorithmValues>(value);
  switch (algorithm) {
    case MPSolverParameters::PRIMAL:
      CHECK_STATUS(
          KN_set_int_param(kc_, KN_PARAM_ACT_LPALG, KN_ACT_LPALG_PRIMAL));
      break;
    case MPSolverParameters::DUAL:
      CHECK_STATUS(
          KN_set_int_param(kc_, KN_PARAM_ACT_LPALG, KN_ACT_LPALG_DUAL));
      break;
    case MPSolverParameters::BARRIER:
      CHECK_STATUS(
          KN_set_int_param(kc_, KN_PARAM_ACT_LPALG, KN_ACT_LPALG_BARRIER));
      break;
    default:
      CHECK_STATUS(
          KN_set_int_param(kc_, KN_PARAM_ACT_LPALG, KN_ACT_LPALG_DEFAULT));
      break;
  }
}

void KnitroInterface::SetCallback(MPCallback* mp_callback) {
  callback_ = mp_callback;
}

absl::Status KnitroInterface::SetNumThreads(int num_threads) {
  CHECK_STATUS(KN_set_int_param(kc_, KN_PARAM_NUMTHREADS, num_threads));
  return absl::OkStatus();
}

// ------ Solve  -----

MPSolver::ResultStatus KnitroInterface::Solve(MPSolverParameters const& param) {
  std::cout << "Solve Called " << std::endl;
  WallTimer timer;
  timer.Start();

  if (param.GetIntegerParam(MPSolverParameters::INCREMENTALITY) ==
      MPSolverParameters::INCREMENTALITY_OFF) {
    Reset();
  }

  ExtractModel();
  VLOG(1) << absl::StrFormat("Model build in %.3f seconds.", timer.Get());

  std::cout << "Number of variables : " << solver_->variables_.size()
            << std::endl;
  std::cout << "Number of constraints : " << solver_->constraints_.size()
            << std::endl;

  // if (quiet_) {
  //   // Silent the screen output
  //   CHECK_STATUS(KN_set_int_param(kc_, KN_PARAM_OUTLEV, KN_OUTLEV_NONE));
  // }

  // Set parameters.
  SetParameters(param);
  solver_->SetSolverSpecificParametersAsString(
      solver_->solver_specific_parameter_string_);
  if (solver_->time_limit()) {
    VLOG(1) << "Setting time limit = " << solver_->time_limit() << " ms.";
    CHECK_STATUS(KN_set_double_param(kc_, KN_PARAM_MAXTIMECPU,
                                     solver_->time_limit_in_secs()));
  }

  // Set the hint (if any)
  this->AddSolutionHintToOptimizer();

  if (callback_ != nullptr) {
    if (callback_->might_add_lazy_constraints()) {
      MPCallBackWithEvent cbe;
      cbe.callback = callback_;
      cbe.event = MPCallbackEvent::kMipSolution;
      CHECK_STATUS(KN_set_mip_lazyconstraints_callback(
          kc_, CallBackFn, static_cast<void*>(&cbe)));
    }
    if (callback_->might_add_cuts()) {
      MPCallBackWithEvent cbe;
      cbe.callback = callback_;
      cbe.event = MPCallbackEvent::kMipNode;
      CHECK_STATUS(KN_set_mip_usercuts_callback(kc_, CallBackFn,
                                                static_cast<void*>(&cbe)));
    }
  }

  // Settings for Knitro Simplex Option
  // CHECK_STATUS(KN_set_int_param(kc_, KN_PARAM_ALG, KN_ALG_ACT_CG));
  // CHECK_STATUS(KN_set_int_param(kc_, KN_PARAM_ACT_LPALG,
  // KN_ACT_LPALG_PRIMAL)); CHECK_STATUS(KN_set_int_param(kc_,
  // KN_PARAM_ACT_LPALG, KN_ACT_LPALG_DUAL));:

  // Special case for empty model (no var)
  // Infeasible Constraint should have been checked
  // by MPSolver upstream
  if (!solver_->NumVariables()) {
    objective_value_ = solver_->Objective().offset();
    if (mip_) best_objective_bound_ = 0;
    result_status_ = MPSolver::OPTIMAL;
    sync_status_ = SOLUTION_SYNCHRONIZED;
    std::cout << "Solution Status (empty problem): " << result_status_
              << std::endl;
    return result_status_;
  }

  // Solve.
  timer.Restart();
  int status;
  status = -KN_solve(kc_);

  if (status == 0) {
    // the final solution is optimal to specified tolerances;
    result_status_ = MPSolver::OPTIMAL;

  } else if ((status < 110 && 100 <= status) ||
             (status < 410 && 400 <= status)) {
    // a feasible solution was found (but not verified optimal)
    // OR
    // a feasible point was found before reaching the limit
    result_status_ = MPSolver::FEASIBLE;

  } else if ((status < 210 && 200 <= status) ||
             (status < 420 && 410 <= status)) {
    // Knitro terminated at an infeasible point;
    // OR
    // no feasible point was found before reaching the limit
    result_status_ = MPSolver::INFEASIBLE;

  } else if (status < 302 && 300 <= status) {
    // the problem was determined to be unbounded;
    result_status_ = MPSolver::UNBOUNDED;

  } else {
    // Knitro terminated with an input error or some non-standard error or else.
    result_status_ = MPSolver::ABNORMAL;
  }

  if (result_status_ == MPSolver::OPTIMAL ||
      result_status_ == MPSolver::FEASIBLE) {
    // If optimal or feasible solution is found.
    SetSolution();
  } else {
    VLOG(1) << "No feasible solution found.";
  }

  int algorithm;
  KN_get_int_param(kc_, KN_PARAM_ALG, &algorithm);
  std::cout << "Algorithm setting param " << algorithm << std::endl;

  sync_status_ = SOLUTION_SYNCHRONIZED;
  std::cout << "Solution Status : " << result_status_ << std::endl;
  return result_status_;
}

void KnitroInterface::SetSolution() {
  int status;
  int const nb_vars = solver_->variables_.size();
  int const nb_cons = solver_->constraints_.size();
  if (nb_vars) {
    std::unique_ptr<double[]> values(new double[nb_vars]);
    std::unique_ptr<double[]> reduced_costs(new double[nb_vars]);
    CHECK_STATUS(
        KN_get_solution(kc_, &status, &objective_value_, values.get(), NULL));
    CHECK_STATUS(KN_get_var_dual_values_all(kc_, reduced_costs.get()));
    for (int j = 0; j < nb_vars; ++j) {
      MPVariable* var = solver_->variables_[j];
      var->set_solution_value(values[j]);
      if (!mip_) var->set_reduced_cost(-reduced_costs[j]);
    }
  }
  if (nb_cons) {
    std::unique_ptr<double[]> duals_cons(new double[nb_cons]);
    CHECK_STATUS(KN_get_con_dual_values_all(kc_, duals_cons.get()));
    if (!mip_) {
      for (int j = 0; j < nb_cons; ++j) {
        MPConstraint* ct = solver_->constraints_[j];
        ct->set_dual_value(-duals_cons[j]);
      }
    }
  }
  if (mip_) {
    double rel_gap;
    CHECK_STATUS(KN_get_mip_rel_gap(kc_, &rel_gap));
    best_objective_bound_ = objective_value_ + rel_gap;
  }
}

void KnitroInterface::AddSolutionHintToOptimizer() {
  const std::size_t len = solver_->solution_hint_.size();
  if (len == 0) {
    // hint is empty, nothing to do
    return;
  }
  std::unique_ptr<int[]> col_ind(new int[len]);
  std::unique_ptr<double[]> val(new double[len]);

  for (std::size_t i = 0; i < len; ++i) {
    col_ind[i] = solver_->solution_hint_[i].first->index();
    val[i] = solver_->solution_hint_[i].second;
  }
  CHECK_STATUS(
      KN_set_var_primal_init_values(kc_, len, col_ind.get(), val.get()));
}

// ------ Query statistics on the solution and the solve ------

int64_t KnitroInterface::iterations() const {
  if (!CheckSolutionIsSynchronized()) return kUnknownNumberOfIterations;
  int numIters;
  CHECK_STATUS(KN_get_number_iters(kc_, &numIters));
  return static_cast<int64_t>(numIters);
}

int64_t KnitroInterface::nodes() const {
  if (mip_) {
    if (!CheckSolutionIsSynchronized()) return kUnknownNumberOfNodes;
    int numNodes;
    CHECK_STATUS(KN_get_mip_number_nodes(kc_, &numNodes));
    return static_cast<int64_t>(numNodes);
  } else {
    LOG(DFATAL) << "Number of nodes only available for discrete problems";
    return kUnknownNumberOfNodes;
  }
}

// ----- Misc -----

std::string KnitroInterface::SolverVersion() const {
  int const length = 15;     // should contain the string termination character
  char release[length + 1];  // checked but there are trouble if not allocated
                             // with a additional char

  CHECK_STATUS(KN_get_release(length, release));

  return absl::StrFormat("Knitro library version %s", release);
}

MPSolverInterface* BuildKnitroInterface(bool mip, MPSolver* const solver) {
  return new KnitroInterface(solver, mip);
}

}  // namespace operations_research