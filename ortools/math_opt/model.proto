// Copyright 2010-2021 Google LLC
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// An encoding format for mathematical optimization problems.
syntax = "proto3";

package operations_research.math_opt;

import "ortools/math_opt/sparse_containers.proto";

option java_package = "com.google.ortools.mathopt";
option java_multiple_files = true;

// As used below, we define "#variables" = size(VariablesProto.ids).
message VariablesProto {
  // Must be nonnegative and strictly increasing. The max(int64) value can't be
  // used.
  repeated int64 ids = 1;
  // Should have length equal to #variables, values in [-inf, inf).
  repeated double lower_bounds = 2;
  // Should have length equal to #variables, values in (-inf, inf].
  repeated double upper_bounds = 3;
  // Should have length equal to #variables. Value is false for continuous
  // variables and true for integer variables.
  repeated bool integers = 4;
  // If not set, assumed to be all empty strings. Otherwise, should have length
  // equal to #variables.
  //
  // All nonempty names must be distinct. TODO(b/169575522): we may relax this.
  repeated string names = 5;
}

message ObjectiveProto {
  // false is minimize, true is maximize
  bool maximize = 1;
  double offset = 2;

  // ObjectiveProto terms that are linear in the decision variables.
  //
  // Requirements:
  //  * linear_coefficients.ids are elements of VariablesProto.ids.
  //  * VariablesProto not specified correspond to zero.
  //  * linear_coefficients.values must all be finite.
  //  * linear_coefficients.values can be zero, but this just wastes space.
  SparseDoubleVectorProto linear_coefficients = 3;

  // Objective terms that are quadratic in the decision variables.
  //
  // Requirements in addition to those on SparseDoubleMatrixProto messages:
  //  * Each element of quadratic_coefficients.row_ids and each element of
  //    quadratic_coefficients.column_ids must be an element of
  //    VariablesProto.ids.
  //  * The matrix must be upper triangular: for each i,
  //    quadratic_coefficients.row_ids[i] <=
  //    quadratic_coefficients.column_ids[i].
  //
  // Notes:
  //  * Terms not explicitly stored have zero coefficient.
  //  * Elements of quadratic_coefficients.coefficients can be zero, but this
  //    just wastes space.
  SparseDoubleMatrixProto quadratic_coefficients = 4;
}

// As used below, we define "#linear constraints" =
// size(LinearConstraintsProto.ids).
message LinearConstraintsProto {
  // Must be nonnegative and strictly increasing. The max(int64) value can't be
  // used.
  repeated int64 ids = 1;
  // Should have length equal to #linear constraints, values in [-inf, inf).
  repeated double lower_bounds = 2;
  // Should have length equal to #linear constraints, values in (-inf, inf].
  repeated double upper_bounds = 3;
  // If not set, assumed to be all empty strings. Otherwise, should have length
  // equal to #linear constraints.
  //
  // All nonempty names must be distinct. TODO(b/169575522): we may relax this.
  repeated string names = 4;
}

// Data for representing a single SOS1 or SOS2 constraint.
message SosConstraintProto {
  // The expressions over which to apply the SOS constraint:
  //   * SOS1: At most one element takes a nonzero value.
  //   * SOS2: At most two elements take nonzero values, and they must be
  //           adjacent in the repeated ordering.
  repeated LinearExpressionProto expressions = 1;

  // Either empty or of equal length to expressions. If empty, default weights
  // are 1, 2, ...
  repeated double weights = 2;

  // Parent messages may have uniqueness requirements on this field; e.g., see
  // ModelProto.sos1_constraints and SosConstraintUpdatesProto.new_constraints.
  string name = 3;
}

// An optimization problem. For full details, see go/mathopt-model.
//
// MathOpt supports:
//   - Continuous and integer decision variables with optional finite bounds.
//   - Linear and quadratic objectives, either minimized or maximized.
//   - A number of constraints types, including:
//     * Linear constraints
//     * Logical constraints
//       > SOS1 and SOS2 constraints
//
// By default, constraints are represented in "id-to-data" maps. However, we
// represent linear constraints in a more efficient "struct-of-arrays" format.
message ModelProto {
  string name = 1;
  VariablesProto variables = 2;
  ObjectiveProto objective = 3;
  LinearConstraintsProto linear_constraints = 4;

  // The variable coefficients for the linear constraints.
  //
  // Requirements:
  //  * linear_constraint_matrix.row_ids are elements of linear_constraints.ids.
  //  * linear_constraint_matrix.column_ids are elements of variables.ids.
  //  * Matrix entries not specified are zero.
  //  * linear_constraint_matrix.values must all be finite.
  SparseDoubleMatrixProto linear_constraint_matrix = 5;

  // Mapped constraints (i.e., stored in "constraint ID"-to-"constraint data"
  // map). For each subsequent submessage, we require that:
  //   * Each key is in [0, max(int64)).
  //   * Each key is unique in its respective map (but not necessarily across
  //     constraint types)
  //   * Each value contains a name field, and each nonempty name must be
  //   distinct across all map entries (but not necessarily across constraint
  //     types).

  // Reserved for quadratic constraints.
  reserved 6;

  // SOS1 constraints in the model, which constrain that at most one
  // `expression` can be nonzero. The optional `weights` entries are an
  // implementation detail used by the solver to (hopefully) converge more
  // quickly. In more detail, solvers may (or may not) use these weights to
  // select branching decisions that produce "balanced" children nodes.
  map<int64, SosConstraintProto> sos1_constraints = 7;

  // SOS2 constraints in the model, which constrain that at most two entries of
  // `expression` can be nonzero, and they must be adjacent in their ordering.
  // If no `weights` are provided, this ordering is their linear ordering in the
  // `expressions` list; if `weights` are presented, the ordering is taken with
  // respect to these values in increasing order.
  map<int64, SosConstraintProto> sos2_constraints = 8;
}
