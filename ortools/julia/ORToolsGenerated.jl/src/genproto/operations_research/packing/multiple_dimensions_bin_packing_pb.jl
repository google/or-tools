# Autogenerated using ProtoBuf.jl v1.1.1 on 2025-07-02T15:45:02.133
# original file: /usr/local/google/home/tcuvelier/.julia/artifacts/502992654d3e610bc079dfc8ac9e663bff6f3a24/include/ortools/packing/multiple_dimensions_bin_packing.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export MultipleDimensionsBinPackingShape, MultipleDimensionsBinPackingItem
export MultipleDimensionsBinPackingProblem


struct MultipleDimensionsBinPackingShape
    dimensions::Vector{Int64}
end
PB.default_values(::Type{MultipleDimensionsBinPackingShape}) = (;dimensions = Vector{Int64}())
PB.field_numbers(::Type{MultipleDimensionsBinPackingShape}) = (;dimensions = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MultipleDimensionsBinPackingShape})
    dimensions = PB.BufferedVector{Int64}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, dimensions)
        else
            PB.skip(d, wire_type)
        end
    end
    return MultipleDimensionsBinPackingShape(dimensions[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MultipleDimensionsBinPackingShape)
    initpos = position(e.io)
    !isempty(x.dimensions) && PB.encode(e, 1, x.dimensions)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MultipleDimensionsBinPackingShape)
    encoded_size = 0
    !isempty(x.dimensions) && (encoded_size += PB._encoded_size(x.dimensions, 1))
    return encoded_size
end

struct MultipleDimensionsBinPackingItem
    shapes::Vector{MultipleDimensionsBinPackingShape}
    value::Int64
end
PB.default_values(::Type{MultipleDimensionsBinPackingItem}) = (;shapes = Vector{MultipleDimensionsBinPackingShape}(), value = zero(Int64))
PB.field_numbers(::Type{MultipleDimensionsBinPackingItem}) = (;shapes = 1, value = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MultipleDimensionsBinPackingItem})
    shapes = PB.BufferedVector{MultipleDimensionsBinPackingShape}()
    value = zero(Int64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, shapes)
        elseif field_number == 2
            value = PB.decode(d, Int64)
        else
            PB.skip(d, wire_type)
        end
    end
    return MultipleDimensionsBinPackingItem(shapes[], value)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MultipleDimensionsBinPackingItem)
    initpos = position(e.io)
    !isempty(x.shapes) && PB.encode(e, 1, x.shapes)
    x.value != zero(Int64) && PB.encode(e, 2, x.value)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MultipleDimensionsBinPackingItem)
    encoded_size = 0
    !isempty(x.shapes) && (encoded_size += PB._encoded_size(x.shapes, 1))
    x.value != zero(Int64) && (encoded_size += PB._encoded_size(x.value, 2))
    return encoded_size
end

struct MultipleDimensionsBinPackingProblem
    box_shape::Union{Nothing,MultipleDimensionsBinPackingShape}
    items::Vector{MultipleDimensionsBinPackingItem}
end
PB.default_values(::Type{MultipleDimensionsBinPackingProblem}) = (;box_shape = nothing, items = Vector{MultipleDimensionsBinPackingItem}())
PB.field_numbers(::Type{MultipleDimensionsBinPackingProblem}) = (;box_shape = 1, items = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MultipleDimensionsBinPackingProblem})
    box_shape = Ref{Union{Nothing,MultipleDimensionsBinPackingShape}}(nothing)
    items = PB.BufferedVector{MultipleDimensionsBinPackingItem}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, box_shape)
        elseif field_number == 2
            PB.decode!(d, items)
        else
            PB.skip(d, wire_type)
        end
    end
    return MultipleDimensionsBinPackingProblem(box_shape[], items[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MultipleDimensionsBinPackingProblem)
    initpos = position(e.io)
    !isnothing(x.box_shape) && PB.encode(e, 1, x.box_shape)
    !isempty(x.items) && PB.encode(e, 2, x.items)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MultipleDimensionsBinPackingProblem)
    encoded_size = 0
    !isnothing(x.box_shape) && (encoded_size += PB._encoded_size(x.box_shape, 1))
    !isempty(x.items) && (encoded_size += PB._encoded_size(x.items, 2))
    return encoded_size
end
