# Autogenerated using ProtoBuf.jl v1.1.1 on 2025-07-02T15:45:02.134
# original file: /usr/local/google/home/tcuvelier/.julia/artifacts/502992654d3e610bc079dfc8ac9e663bff6f3a24/include/ortools/packing/vbp/vector_bin_packing.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export VectorBinPackingOneBinInSolution, VectorBinPackingSolveStatus, Item
export VectorBinPackingSolution, VectorBinPackingProblem


struct VectorBinPackingOneBinInSolution
    item_indices::Vector{Int32}
    item_copies::Vector{Int32}
end
PB.default_values(::Type{VectorBinPackingOneBinInSolution}) = (;item_indices = Vector{Int32}(), item_copies = Vector{Int32}())
PB.field_numbers(::Type{VectorBinPackingOneBinInSolution}) = (;item_indices = 1, item_copies = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:VectorBinPackingOneBinInSolution})
    item_indices = PB.BufferedVector{Int32}()
    item_copies = PB.BufferedVector{Int32}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, item_indices)
        elseif field_number == 2
            PB.decode!(d, wire_type, item_copies)
        else
            PB.skip(d, wire_type)
        end
    end
    return VectorBinPackingOneBinInSolution(item_indices[], item_copies[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::VectorBinPackingOneBinInSolution)
    initpos = position(e.io)
    !isempty(x.item_indices) && PB.encode(e, 1, x.item_indices)
    !isempty(x.item_copies) && PB.encode(e, 2, x.item_copies)
    return position(e.io) - initpos
end
function PB._encoded_size(x::VectorBinPackingOneBinInSolution)
    encoded_size = 0
    !isempty(x.item_indices) && (encoded_size += PB._encoded_size(x.item_indices, 1))
    !isempty(x.item_copies) && (encoded_size += PB._encoded_size(x.item_copies, 2))
    return encoded_size
end

@enumx VectorBinPackingSolveStatus VECTOR_BIN_PACKING_SOLVE_STATUS_UNSPECIFIED=0 OPTIMAL=1 FEASIBLE=2 INFEASIBLE=3

struct Item
    name::String
    resource_usage::Vector{Int64}
    num_copies::Int32
    num_optional_copies::Int32
    max_number_of_copies_per_bin::Int32
    penalty_per_missing_copy::Float64
end
PB.default_values(::Type{Item}) = (;name = "", resource_usage = Vector{Int64}(), num_copies = zero(Int32), num_optional_copies = zero(Int32), max_number_of_copies_per_bin = zero(Int32), penalty_per_missing_copy = zero(Float64))
PB.field_numbers(::Type{Item}) = (;name = 1, resource_usage = 2, num_copies = 3, num_optional_copies = 5, max_number_of_copies_per_bin = 4, penalty_per_missing_copy = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Item})
    name = ""
    resource_usage = PB.BufferedVector{Int64}()
    num_copies = zero(Int32)
    num_optional_copies = zero(Int32)
    max_number_of_copies_per_bin = zero(Int32)
    penalty_per_missing_copy = zero(Float64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, wire_type, resource_usage)
        elseif field_number == 3
            num_copies = PB.decode(d, Int32)
        elseif field_number == 5
            num_optional_copies = PB.decode(d, Int32)
        elseif field_number == 4
            max_number_of_copies_per_bin = PB.decode(d, Int32)
        elseif field_number == 6
            penalty_per_missing_copy = PB.decode(d, Float64)
        else
            PB.skip(d, wire_type)
        end
    end
    return Item(name, resource_usage[], num_copies, num_optional_copies, max_number_of_copies_per_bin, penalty_per_missing_copy)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Item)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.resource_usage) && PB.encode(e, 2, x.resource_usage)
    x.num_copies != zero(Int32) && PB.encode(e, 3, x.num_copies)
    x.num_optional_copies != zero(Int32) && PB.encode(e, 5, x.num_optional_copies)
    x.max_number_of_copies_per_bin != zero(Int32) && PB.encode(e, 4, x.max_number_of_copies_per_bin)
    x.penalty_per_missing_copy !== zero(Float64) && PB.encode(e, 6, x.penalty_per_missing_copy)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Item)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.resource_usage) && (encoded_size += PB._encoded_size(x.resource_usage, 2))
    x.num_copies != zero(Int32) && (encoded_size += PB._encoded_size(x.num_copies, 3))
    x.num_optional_copies != zero(Int32) && (encoded_size += PB._encoded_size(x.num_optional_copies, 5))
    x.max_number_of_copies_per_bin != zero(Int32) && (encoded_size += PB._encoded_size(x.max_number_of_copies_per_bin, 4))
    x.penalty_per_missing_copy !== zero(Float64) && (encoded_size += PB._encoded_size(x.penalty_per_missing_copy, 6))
    return encoded_size
end

struct VectorBinPackingSolution
    solver_info::String
    bins::Vector{VectorBinPackingOneBinInSolution}
    status::VectorBinPackingSolveStatus.T
    objective_value::Float64
    solve_time_in_seconds::Float64
    arc_flow_time_in_seconds::Float64
end
PB.default_values(::Type{VectorBinPackingSolution}) = (;solver_info = "", bins = Vector{VectorBinPackingOneBinInSolution}(), status = VectorBinPackingSolveStatus.VECTOR_BIN_PACKING_SOLVE_STATUS_UNSPECIFIED, objective_value = zero(Float64), solve_time_in_seconds = zero(Float64), arc_flow_time_in_seconds = zero(Float64))
PB.field_numbers(::Type{VectorBinPackingSolution}) = (;solver_info = 1, bins = 2, status = 3, objective_value = 4, solve_time_in_seconds = 5, arc_flow_time_in_seconds = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:VectorBinPackingSolution})
    solver_info = ""
    bins = PB.BufferedVector{VectorBinPackingOneBinInSolution}()
    status = VectorBinPackingSolveStatus.VECTOR_BIN_PACKING_SOLVE_STATUS_UNSPECIFIED
    objective_value = zero(Float64)
    solve_time_in_seconds = zero(Float64)
    arc_flow_time_in_seconds = zero(Float64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            solver_info = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, bins)
        elseif field_number == 3
            status = PB.decode(d, VectorBinPackingSolveStatus.T)
        elseif field_number == 4
            objective_value = PB.decode(d, Float64)
        elseif field_number == 5
            solve_time_in_seconds = PB.decode(d, Float64)
        elseif field_number == 6
            arc_flow_time_in_seconds = PB.decode(d, Float64)
        else
            PB.skip(d, wire_type)
        end
    end
    return VectorBinPackingSolution(solver_info, bins[], status, objective_value, solve_time_in_seconds, arc_flow_time_in_seconds)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::VectorBinPackingSolution)
    initpos = position(e.io)
    !isempty(x.solver_info) && PB.encode(e, 1, x.solver_info)
    !isempty(x.bins) && PB.encode(e, 2, x.bins)
    x.status != VectorBinPackingSolveStatus.VECTOR_BIN_PACKING_SOLVE_STATUS_UNSPECIFIED && PB.encode(e, 3, x.status)
    x.objective_value !== zero(Float64) && PB.encode(e, 4, x.objective_value)
    x.solve_time_in_seconds !== zero(Float64) && PB.encode(e, 5, x.solve_time_in_seconds)
    x.arc_flow_time_in_seconds !== zero(Float64) && PB.encode(e, 6, x.arc_flow_time_in_seconds)
    return position(e.io) - initpos
end
function PB._encoded_size(x::VectorBinPackingSolution)
    encoded_size = 0
    !isempty(x.solver_info) && (encoded_size += PB._encoded_size(x.solver_info, 1))
    !isempty(x.bins) && (encoded_size += PB._encoded_size(x.bins, 2))
    x.status != VectorBinPackingSolveStatus.VECTOR_BIN_PACKING_SOLVE_STATUS_UNSPECIFIED && (encoded_size += PB._encoded_size(x.status, 3))
    x.objective_value !== zero(Float64) && (encoded_size += PB._encoded_size(x.objective_value, 4))
    x.solve_time_in_seconds !== zero(Float64) && (encoded_size += PB._encoded_size(x.solve_time_in_seconds, 5))
    x.arc_flow_time_in_seconds !== zero(Float64) && (encoded_size += PB._encoded_size(x.arc_flow_time_in_seconds, 6))
    return encoded_size
end

struct VectorBinPackingProblem
    name::String
    resource_capacity::Vector{Int64}
    resource_name::Vector{String}
    item::Vector{Item}
    max_bins::Int32
    cost_per_bin::Float64
end
PB.default_values(::Type{VectorBinPackingProblem}) = (;name = "", resource_capacity = Vector{Int64}(), resource_name = Vector{String}(), item = Vector{Item}(), max_bins = zero(Int32), cost_per_bin = zero(Float64))
PB.field_numbers(::Type{VectorBinPackingProblem}) = (;name = 1, resource_capacity = 2, resource_name = 3, item = 4, max_bins = 5, cost_per_bin = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:VectorBinPackingProblem})
    name = ""
    resource_capacity = PB.BufferedVector{Int64}()
    resource_name = PB.BufferedVector{String}()
    item = PB.BufferedVector{Item}()
    max_bins = zero(Int32)
    cost_per_bin = zero(Float64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, wire_type, resource_capacity)
        elseif field_number == 3
            PB.decode!(d, resource_name)
        elseif field_number == 4
            PB.decode!(d, item)
        elseif field_number == 5
            max_bins = PB.decode(d, Int32)
        elseif field_number == 6
            cost_per_bin = PB.decode(d, Float64)
        else
            PB.skip(d, wire_type)
        end
    end
    return VectorBinPackingProblem(name, resource_capacity[], resource_name[], item[], max_bins, cost_per_bin)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::VectorBinPackingProblem)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.resource_capacity) && PB.encode(e, 2, x.resource_capacity)
    !isempty(x.resource_name) && PB.encode(e, 3, x.resource_name)
    !isempty(x.item) && PB.encode(e, 4, x.item)
    x.max_bins != zero(Int32) && PB.encode(e, 5, x.max_bins)
    x.cost_per_bin !== zero(Float64) && PB.encode(e, 6, x.cost_per_bin)
    return position(e.io) - initpos
end
function PB._encoded_size(x::VectorBinPackingProblem)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.resource_capacity) && (encoded_size += PB._encoded_size(x.resource_capacity, 2))
    !isempty(x.resource_name) && (encoded_size += PB._encoded_size(x.resource_name, 3))
    !isempty(x.item) && (encoded_size += PB._encoded_size(x.item, 4))
    x.max_bins != zero(Int32) && (encoded_size += PB._encoded_size(x.max_bins, 5))
    x.cost_per_bin !== zero(Float64) && (encoded_size += PB._encoded_size(x.cost_per_bin, 6))
    return encoded_size
end
