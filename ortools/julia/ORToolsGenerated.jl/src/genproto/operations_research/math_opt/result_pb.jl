# Autogenerated using ProtoBuf.jl v1.1.1 on 2025-07-02T15:45:02.129
# original file: /usr/local/google/home/tcuvelier/.julia/artifacts/502992654d3e610bc079dfc8ac9e663bff6f3a24/include/ortools/math_opt/result.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export var"SolveResultProto.PdlpOutput", ObjectiveBoundsProto, LimitProto
export FeasibilityStatusProto, TerminationReasonProto, ProblemStatusProto, SolveStatsProto
export TerminationProto, SolveResultProto


struct var"SolveResultProto.PdlpOutput"
    convergence_information::Union{Nothing,operations_research.pdlp.ConvergenceInformation}
end
PB.default_values(::Type{var"SolveResultProto.PdlpOutput"}) = (;convergence_information = nothing)
PB.field_numbers(::Type{var"SolveResultProto.PdlpOutput"}) = (;convergence_information = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"SolveResultProto.PdlpOutput"})
    convergence_information = Ref{Union{Nothing,operations_research.pdlp.ConvergenceInformation}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, convergence_information)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"SolveResultProto.PdlpOutput"(convergence_information[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"SolveResultProto.PdlpOutput")
    initpos = position(e.io)
    !isnothing(x.convergence_information) && PB.encode(e, 1, x.convergence_information)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"SolveResultProto.PdlpOutput")
    encoded_size = 0
    !isnothing(x.convergence_information) && (encoded_size += PB._encoded_size(x.convergence_information, 1))
    return encoded_size
end

struct ObjectiveBoundsProto
    primal_bound::Float64
    dual_bound::Float64
end
PB.default_values(::Type{ObjectiveBoundsProto}) = (;primal_bound = zero(Float64), dual_bound = zero(Float64))
PB.field_numbers(::Type{ObjectiveBoundsProto}) = (;primal_bound = 2, dual_bound = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ObjectiveBoundsProto})
    primal_bound = zero(Float64)
    dual_bound = zero(Float64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 2
            primal_bound = PB.decode(d, Float64)
        elseif field_number == 3
            dual_bound = PB.decode(d, Float64)
        else
            PB.skip(d, wire_type)
        end
    end
    return ObjectiveBoundsProto(primal_bound, dual_bound)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ObjectiveBoundsProto)
    initpos = position(e.io)
    x.primal_bound !== zero(Float64) && PB.encode(e, 2, x.primal_bound)
    x.dual_bound !== zero(Float64) && PB.encode(e, 3, x.dual_bound)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ObjectiveBoundsProto)
    encoded_size = 0
    x.primal_bound !== zero(Float64) && (encoded_size += PB._encoded_size(x.primal_bound, 2))
    x.dual_bound !== zero(Float64) && (encoded_size += PB._encoded_size(x.dual_bound, 3))
    return encoded_size
end

@enumx LimitProto LIMIT_UNSPECIFIED=0 LIMIT_UNDETERMINED=1 LIMIT_ITERATION=2 LIMIT_TIME=3 LIMIT_NODE=4 LIMIT_SOLUTION=5 LIMIT_MEMORY=6 LIMIT_CUTOFF=12 LIMIT_OBJECTIVE=7 LIMIT_NORM=8 LIMIT_INTERRUPTED=9 LIMIT_SLOW_PROGRESS=10 LIMIT_OTHER=11

@enumx FeasibilityStatusProto FEASIBILITY_STATUS_UNSPECIFIED=0 FEASIBILITY_STATUS_UNDETERMINED=1 FEASIBILITY_STATUS_FEASIBLE=2 FEASIBILITY_STATUS_INFEASIBLE=3

@enumx TerminationReasonProto TERMINATION_REASON_UNSPECIFIED=0 TERMINATION_REASON_OPTIMAL=1 TERMINATION_REASON_INFEASIBLE=2 TERMINATION_REASON_UNBOUNDED=3 TERMINATION_REASON_INFEASIBLE_OR_UNBOUNDED=4 TERMINATION_REASON_IMPRECISE=5 TERMINATION_REASON_FEASIBLE=9 TERMINATION_REASON_NO_SOLUTION_FOUND=6 TERMINATION_REASON_NUMERICAL_ERROR=7 TERMINATION_REASON_OTHER_ERROR=8

struct ProblemStatusProto
    primal_status::FeasibilityStatusProto.T
    dual_status::FeasibilityStatusProto.T
    primal_or_dual_infeasible::Bool
end
PB.default_values(::Type{ProblemStatusProto}) = (;primal_status = FeasibilityStatusProto.FEASIBILITY_STATUS_UNSPECIFIED, dual_status = FeasibilityStatusProto.FEASIBILITY_STATUS_UNSPECIFIED, primal_or_dual_infeasible = false)
PB.field_numbers(::Type{ProblemStatusProto}) = (;primal_status = 1, dual_status = 2, primal_or_dual_infeasible = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ProblemStatusProto})
    primal_status = FeasibilityStatusProto.FEASIBILITY_STATUS_UNSPECIFIED
    dual_status = FeasibilityStatusProto.FEASIBILITY_STATUS_UNSPECIFIED
    primal_or_dual_infeasible = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            primal_status = PB.decode(d, FeasibilityStatusProto.T)
        elseif field_number == 2
            dual_status = PB.decode(d, FeasibilityStatusProto.T)
        elseif field_number == 3
            primal_or_dual_infeasible = PB.decode(d, Bool)
        else
            PB.skip(d, wire_type)
        end
    end
    return ProblemStatusProto(primal_status, dual_status, primal_or_dual_infeasible)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ProblemStatusProto)
    initpos = position(e.io)
    x.primal_status != FeasibilityStatusProto.FEASIBILITY_STATUS_UNSPECIFIED && PB.encode(e, 1, x.primal_status)
    x.dual_status != FeasibilityStatusProto.FEASIBILITY_STATUS_UNSPECIFIED && PB.encode(e, 2, x.dual_status)
    x.primal_or_dual_infeasible != false && PB.encode(e, 3, x.primal_or_dual_infeasible)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ProblemStatusProto)
    encoded_size = 0
    x.primal_status != FeasibilityStatusProto.FEASIBILITY_STATUS_UNSPECIFIED && (encoded_size += PB._encoded_size(x.primal_status, 1))
    x.dual_status != FeasibilityStatusProto.FEASIBILITY_STATUS_UNSPECIFIED && (encoded_size += PB._encoded_size(x.dual_status, 2))
    x.primal_or_dual_infeasible != false && (encoded_size += PB._encoded_size(x.primal_or_dual_infeasible, 3))
    return encoded_size
end

struct SolveStatsProto
    solve_time::Union{Nothing,google.protobuf.Duration}
    best_primal_bound::Float64
    best_dual_bound::Float64
    problem_status::Union{Nothing,ProblemStatusProto}
    simplex_iterations::Int64
    barrier_iterations::Int64
    first_order_iterations::Int64
    node_count::Int64
end
PB.default_values(::Type{SolveStatsProto}) = (;solve_time = nothing, best_primal_bound = zero(Float64), best_dual_bound = zero(Float64), problem_status = nothing, simplex_iterations = zero(Int64), barrier_iterations = zero(Int64), first_order_iterations = zero(Int64), node_count = zero(Int64))
PB.field_numbers(::Type{SolveStatsProto}) = (;solve_time = 1, best_primal_bound = 2, best_dual_bound = 3, problem_status = 4, simplex_iterations = 5, barrier_iterations = 6, first_order_iterations = 8, node_count = 7)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SolveStatsProto})
    solve_time = Ref{Union{Nothing,google.protobuf.Duration}}(nothing)
    best_primal_bound = zero(Float64)
    best_dual_bound = zero(Float64)
    problem_status = Ref{Union{Nothing,ProblemStatusProto}}(nothing)
    simplex_iterations = zero(Int64)
    barrier_iterations = zero(Int64)
    first_order_iterations = zero(Int64)
    node_count = zero(Int64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, solve_time)
        elseif field_number == 2
            best_primal_bound = PB.decode(d, Float64)
        elseif field_number == 3
            best_dual_bound = PB.decode(d, Float64)
        elseif field_number == 4
            PB.decode!(d, problem_status)
        elseif field_number == 5
            simplex_iterations = PB.decode(d, Int64)
        elseif field_number == 6
            barrier_iterations = PB.decode(d, Int64)
        elseif field_number == 8
            first_order_iterations = PB.decode(d, Int64)
        elseif field_number == 7
            node_count = PB.decode(d, Int64)
        else
            PB.skip(d, wire_type)
        end
    end
    return SolveStatsProto(solve_time[], best_primal_bound, best_dual_bound, problem_status[], simplex_iterations, barrier_iterations, first_order_iterations, node_count)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SolveStatsProto)
    initpos = position(e.io)
    !isnothing(x.solve_time) && PB.encode(e, 1, x.solve_time)
    x.best_primal_bound !== zero(Float64) && PB.encode(e, 2, x.best_primal_bound)
    x.best_dual_bound !== zero(Float64) && PB.encode(e, 3, x.best_dual_bound)
    !isnothing(x.problem_status) && PB.encode(e, 4, x.problem_status)
    x.simplex_iterations != zero(Int64) && PB.encode(e, 5, x.simplex_iterations)
    x.barrier_iterations != zero(Int64) && PB.encode(e, 6, x.barrier_iterations)
    x.first_order_iterations != zero(Int64) && PB.encode(e, 8, x.first_order_iterations)
    x.node_count != zero(Int64) && PB.encode(e, 7, x.node_count)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SolveStatsProto)
    encoded_size = 0
    !isnothing(x.solve_time) && (encoded_size += PB._encoded_size(x.solve_time, 1))
    x.best_primal_bound !== zero(Float64) && (encoded_size += PB._encoded_size(x.best_primal_bound, 2))
    x.best_dual_bound !== zero(Float64) && (encoded_size += PB._encoded_size(x.best_dual_bound, 3))
    !isnothing(x.problem_status) && (encoded_size += PB._encoded_size(x.problem_status, 4))
    x.simplex_iterations != zero(Int64) && (encoded_size += PB._encoded_size(x.simplex_iterations, 5))
    x.barrier_iterations != zero(Int64) && (encoded_size += PB._encoded_size(x.barrier_iterations, 6))
    x.first_order_iterations != zero(Int64) && (encoded_size += PB._encoded_size(x.first_order_iterations, 8))
    x.node_count != zero(Int64) && (encoded_size += PB._encoded_size(x.node_count, 7))
    return encoded_size
end

struct TerminationProto
    reason::TerminationReasonProto.T
    limit::LimitProto.T
    detail::String
    problem_status::Union{Nothing,ProblemStatusProto}
    objective_bounds::Union{Nothing,ObjectiveBoundsProto}
end
PB.default_values(::Type{TerminationProto}) = (;reason = TerminationReasonProto.TERMINATION_REASON_UNSPECIFIED, limit = LimitProto.LIMIT_UNSPECIFIED, detail = "", problem_status = nothing, objective_bounds = nothing)
PB.field_numbers(::Type{TerminationProto}) = (;reason = 1, limit = 2, detail = 3, problem_status = 4, objective_bounds = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:TerminationProto})
    reason = TerminationReasonProto.TERMINATION_REASON_UNSPECIFIED
    limit = LimitProto.LIMIT_UNSPECIFIED
    detail = ""
    problem_status = Ref{Union{Nothing,ProblemStatusProto}}(nothing)
    objective_bounds = Ref{Union{Nothing,ObjectiveBoundsProto}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            reason = PB.decode(d, TerminationReasonProto.T)
        elseif field_number == 2
            limit = PB.decode(d, LimitProto.T)
        elseif field_number == 3
            detail = PB.decode(d, String)
        elseif field_number == 4
            PB.decode!(d, problem_status)
        elseif field_number == 5
            PB.decode!(d, objective_bounds)
        else
            PB.skip(d, wire_type)
        end
    end
    return TerminationProto(reason, limit, detail, problem_status[], objective_bounds[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::TerminationProto)
    initpos = position(e.io)
    x.reason != TerminationReasonProto.TERMINATION_REASON_UNSPECIFIED && PB.encode(e, 1, x.reason)
    x.limit != LimitProto.LIMIT_UNSPECIFIED && PB.encode(e, 2, x.limit)
    !isempty(x.detail) && PB.encode(e, 3, x.detail)
    !isnothing(x.problem_status) && PB.encode(e, 4, x.problem_status)
    !isnothing(x.objective_bounds) && PB.encode(e, 5, x.objective_bounds)
    return position(e.io) - initpos
end
function PB._encoded_size(x::TerminationProto)
    encoded_size = 0
    x.reason != TerminationReasonProto.TERMINATION_REASON_UNSPECIFIED && (encoded_size += PB._encoded_size(x.reason, 1))
    x.limit != LimitProto.LIMIT_UNSPECIFIED && (encoded_size += PB._encoded_size(x.limit, 2))
    !isempty(x.detail) && (encoded_size += PB._encoded_size(x.detail, 3))
    !isnothing(x.problem_status) && (encoded_size += PB._encoded_size(x.problem_status, 4))
    !isnothing(x.objective_bounds) && (encoded_size += PB._encoded_size(x.objective_bounds, 5))
    return encoded_size
end

struct SolveResultProto
    termination::Union{Nothing,TerminationProto}
    solutions::Vector{SolutionProto}
    primal_rays::Vector{PrimalRayProto}
    dual_rays::Vector{DualRayProto}
    solve_stats::Union{Nothing,SolveStatsProto}
    solver_specific_output::Union{Nothing,OneOf{<:Union{operations_research.GScipOutput,OsqpOutput,var"SolveResultProto.PdlpOutput"}}}
end
PB.reserved_fields(::Type{SolveResultProto}) = (names = String[], numbers = Union{Int,UnitRange{Int}}[1])
PB.oneof_field_types(::Type{SolveResultProto}) = (;
    solver_specific_output = (;gscip_output=operations_research.GScipOutput, osqp_output=OsqpOutput, pdlp_output=var"SolveResultProto.PdlpOutput"),
)
PB.default_values(::Type{SolveResultProto}) = (;termination = nothing, solutions = Vector{SolutionProto}(), primal_rays = Vector{PrimalRayProto}(), dual_rays = Vector{DualRayProto}(), solve_stats = nothing, gscip_output = nothing, osqp_output = nothing, pdlp_output = nothing)
PB.field_numbers(::Type{SolveResultProto}) = (;termination = 2, solutions = 3, primal_rays = 4, dual_rays = 5, solve_stats = 6, gscip_output = 7, osqp_output = 8, pdlp_output = 9)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SolveResultProto})
    termination = Ref{Union{Nothing,TerminationProto}}(nothing)
    solutions = PB.BufferedVector{SolutionProto}()
    primal_rays = PB.BufferedVector{PrimalRayProto}()
    dual_rays = PB.BufferedVector{DualRayProto}()
    solve_stats = Ref{Union{Nothing,SolveStatsProto}}(nothing)
    solver_specific_output = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 2
            PB.decode!(d, termination)
        elseif field_number == 3
            PB.decode!(d, solutions)
        elseif field_number == 4
            PB.decode!(d, primal_rays)
        elseif field_number == 5
            PB.decode!(d, dual_rays)
        elseif field_number == 6
            PB.decode!(d, solve_stats)
        elseif field_number == 7
            solver_specific_output = OneOf(:gscip_output, PB.decode(d, Ref{operations_research.GScipOutput}))
        elseif field_number == 8
            solver_specific_output = OneOf(:osqp_output, PB.decode(d, Ref{OsqpOutput}))
        elseif field_number == 9
            solver_specific_output = OneOf(:pdlp_output, PB.decode(d, Ref{var"SolveResultProto.PdlpOutput"}))
        else
            PB.skip(d, wire_type)
        end
    end
    return SolveResultProto(termination[], solutions[], primal_rays[], dual_rays[], solve_stats[], solver_specific_output)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SolveResultProto)
    initpos = position(e.io)
    !isnothing(x.termination) && PB.encode(e, 2, x.termination)
    !isempty(x.solutions) && PB.encode(e, 3, x.solutions)
    !isempty(x.primal_rays) && PB.encode(e, 4, x.primal_rays)
    !isempty(x.dual_rays) && PB.encode(e, 5, x.dual_rays)
    !isnothing(x.solve_stats) && PB.encode(e, 6, x.solve_stats)
    if isnothing(x.solver_specific_output);
    elseif x.solver_specific_output.name === :gscip_output
        PB.encode(e, 7, x.solver_specific_output[]::operations_research.GScipOutput)
    elseif x.solver_specific_output.name === :osqp_output
        PB.encode(e, 8, x.solver_specific_output[]::OsqpOutput)
    elseif x.solver_specific_output.name === :pdlp_output
        PB.encode(e, 9, x.solver_specific_output[]::var"SolveResultProto.PdlpOutput")
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::SolveResultProto)
    encoded_size = 0
    !isnothing(x.termination) && (encoded_size += PB._encoded_size(x.termination, 2))
    !isempty(x.solutions) && (encoded_size += PB._encoded_size(x.solutions, 3))
    !isempty(x.primal_rays) && (encoded_size += PB._encoded_size(x.primal_rays, 4))
    !isempty(x.dual_rays) && (encoded_size += PB._encoded_size(x.dual_rays, 5))
    !isnothing(x.solve_stats) && (encoded_size += PB._encoded_size(x.solve_stats, 6))
    if isnothing(x.solver_specific_output);
    elseif x.solver_specific_output.name === :gscip_output
        encoded_size += PB._encoded_size(x.solver_specific_output[]::operations_research.GScipOutput, 7)
    elseif x.solver_specific_output.name === :osqp_output
        encoded_size += PB._encoded_size(x.solver_specific_output[]::OsqpOutput, 8)
    elseif x.solver_specific_output.name === :pdlp_output
        encoded_size += PB._encoded_size(x.solver_specific_output[]::var"SolveResultProto.PdlpOutput", 9)
    end
    return encoded_size
end
