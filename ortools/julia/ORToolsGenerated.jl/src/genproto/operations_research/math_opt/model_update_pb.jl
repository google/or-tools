# Autogenerated using ProtoBuf.jl v1.1.1 on 2025-07-02T15:45:02.130
# original file: /usr/local/google/home/tcuvelier/.julia/artifacts/502992654d3e610bc079dfc8ac9e663bff6f3a24/include/ortools/math_opt/model_update.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export LinearConstraintUpdatesProto, ObjectiveUpdatesProto, IndicatorConstraintUpdatesProto
export VariableUpdatesProto, SosConstraintUpdatesProto
export SecondOrderConeConstraintUpdatesProto, QuadraticConstraintUpdatesProto
export AuxiliaryObjectivesUpdatesProto, ModelUpdateProto


struct LinearConstraintUpdatesProto
    lower_bounds::Union{Nothing,SparseDoubleVectorProto}
    upper_bounds::Union{Nothing,SparseDoubleVectorProto}
end
PB.default_values(::Type{LinearConstraintUpdatesProto}) = (;lower_bounds = nothing, upper_bounds = nothing)
PB.field_numbers(::Type{LinearConstraintUpdatesProto}) = (;lower_bounds = 1, upper_bounds = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:LinearConstraintUpdatesProto})
    lower_bounds = Ref{Union{Nothing,SparseDoubleVectorProto}}(nothing)
    upper_bounds = Ref{Union{Nothing,SparseDoubleVectorProto}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, lower_bounds)
        elseif field_number == 2
            PB.decode!(d, upper_bounds)
        else
            PB.skip(d, wire_type)
        end
    end
    return LinearConstraintUpdatesProto(lower_bounds[], upper_bounds[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::LinearConstraintUpdatesProto)
    initpos = position(e.io)
    !isnothing(x.lower_bounds) && PB.encode(e, 1, x.lower_bounds)
    !isnothing(x.upper_bounds) && PB.encode(e, 2, x.upper_bounds)
    return position(e.io) - initpos
end
function PB._encoded_size(x::LinearConstraintUpdatesProto)
    encoded_size = 0
    !isnothing(x.lower_bounds) && (encoded_size += PB._encoded_size(x.lower_bounds, 1))
    !isnothing(x.upper_bounds) && (encoded_size += PB._encoded_size(x.upper_bounds, 2))
    return encoded_size
end

struct ObjectiveUpdatesProto
    direction_update::Bool
    offset_update::Float64
    linear_coefficients::Union{Nothing,SparseDoubleVectorProto}
    quadratic_coefficients::Union{Nothing,SparseDoubleMatrixProto}
    priority_update::Int64
end
PB.default_values(::Type{ObjectiveUpdatesProto}) = (;direction_update = false, offset_update = zero(Float64), linear_coefficients = nothing, quadratic_coefficients = nothing, priority_update = zero(Int64))
PB.field_numbers(::Type{ObjectiveUpdatesProto}) = (;direction_update = 1, offset_update = 2, linear_coefficients = 3, quadratic_coefficients = 4, priority_update = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ObjectiveUpdatesProto})
    direction_update = false
    offset_update = zero(Float64)
    linear_coefficients = Ref{Union{Nothing,SparseDoubleVectorProto}}(nothing)
    quadratic_coefficients = Ref{Union{Nothing,SparseDoubleMatrixProto}}(nothing)
    priority_update = zero(Int64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            direction_update = PB.decode(d, Bool)
        elseif field_number == 2
            offset_update = PB.decode(d, Float64)
        elseif field_number == 3
            PB.decode!(d, linear_coefficients)
        elseif field_number == 4
            PB.decode!(d, quadratic_coefficients)
        elseif field_number == 5
            priority_update = PB.decode(d, Int64)
        else
            PB.skip(d, wire_type)
        end
    end
    return ObjectiveUpdatesProto(direction_update, offset_update, linear_coefficients[], quadratic_coefficients[], priority_update)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ObjectiveUpdatesProto)
    initpos = position(e.io)
    x.direction_update != false && PB.encode(e, 1, x.direction_update)
    x.offset_update !== zero(Float64) && PB.encode(e, 2, x.offset_update)
    !isnothing(x.linear_coefficients) && PB.encode(e, 3, x.linear_coefficients)
    !isnothing(x.quadratic_coefficients) && PB.encode(e, 4, x.quadratic_coefficients)
    x.priority_update != zero(Int64) && PB.encode(e, 5, x.priority_update)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ObjectiveUpdatesProto)
    encoded_size = 0
    x.direction_update != false && (encoded_size += PB._encoded_size(x.direction_update, 1))
    x.offset_update !== zero(Float64) && (encoded_size += PB._encoded_size(x.offset_update, 2))
    !isnothing(x.linear_coefficients) && (encoded_size += PB._encoded_size(x.linear_coefficients, 3))
    !isnothing(x.quadratic_coefficients) && (encoded_size += PB._encoded_size(x.quadratic_coefficients, 4))
    x.priority_update != zero(Int64) && (encoded_size += PB._encoded_size(x.priority_update, 5))
    return encoded_size
end

struct IndicatorConstraintUpdatesProto
    deleted_constraint_ids::Vector{Int64}
    new_constraints::Dict{Int64,IndicatorConstraintProto}
end
PB.default_values(::Type{IndicatorConstraintUpdatesProto}) = (;deleted_constraint_ids = Vector{Int64}(), new_constraints = Dict{Int64,IndicatorConstraintProto}())
PB.field_numbers(::Type{IndicatorConstraintUpdatesProto}) = (;deleted_constraint_ids = 1, new_constraints = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:IndicatorConstraintUpdatesProto})
    deleted_constraint_ids = PB.BufferedVector{Int64}()
    new_constraints = Dict{Int64,IndicatorConstraintProto}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, deleted_constraint_ids)
        elseif field_number == 2
            PB.decode!(d, new_constraints)
        else
            PB.skip(d, wire_type)
        end
    end
    return IndicatorConstraintUpdatesProto(deleted_constraint_ids[], new_constraints)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::IndicatorConstraintUpdatesProto)
    initpos = position(e.io)
    !isempty(x.deleted_constraint_ids) && PB.encode(e, 1, x.deleted_constraint_ids)
    !isempty(x.new_constraints) && PB.encode(e, 2, x.new_constraints)
    return position(e.io) - initpos
end
function PB._encoded_size(x::IndicatorConstraintUpdatesProto)
    encoded_size = 0
    !isempty(x.deleted_constraint_ids) && (encoded_size += PB._encoded_size(x.deleted_constraint_ids, 1))
    !isempty(x.new_constraints) && (encoded_size += PB._encoded_size(x.new_constraints, 2))
    return encoded_size
end

struct VariableUpdatesProto
    lower_bounds::Union{Nothing,SparseDoubleVectorProto}
    upper_bounds::Union{Nothing,SparseDoubleVectorProto}
    integers::Union{Nothing,SparseBoolVectorProto}
end
PB.default_values(::Type{VariableUpdatesProto}) = (;lower_bounds = nothing, upper_bounds = nothing, integers = nothing)
PB.field_numbers(::Type{VariableUpdatesProto}) = (;lower_bounds = 1, upper_bounds = 2, integers = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:VariableUpdatesProto})
    lower_bounds = Ref{Union{Nothing,SparseDoubleVectorProto}}(nothing)
    upper_bounds = Ref{Union{Nothing,SparseDoubleVectorProto}}(nothing)
    integers = Ref{Union{Nothing,SparseBoolVectorProto}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, lower_bounds)
        elseif field_number == 2
            PB.decode!(d, upper_bounds)
        elseif field_number == 3
            PB.decode!(d, integers)
        else
            PB.skip(d, wire_type)
        end
    end
    return VariableUpdatesProto(lower_bounds[], upper_bounds[], integers[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::VariableUpdatesProto)
    initpos = position(e.io)
    !isnothing(x.lower_bounds) && PB.encode(e, 1, x.lower_bounds)
    !isnothing(x.upper_bounds) && PB.encode(e, 2, x.upper_bounds)
    !isnothing(x.integers) && PB.encode(e, 3, x.integers)
    return position(e.io) - initpos
end
function PB._encoded_size(x::VariableUpdatesProto)
    encoded_size = 0
    !isnothing(x.lower_bounds) && (encoded_size += PB._encoded_size(x.lower_bounds, 1))
    !isnothing(x.upper_bounds) && (encoded_size += PB._encoded_size(x.upper_bounds, 2))
    !isnothing(x.integers) && (encoded_size += PB._encoded_size(x.integers, 3))
    return encoded_size
end

struct SosConstraintUpdatesProto
    deleted_constraint_ids::Vector{Int64}
    new_constraints::Dict{Int64,SosConstraintProto}
end
PB.default_values(::Type{SosConstraintUpdatesProto}) = (;deleted_constraint_ids = Vector{Int64}(), new_constraints = Dict{Int64,SosConstraintProto}())
PB.field_numbers(::Type{SosConstraintUpdatesProto}) = (;deleted_constraint_ids = 1, new_constraints = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SosConstraintUpdatesProto})
    deleted_constraint_ids = PB.BufferedVector{Int64}()
    new_constraints = Dict{Int64,SosConstraintProto}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, deleted_constraint_ids)
        elseif field_number == 2
            PB.decode!(d, new_constraints)
        else
            PB.skip(d, wire_type)
        end
    end
    return SosConstraintUpdatesProto(deleted_constraint_ids[], new_constraints)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SosConstraintUpdatesProto)
    initpos = position(e.io)
    !isempty(x.deleted_constraint_ids) && PB.encode(e, 1, x.deleted_constraint_ids)
    !isempty(x.new_constraints) && PB.encode(e, 2, x.new_constraints)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SosConstraintUpdatesProto)
    encoded_size = 0
    !isempty(x.deleted_constraint_ids) && (encoded_size += PB._encoded_size(x.deleted_constraint_ids, 1))
    !isempty(x.new_constraints) && (encoded_size += PB._encoded_size(x.new_constraints, 2))
    return encoded_size
end

struct SecondOrderConeConstraintUpdatesProto
    deleted_constraint_ids::Vector{Int64}
    new_constraints::Dict{Int64,SecondOrderConeConstraintProto}
end
PB.default_values(::Type{SecondOrderConeConstraintUpdatesProto}) = (;deleted_constraint_ids = Vector{Int64}(), new_constraints = Dict{Int64,SecondOrderConeConstraintProto}())
PB.field_numbers(::Type{SecondOrderConeConstraintUpdatesProto}) = (;deleted_constraint_ids = 1, new_constraints = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SecondOrderConeConstraintUpdatesProto})
    deleted_constraint_ids = PB.BufferedVector{Int64}()
    new_constraints = Dict{Int64,SecondOrderConeConstraintProto}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, deleted_constraint_ids)
        elseif field_number == 2
            PB.decode!(d, new_constraints)
        else
            PB.skip(d, wire_type)
        end
    end
    return SecondOrderConeConstraintUpdatesProto(deleted_constraint_ids[], new_constraints)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SecondOrderConeConstraintUpdatesProto)
    initpos = position(e.io)
    !isempty(x.deleted_constraint_ids) && PB.encode(e, 1, x.deleted_constraint_ids)
    !isempty(x.new_constraints) && PB.encode(e, 2, x.new_constraints)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SecondOrderConeConstraintUpdatesProto)
    encoded_size = 0
    !isempty(x.deleted_constraint_ids) && (encoded_size += PB._encoded_size(x.deleted_constraint_ids, 1))
    !isempty(x.new_constraints) && (encoded_size += PB._encoded_size(x.new_constraints, 2))
    return encoded_size
end

struct QuadraticConstraintUpdatesProto
    deleted_constraint_ids::Vector{Int64}
    new_constraints::Dict{Int64,QuadraticConstraintProto}
end
PB.default_values(::Type{QuadraticConstraintUpdatesProto}) = (;deleted_constraint_ids = Vector{Int64}(), new_constraints = Dict{Int64,QuadraticConstraintProto}())
PB.field_numbers(::Type{QuadraticConstraintUpdatesProto}) = (;deleted_constraint_ids = 1, new_constraints = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:QuadraticConstraintUpdatesProto})
    deleted_constraint_ids = PB.BufferedVector{Int64}()
    new_constraints = Dict{Int64,QuadraticConstraintProto}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, deleted_constraint_ids)
        elseif field_number == 2
            PB.decode!(d, new_constraints)
        else
            PB.skip(d, wire_type)
        end
    end
    return QuadraticConstraintUpdatesProto(deleted_constraint_ids[], new_constraints)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::QuadraticConstraintUpdatesProto)
    initpos = position(e.io)
    !isempty(x.deleted_constraint_ids) && PB.encode(e, 1, x.deleted_constraint_ids)
    !isempty(x.new_constraints) && PB.encode(e, 2, x.new_constraints)
    return position(e.io) - initpos
end
function PB._encoded_size(x::QuadraticConstraintUpdatesProto)
    encoded_size = 0
    !isempty(x.deleted_constraint_ids) && (encoded_size += PB._encoded_size(x.deleted_constraint_ids, 1))
    !isempty(x.new_constraints) && (encoded_size += PB._encoded_size(x.new_constraints, 2))
    return encoded_size
end

struct AuxiliaryObjectivesUpdatesProto
    deleted_objective_ids::Vector{Int64}
    new_objectives::Dict{Int64,ObjectiveProto}
    objective_updates::Dict{Int64,ObjectiveUpdatesProto}
end
PB.default_values(::Type{AuxiliaryObjectivesUpdatesProto}) = (;deleted_objective_ids = Vector{Int64}(), new_objectives = Dict{Int64,ObjectiveProto}(), objective_updates = Dict{Int64,ObjectiveUpdatesProto}())
PB.field_numbers(::Type{AuxiliaryObjectivesUpdatesProto}) = (;deleted_objective_ids = 1, new_objectives = 2, objective_updates = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:AuxiliaryObjectivesUpdatesProto})
    deleted_objective_ids = PB.BufferedVector{Int64}()
    new_objectives = Dict{Int64,ObjectiveProto}()
    objective_updates = Dict{Int64,ObjectiveUpdatesProto}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, deleted_objective_ids)
        elseif field_number == 2
            PB.decode!(d, new_objectives)
        elseif field_number == 3
            PB.decode!(d, objective_updates)
        else
            PB.skip(d, wire_type)
        end
    end
    return AuxiliaryObjectivesUpdatesProto(deleted_objective_ids[], new_objectives, objective_updates)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::AuxiliaryObjectivesUpdatesProto)
    initpos = position(e.io)
    !isempty(x.deleted_objective_ids) && PB.encode(e, 1, x.deleted_objective_ids)
    !isempty(x.new_objectives) && PB.encode(e, 2, x.new_objectives)
    !isempty(x.objective_updates) && PB.encode(e, 3, x.objective_updates)
    return position(e.io) - initpos
end
function PB._encoded_size(x::AuxiliaryObjectivesUpdatesProto)
    encoded_size = 0
    !isempty(x.deleted_objective_ids) && (encoded_size += PB._encoded_size(x.deleted_objective_ids, 1))
    !isempty(x.new_objectives) && (encoded_size += PB._encoded_size(x.new_objectives, 2))
    !isempty(x.objective_updates) && (encoded_size += PB._encoded_size(x.objective_updates, 3))
    return encoded_size
end

struct ModelUpdateProto
    deleted_variable_ids::Vector{Int64}
    deleted_linear_constraint_ids::Vector{Int64}
    variable_updates::Union{Nothing,VariableUpdatesProto}
    linear_constraint_updates::Union{Nothing,LinearConstraintUpdatesProto}
    new_variables::Union{Nothing,VariablesProto}
    new_linear_constraints::Union{Nothing,LinearConstraintsProto}
    objective_updates::Union{Nothing,ObjectiveUpdatesProto}
    auxiliary_objectives_updates::Union{Nothing,AuxiliaryObjectivesUpdatesProto}
    linear_constraint_matrix_updates::Union{Nothing,SparseDoubleMatrixProto}
    quadratic_constraint_updates::Union{Nothing,QuadraticConstraintUpdatesProto}
    second_order_cone_constraint_updates::Union{Nothing,SecondOrderConeConstraintUpdatesProto}
    sos1_constraint_updates::Union{Nothing,SosConstraintUpdatesProto}
    sos2_constraint_updates::Union{Nothing,SosConstraintUpdatesProto}
    indicator_constraint_updates::Union{Nothing,IndicatorConstraintUpdatesProto}
end
PB.default_values(::Type{ModelUpdateProto}) = (;deleted_variable_ids = Vector{Int64}(), deleted_linear_constraint_ids = Vector{Int64}(), variable_updates = nothing, linear_constraint_updates = nothing, new_variables = nothing, new_linear_constraints = nothing, objective_updates = nothing, auxiliary_objectives_updates = nothing, linear_constraint_matrix_updates = nothing, quadratic_constraint_updates = nothing, second_order_cone_constraint_updates = nothing, sos1_constraint_updates = nothing, sos2_constraint_updates = nothing, indicator_constraint_updates = nothing)
PB.field_numbers(::Type{ModelUpdateProto}) = (;deleted_variable_ids = 1, deleted_linear_constraint_ids = 2, variable_updates = 3, linear_constraint_updates = 4, new_variables = 5, new_linear_constraints = 6, objective_updates = 7, auxiliary_objectives_updates = 13, linear_constraint_matrix_updates = 8, quadratic_constraint_updates = 9, second_order_cone_constraint_updates = 14, sos1_constraint_updates = 10, sos2_constraint_updates = 11, indicator_constraint_updates = 12)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ModelUpdateProto})
    deleted_variable_ids = PB.BufferedVector{Int64}()
    deleted_linear_constraint_ids = PB.BufferedVector{Int64}()
    variable_updates = Ref{Union{Nothing,VariableUpdatesProto}}(nothing)
    linear_constraint_updates = Ref{Union{Nothing,LinearConstraintUpdatesProto}}(nothing)
    new_variables = Ref{Union{Nothing,VariablesProto}}(nothing)
    new_linear_constraints = Ref{Union{Nothing,LinearConstraintsProto}}(nothing)
    objective_updates = Ref{Union{Nothing,ObjectiveUpdatesProto}}(nothing)
    auxiliary_objectives_updates = Ref{Union{Nothing,AuxiliaryObjectivesUpdatesProto}}(nothing)
    linear_constraint_matrix_updates = Ref{Union{Nothing,SparseDoubleMatrixProto}}(nothing)
    quadratic_constraint_updates = Ref{Union{Nothing,QuadraticConstraintUpdatesProto}}(nothing)
    second_order_cone_constraint_updates = Ref{Union{Nothing,SecondOrderConeConstraintUpdatesProto}}(nothing)
    sos1_constraint_updates = Ref{Union{Nothing,SosConstraintUpdatesProto}}(nothing)
    sos2_constraint_updates = Ref{Union{Nothing,SosConstraintUpdatesProto}}(nothing)
    indicator_constraint_updates = Ref{Union{Nothing,IndicatorConstraintUpdatesProto}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, deleted_variable_ids)
        elseif field_number == 2
            PB.decode!(d, wire_type, deleted_linear_constraint_ids)
        elseif field_number == 3
            PB.decode!(d, variable_updates)
        elseif field_number == 4
            PB.decode!(d, linear_constraint_updates)
        elseif field_number == 5
            PB.decode!(d, new_variables)
        elseif field_number == 6
            PB.decode!(d, new_linear_constraints)
        elseif field_number == 7
            PB.decode!(d, objective_updates)
        elseif field_number == 13
            PB.decode!(d, auxiliary_objectives_updates)
        elseif field_number == 8
            PB.decode!(d, linear_constraint_matrix_updates)
        elseif field_number == 9
            PB.decode!(d, quadratic_constraint_updates)
        elseif field_number == 14
            PB.decode!(d, second_order_cone_constraint_updates)
        elseif field_number == 10
            PB.decode!(d, sos1_constraint_updates)
        elseif field_number == 11
            PB.decode!(d, sos2_constraint_updates)
        elseif field_number == 12
            PB.decode!(d, indicator_constraint_updates)
        else
            PB.skip(d, wire_type)
        end
    end
    return ModelUpdateProto(deleted_variable_ids[], deleted_linear_constraint_ids[], variable_updates[], linear_constraint_updates[], new_variables[], new_linear_constraints[], objective_updates[], auxiliary_objectives_updates[], linear_constraint_matrix_updates[], quadratic_constraint_updates[], second_order_cone_constraint_updates[], sos1_constraint_updates[], sos2_constraint_updates[], indicator_constraint_updates[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ModelUpdateProto)
    initpos = position(e.io)
    !isempty(x.deleted_variable_ids) && PB.encode(e, 1, x.deleted_variable_ids)
    !isempty(x.deleted_linear_constraint_ids) && PB.encode(e, 2, x.deleted_linear_constraint_ids)
    !isnothing(x.variable_updates) && PB.encode(e, 3, x.variable_updates)
    !isnothing(x.linear_constraint_updates) && PB.encode(e, 4, x.linear_constraint_updates)
    !isnothing(x.new_variables) && PB.encode(e, 5, x.new_variables)
    !isnothing(x.new_linear_constraints) && PB.encode(e, 6, x.new_linear_constraints)
    !isnothing(x.objective_updates) && PB.encode(e, 7, x.objective_updates)
    !isnothing(x.auxiliary_objectives_updates) && PB.encode(e, 13, x.auxiliary_objectives_updates)
    !isnothing(x.linear_constraint_matrix_updates) && PB.encode(e, 8, x.linear_constraint_matrix_updates)
    !isnothing(x.quadratic_constraint_updates) && PB.encode(e, 9, x.quadratic_constraint_updates)
    !isnothing(x.second_order_cone_constraint_updates) && PB.encode(e, 14, x.second_order_cone_constraint_updates)
    !isnothing(x.sos1_constraint_updates) && PB.encode(e, 10, x.sos1_constraint_updates)
    !isnothing(x.sos2_constraint_updates) && PB.encode(e, 11, x.sos2_constraint_updates)
    !isnothing(x.indicator_constraint_updates) && PB.encode(e, 12, x.indicator_constraint_updates)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ModelUpdateProto)
    encoded_size = 0
    !isempty(x.deleted_variable_ids) && (encoded_size += PB._encoded_size(x.deleted_variable_ids, 1))
    !isempty(x.deleted_linear_constraint_ids) && (encoded_size += PB._encoded_size(x.deleted_linear_constraint_ids, 2))
    !isnothing(x.variable_updates) && (encoded_size += PB._encoded_size(x.variable_updates, 3))
    !isnothing(x.linear_constraint_updates) && (encoded_size += PB._encoded_size(x.linear_constraint_updates, 4))
    !isnothing(x.new_variables) && (encoded_size += PB._encoded_size(x.new_variables, 5))
    !isnothing(x.new_linear_constraints) && (encoded_size += PB._encoded_size(x.new_linear_constraints, 6))
    !isnothing(x.objective_updates) && (encoded_size += PB._encoded_size(x.objective_updates, 7))
    !isnothing(x.auxiliary_objectives_updates) && (encoded_size += PB._encoded_size(x.auxiliary_objectives_updates, 13))
    !isnothing(x.linear_constraint_matrix_updates) && (encoded_size += PB._encoded_size(x.linear_constraint_matrix_updates, 8))
    !isnothing(x.quadratic_constraint_updates) && (encoded_size += PB._encoded_size(x.quadratic_constraint_updates, 9))
    !isnothing(x.second_order_cone_constraint_updates) && (encoded_size += PB._encoded_size(x.second_order_cone_constraint_updates, 14))
    !isnothing(x.sos1_constraint_updates) && (encoded_size += PB._encoded_size(x.sos1_constraint_updates, 10))
    !isnothing(x.sos2_constraint_updates) && (encoded_size += PB._encoded_size(x.sos2_constraint_updates, 11))
    !isnothing(x.indicator_constraint_updates) && (encoded_size += PB._encoded_size(x.indicator_constraint_updates, 12))
    return encoded_size
end
