# Autogenerated using ProtoBuf.jl v1.1.1 on 2025-07-02T15:45:02.125
# original file: /usr/local/google/home/tcuvelier/.julia/artifacts/502992654d3e610bc079dfc8ac9e663bff6f3a24/include/ortools/math_opt/sparse_containers.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export LinearExpressionProto, SparseDoubleVectorProto, SparseInt32VectorProto
export SparseBoolVectorProto, SparseVectorFilterProto, SparseDoubleMatrixProto


struct LinearExpressionProto
    ids::Vector{Int64}
    coefficients::Vector{Float64}
    offset::Float64
end
PB.default_values(::Type{LinearExpressionProto}) = (;ids = Vector{Int64}(), coefficients = Vector{Float64}(), offset = zero(Float64))
PB.field_numbers(::Type{LinearExpressionProto}) = (;ids = 1, coefficients = 2, offset = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:LinearExpressionProto})
    ids = PB.BufferedVector{Int64}()
    coefficients = PB.BufferedVector{Float64}()
    offset = zero(Float64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, ids)
        elseif field_number == 2
            PB.decode!(d, wire_type, coefficients)
        elseif field_number == 3
            offset = PB.decode(d, Float64)
        else
            PB.skip(d, wire_type)
        end
    end
    return LinearExpressionProto(ids[], coefficients[], offset)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::LinearExpressionProto)
    initpos = position(e.io)
    !isempty(x.ids) && PB.encode(e, 1, x.ids)
    !isempty(x.coefficients) && PB.encode(e, 2, x.coefficients)
    x.offset !== zero(Float64) && PB.encode(e, 3, x.offset)
    return position(e.io) - initpos
end
function PB._encoded_size(x::LinearExpressionProto)
    encoded_size = 0
    !isempty(x.ids) && (encoded_size += PB._encoded_size(x.ids, 1))
    !isempty(x.coefficients) && (encoded_size += PB._encoded_size(x.coefficients, 2))
    x.offset !== zero(Float64) && (encoded_size += PB._encoded_size(x.offset, 3))
    return encoded_size
end

struct SparseDoubleVectorProto
    ids::Vector{Int64}
    values::Vector{Float64}
end
PB.default_values(::Type{SparseDoubleVectorProto}) = (;ids = Vector{Int64}(), values = Vector{Float64}())
PB.field_numbers(::Type{SparseDoubleVectorProto}) = (;ids = 1, values = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SparseDoubleVectorProto})
    ids = PB.BufferedVector{Int64}()
    values = PB.BufferedVector{Float64}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, ids)
        elseif field_number == 2
            PB.decode!(d, wire_type, values)
        else
            PB.skip(d, wire_type)
        end
    end
    return SparseDoubleVectorProto(ids[], values[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SparseDoubleVectorProto)
    initpos = position(e.io)
    !isempty(x.ids) && PB.encode(e, 1, x.ids)
    !isempty(x.values) && PB.encode(e, 2, x.values)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SparseDoubleVectorProto)
    encoded_size = 0
    !isempty(x.ids) && (encoded_size += PB._encoded_size(x.ids, 1))
    !isempty(x.values) && (encoded_size += PB._encoded_size(x.values, 2))
    return encoded_size
end

struct SparseInt32VectorProto
    ids::Vector{Int64}
    values::Vector{Int32}
end
PB.default_values(::Type{SparseInt32VectorProto}) = (;ids = Vector{Int64}(), values = Vector{Int32}())
PB.field_numbers(::Type{SparseInt32VectorProto}) = (;ids = 1, values = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SparseInt32VectorProto})
    ids = PB.BufferedVector{Int64}()
    values = PB.BufferedVector{Int32}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, ids)
        elseif field_number == 2
            PB.decode!(d, wire_type, values)
        else
            PB.skip(d, wire_type)
        end
    end
    return SparseInt32VectorProto(ids[], values[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SparseInt32VectorProto)
    initpos = position(e.io)
    !isempty(x.ids) && PB.encode(e, 1, x.ids)
    !isempty(x.values) && PB.encode(e, 2, x.values)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SparseInt32VectorProto)
    encoded_size = 0
    !isempty(x.ids) && (encoded_size += PB._encoded_size(x.ids, 1))
    !isempty(x.values) && (encoded_size += PB._encoded_size(x.values, 2))
    return encoded_size
end

struct SparseBoolVectorProto
    ids::Vector{Int64}
    values::Vector{Bool}
end
PB.default_values(::Type{SparseBoolVectorProto}) = (;ids = Vector{Int64}(), values = Vector{Bool}())
PB.field_numbers(::Type{SparseBoolVectorProto}) = (;ids = 1, values = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SparseBoolVectorProto})
    ids = PB.BufferedVector{Int64}()
    values = PB.BufferedVector{Bool}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, ids)
        elseif field_number == 2
            PB.decode!(d, wire_type, values)
        else
            PB.skip(d, wire_type)
        end
    end
    return SparseBoolVectorProto(ids[], values[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SparseBoolVectorProto)
    initpos = position(e.io)
    !isempty(x.ids) && PB.encode(e, 1, x.ids)
    !isempty(x.values) && PB.encode(e, 2, x.values)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SparseBoolVectorProto)
    encoded_size = 0
    !isempty(x.ids) && (encoded_size += PB._encoded_size(x.ids, 1))
    !isempty(x.values) && (encoded_size += PB._encoded_size(x.values, 2))
    return encoded_size
end

struct SparseVectorFilterProto
    skip_zero_values::Bool
    filter_by_ids::Bool
    filtered_ids::Vector{Int64}
end
PB.default_values(::Type{SparseVectorFilterProto}) = (;skip_zero_values = false, filter_by_ids = false, filtered_ids = Vector{Int64}())
PB.field_numbers(::Type{SparseVectorFilterProto}) = (;skip_zero_values = 1, filter_by_ids = 2, filtered_ids = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SparseVectorFilterProto})
    skip_zero_values = false
    filter_by_ids = false
    filtered_ids = PB.BufferedVector{Int64}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            skip_zero_values = PB.decode(d, Bool)
        elseif field_number == 2
            filter_by_ids = PB.decode(d, Bool)
        elseif field_number == 3
            PB.decode!(d, wire_type, filtered_ids)
        else
            PB.skip(d, wire_type)
        end
    end
    return SparseVectorFilterProto(skip_zero_values, filter_by_ids, filtered_ids[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SparseVectorFilterProto)
    initpos = position(e.io)
    x.skip_zero_values != false && PB.encode(e, 1, x.skip_zero_values)
    x.filter_by_ids != false && PB.encode(e, 2, x.filter_by_ids)
    !isempty(x.filtered_ids) && PB.encode(e, 3, x.filtered_ids)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SparseVectorFilterProto)
    encoded_size = 0
    x.skip_zero_values != false && (encoded_size += PB._encoded_size(x.skip_zero_values, 1))
    x.filter_by_ids != false && (encoded_size += PB._encoded_size(x.filter_by_ids, 2))
    !isempty(x.filtered_ids) && (encoded_size += PB._encoded_size(x.filtered_ids, 3))
    return encoded_size
end

struct SparseDoubleMatrixProto
    row_ids::Vector{Int64}
    column_ids::Vector{Int64}
    coefficients::Vector{Float64}
end
PB.default_values(::Type{SparseDoubleMatrixProto}) = (;row_ids = Vector{Int64}(), column_ids = Vector{Int64}(), coefficients = Vector{Float64}())
PB.field_numbers(::Type{SparseDoubleMatrixProto}) = (;row_ids = 1, column_ids = 2, coefficients = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SparseDoubleMatrixProto})
    row_ids = PB.BufferedVector{Int64}()
    column_ids = PB.BufferedVector{Int64}()
    coefficients = PB.BufferedVector{Float64}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, row_ids)
        elseif field_number == 2
            PB.decode!(d, wire_type, column_ids)
        elseif field_number == 3
            PB.decode!(d, wire_type, coefficients)
        else
            PB.skip(d, wire_type)
        end
    end
    return SparseDoubleMatrixProto(row_ids[], column_ids[], coefficients[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SparseDoubleMatrixProto)
    initpos = position(e.io)
    !isempty(x.row_ids) && PB.encode(e, 1, x.row_ids)
    !isempty(x.column_ids) && PB.encode(e, 2, x.column_ids)
    !isempty(x.coefficients) && PB.encode(e, 3, x.coefficients)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SparseDoubleMatrixProto)
    encoded_size = 0
    !isempty(x.row_ids) && (encoded_size += PB._encoded_size(x.row_ids, 1))
    !isempty(x.column_ids) && (encoded_size += PB._encoded_size(x.column_ids, 2))
    !isempty(x.coefficients) && (encoded_size += PB._encoded_size(x.coefficients, 3))
    return encoded_size
end
