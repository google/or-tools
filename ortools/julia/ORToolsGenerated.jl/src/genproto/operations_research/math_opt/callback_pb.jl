# Autogenerated using ProtoBuf.jl v1.1.1 on 2025-07-02T15:45:02.127
# original file: /usr/local/google/home/tcuvelier/.julia/artifacts/502992654d3e610bc079dfc8ac9e663bff6f3a24/include/ortools/math_opt/callback.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export var"CallbackDataProto.PresolveStats"
export var"CallbackResultProto.GeneratedLinearConstraint", CallbackEventProto
export var"CallbackDataProto.MipStats", var"CallbackDataProto.BarrierStats"
export var"CallbackDataProto.SimplexStats", CallbackResultProto, CallbackRegistrationProto
export CallbackDataProto


struct var"CallbackDataProto.PresolveStats"
    removed_variables::Int64
    removed_constraints::Int64
    bound_changes::Int64
    coefficient_changes::Int64
end
PB.default_values(::Type{var"CallbackDataProto.PresolveStats"}) = (;removed_variables = zero(Int64), removed_constraints = zero(Int64), bound_changes = zero(Int64), coefficient_changes = zero(Int64))
PB.field_numbers(::Type{var"CallbackDataProto.PresolveStats"}) = (;removed_variables = 1, removed_constraints = 2, bound_changes = 3, coefficient_changes = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"CallbackDataProto.PresolveStats"})
    removed_variables = zero(Int64)
    removed_constraints = zero(Int64)
    bound_changes = zero(Int64)
    coefficient_changes = zero(Int64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            removed_variables = PB.decode(d, Int64)
        elseif field_number == 2
            removed_constraints = PB.decode(d, Int64)
        elseif field_number == 3
            bound_changes = PB.decode(d, Int64)
        elseif field_number == 4
            coefficient_changes = PB.decode(d, Int64)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"CallbackDataProto.PresolveStats"(removed_variables, removed_constraints, bound_changes, coefficient_changes)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"CallbackDataProto.PresolveStats")
    initpos = position(e.io)
    x.removed_variables != zero(Int64) && PB.encode(e, 1, x.removed_variables)
    x.removed_constraints != zero(Int64) && PB.encode(e, 2, x.removed_constraints)
    x.bound_changes != zero(Int64) && PB.encode(e, 3, x.bound_changes)
    x.coefficient_changes != zero(Int64) && PB.encode(e, 4, x.coefficient_changes)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"CallbackDataProto.PresolveStats")
    encoded_size = 0
    x.removed_variables != zero(Int64) && (encoded_size += PB._encoded_size(x.removed_variables, 1))
    x.removed_constraints != zero(Int64) && (encoded_size += PB._encoded_size(x.removed_constraints, 2))
    x.bound_changes != zero(Int64) && (encoded_size += PB._encoded_size(x.bound_changes, 3))
    x.coefficient_changes != zero(Int64) && (encoded_size += PB._encoded_size(x.coefficient_changes, 4))
    return encoded_size
end

struct var"CallbackResultProto.GeneratedLinearConstraint"
    linear_expression::Union{Nothing,SparseDoubleVectorProto}
    lower_bound::Float64
    upper_bound::Float64
    is_lazy::Bool
end
PB.default_values(::Type{var"CallbackResultProto.GeneratedLinearConstraint"}) = (;linear_expression = nothing, lower_bound = zero(Float64), upper_bound = zero(Float64), is_lazy = false)
PB.field_numbers(::Type{var"CallbackResultProto.GeneratedLinearConstraint"}) = (;linear_expression = 1, lower_bound = 2, upper_bound = 3, is_lazy = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"CallbackResultProto.GeneratedLinearConstraint"})
    linear_expression = Ref{Union{Nothing,SparseDoubleVectorProto}}(nothing)
    lower_bound = zero(Float64)
    upper_bound = zero(Float64)
    is_lazy = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, linear_expression)
        elseif field_number == 2
            lower_bound = PB.decode(d, Float64)
        elseif field_number == 3
            upper_bound = PB.decode(d, Float64)
        elseif field_number == 4
            is_lazy = PB.decode(d, Bool)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"CallbackResultProto.GeneratedLinearConstraint"(linear_expression[], lower_bound, upper_bound, is_lazy)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"CallbackResultProto.GeneratedLinearConstraint")
    initpos = position(e.io)
    !isnothing(x.linear_expression) && PB.encode(e, 1, x.linear_expression)
    x.lower_bound !== zero(Float64) && PB.encode(e, 2, x.lower_bound)
    x.upper_bound !== zero(Float64) && PB.encode(e, 3, x.upper_bound)
    x.is_lazy != false && PB.encode(e, 4, x.is_lazy)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"CallbackResultProto.GeneratedLinearConstraint")
    encoded_size = 0
    !isnothing(x.linear_expression) && (encoded_size += PB._encoded_size(x.linear_expression, 1))
    x.lower_bound !== zero(Float64) && (encoded_size += PB._encoded_size(x.lower_bound, 2))
    x.upper_bound !== zero(Float64) && (encoded_size += PB._encoded_size(x.upper_bound, 3))
    x.is_lazy != false && (encoded_size += PB._encoded_size(x.is_lazy, 4))
    return encoded_size
end

@enumx CallbackEventProto CALLBACK_EVENT_UNSPECIFIED=0 CALLBACK_EVENT_PRESOLVE=1 CALLBACK_EVENT_SIMPLEX=2 CALLBACK_EVENT_MIP=3 CALLBACK_EVENT_MIP_SOLUTION=4 CALLBACK_EVENT_MIP_NODE=5 CALLBACK_EVENT_BARRIER=6

struct var"CallbackDataProto.MipStats"
    primal_bound::Float64
    dual_bound::Float64
    explored_nodes::Int64
    open_nodes::Int64
    simplex_iterations::Int64
    number_of_solutions_found::Int32
    cutting_planes_in_lp::Int32
end
PB.default_values(::Type{var"CallbackDataProto.MipStats"}) = (;primal_bound = zero(Float64), dual_bound = zero(Float64), explored_nodes = zero(Int64), open_nodes = zero(Int64), simplex_iterations = zero(Int64), number_of_solutions_found = zero(Int32), cutting_planes_in_lp = zero(Int32))
PB.field_numbers(::Type{var"CallbackDataProto.MipStats"}) = (;primal_bound = 1, dual_bound = 2, explored_nodes = 3, open_nodes = 4, simplex_iterations = 5, number_of_solutions_found = 6, cutting_planes_in_lp = 7)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"CallbackDataProto.MipStats"})
    primal_bound = zero(Float64)
    dual_bound = zero(Float64)
    explored_nodes = zero(Int64)
    open_nodes = zero(Int64)
    simplex_iterations = zero(Int64)
    number_of_solutions_found = zero(Int32)
    cutting_planes_in_lp = zero(Int32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            primal_bound = PB.decode(d, Float64)
        elseif field_number == 2
            dual_bound = PB.decode(d, Float64)
        elseif field_number == 3
            explored_nodes = PB.decode(d, Int64)
        elseif field_number == 4
            open_nodes = PB.decode(d, Int64)
        elseif field_number == 5
            simplex_iterations = PB.decode(d, Int64)
        elseif field_number == 6
            number_of_solutions_found = PB.decode(d, Int32)
        elseif field_number == 7
            cutting_planes_in_lp = PB.decode(d, Int32)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"CallbackDataProto.MipStats"(primal_bound, dual_bound, explored_nodes, open_nodes, simplex_iterations, number_of_solutions_found, cutting_planes_in_lp)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"CallbackDataProto.MipStats")
    initpos = position(e.io)
    x.primal_bound !== zero(Float64) && PB.encode(e, 1, x.primal_bound)
    x.dual_bound !== zero(Float64) && PB.encode(e, 2, x.dual_bound)
    x.explored_nodes != zero(Int64) && PB.encode(e, 3, x.explored_nodes)
    x.open_nodes != zero(Int64) && PB.encode(e, 4, x.open_nodes)
    x.simplex_iterations != zero(Int64) && PB.encode(e, 5, x.simplex_iterations)
    x.number_of_solutions_found != zero(Int32) && PB.encode(e, 6, x.number_of_solutions_found)
    x.cutting_planes_in_lp != zero(Int32) && PB.encode(e, 7, x.cutting_planes_in_lp)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"CallbackDataProto.MipStats")
    encoded_size = 0
    x.primal_bound !== zero(Float64) && (encoded_size += PB._encoded_size(x.primal_bound, 1))
    x.dual_bound !== zero(Float64) && (encoded_size += PB._encoded_size(x.dual_bound, 2))
    x.explored_nodes != zero(Int64) && (encoded_size += PB._encoded_size(x.explored_nodes, 3))
    x.open_nodes != zero(Int64) && (encoded_size += PB._encoded_size(x.open_nodes, 4))
    x.simplex_iterations != zero(Int64) && (encoded_size += PB._encoded_size(x.simplex_iterations, 5))
    x.number_of_solutions_found != zero(Int32) && (encoded_size += PB._encoded_size(x.number_of_solutions_found, 6))
    x.cutting_planes_in_lp != zero(Int32) && (encoded_size += PB._encoded_size(x.cutting_planes_in_lp, 7))
    return encoded_size
end

struct var"CallbackDataProto.BarrierStats"
    iteration_count::Int32
    primal_objective::Float64
    dual_objective::Float64
    complementarity::Float64
    primal_infeasibility::Float64
    dual_infeasibility::Float64
end
PB.default_values(::Type{var"CallbackDataProto.BarrierStats"}) = (;iteration_count = zero(Int32), primal_objective = zero(Float64), dual_objective = zero(Float64), complementarity = zero(Float64), primal_infeasibility = zero(Float64), dual_infeasibility = zero(Float64))
PB.field_numbers(::Type{var"CallbackDataProto.BarrierStats"}) = (;iteration_count = 1, primal_objective = 2, dual_objective = 3, complementarity = 4, primal_infeasibility = 5, dual_infeasibility = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"CallbackDataProto.BarrierStats"})
    iteration_count = zero(Int32)
    primal_objective = zero(Float64)
    dual_objective = zero(Float64)
    complementarity = zero(Float64)
    primal_infeasibility = zero(Float64)
    dual_infeasibility = zero(Float64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            iteration_count = PB.decode(d, Int32)
        elseif field_number == 2
            primal_objective = PB.decode(d, Float64)
        elseif field_number == 3
            dual_objective = PB.decode(d, Float64)
        elseif field_number == 4
            complementarity = PB.decode(d, Float64)
        elseif field_number == 5
            primal_infeasibility = PB.decode(d, Float64)
        elseif field_number == 6
            dual_infeasibility = PB.decode(d, Float64)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"CallbackDataProto.BarrierStats"(iteration_count, primal_objective, dual_objective, complementarity, primal_infeasibility, dual_infeasibility)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"CallbackDataProto.BarrierStats")
    initpos = position(e.io)
    x.iteration_count != zero(Int32) && PB.encode(e, 1, x.iteration_count)
    x.primal_objective !== zero(Float64) && PB.encode(e, 2, x.primal_objective)
    x.dual_objective !== zero(Float64) && PB.encode(e, 3, x.dual_objective)
    x.complementarity !== zero(Float64) && PB.encode(e, 4, x.complementarity)
    x.primal_infeasibility !== zero(Float64) && PB.encode(e, 5, x.primal_infeasibility)
    x.dual_infeasibility !== zero(Float64) && PB.encode(e, 6, x.dual_infeasibility)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"CallbackDataProto.BarrierStats")
    encoded_size = 0
    x.iteration_count != zero(Int32) && (encoded_size += PB._encoded_size(x.iteration_count, 1))
    x.primal_objective !== zero(Float64) && (encoded_size += PB._encoded_size(x.primal_objective, 2))
    x.dual_objective !== zero(Float64) && (encoded_size += PB._encoded_size(x.dual_objective, 3))
    x.complementarity !== zero(Float64) && (encoded_size += PB._encoded_size(x.complementarity, 4))
    x.primal_infeasibility !== zero(Float64) && (encoded_size += PB._encoded_size(x.primal_infeasibility, 5))
    x.dual_infeasibility !== zero(Float64) && (encoded_size += PB._encoded_size(x.dual_infeasibility, 6))
    return encoded_size
end

struct var"CallbackDataProto.SimplexStats"
    iteration_count::Int64
    objective_value::Float64
    primal_infeasibility::Float64
    dual_infeasibility::Float64
    is_pertubated::Bool
end
PB.default_values(::Type{var"CallbackDataProto.SimplexStats"}) = (;iteration_count = zero(Int64), objective_value = zero(Float64), primal_infeasibility = zero(Float64), dual_infeasibility = zero(Float64), is_pertubated = false)
PB.field_numbers(::Type{var"CallbackDataProto.SimplexStats"}) = (;iteration_count = 1, objective_value = 2, primal_infeasibility = 3, dual_infeasibility = 4, is_pertubated = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"CallbackDataProto.SimplexStats"})
    iteration_count = zero(Int64)
    objective_value = zero(Float64)
    primal_infeasibility = zero(Float64)
    dual_infeasibility = zero(Float64)
    is_pertubated = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            iteration_count = PB.decode(d, Int64)
        elseif field_number == 2
            objective_value = PB.decode(d, Float64)
        elseif field_number == 3
            primal_infeasibility = PB.decode(d, Float64)
        elseif field_number == 4
            dual_infeasibility = PB.decode(d, Float64)
        elseif field_number == 5
            is_pertubated = PB.decode(d, Bool)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"CallbackDataProto.SimplexStats"(iteration_count, objective_value, primal_infeasibility, dual_infeasibility, is_pertubated)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"CallbackDataProto.SimplexStats")
    initpos = position(e.io)
    x.iteration_count != zero(Int64) && PB.encode(e, 1, x.iteration_count)
    x.objective_value !== zero(Float64) && PB.encode(e, 2, x.objective_value)
    x.primal_infeasibility !== zero(Float64) && PB.encode(e, 3, x.primal_infeasibility)
    x.dual_infeasibility !== zero(Float64) && PB.encode(e, 4, x.dual_infeasibility)
    x.is_pertubated != false && PB.encode(e, 5, x.is_pertubated)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"CallbackDataProto.SimplexStats")
    encoded_size = 0
    x.iteration_count != zero(Int64) && (encoded_size += PB._encoded_size(x.iteration_count, 1))
    x.objective_value !== zero(Float64) && (encoded_size += PB._encoded_size(x.objective_value, 2))
    x.primal_infeasibility !== zero(Float64) && (encoded_size += PB._encoded_size(x.primal_infeasibility, 3))
    x.dual_infeasibility !== zero(Float64) && (encoded_size += PB._encoded_size(x.dual_infeasibility, 4))
    x.is_pertubated != false && (encoded_size += PB._encoded_size(x.is_pertubated, 5))
    return encoded_size
end

struct CallbackResultProto
    terminate::Bool
    cuts::Vector{var"CallbackResultProto.GeneratedLinearConstraint"}
    suggested_solutions::Vector{SparseDoubleVectorProto}
end
PB.default_values(::Type{CallbackResultProto}) = (;terminate = false, cuts = Vector{var"CallbackResultProto.GeneratedLinearConstraint"}(), suggested_solutions = Vector{SparseDoubleVectorProto}())
PB.field_numbers(::Type{CallbackResultProto}) = (;terminate = 1, cuts = 4, suggested_solutions = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:CallbackResultProto})
    terminate = false
    cuts = PB.BufferedVector{var"CallbackResultProto.GeneratedLinearConstraint"}()
    suggested_solutions = PB.BufferedVector{SparseDoubleVectorProto}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            terminate = PB.decode(d, Bool)
        elseif field_number == 4
            PB.decode!(d, cuts)
        elseif field_number == 5
            PB.decode!(d, suggested_solutions)
        else
            PB.skip(d, wire_type)
        end
    end
    return CallbackResultProto(terminate, cuts[], suggested_solutions[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::CallbackResultProto)
    initpos = position(e.io)
    x.terminate != false && PB.encode(e, 1, x.terminate)
    !isempty(x.cuts) && PB.encode(e, 4, x.cuts)
    !isempty(x.suggested_solutions) && PB.encode(e, 5, x.suggested_solutions)
    return position(e.io) - initpos
end
function PB._encoded_size(x::CallbackResultProto)
    encoded_size = 0
    x.terminate != false && (encoded_size += PB._encoded_size(x.terminate, 1))
    !isempty(x.cuts) && (encoded_size += PB._encoded_size(x.cuts, 4))
    !isempty(x.suggested_solutions) && (encoded_size += PB._encoded_size(x.suggested_solutions, 5))
    return encoded_size
end

struct CallbackRegistrationProto
    request_registration::Vector{CallbackEventProto.T}
    mip_solution_filter::Union{Nothing,SparseVectorFilterProto}
    mip_node_filter::Union{Nothing,SparseVectorFilterProto}
    add_cuts::Bool
    add_lazy_constraints::Bool
end
PB.default_values(::Type{CallbackRegistrationProto}) = (;request_registration = Vector{CallbackEventProto.T}(), mip_solution_filter = nothing, mip_node_filter = nothing, add_cuts = false, add_lazy_constraints = false)
PB.field_numbers(::Type{CallbackRegistrationProto}) = (;request_registration = 1, mip_solution_filter = 2, mip_node_filter = 3, add_cuts = 4, add_lazy_constraints = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:CallbackRegistrationProto})
    request_registration = PB.BufferedVector{CallbackEventProto.T}()
    mip_solution_filter = Ref{Union{Nothing,SparseVectorFilterProto}}(nothing)
    mip_node_filter = Ref{Union{Nothing,SparseVectorFilterProto}}(nothing)
    add_cuts = false
    add_lazy_constraints = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, request_registration)
        elseif field_number == 2
            PB.decode!(d, mip_solution_filter)
        elseif field_number == 3
            PB.decode!(d, mip_node_filter)
        elseif field_number == 4
            add_cuts = PB.decode(d, Bool)
        elseif field_number == 5
            add_lazy_constraints = PB.decode(d, Bool)
        else
            PB.skip(d, wire_type)
        end
    end
    return CallbackRegistrationProto(request_registration[], mip_solution_filter[], mip_node_filter[], add_cuts, add_lazy_constraints)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::CallbackRegistrationProto)
    initpos = position(e.io)
    !isempty(x.request_registration) && PB.encode(e, 1, x.request_registration)
    !isnothing(x.mip_solution_filter) && PB.encode(e, 2, x.mip_solution_filter)
    !isnothing(x.mip_node_filter) && PB.encode(e, 3, x.mip_node_filter)
    x.add_cuts != false && PB.encode(e, 4, x.add_cuts)
    x.add_lazy_constraints != false && PB.encode(e, 5, x.add_lazy_constraints)
    return position(e.io) - initpos
end
function PB._encoded_size(x::CallbackRegistrationProto)
    encoded_size = 0
    !isempty(x.request_registration) && (encoded_size += PB._encoded_size(x.request_registration, 1))
    !isnothing(x.mip_solution_filter) && (encoded_size += PB._encoded_size(x.mip_solution_filter, 2))
    !isnothing(x.mip_node_filter) && (encoded_size += PB._encoded_size(x.mip_node_filter, 3))
    x.add_cuts != false && (encoded_size += PB._encoded_size(x.add_cuts, 4))
    x.add_lazy_constraints != false && (encoded_size += PB._encoded_size(x.add_lazy_constraints, 5))
    return encoded_size
end

struct CallbackDataProto
    event::CallbackEventProto.T
    primal_solution_vector::Union{Nothing,SparseDoubleVectorProto}
    runtime::Union{Nothing,google.protobuf.Duration}
    presolve_stats::Union{Nothing,var"CallbackDataProto.PresolveStats"}
    simplex_stats::Union{Nothing,var"CallbackDataProto.SimplexStats"}
    barrier_stats::Union{Nothing,var"CallbackDataProto.BarrierStats"}
    mip_stats::Union{Nothing,var"CallbackDataProto.MipStats"}
end
PB.default_values(::Type{CallbackDataProto}) = (;event = CallbackEventProto.CALLBACK_EVENT_UNSPECIFIED, primal_solution_vector = nothing, runtime = nothing, presolve_stats = nothing, simplex_stats = nothing, barrier_stats = nothing, mip_stats = nothing)
PB.field_numbers(::Type{CallbackDataProto}) = (;event = 1, primal_solution_vector = 2, runtime = 3, presolve_stats = 4, simplex_stats = 5, barrier_stats = 6, mip_stats = 7)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:CallbackDataProto})
    event = CallbackEventProto.CALLBACK_EVENT_UNSPECIFIED
    primal_solution_vector = Ref{Union{Nothing,SparseDoubleVectorProto}}(nothing)
    runtime = Ref{Union{Nothing,google.protobuf.Duration}}(nothing)
    presolve_stats = Ref{Union{Nothing,var"CallbackDataProto.PresolveStats"}}(nothing)
    simplex_stats = Ref{Union{Nothing,var"CallbackDataProto.SimplexStats"}}(nothing)
    barrier_stats = Ref{Union{Nothing,var"CallbackDataProto.BarrierStats"}}(nothing)
    mip_stats = Ref{Union{Nothing,var"CallbackDataProto.MipStats"}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            event = PB.decode(d, CallbackEventProto.T)
        elseif field_number == 2
            PB.decode!(d, primal_solution_vector)
        elseif field_number == 3
            PB.decode!(d, runtime)
        elseif field_number == 4
            PB.decode!(d, presolve_stats)
        elseif field_number == 5
            PB.decode!(d, simplex_stats)
        elseif field_number == 6
            PB.decode!(d, barrier_stats)
        elseif field_number == 7
            PB.decode!(d, mip_stats)
        else
            PB.skip(d, wire_type)
        end
    end
    return CallbackDataProto(event, primal_solution_vector[], runtime[], presolve_stats[], simplex_stats[], barrier_stats[], mip_stats[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::CallbackDataProto)
    initpos = position(e.io)
    x.event != CallbackEventProto.CALLBACK_EVENT_UNSPECIFIED && PB.encode(e, 1, x.event)
    !isnothing(x.primal_solution_vector) && PB.encode(e, 2, x.primal_solution_vector)
    !isnothing(x.runtime) && PB.encode(e, 3, x.runtime)
    !isnothing(x.presolve_stats) && PB.encode(e, 4, x.presolve_stats)
    !isnothing(x.simplex_stats) && PB.encode(e, 5, x.simplex_stats)
    !isnothing(x.barrier_stats) && PB.encode(e, 6, x.barrier_stats)
    !isnothing(x.mip_stats) && PB.encode(e, 7, x.mip_stats)
    return position(e.io) - initpos
end
function PB._encoded_size(x::CallbackDataProto)
    encoded_size = 0
    x.event != CallbackEventProto.CALLBACK_EVENT_UNSPECIFIED && (encoded_size += PB._encoded_size(x.event, 1))
    !isnothing(x.primal_solution_vector) && (encoded_size += PB._encoded_size(x.primal_solution_vector, 2))
    !isnothing(x.runtime) && (encoded_size += PB._encoded_size(x.runtime, 3))
    !isnothing(x.presolve_stats) && (encoded_size += PB._encoded_size(x.presolve_stats, 4))
    !isnothing(x.simplex_stats) && (encoded_size += PB._encoded_size(x.simplex_stats, 5))
    !isnothing(x.barrier_stats) && (encoded_size += PB._encoded_size(x.barrier_stats, 6))
    !isnothing(x.mip_stats) && (encoded_size += PB._encoded_size(x.mip_stats, 7))
    return encoded_size
end
