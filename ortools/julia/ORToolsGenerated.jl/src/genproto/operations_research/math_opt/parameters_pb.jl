# Autogenerated using ProtoBuf.jl v1.1.1 on 2025-07-02T15:45:02.128
# original file: /usr/local/google/home/tcuvelier/.julia/artifacts/502992654d3e610bc079dfc8ac9e663bff6f3a24/include/ortools/math_opt/parameters.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export EmphasisProto, StrictnessProto, SolverTypeProto, SolverInitializerProto
export LPAlgorithmProto, SolveParametersProto


@enumx EmphasisProto EMPHASIS_UNSPECIFIED=0 EMPHASIS_OFF=1 EMPHASIS_LOW=2 EMPHASIS_MEDIUM=3 EMPHASIS_HIGH=4 EMPHASIS_VERY_HIGH=5

struct StrictnessProto
    bad_parameter::Bool
end
PB.default_values(::Type{StrictnessProto}) = (;bad_parameter = false)
PB.field_numbers(::Type{StrictnessProto}) = (;bad_parameter = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:StrictnessProto})
    bad_parameter = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            bad_parameter = PB.decode(d, Bool)
        else
            PB.skip(d, wire_type)
        end
    end
    return StrictnessProto(bad_parameter)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::StrictnessProto)
    initpos = position(e.io)
    x.bad_parameter != false && PB.encode(e, 1, x.bad_parameter)
    return position(e.io) - initpos
end
function PB._encoded_size(x::StrictnessProto)
    encoded_size = 0
    x.bad_parameter != false && (encoded_size += PB._encoded_size(x.bad_parameter, 1))
    return encoded_size
end

@enumx SolverTypeProto SOLVER_TYPE_UNSPECIFIED=0 SOLVER_TYPE_GSCIP=1 SOLVER_TYPE_GUROBI=2 SOLVER_TYPE_GLOP=3 SOLVER_TYPE_CP_SAT=4 SOLVER_TYPE_PDLP=5 SOLVER_TYPE_GLPK=6 SOLVER_TYPE_OSQP=7 SOLVER_TYPE_ECOS=8 SOLVER_TYPE_SCS=9 SOLVER_TYPE_HIGHS=10 SOLVER_TYPE_SANTORINI=11 SOLVER_TYPE_XPRESS=13
PB.reserved_fields(::Type{SolverTypeProto.T}) = (names = String[], numbers = Union{Int,UnitRange{Int}}[12])

struct SolverInitializerProto
    gurobi::Union{Nothing,GurobiInitializerProto}
end
PB.reserved_fields(::Type{SolverInitializerProto}) = (names = String[], numbers = Union{Int,UnitRange{Int}}[2])
PB.default_values(::Type{SolverInitializerProto}) = (;gurobi = nothing)
PB.field_numbers(::Type{SolverInitializerProto}) = (;gurobi = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SolverInitializerProto})
    gurobi = Ref{Union{Nothing,GurobiInitializerProto}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, gurobi)
        else
            PB.skip(d, wire_type)
        end
    end
    return SolverInitializerProto(gurobi[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SolverInitializerProto)
    initpos = position(e.io)
    !isnothing(x.gurobi) && PB.encode(e, 1, x.gurobi)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SolverInitializerProto)
    encoded_size = 0
    !isnothing(x.gurobi) && (encoded_size += PB._encoded_size(x.gurobi, 1))
    return encoded_size
end

@enumx LPAlgorithmProto LP_ALGORITHM_UNSPECIFIED=0 LP_ALGORITHM_PRIMAL_SIMPLEX=1 LP_ALGORITHM_DUAL_SIMPLEX=2 LP_ALGORITHM_BARRIER=3 LP_ALGORITHM_FIRST_ORDER=4

struct SolveParametersProto
    time_limit::Union{Nothing,google.protobuf.Duration}
    iteration_limit::Int64
    node_limit::Int64
    cutoff_limit::Float64
    objective_limit::Float64
    best_bound_limit::Float64
    solution_limit::Int32
    enable_output::Bool
    threads::Int32
    random_seed::Int32
    absolute_gap_tolerance::Float64
    relative_gap_tolerance::Float64
    solution_pool_size::Int32
    lp_algorithm::LPAlgorithmProto.T
    presolve::EmphasisProto.T
    cuts::EmphasisProto.T
    heuristics::EmphasisProto.T
    scaling::EmphasisProto.T
    gscip::Union{Nothing,operations_research.GScipParameters}
    gurobi::Union{Nothing,GurobiParametersProto}
    glop::Union{Nothing,operations_research.glop.GlopParameters}
    cp_sat::Union{Nothing,operations_research.sat.SatParameters}
    pdlp::Union{Nothing,operations_research.pdlp.PrimalDualHybridGradientParams}
    osqp::Union{Nothing,OsqpSettingsProto}
    glpk::Union{Nothing,GlpkParametersProto}
    highs::Union{Nothing,HighsOptionsProto}
end
PB.reserved_fields(::Type{SolveParametersProto}) = (names = String[], numbers = Union{Int,UnitRange{Int}}[11])
PB.default_values(::Type{SolveParametersProto}) = (;time_limit = nothing, iteration_limit = zero(Int64), node_limit = zero(Int64), cutoff_limit = zero(Float64), objective_limit = zero(Float64), best_bound_limit = zero(Float64), solution_limit = zero(Int32), enable_output = false, threads = zero(Int32), random_seed = zero(Int32), absolute_gap_tolerance = zero(Float64), relative_gap_tolerance = zero(Float64), solution_pool_size = zero(Int32), lp_algorithm = LPAlgorithmProto.LP_ALGORITHM_UNSPECIFIED, presolve = EmphasisProto.EMPHASIS_UNSPECIFIED, cuts = EmphasisProto.EMPHASIS_UNSPECIFIED, heuristics = EmphasisProto.EMPHASIS_UNSPECIFIED, scaling = EmphasisProto.EMPHASIS_UNSPECIFIED, gscip = nothing, gurobi = nothing, glop = nothing, cp_sat = nothing, pdlp = nothing, osqp = nothing, glpk = nothing, highs = nothing)
PB.field_numbers(::Type{SolveParametersProto}) = (;time_limit = 1, iteration_limit = 2, node_limit = 24, cutoff_limit = 20, objective_limit = 21, best_bound_limit = 22, solution_limit = 23, enable_output = 3, threads = 4, random_seed = 5, absolute_gap_tolerance = 18, relative_gap_tolerance = 17, solution_pool_size = 25, lp_algorithm = 6, presolve = 7, cuts = 8, heuristics = 9, scaling = 10, gscip = 12, gurobi = 13, glop = 14, cp_sat = 15, pdlp = 16, osqp = 19, glpk = 26, highs = 27)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SolveParametersProto})
    time_limit = Ref{Union{Nothing,google.protobuf.Duration}}(nothing)
    iteration_limit = zero(Int64)
    node_limit = zero(Int64)
    cutoff_limit = zero(Float64)
    objective_limit = zero(Float64)
    best_bound_limit = zero(Float64)
    solution_limit = zero(Int32)
    enable_output = false
    threads = zero(Int32)
    random_seed = zero(Int32)
    absolute_gap_tolerance = zero(Float64)
    relative_gap_tolerance = zero(Float64)
    solution_pool_size = zero(Int32)
    lp_algorithm = LPAlgorithmProto.LP_ALGORITHM_UNSPECIFIED
    presolve = EmphasisProto.EMPHASIS_UNSPECIFIED
    cuts = EmphasisProto.EMPHASIS_UNSPECIFIED
    heuristics = EmphasisProto.EMPHASIS_UNSPECIFIED
    scaling = EmphasisProto.EMPHASIS_UNSPECIFIED
    gscip = Ref{Union{Nothing,operations_research.GScipParameters}}(nothing)
    gurobi = Ref{Union{Nothing,GurobiParametersProto}}(nothing)
    glop = Ref{Union{Nothing,operations_research.glop.GlopParameters}}(nothing)
    cp_sat = Ref{Union{Nothing,operations_research.sat.SatParameters}}(nothing)
    pdlp = Ref{Union{Nothing,operations_research.pdlp.PrimalDualHybridGradientParams}}(nothing)
    osqp = Ref{Union{Nothing,OsqpSettingsProto}}(nothing)
    glpk = Ref{Union{Nothing,GlpkParametersProto}}(nothing)
    highs = Ref{Union{Nothing,HighsOptionsProto}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, time_limit)
        elseif field_number == 2
            iteration_limit = PB.decode(d, Int64)
        elseif field_number == 24
            node_limit = PB.decode(d, Int64)
        elseif field_number == 20
            cutoff_limit = PB.decode(d, Float64)
        elseif field_number == 21
            objective_limit = PB.decode(d, Float64)
        elseif field_number == 22
            best_bound_limit = PB.decode(d, Float64)
        elseif field_number == 23
            solution_limit = PB.decode(d, Int32)
        elseif field_number == 3
            enable_output = PB.decode(d, Bool)
        elseif field_number == 4
            threads = PB.decode(d, Int32)
        elseif field_number == 5
            random_seed = PB.decode(d, Int32)
        elseif field_number == 18
            absolute_gap_tolerance = PB.decode(d, Float64)
        elseif field_number == 17
            relative_gap_tolerance = PB.decode(d, Float64)
        elseif field_number == 25
            solution_pool_size = PB.decode(d, Int32)
        elseif field_number == 6
            lp_algorithm = PB.decode(d, LPAlgorithmProto.T)
        elseif field_number == 7
            presolve = PB.decode(d, EmphasisProto.T)
        elseif field_number == 8
            cuts = PB.decode(d, EmphasisProto.T)
        elseif field_number == 9
            heuristics = PB.decode(d, EmphasisProto.T)
        elseif field_number == 10
            scaling = PB.decode(d, EmphasisProto.T)
        elseif field_number == 12
            PB.decode!(d, gscip)
        elseif field_number == 13
            PB.decode!(d, gurobi)
        elseif field_number == 14
            PB.decode!(d, glop)
        elseif field_number == 15
            PB.decode!(d, cp_sat)
        elseif field_number == 16
            PB.decode!(d, pdlp)
        elseif field_number == 19
            PB.decode!(d, osqp)
        elseif field_number == 26
            PB.decode!(d, glpk)
        elseif field_number == 27
            PB.decode!(d, highs)
        else
            PB.skip(d, wire_type)
        end
    end
    return SolveParametersProto(time_limit[], iteration_limit, node_limit, cutoff_limit, objective_limit, best_bound_limit, solution_limit, enable_output, threads, random_seed, absolute_gap_tolerance, relative_gap_tolerance, solution_pool_size, lp_algorithm, presolve, cuts, heuristics, scaling, gscip[], gurobi[], glop[], cp_sat[], pdlp[], osqp[], glpk[], highs[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SolveParametersProto)
    initpos = position(e.io)
    !isnothing(x.time_limit) && PB.encode(e, 1, x.time_limit)
    x.iteration_limit != zero(Int64) && PB.encode(e, 2, x.iteration_limit)
    x.node_limit != zero(Int64) && PB.encode(e, 24, x.node_limit)
    x.cutoff_limit !== zero(Float64) && PB.encode(e, 20, x.cutoff_limit)
    x.objective_limit !== zero(Float64) && PB.encode(e, 21, x.objective_limit)
    x.best_bound_limit !== zero(Float64) && PB.encode(e, 22, x.best_bound_limit)
    x.solution_limit != zero(Int32) && PB.encode(e, 23, x.solution_limit)
    x.enable_output != false && PB.encode(e, 3, x.enable_output)
    x.threads != zero(Int32) && PB.encode(e, 4, x.threads)
    x.random_seed != zero(Int32) && PB.encode(e, 5, x.random_seed)
    x.absolute_gap_tolerance !== zero(Float64) && PB.encode(e, 18, x.absolute_gap_tolerance)
    x.relative_gap_tolerance !== zero(Float64) && PB.encode(e, 17, x.relative_gap_tolerance)
    x.solution_pool_size != zero(Int32) && PB.encode(e, 25, x.solution_pool_size)
    x.lp_algorithm != LPAlgorithmProto.LP_ALGORITHM_UNSPECIFIED && PB.encode(e, 6, x.lp_algorithm)
    x.presolve != EmphasisProto.EMPHASIS_UNSPECIFIED && PB.encode(e, 7, x.presolve)
    x.cuts != EmphasisProto.EMPHASIS_UNSPECIFIED && PB.encode(e, 8, x.cuts)
    x.heuristics != EmphasisProto.EMPHASIS_UNSPECIFIED && PB.encode(e, 9, x.heuristics)
    x.scaling != EmphasisProto.EMPHASIS_UNSPECIFIED && PB.encode(e, 10, x.scaling)
    !isnothing(x.gscip) && PB.encode(e, 12, x.gscip)
    !isnothing(x.gurobi) && PB.encode(e, 13, x.gurobi)
    !isnothing(x.glop) && PB.encode(e, 14, x.glop)
    !isnothing(x.cp_sat) && PB.encode(e, 15, x.cp_sat)
    !isnothing(x.pdlp) && PB.encode(e, 16, x.pdlp)
    !isnothing(x.osqp) && PB.encode(e, 19, x.osqp)
    !isnothing(x.glpk) && PB.encode(e, 26, x.glpk)
    !isnothing(x.highs) && PB.encode(e, 27, x.highs)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SolveParametersProto)
    encoded_size = 0
    !isnothing(x.time_limit) && (encoded_size += PB._encoded_size(x.time_limit, 1))
    x.iteration_limit != zero(Int64) && (encoded_size += PB._encoded_size(x.iteration_limit, 2))
    x.node_limit != zero(Int64) && (encoded_size += PB._encoded_size(x.node_limit, 24))
    x.cutoff_limit !== zero(Float64) && (encoded_size += PB._encoded_size(x.cutoff_limit, 20))
    x.objective_limit !== zero(Float64) && (encoded_size += PB._encoded_size(x.objective_limit, 21))
    x.best_bound_limit !== zero(Float64) && (encoded_size += PB._encoded_size(x.best_bound_limit, 22))
    x.solution_limit != zero(Int32) && (encoded_size += PB._encoded_size(x.solution_limit, 23))
    x.enable_output != false && (encoded_size += PB._encoded_size(x.enable_output, 3))
    x.threads != zero(Int32) && (encoded_size += PB._encoded_size(x.threads, 4))
    x.random_seed != zero(Int32) && (encoded_size += PB._encoded_size(x.random_seed, 5))
    x.absolute_gap_tolerance !== zero(Float64) && (encoded_size += PB._encoded_size(x.absolute_gap_tolerance, 18))
    x.relative_gap_tolerance !== zero(Float64) && (encoded_size += PB._encoded_size(x.relative_gap_tolerance, 17))
    x.solution_pool_size != zero(Int32) && (encoded_size += PB._encoded_size(x.solution_pool_size, 25))
    x.lp_algorithm != LPAlgorithmProto.LP_ALGORITHM_UNSPECIFIED && (encoded_size += PB._encoded_size(x.lp_algorithm, 6))
    x.presolve != EmphasisProto.EMPHASIS_UNSPECIFIED && (encoded_size += PB._encoded_size(x.presolve, 7))
    x.cuts != EmphasisProto.EMPHASIS_UNSPECIFIED && (encoded_size += PB._encoded_size(x.cuts, 8))
    x.heuristics != EmphasisProto.EMPHASIS_UNSPECIFIED && (encoded_size += PB._encoded_size(x.heuristics, 9))
    x.scaling != EmphasisProto.EMPHASIS_UNSPECIFIED && (encoded_size += PB._encoded_size(x.scaling, 10))
    !isnothing(x.gscip) && (encoded_size += PB._encoded_size(x.gscip, 12))
    !isnothing(x.gurobi) && (encoded_size += PB._encoded_size(x.gurobi, 13))
    !isnothing(x.glop) && (encoded_size += PB._encoded_size(x.glop, 14))
    !isnothing(x.cp_sat) && (encoded_size += PB._encoded_size(x.cp_sat, 15))
    !isnothing(x.pdlp) && (encoded_size += PB._encoded_size(x.pdlp, 16))
    !isnothing(x.osqp) && (encoded_size += PB._encoded_size(x.osqp, 19))
    !isnothing(x.glpk) && (encoded_size += PB._encoded_size(x.glpk, 26))
    !isnothing(x.highs) && (encoded_size += PB._encoded_size(x.highs, 27))
    return encoded_size
end
