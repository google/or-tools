# Autogenerated using ProtoBuf.jl v1.1.1 on 2025-07-02T15:45:02.131
# original file: /usr/local/google/home/tcuvelier/.julia/artifacts/502992654d3e610bc079dfc8ac9e663bff6f3a24/include/ortools/pdlp/solvers.proto (proto2 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export var"TerminationCriteria.SimpleOptimalityCriteria"
export var"PrimalDualHybridGradientParams.PresolveOptions", MalitskyPockParams
export OptimalityNorm, var"PrimalDualHybridGradientParams.RestartStrategy", SchedulerType
export var"PrimalDualHybridGradientParams.LinesearchRule"
export var"TerminationCriteria.DetailedOptimalityCriteria", AdaptiveLinesearchParams
export TerminationCriteria, PrimalDualHybridGradientParams


struct var"TerminationCriteria.SimpleOptimalityCriteria"
    eps_optimal_absolute::Float64
    eps_optimal_relative::Float64
end
PB.default_values(::Type{var"TerminationCriteria.SimpleOptimalityCriteria"}) = (;eps_optimal_absolute = Float64(1.0e-6), eps_optimal_relative = Float64(1.0e-6))
PB.field_numbers(::Type{var"TerminationCriteria.SimpleOptimalityCriteria"}) = (;eps_optimal_absolute = 1, eps_optimal_relative = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"TerminationCriteria.SimpleOptimalityCriteria"})
    eps_optimal_absolute = Float64(1.0e-6)
    eps_optimal_relative = Float64(1.0e-6)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            eps_optimal_absolute = PB.decode(d, Float64)
        elseif field_number == 2
            eps_optimal_relative = PB.decode(d, Float64)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"TerminationCriteria.SimpleOptimalityCriteria"(eps_optimal_absolute, eps_optimal_relative)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"TerminationCriteria.SimpleOptimalityCriteria")
    initpos = position(e.io)
    x.eps_optimal_absolute !== Float64(1.0e-6) && PB.encode(e, 1, x.eps_optimal_absolute)
    x.eps_optimal_relative !== Float64(1.0e-6) && PB.encode(e, 2, x.eps_optimal_relative)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"TerminationCriteria.SimpleOptimalityCriteria")
    encoded_size = 0
    x.eps_optimal_absolute !== Float64(1.0e-6) && (encoded_size += PB._encoded_size(x.eps_optimal_absolute, 1))
    x.eps_optimal_relative !== Float64(1.0e-6) && (encoded_size += PB._encoded_size(x.eps_optimal_relative, 2))
    return encoded_size
end

struct var"PrimalDualHybridGradientParams.PresolveOptions"
    use_glop::Bool
    glop_parameters::Union{Nothing,operations_research.glop.GlopParameters}
end
PB.default_values(::Type{var"PrimalDualHybridGradientParams.PresolveOptions"}) = (;use_glop = false, glop_parameters = nothing)
PB.field_numbers(::Type{var"PrimalDualHybridGradientParams.PresolveOptions"}) = (;use_glop = 1, glop_parameters = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"PrimalDualHybridGradientParams.PresolveOptions"})
    use_glop = false
    glop_parameters = Ref{Union{Nothing,operations_research.glop.GlopParameters}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            use_glop = PB.decode(d, Bool)
        elseif field_number == 2
            PB.decode!(d, glop_parameters)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"PrimalDualHybridGradientParams.PresolveOptions"(use_glop, glop_parameters[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"PrimalDualHybridGradientParams.PresolveOptions")
    initpos = position(e.io)
    x.use_glop != false && PB.encode(e, 1, x.use_glop)
    !isnothing(x.glop_parameters) && PB.encode(e, 2, x.glop_parameters)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"PrimalDualHybridGradientParams.PresolveOptions")
    encoded_size = 0
    x.use_glop != false && (encoded_size += PB._encoded_size(x.use_glop, 1))
    !isnothing(x.glop_parameters) && (encoded_size += PB._encoded_size(x.glop_parameters, 2))
    return encoded_size
end

struct MalitskyPockParams
    step_size_downscaling_factor::Float64
    linesearch_contraction_factor::Float64
    step_size_interpolation::Float64
end
PB.default_values(::Type{MalitskyPockParams}) = (;step_size_downscaling_factor = Float64(0.7), linesearch_contraction_factor = Float64(0.99), step_size_interpolation = Float64(1))
PB.field_numbers(::Type{MalitskyPockParams}) = (;step_size_downscaling_factor = 1, linesearch_contraction_factor = 2, step_size_interpolation = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MalitskyPockParams})
    step_size_downscaling_factor = Float64(0.7)
    linesearch_contraction_factor = Float64(0.99)
    step_size_interpolation = Float64(1)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            step_size_downscaling_factor = PB.decode(d, Float64)
        elseif field_number == 2
            linesearch_contraction_factor = PB.decode(d, Float64)
        elseif field_number == 3
            step_size_interpolation = PB.decode(d, Float64)
        else
            PB.skip(d, wire_type)
        end
    end
    return MalitskyPockParams(step_size_downscaling_factor, linesearch_contraction_factor, step_size_interpolation)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MalitskyPockParams)
    initpos = position(e.io)
    x.step_size_downscaling_factor !== Float64(0.7) && PB.encode(e, 1, x.step_size_downscaling_factor)
    x.linesearch_contraction_factor !== Float64(0.99) && PB.encode(e, 2, x.linesearch_contraction_factor)
    x.step_size_interpolation !== Float64(1) && PB.encode(e, 3, x.step_size_interpolation)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MalitskyPockParams)
    encoded_size = 0
    x.step_size_downscaling_factor !== Float64(0.7) && (encoded_size += PB._encoded_size(x.step_size_downscaling_factor, 1))
    x.linesearch_contraction_factor !== Float64(0.99) && (encoded_size += PB._encoded_size(x.linesearch_contraction_factor, 2))
    x.step_size_interpolation !== Float64(1) && (encoded_size += PB._encoded_size(x.step_size_interpolation, 3))
    return encoded_size
end

@enumx OptimalityNorm OPTIMALITY_NORM_UNSPECIFIED=0 OPTIMALITY_NORM_L_INF=1 OPTIMALITY_NORM_L2=2 OPTIMALITY_NORM_L_INF_COMPONENTWISE=3

@enumx var"PrimalDualHybridGradientParams.RestartStrategy" RESTART_STRATEGY_UNSPECIFIED=0 NO_RESTARTS=1 EVERY_MAJOR_ITERATION=2 ADAPTIVE_HEURISTIC=3 ADAPTIVE_DISTANCE_BASED=4

@enumx SchedulerType SCHEDULER_TYPE_UNSPECIFIED=0 SCHEDULER_TYPE_GOOGLE_THREADPOOL=1 SCHEDULER_TYPE_EIGEN_THREADPOOL=3

@enumx var"PrimalDualHybridGradientParams.LinesearchRule" LINESEARCH_RULE_UNSPECIFIED=0 ADAPTIVE_LINESEARCH_RULE=1 MALITSKY_POCK_LINESEARCH_RULE=2 CONSTANT_STEP_SIZE_RULE=3

struct var"TerminationCriteria.DetailedOptimalityCriteria"
    eps_optimal_primal_residual_absolute::Float64
    eps_optimal_primal_residual_relative::Float64
    eps_optimal_dual_residual_absolute::Float64
    eps_optimal_dual_residual_relative::Float64
    eps_optimal_objective_gap_absolute::Float64
    eps_optimal_objective_gap_relative::Float64
end
PB.default_values(::Type{var"TerminationCriteria.DetailedOptimalityCriteria"}) = (;eps_optimal_primal_residual_absolute = Float64(1.0e-6), eps_optimal_primal_residual_relative = Float64(1.0e-6), eps_optimal_dual_residual_absolute = Float64(1.0e-6), eps_optimal_dual_residual_relative = Float64(1.0e-6), eps_optimal_objective_gap_absolute = Float64(1.0e-6), eps_optimal_objective_gap_relative = Float64(1.0e-6))
PB.field_numbers(::Type{var"TerminationCriteria.DetailedOptimalityCriteria"}) = (;eps_optimal_primal_residual_absolute = 1, eps_optimal_primal_residual_relative = 2, eps_optimal_dual_residual_absolute = 3, eps_optimal_dual_residual_relative = 4, eps_optimal_objective_gap_absolute = 5, eps_optimal_objective_gap_relative = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"TerminationCriteria.DetailedOptimalityCriteria"})
    eps_optimal_primal_residual_absolute = Float64(1.0e-6)
    eps_optimal_primal_residual_relative = Float64(1.0e-6)
    eps_optimal_dual_residual_absolute = Float64(1.0e-6)
    eps_optimal_dual_residual_relative = Float64(1.0e-6)
    eps_optimal_objective_gap_absolute = Float64(1.0e-6)
    eps_optimal_objective_gap_relative = Float64(1.0e-6)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            eps_optimal_primal_residual_absolute = PB.decode(d, Float64)
        elseif field_number == 2
            eps_optimal_primal_residual_relative = PB.decode(d, Float64)
        elseif field_number == 3
            eps_optimal_dual_residual_absolute = PB.decode(d, Float64)
        elseif field_number == 4
            eps_optimal_dual_residual_relative = PB.decode(d, Float64)
        elseif field_number == 5
            eps_optimal_objective_gap_absolute = PB.decode(d, Float64)
        elseif field_number == 6
            eps_optimal_objective_gap_relative = PB.decode(d, Float64)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"TerminationCriteria.DetailedOptimalityCriteria"(eps_optimal_primal_residual_absolute, eps_optimal_primal_residual_relative, eps_optimal_dual_residual_absolute, eps_optimal_dual_residual_relative, eps_optimal_objective_gap_absolute, eps_optimal_objective_gap_relative)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"TerminationCriteria.DetailedOptimalityCriteria")
    initpos = position(e.io)
    x.eps_optimal_primal_residual_absolute !== Float64(1.0e-6) && PB.encode(e, 1, x.eps_optimal_primal_residual_absolute)
    x.eps_optimal_primal_residual_relative !== Float64(1.0e-6) && PB.encode(e, 2, x.eps_optimal_primal_residual_relative)
    x.eps_optimal_dual_residual_absolute !== Float64(1.0e-6) && PB.encode(e, 3, x.eps_optimal_dual_residual_absolute)
    x.eps_optimal_dual_residual_relative !== Float64(1.0e-6) && PB.encode(e, 4, x.eps_optimal_dual_residual_relative)
    x.eps_optimal_objective_gap_absolute !== Float64(1.0e-6) && PB.encode(e, 5, x.eps_optimal_objective_gap_absolute)
    x.eps_optimal_objective_gap_relative !== Float64(1.0e-6) && PB.encode(e, 6, x.eps_optimal_objective_gap_relative)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"TerminationCriteria.DetailedOptimalityCriteria")
    encoded_size = 0
    x.eps_optimal_primal_residual_absolute !== Float64(1.0e-6) && (encoded_size += PB._encoded_size(x.eps_optimal_primal_residual_absolute, 1))
    x.eps_optimal_primal_residual_relative !== Float64(1.0e-6) && (encoded_size += PB._encoded_size(x.eps_optimal_primal_residual_relative, 2))
    x.eps_optimal_dual_residual_absolute !== Float64(1.0e-6) && (encoded_size += PB._encoded_size(x.eps_optimal_dual_residual_absolute, 3))
    x.eps_optimal_dual_residual_relative !== Float64(1.0e-6) && (encoded_size += PB._encoded_size(x.eps_optimal_dual_residual_relative, 4))
    x.eps_optimal_objective_gap_absolute !== Float64(1.0e-6) && (encoded_size += PB._encoded_size(x.eps_optimal_objective_gap_absolute, 5))
    x.eps_optimal_objective_gap_relative !== Float64(1.0e-6) && (encoded_size += PB._encoded_size(x.eps_optimal_objective_gap_relative, 6))
    return encoded_size
end

struct AdaptiveLinesearchParams
    step_size_reduction_exponent::Float64
    step_size_growth_exponent::Float64
end
PB.default_values(::Type{AdaptiveLinesearchParams}) = (;step_size_reduction_exponent = Float64(0.3), step_size_growth_exponent = Float64(0.6))
PB.field_numbers(::Type{AdaptiveLinesearchParams}) = (;step_size_reduction_exponent = 1, step_size_growth_exponent = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:AdaptiveLinesearchParams})
    step_size_reduction_exponent = Float64(0.3)
    step_size_growth_exponent = Float64(0.6)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            step_size_reduction_exponent = PB.decode(d, Float64)
        elseif field_number == 2
            step_size_growth_exponent = PB.decode(d, Float64)
        else
            PB.skip(d, wire_type)
        end
    end
    return AdaptiveLinesearchParams(step_size_reduction_exponent, step_size_growth_exponent)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::AdaptiveLinesearchParams)
    initpos = position(e.io)
    x.step_size_reduction_exponent !== Float64(0.3) && PB.encode(e, 1, x.step_size_reduction_exponent)
    x.step_size_growth_exponent !== Float64(0.6) && PB.encode(e, 2, x.step_size_growth_exponent)
    return position(e.io) - initpos
end
function PB._encoded_size(x::AdaptiveLinesearchParams)
    encoded_size = 0
    x.step_size_reduction_exponent !== Float64(0.3) && (encoded_size += PB._encoded_size(x.step_size_reduction_exponent, 1))
    x.step_size_growth_exponent !== Float64(0.6) && (encoded_size += PB._encoded_size(x.step_size_growth_exponent, 2))
    return encoded_size
end

struct TerminationCriteria
    optimality_norm::OptimalityNorm.T
    optimality_criteria::Union{Nothing,OneOf{<:Union{var"TerminationCriteria.SimpleOptimalityCriteria",var"TerminationCriteria.DetailedOptimalityCriteria"}}}
    eps_optimal_absolute::Float64
    eps_optimal_relative::Float64
    eps_primal_infeasible::Float64
    eps_dual_infeasible::Float64
    time_sec_limit::Float64
    iteration_limit::Int32
    kkt_matrix_pass_limit::Float64
end
PB.oneof_field_types(::Type{TerminationCriteria}) = (;
    optimality_criteria = (;simple_optimality_criteria=var"TerminationCriteria.SimpleOptimalityCriteria", detailed_optimality_criteria=var"TerminationCriteria.DetailedOptimalityCriteria"),
)
PB.default_values(::Type{TerminationCriteria}) = (;optimality_norm = OptimalityNorm.OPTIMALITY_NORM_L2, simple_optimality_criteria = nothing, detailed_optimality_criteria = nothing, eps_optimal_absolute = Float64(1.0e-6), eps_optimal_relative = Float64(1.0e-6), eps_primal_infeasible = Float64(1.0e-8), eps_dual_infeasible = Float64(1.0e-8), time_sec_limit = Float64(Inf), iteration_limit = Int32(2147483647), kkt_matrix_pass_limit = Float64(Inf))
PB.field_numbers(::Type{TerminationCriteria}) = (;optimality_norm = 1, simple_optimality_criteria = 9, detailed_optimality_criteria = 10, eps_optimal_absolute = 2, eps_optimal_relative = 3, eps_primal_infeasible = 4, eps_dual_infeasible = 5, time_sec_limit = 6, iteration_limit = 7, kkt_matrix_pass_limit = 8)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:TerminationCriteria})
    optimality_norm = OptimalityNorm.OPTIMALITY_NORM_L2
    optimality_criteria = nothing
    eps_optimal_absolute = Float64(1.0e-6)
    eps_optimal_relative = Float64(1.0e-6)
    eps_primal_infeasible = Float64(1.0e-8)
    eps_dual_infeasible = Float64(1.0e-8)
    time_sec_limit = Float64(Inf)
    iteration_limit = Int32(2147483647)
    kkt_matrix_pass_limit = Float64(Inf)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            optimality_norm = PB.decode(d, OptimalityNorm.T)
        elseif field_number == 9
            optimality_criteria = OneOf(:simple_optimality_criteria, PB.decode(d, Ref{var"TerminationCriteria.SimpleOptimalityCriteria"}))
        elseif field_number == 10
            optimality_criteria = OneOf(:detailed_optimality_criteria, PB.decode(d, Ref{var"TerminationCriteria.DetailedOptimalityCriteria"}))
        elseif field_number == 2
            eps_optimal_absolute = PB.decode(d, Float64)
        elseif field_number == 3
            eps_optimal_relative = PB.decode(d, Float64)
        elseif field_number == 4
            eps_primal_infeasible = PB.decode(d, Float64)
        elseif field_number == 5
            eps_dual_infeasible = PB.decode(d, Float64)
        elseif field_number == 6
            time_sec_limit = PB.decode(d, Float64)
        elseif field_number == 7
            iteration_limit = PB.decode(d, Int32)
        elseif field_number == 8
            kkt_matrix_pass_limit = PB.decode(d, Float64)
        else
            PB.skip(d, wire_type)
        end
    end
    return TerminationCriteria(optimality_norm, optimality_criteria, eps_optimal_absolute, eps_optimal_relative, eps_primal_infeasible, eps_dual_infeasible, time_sec_limit, iteration_limit, kkt_matrix_pass_limit)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::TerminationCriteria)
    initpos = position(e.io)
    x.optimality_norm != OptimalityNorm.OPTIMALITY_NORM_L2 && PB.encode(e, 1, x.optimality_norm)
    if isnothing(x.optimality_criteria);
    elseif x.optimality_criteria.name === :simple_optimality_criteria
        PB.encode(e, 9, x.optimality_criteria[]::var"TerminationCriteria.SimpleOptimalityCriteria")
    elseif x.optimality_criteria.name === :detailed_optimality_criteria
        PB.encode(e, 10, x.optimality_criteria[]::var"TerminationCriteria.DetailedOptimalityCriteria")
    end
    x.eps_optimal_absolute !== Float64(1.0e-6) && PB.encode(e, 2, x.eps_optimal_absolute)
    x.eps_optimal_relative !== Float64(1.0e-6) && PB.encode(e, 3, x.eps_optimal_relative)
    x.eps_primal_infeasible !== Float64(1.0e-8) && PB.encode(e, 4, x.eps_primal_infeasible)
    x.eps_dual_infeasible !== Float64(1.0e-8) && PB.encode(e, 5, x.eps_dual_infeasible)
    x.time_sec_limit !== Float64(Inf) && PB.encode(e, 6, x.time_sec_limit)
    x.iteration_limit != Int32(2147483647) && PB.encode(e, 7, x.iteration_limit)
    x.kkt_matrix_pass_limit !== Float64(Inf) && PB.encode(e, 8, x.kkt_matrix_pass_limit)
    return position(e.io) - initpos
end
function PB._encoded_size(x::TerminationCriteria)
    encoded_size = 0
    x.optimality_norm != OptimalityNorm.OPTIMALITY_NORM_L2 && (encoded_size += PB._encoded_size(x.optimality_norm, 1))
    if isnothing(x.optimality_criteria);
    elseif x.optimality_criteria.name === :simple_optimality_criteria
        encoded_size += PB._encoded_size(x.optimality_criteria[]::var"TerminationCriteria.SimpleOptimalityCriteria", 9)
    elseif x.optimality_criteria.name === :detailed_optimality_criteria
        encoded_size += PB._encoded_size(x.optimality_criteria[]::var"TerminationCriteria.DetailedOptimalityCriteria", 10)
    end
    x.eps_optimal_absolute !== Float64(1.0e-6) && (encoded_size += PB._encoded_size(x.eps_optimal_absolute, 2))
    x.eps_optimal_relative !== Float64(1.0e-6) && (encoded_size += PB._encoded_size(x.eps_optimal_relative, 3))
    x.eps_primal_infeasible !== Float64(1.0e-8) && (encoded_size += PB._encoded_size(x.eps_primal_infeasible, 4))
    x.eps_dual_infeasible !== Float64(1.0e-8) && (encoded_size += PB._encoded_size(x.eps_dual_infeasible, 5))
    x.time_sec_limit !== Float64(Inf) && (encoded_size += PB._encoded_size(x.time_sec_limit, 6))
    x.iteration_limit != Int32(2147483647) && (encoded_size += PB._encoded_size(x.iteration_limit, 7))
    x.kkt_matrix_pass_limit !== Float64(Inf) && (encoded_size += PB._encoded_size(x.kkt_matrix_pass_limit, 8))
    return encoded_size
end

struct PrimalDualHybridGradientParams
    termination_criteria::Union{Nothing,TerminationCriteria}
    num_threads::Int32
    num_shards::Int32
    scheduler_type::SchedulerType.T
    record_iteration_stats::Bool
    verbosity_level::Int32
    log_interval_seconds::Float64
    major_iteration_frequency::Int32
    termination_check_frequency::Int32
    restart_strategy::var"PrimalDualHybridGradientParams.RestartStrategy".T
    primal_weight_update_smoothing::Float64
    initial_primal_weight::Float64
    presolve_options::Union{Nothing,var"PrimalDualHybridGradientParams.PresolveOptions"}
    l_inf_ruiz_iterations::Int32
    l2_norm_rescaling::Bool
    sufficient_reduction_for_restart::Float64
    necessary_reduction_for_restart::Float64
    linesearch_rule::var"PrimalDualHybridGradientParams.LinesearchRule".T
    adaptive_linesearch_parameters::Union{Nothing,AdaptiveLinesearchParams}
    malitsky_pock_parameters::Union{Nothing,MalitskyPockParams}
    initial_step_size_scaling::Float64
    random_projection_seeds::Vector{Int32}
    infinite_constraint_bound_threshold::Float64
    handle_some_primal_gradients_on_finite_bounds_as_residuals::Bool
    use_diagonal_qp_trust_region_solver::Bool
    diagonal_qp_trust_region_solver_tolerance::Float64
    use_feasibility_polishing::Bool
    apply_feasibility_polishing_after_limits_reached::Bool
    apply_feasibility_polishing_if_solver_is_interrupted::Bool
end
PB.reserved_fields(::Type{PrimalDualHybridGradientParams}) = (names = String[], numbers = Union{Int,UnitRange{Int}}[13, 14, 15, 20, 21])
PB.default_values(::Type{PrimalDualHybridGradientParams}) = (;termination_criteria = nothing, num_threads = Int32(1), num_shards = Int32(0), scheduler_type = SchedulerType.SCHEDULER_TYPE_GOOGLE_THREADPOOL, record_iteration_stats = false, verbosity_level = Int32(0), log_interval_seconds = Float64(0.0), major_iteration_frequency = Int32(64), termination_check_frequency = Int32(64), restart_strategy = var"PrimalDualHybridGradientParams.RestartStrategy".ADAPTIVE_HEURISTIC, primal_weight_update_smoothing = Float64(0.5), initial_primal_weight = zero(Float64), presolve_options = nothing, l_inf_ruiz_iterations = Int32(5), l2_norm_rescaling = true, sufficient_reduction_for_restart = Float64(0.1), necessary_reduction_for_restart = Float64(0.9), linesearch_rule = var"PrimalDualHybridGradientParams.LinesearchRule".ADAPTIVE_LINESEARCH_RULE, adaptive_linesearch_parameters = nothing, malitsky_pock_parameters = nothing, initial_step_size_scaling = Float64(1.0), random_projection_seeds = Vector{Int32}(), infinite_constraint_bound_threshold = Float64(Inf), handle_some_primal_gradients_on_finite_bounds_as_residuals = true, use_diagonal_qp_trust_region_solver = false, diagonal_qp_trust_region_solver_tolerance = Float64(1.0e-8), use_feasibility_polishing = false, apply_feasibility_polishing_after_limits_reached = false, apply_feasibility_polishing_if_solver_is_interrupted = false)
PB.field_numbers(::Type{PrimalDualHybridGradientParams}) = (;termination_criteria = 1, num_threads = 2, num_shards = 27, scheduler_type = 32, record_iteration_stats = 3, verbosity_level = 26, log_interval_seconds = 31, major_iteration_frequency = 4, termination_check_frequency = 5, restart_strategy = 6, primal_weight_update_smoothing = 7, initial_primal_weight = 8, presolve_options = 16, l_inf_ruiz_iterations = 9, l2_norm_rescaling = 10, sufficient_reduction_for_restart = 11, necessary_reduction_for_restart = 17, linesearch_rule = 12, adaptive_linesearch_parameters = 18, malitsky_pock_parameters = 19, initial_step_size_scaling = 25, random_projection_seeds = 28, infinite_constraint_bound_threshold = 22, handle_some_primal_gradients_on_finite_bounds_as_residuals = 29, use_diagonal_qp_trust_region_solver = 23, diagonal_qp_trust_region_solver_tolerance = 24, use_feasibility_polishing = 30, apply_feasibility_polishing_after_limits_reached = 33, apply_feasibility_polishing_if_solver_is_interrupted = 34)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:PrimalDualHybridGradientParams})
    termination_criteria = Ref{Union{Nothing,TerminationCriteria}}(nothing)
    num_threads = Int32(1)
    num_shards = Int32(0)
    scheduler_type = SchedulerType.SCHEDULER_TYPE_GOOGLE_THREADPOOL
    record_iteration_stats = false
    verbosity_level = Int32(0)
    log_interval_seconds = Float64(0.0)
    major_iteration_frequency = Int32(64)
    termination_check_frequency = Int32(64)
    restart_strategy = var"PrimalDualHybridGradientParams.RestartStrategy".ADAPTIVE_HEURISTIC
    primal_weight_update_smoothing = Float64(0.5)
    initial_primal_weight = zero(Float64)
    presolve_options = Ref{Union{Nothing,var"PrimalDualHybridGradientParams.PresolveOptions"}}(nothing)
    l_inf_ruiz_iterations = Int32(5)
    l2_norm_rescaling = true
    sufficient_reduction_for_restart = Float64(0.1)
    necessary_reduction_for_restart = Float64(0.9)
    linesearch_rule = var"PrimalDualHybridGradientParams.LinesearchRule".ADAPTIVE_LINESEARCH_RULE
    adaptive_linesearch_parameters = Ref{Union{Nothing,AdaptiveLinesearchParams}}(nothing)
    malitsky_pock_parameters = Ref{Union{Nothing,MalitskyPockParams}}(nothing)
    initial_step_size_scaling = Float64(1.0)
    random_projection_seeds = PB.BufferedVector{Int32}()
    infinite_constraint_bound_threshold = Float64(Inf)
    handle_some_primal_gradients_on_finite_bounds_as_residuals = true
    use_diagonal_qp_trust_region_solver = false
    diagonal_qp_trust_region_solver_tolerance = Float64(1.0e-8)
    use_feasibility_polishing = false
    apply_feasibility_polishing_after_limits_reached = false
    apply_feasibility_polishing_if_solver_is_interrupted = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, termination_criteria)
        elseif field_number == 2
            num_threads = PB.decode(d, Int32)
        elseif field_number == 27
            num_shards = PB.decode(d, Int32)
        elseif field_number == 32
            scheduler_type = PB.decode(d, SchedulerType.T)
        elseif field_number == 3
            record_iteration_stats = PB.decode(d, Bool)
        elseif field_number == 26
            verbosity_level = PB.decode(d, Int32)
        elseif field_number == 31
            log_interval_seconds = PB.decode(d, Float64)
        elseif field_number == 4
            major_iteration_frequency = PB.decode(d, Int32)
        elseif field_number == 5
            termination_check_frequency = PB.decode(d, Int32)
        elseif field_number == 6
            restart_strategy = PB.decode(d, var"PrimalDualHybridGradientParams.RestartStrategy".T)
        elseif field_number == 7
            primal_weight_update_smoothing = PB.decode(d, Float64)
        elseif field_number == 8
            initial_primal_weight = PB.decode(d, Float64)
        elseif field_number == 16
            PB.decode!(d, presolve_options)
        elseif field_number == 9
            l_inf_ruiz_iterations = PB.decode(d, Int32)
        elseif field_number == 10
            l2_norm_rescaling = PB.decode(d, Bool)
        elseif field_number == 11
            sufficient_reduction_for_restart = PB.decode(d, Float64)
        elseif field_number == 17
            necessary_reduction_for_restart = PB.decode(d, Float64)
        elseif field_number == 12
            linesearch_rule = PB.decode(d, var"PrimalDualHybridGradientParams.LinesearchRule".T)
        elseif field_number == 18
            PB.decode!(d, adaptive_linesearch_parameters)
        elseif field_number == 19
            PB.decode!(d, malitsky_pock_parameters)
        elseif field_number == 25
            initial_step_size_scaling = PB.decode(d, Float64)
        elseif field_number == 28
            PB.decode!(d, wire_type, random_projection_seeds)
        elseif field_number == 22
            infinite_constraint_bound_threshold = PB.decode(d, Float64)
        elseif field_number == 29
            handle_some_primal_gradients_on_finite_bounds_as_residuals = PB.decode(d, Bool)
        elseif field_number == 23
            use_diagonal_qp_trust_region_solver = PB.decode(d, Bool)
        elseif field_number == 24
            diagonal_qp_trust_region_solver_tolerance = PB.decode(d, Float64)
        elseif field_number == 30
            use_feasibility_polishing = PB.decode(d, Bool)
        elseif field_number == 33
            apply_feasibility_polishing_after_limits_reached = PB.decode(d, Bool)
        elseif field_number == 34
            apply_feasibility_polishing_if_solver_is_interrupted = PB.decode(d, Bool)
        else
            PB.skip(d, wire_type)
        end
    end
    return PrimalDualHybridGradientParams(termination_criteria[], num_threads, num_shards, scheduler_type, record_iteration_stats, verbosity_level, log_interval_seconds, major_iteration_frequency, termination_check_frequency, restart_strategy, primal_weight_update_smoothing, initial_primal_weight, presolve_options[], l_inf_ruiz_iterations, l2_norm_rescaling, sufficient_reduction_for_restart, necessary_reduction_for_restart, linesearch_rule, adaptive_linesearch_parameters[], malitsky_pock_parameters[], initial_step_size_scaling, random_projection_seeds[], infinite_constraint_bound_threshold, handle_some_primal_gradients_on_finite_bounds_as_residuals, use_diagonal_qp_trust_region_solver, diagonal_qp_trust_region_solver_tolerance, use_feasibility_polishing, apply_feasibility_polishing_after_limits_reached, apply_feasibility_polishing_if_solver_is_interrupted)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::PrimalDualHybridGradientParams)
    initpos = position(e.io)
    !isnothing(x.termination_criteria) && PB.encode(e, 1, x.termination_criteria)
    x.num_threads != Int32(1) && PB.encode(e, 2, x.num_threads)
    x.num_shards != Int32(0) && PB.encode(e, 27, x.num_shards)
    x.scheduler_type != SchedulerType.SCHEDULER_TYPE_GOOGLE_THREADPOOL && PB.encode(e, 32, x.scheduler_type)
    x.record_iteration_stats != false && PB.encode(e, 3, x.record_iteration_stats)
    x.verbosity_level != Int32(0) && PB.encode(e, 26, x.verbosity_level)
    x.log_interval_seconds !== Float64(0.0) && PB.encode(e, 31, x.log_interval_seconds)
    x.major_iteration_frequency != Int32(64) && PB.encode(e, 4, x.major_iteration_frequency)
    x.termination_check_frequency != Int32(64) && PB.encode(e, 5, x.termination_check_frequency)
    x.restart_strategy != var"PrimalDualHybridGradientParams.RestartStrategy".ADAPTIVE_HEURISTIC && PB.encode(e, 6, x.restart_strategy)
    x.primal_weight_update_smoothing !== Float64(0.5) && PB.encode(e, 7, x.primal_weight_update_smoothing)
    x.initial_primal_weight !== zero(Float64) && PB.encode(e, 8, x.initial_primal_weight)
    !isnothing(x.presolve_options) && PB.encode(e, 16, x.presolve_options)
    x.l_inf_ruiz_iterations != Int32(5) && PB.encode(e, 9, x.l_inf_ruiz_iterations)
    x.l2_norm_rescaling != true && PB.encode(e, 10, x.l2_norm_rescaling)
    x.sufficient_reduction_for_restart !== Float64(0.1) && PB.encode(e, 11, x.sufficient_reduction_for_restart)
    x.necessary_reduction_for_restart !== Float64(0.9) && PB.encode(e, 17, x.necessary_reduction_for_restart)
    x.linesearch_rule != var"PrimalDualHybridGradientParams.LinesearchRule".ADAPTIVE_LINESEARCH_RULE && PB.encode(e, 12, x.linesearch_rule)
    !isnothing(x.adaptive_linesearch_parameters) && PB.encode(e, 18, x.adaptive_linesearch_parameters)
    !isnothing(x.malitsky_pock_parameters) && PB.encode(e, 19, x.malitsky_pock_parameters)
    x.initial_step_size_scaling !== Float64(1.0) && PB.encode(e, 25, x.initial_step_size_scaling)
    !isempty(x.random_projection_seeds) && PB.encode(e, 28, x.random_projection_seeds)
    x.infinite_constraint_bound_threshold !== Float64(Inf) && PB.encode(e, 22, x.infinite_constraint_bound_threshold)
    x.handle_some_primal_gradients_on_finite_bounds_as_residuals != true && PB.encode(e, 29, x.handle_some_primal_gradients_on_finite_bounds_as_residuals)
    x.use_diagonal_qp_trust_region_solver != false && PB.encode(e, 23, x.use_diagonal_qp_trust_region_solver)
    x.diagonal_qp_trust_region_solver_tolerance !== Float64(1.0e-8) && PB.encode(e, 24, x.diagonal_qp_trust_region_solver_tolerance)
    x.use_feasibility_polishing != false && PB.encode(e, 30, x.use_feasibility_polishing)
    x.apply_feasibility_polishing_after_limits_reached != false && PB.encode(e, 33, x.apply_feasibility_polishing_after_limits_reached)
    x.apply_feasibility_polishing_if_solver_is_interrupted != false && PB.encode(e, 34, x.apply_feasibility_polishing_if_solver_is_interrupted)
    return position(e.io) - initpos
end
function PB._encoded_size(x::PrimalDualHybridGradientParams)
    encoded_size = 0
    !isnothing(x.termination_criteria) && (encoded_size += PB._encoded_size(x.termination_criteria, 1))
    x.num_threads != Int32(1) && (encoded_size += PB._encoded_size(x.num_threads, 2))
    x.num_shards != Int32(0) && (encoded_size += PB._encoded_size(x.num_shards, 27))
    x.scheduler_type != SchedulerType.SCHEDULER_TYPE_GOOGLE_THREADPOOL && (encoded_size += PB._encoded_size(x.scheduler_type, 32))
    x.record_iteration_stats != false && (encoded_size += PB._encoded_size(x.record_iteration_stats, 3))
    x.verbosity_level != Int32(0) && (encoded_size += PB._encoded_size(x.verbosity_level, 26))
    x.log_interval_seconds !== Float64(0.0) && (encoded_size += PB._encoded_size(x.log_interval_seconds, 31))
    x.major_iteration_frequency != Int32(64) && (encoded_size += PB._encoded_size(x.major_iteration_frequency, 4))
    x.termination_check_frequency != Int32(64) && (encoded_size += PB._encoded_size(x.termination_check_frequency, 5))
    x.restart_strategy != var"PrimalDualHybridGradientParams.RestartStrategy".ADAPTIVE_HEURISTIC && (encoded_size += PB._encoded_size(x.restart_strategy, 6))
    x.primal_weight_update_smoothing !== Float64(0.5) && (encoded_size += PB._encoded_size(x.primal_weight_update_smoothing, 7))
    x.initial_primal_weight !== zero(Float64) && (encoded_size += PB._encoded_size(x.initial_primal_weight, 8))
    !isnothing(x.presolve_options) && (encoded_size += PB._encoded_size(x.presolve_options, 16))
    x.l_inf_ruiz_iterations != Int32(5) && (encoded_size += PB._encoded_size(x.l_inf_ruiz_iterations, 9))
    x.l2_norm_rescaling != true && (encoded_size += PB._encoded_size(x.l2_norm_rescaling, 10))
    x.sufficient_reduction_for_restart !== Float64(0.1) && (encoded_size += PB._encoded_size(x.sufficient_reduction_for_restart, 11))
    x.necessary_reduction_for_restart !== Float64(0.9) && (encoded_size += PB._encoded_size(x.necessary_reduction_for_restart, 17))
    x.linesearch_rule != var"PrimalDualHybridGradientParams.LinesearchRule".ADAPTIVE_LINESEARCH_RULE && (encoded_size += PB._encoded_size(x.linesearch_rule, 12))
    !isnothing(x.adaptive_linesearch_parameters) && (encoded_size += PB._encoded_size(x.adaptive_linesearch_parameters, 18))
    !isnothing(x.malitsky_pock_parameters) && (encoded_size += PB._encoded_size(x.malitsky_pock_parameters, 19))
    x.initial_step_size_scaling !== Float64(1.0) && (encoded_size += PB._encoded_size(x.initial_step_size_scaling, 25))
    !isempty(x.random_projection_seeds) && (encoded_size += PB._encoded_size(x.random_projection_seeds, 28))
    x.infinite_constraint_bound_threshold !== Float64(Inf) && (encoded_size += PB._encoded_size(x.infinite_constraint_bound_threshold, 22))
    x.handle_some_primal_gradients_on_finite_bounds_as_residuals != true && (encoded_size += PB._encoded_size(x.handle_some_primal_gradients_on_finite_bounds_as_residuals, 29))
    x.use_diagonal_qp_trust_region_solver != false && (encoded_size += PB._encoded_size(x.use_diagonal_qp_trust_region_solver, 23))
    x.diagonal_qp_trust_region_solver_tolerance !== Float64(1.0e-8) && (encoded_size += PB._encoded_size(x.diagonal_qp_trust_region_solver_tolerance, 24))
    x.use_feasibility_polishing != false && (encoded_size += PB._encoded_size(x.use_feasibility_polishing, 30))
    x.apply_feasibility_polishing_after_limits_reached != false && (encoded_size += PB._encoded_size(x.apply_feasibility_polishing_after_limits_reached, 33))
    x.apply_feasibility_polishing_if_solver_is_interrupted != false && (encoded_size += PB._encoded_size(x.apply_feasibility_polishing_if_solver_is_interrupted, 34))
    return encoded_size
end
