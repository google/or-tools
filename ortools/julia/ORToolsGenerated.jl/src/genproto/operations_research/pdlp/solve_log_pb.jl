# Autogenerated using ProtoBuf.jl v1.1.1 on 2025-07-02T15:45:02.132
# original file: /usr/local/google/home/tcuvelier/.julia/artifacts/502992654d3e610bc079dfc8ac9e663bff6f3a24/include/ortools/pdlp/solve_log.proto (proto2 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export QuadraticProgramStats, PolishingPhaseType, PointType, TerminationReason
export RestartChoice, PointMetadata, InfeasibilityInformation, ConvergenceInformation
export IterationStats, FeasibilityPolishingDetails, SolveLog


struct QuadraticProgramStats
    num_variables::Int64
    num_constraints::Int64
    constraint_matrix_col_min_l_inf_norm::Float64
    constraint_matrix_row_min_l_inf_norm::Float64
    constraint_matrix_num_nonzeros::Int64
    constraint_matrix_abs_max::Float64
    constraint_matrix_abs_min::Float64
    constraint_matrix_abs_avg::Float64
    constraint_matrix_l2_norm::Float64
    combined_bounds_max::Float64
    combined_bounds_min::Float64
    combined_bounds_avg::Float64
    combined_bounds_l2_norm::Float64
    combined_variable_bounds_max::Float64
    combined_variable_bounds_min::Float64
    combined_variable_bounds_avg::Float64
    combined_variable_bounds_l2_norm::Float64
    variable_bound_gaps_num_finite::Int64
    variable_bound_gaps_max::Float64
    variable_bound_gaps_min::Float64
    variable_bound_gaps_avg::Float64
    variable_bound_gaps_l2_norm::Float64
    objective_vector_abs_max::Float64
    objective_vector_abs_min::Float64
    objective_vector_abs_avg::Float64
    objective_vector_l2_norm::Float64
    objective_matrix_num_nonzeros::Int64
    objective_matrix_abs_max::Float64
    objective_matrix_abs_min::Float64
    objective_matrix_abs_avg::Float64
    objective_matrix_l2_norm::Float64
end
PB.default_values(::Type{QuadraticProgramStats}) = (;num_variables = zero(Int64), num_constraints = zero(Int64), constraint_matrix_col_min_l_inf_norm = zero(Float64), constraint_matrix_row_min_l_inf_norm = zero(Float64), constraint_matrix_num_nonzeros = zero(Int64), constraint_matrix_abs_max = zero(Float64), constraint_matrix_abs_min = zero(Float64), constraint_matrix_abs_avg = zero(Float64), constraint_matrix_l2_norm = zero(Float64), combined_bounds_max = zero(Float64), combined_bounds_min = zero(Float64), combined_bounds_avg = zero(Float64), combined_bounds_l2_norm = zero(Float64), combined_variable_bounds_max = zero(Float64), combined_variable_bounds_min = zero(Float64), combined_variable_bounds_avg = zero(Float64), combined_variable_bounds_l2_norm = zero(Float64), variable_bound_gaps_num_finite = zero(Int64), variable_bound_gaps_max = zero(Float64), variable_bound_gaps_min = zero(Float64), variable_bound_gaps_avg = zero(Float64), variable_bound_gaps_l2_norm = zero(Float64), objective_vector_abs_max = zero(Float64), objective_vector_abs_min = zero(Float64), objective_vector_abs_avg = zero(Float64), objective_vector_l2_norm = zero(Float64), objective_matrix_num_nonzeros = zero(Int64), objective_matrix_abs_max = zero(Float64), objective_matrix_abs_min = zero(Float64), objective_matrix_abs_avg = zero(Float64), objective_matrix_l2_norm = zero(Float64))
PB.field_numbers(::Type{QuadraticProgramStats}) = (;num_variables = 1, num_constraints = 2, constraint_matrix_col_min_l_inf_norm = 3, constraint_matrix_row_min_l_inf_norm = 4, constraint_matrix_num_nonzeros = 5, constraint_matrix_abs_max = 6, constraint_matrix_abs_min = 7, constraint_matrix_abs_avg = 8, constraint_matrix_l2_norm = 25, combined_bounds_max = 9, combined_bounds_min = 10, combined_bounds_avg = 11, combined_bounds_l2_norm = 24, combined_variable_bounds_max = 28, combined_variable_bounds_min = 29, combined_variable_bounds_avg = 30, combined_variable_bounds_l2_norm = 31, variable_bound_gaps_num_finite = 12, variable_bound_gaps_max = 13, variable_bound_gaps_min = 14, variable_bound_gaps_avg = 15, variable_bound_gaps_l2_norm = 26, objective_vector_abs_max = 16, objective_vector_abs_min = 17, objective_vector_abs_avg = 18, objective_vector_l2_norm = 23, objective_matrix_num_nonzeros = 19, objective_matrix_abs_max = 20, objective_matrix_abs_min = 21, objective_matrix_abs_avg = 22, objective_matrix_l2_norm = 27)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:QuadraticProgramStats})
    num_variables = zero(Int64)
    num_constraints = zero(Int64)
    constraint_matrix_col_min_l_inf_norm = zero(Float64)
    constraint_matrix_row_min_l_inf_norm = zero(Float64)
    constraint_matrix_num_nonzeros = zero(Int64)
    constraint_matrix_abs_max = zero(Float64)
    constraint_matrix_abs_min = zero(Float64)
    constraint_matrix_abs_avg = zero(Float64)
    constraint_matrix_l2_norm = zero(Float64)
    combined_bounds_max = zero(Float64)
    combined_bounds_min = zero(Float64)
    combined_bounds_avg = zero(Float64)
    combined_bounds_l2_norm = zero(Float64)
    combined_variable_bounds_max = zero(Float64)
    combined_variable_bounds_min = zero(Float64)
    combined_variable_bounds_avg = zero(Float64)
    combined_variable_bounds_l2_norm = zero(Float64)
    variable_bound_gaps_num_finite = zero(Int64)
    variable_bound_gaps_max = zero(Float64)
    variable_bound_gaps_min = zero(Float64)
    variable_bound_gaps_avg = zero(Float64)
    variable_bound_gaps_l2_norm = zero(Float64)
    objective_vector_abs_max = zero(Float64)
    objective_vector_abs_min = zero(Float64)
    objective_vector_abs_avg = zero(Float64)
    objective_vector_l2_norm = zero(Float64)
    objective_matrix_num_nonzeros = zero(Int64)
    objective_matrix_abs_max = zero(Float64)
    objective_matrix_abs_min = zero(Float64)
    objective_matrix_abs_avg = zero(Float64)
    objective_matrix_l2_norm = zero(Float64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            num_variables = PB.decode(d, Int64)
        elseif field_number == 2
            num_constraints = PB.decode(d, Int64)
        elseif field_number == 3
            constraint_matrix_col_min_l_inf_norm = PB.decode(d, Float64)
        elseif field_number == 4
            constraint_matrix_row_min_l_inf_norm = PB.decode(d, Float64)
        elseif field_number == 5
            constraint_matrix_num_nonzeros = PB.decode(d, Int64)
        elseif field_number == 6
            constraint_matrix_abs_max = PB.decode(d, Float64)
        elseif field_number == 7
            constraint_matrix_abs_min = PB.decode(d, Float64)
        elseif field_number == 8
            constraint_matrix_abs_avg = PB.decode(d, Float64)
        elseif field_number == 25
            constraint_matrix_l2_norm = PB.decode(d, Float64)
        elseif field_number == 9
            combined_bounds_max = PB.decode(d, Float64)
        elseif field_number == 10
            combined_bounds_min = PB.decode(d, Float64)
        elseif field_number == 11
            combined_bounds_avg = PB.decode(d, Float64)
        elseif field_number == 24
            combined_bounds_l2_norm = PB.decode(d, Float64)
        elseif field_number == 28
            combined_variable_bounds_max = PB.decode(d, Float64)
        elseif field_number == 29
            combined_variable_bounds_min = PB.decode(d, Float64)
        elseif field_number == 30
            combined_variable_bounds_avg = PB.decode(d, Float64)
        elseif field_number == 31
            combined_variable_bounds_l2_norm = PB.decode(d, Float64)
        elseif field_number == 12
            variable_bound_gaps_num_finite = PB.decode(d, Int64)
        elseif field_number == 13
            variable_bound_gaps_max = PB.decode(d, Float64)
        elseif field_number == 14
            variable_bound_gaps_min = PB.decode(d, Float64)
        elseif field_number == 15
            variable_bound_gaps_avg = PB.decode(d, Float64)
        elseif field_number == 26
            variable_bound_gaps_l2_norm = PB.decode(d, Float64)
        elseif field_number == 16
            objective_vector_abs_max = PB.decode(d, Float64)
        elseif field_number == 17
            objective_vector_abs_min = PB.decode(d, Float64)
        elseif field_number == 18
            objective_vector_abs_avg = PB.decode(d, Float64)
        elseif field_number == 23
            objective_vector_l2_norm = PB.decode(d, Float64)
        elseif field_number == 19
            objective_matrix_num_nonzeros = PB.decode(d, Int64)
        elseif field_number == 20
            objective_matrix_abs_max = PB.decode(d, Float64)
        elseif field_number == 21
            objective_matrix_abs_min = PB.decode(d, Float64)
        elseif field_number == 22
            objective_matrix_abs_avg = PB.decode(d, Float64)
        elseif field_number == 27
            objective_matrix_l2_norm = PB.decode(d, Float64)
        else
            PB.skip(d, wire_type)
        end
    end
    return QuadraticProgramStats(num_variables, num_constraints, constraint_matrix_col_min_l_inf_norm, constraint_matrix_row_min_l_inf_norm, constraint_matrix_num_nonzeros, constraint_matrix_abs_max, constraint_matrix_abs_min, constraint_matrix_abs_avg, constraint_matrix_l2_norm, combined_bounds_max, combined_bounds_min, combined_bounds_avg, combined_bounds_l2_norm, combined_variable_bounds_max, combined_variable_bounds_min, combined_variable_bounds_avg, combined_variable_bounds_l2_norm, variable_bound_gaps_num_finite, variable_bound_gaps_max, variable_bound_gaps_min, variable_bound_gaps_avg, variable_bound_gaps_l2_norm, objective_vector_abs_max, objective_vector_abs_min, objective_vector_abs_avg, objective_vector_l2_norm, objective_matrix_num_nonzeros, objective_matrix_abs_max, objective_matrix_abs_min, objective_matrix_abs_avg, objective_matrix_l2_norm)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::QuadraticProgramStats)
    initpos = position(e.io)
    x.num_variables != zero(Int64) && PB.encode(e, 1, x.num_variables)
    x.num_constraints != zero(Int64) && PB.encode(e, 2, x.num_constraints)
    x.constraint_matrix_col_min_l_inf_norm !== zero(Float64) && PB.encode(e, 3, x.constraint_matrix_col_min_l_inf_norm)
    x.constraint_matrix_row_min_l_inf_norm !== zero(Float64) && PB.encode(e, 4, x.constraint_matrix_row_min_l_inf_norm)
    x.constraint_matrix_num_nonzeros != zero(Int64) && PB.encode(e, 5, x.constraint_matrix_num_nonzeros)
    x.constraint_matrix_abs_max !== zero(Float64) && PB.encode(e, 6, x.constraint_matrix_abs_max)
    x.constraint_matrix_abs_min !== zero(Float64) && PB.encode(e, 7, x.constraint_matrix_abs_min)
    x.constraint_matrix_abs_avg !== zero(Float64) && PB.encode(e, 8, x.constraint_matrix_abs_avg)
    x.constraint_matrix_l2_norm !== zero(Float64) && PB.encode(e, 25, x.constraint_matrix_l2_norm)
    x.combined_bounds_max !== zero(Float64) && PB.encode(e, 9, x.combined_bounds_max)
    x.combined_bounds_min !== zero(Float64) && PB.encode(e, 10, x.combined_bounds_min)
    x.combined_bounds_avg !== zero(Float64) && PB.encode(e, 11, x.combined_bounds_avg)
    x.combined_bounds_l2_norm !== zero(Float64) && PB.encode(e, 24, x.combined_bounds_l2_norm)
    x.combined_variable_bounds_max !== zero(Float64) && PB.encode(e, 28, x.combined_variable_bounds_max)
    x.combined_variable_bounds_min !== zero(Float64) && PB.encode(e, 29, x.combined_variable_bounds_min)
    x.combined_variable_bounds_avg !== zero(Float64) && PB.encode(e, 30, x.combined_variable_bounds_avg)
    x.combined_variable_bounds_l2_norm !== zero(Float64) && PB.encode(e, 31, x.combined_variable_bounds_l2_norm)
    x.variable_bound_gaps_num_finite != zero(Int64) && PB.encode(e, 12, x.variable_bound_gaps_num_finite)
    x.variable_bound_gaps_max !== zero(Float64) && PB.encode(e, 13, x.variable_bound_gaps_max)
    x.variable_bound_gaps_min !== zero(Float64) && PB.encode(e, 14, x.variable_bound_gaps_min)
    x.variable_bound_gaps_avg !== zero(Float64) && PB.encode(e, 15, x.variable_bound_gaps_avg)
    x.variable_bound_gaps_l2_norm !== zero(Float64) && PB.encode(e, 26, x.variable_bound_gaps_l2_norm)
    x.objective_vector_abs_max !== zero(Float64) && PB.encode(e, 16, x.objective_vector_abs_max)
    x.objective_vector_abs_min !== zero(Float64) && PB.encode(e, 17, x.objective_vector_abs_min)
    x.objective_vector_abs_avg !== zero(Float64) && PB.encode(e, 18, x.objective_vector_abs_avg)
    x.objective_vector_l2_norm !== zero(Float64) && PB.encode(e, 23, x.objective_vector_l2_norm)
    x.objective_matrix_num_nonzeros != zero(Int64) && PB.encode(e, 19, x.objective_matrix_num_nonzeros)
    x.objective_matrix_abs_max !== zero(Float64) && PB.encode(e, 20, x.objective_matrix_abs_max)
    x.objective_matrix_abs_min !== zero(Float64) && PB.encode(e, 21, x.objective_matrix_abs_min)
    x.objective_matrix_abs_avg !== zero(Float64) && PB.encode(e, 22, x.objective_matrix_abs_avg)
    x.objective_matrix_l2_norm !== zero(Float64) && PB.encode(e, 27, x.objective_matrix_l2_norm)
    return position(e.io) - initpos
end
function PB._encoded_size(x::QuadraticProgramStats)
    encoded_size = 0
    x.num_variables != zero(Int64) && (encoded_size += PB._encoded_size(x.num_variables, 1))
    x.num_constraints != zero(Int64) && (encoded_size += PB._encoded_size(x.num_constraints, 2))
    x.constraint_matrix_col_min_l_inf_norm !== zero(Float64) && (encoded_size += PB._encoded_size(x.constraint_matrix_col_min_l_inf_norm, 3))
    x.constraint_matrix_row_min_l_inf_norm !== zero(Float64) && (encoded_size += PB._encoded_size(x.constraint_matrix_row_min_l_inf_norm, 4))
    x.constraint_matrix_num_nonzeros != zero(Int64) && (encoded_size += PB._encoded_size(x.constraint_matrix_num_nonzeros, 5))
    x.constraint_matrix_abs_max !== zero(Float64) && (encoded_size += PB._encoded_size(x.constraint_matrix_abs_max, 6))
    x.constraint_matrix_abs_min !== zero(Float64) && (encoded_size += PB._encoded_size(x.constraint_matrix_abs_min, 7))
    x.constraint_matrix_abs_avg !== zero(Float64) && (encoded_size += PB._encoded_size(x.constraint_matrix_abs_avg, 8))
    x.constraint_matrix_l2_norm !== zero(Float64) && (encoded_size += PB._encoded_size(x.constraint_matrix_l2_norm, 25))
    x.combined_bounds_max !== zero(Float64) && (encoded_size += PB._encoded_size(x.combined_bounds_max, 9))
    x.combined_bounds_min !== zero(Float64) && (encoded_size += PB._encoded_size(x.combined_bounds_min, 10))
    x.combined_bounds_avg !== zero(Float64) && (encoded_size += PB._encoded_size(x.combined_bounds_avg, 11))
    x.combined_bounds_l2_norm !== zero(Float64) && (encoded_size += PB._encoded_size(x.combined_bounds_l2_norm, 24))
    x.combined_variable_bounds_max !== zero(Float64) && (encoded_size += PB._encoded_size(x.combined_variable_bounds_max, 28))
    x.combined_variable_bounds_min !== zero(Float64) && (encoded_size += PB._encoded_size(x.combined_variable_bounds_min, 29))
    x.combined_variable_bounds_avg !== zero(Float64) && (encoded_size += PB._encoded_size(x.combined_variable_bounds_avg, 30))
    x.combined_variable_bounds_l2_norm !== zero(Float64) && (encoded_size += PB._encoded_size(x.combined_variable_bounds_l2_norm, 31))
    x.variable_bound_gaps_num_finite != zero(Int64) && (encoded_size += PB._encoded_size(x.variable_bound_gaps_num_finite, 12))
    x.variable_bound_gaps_max !== zero(Float64) && (encoded_size += PB._encoded_size(x.variable_bound_gaps_max, 13))
    x.variable_bound_gaps_min !== zero(Float64) && (encoded_size += PB._encoded_size(x.variable_bound_gaps_min, 14))
    x.variable_bound_gaps_avg !== zero(Float64) && (encoded_size += PB._encoded_size(x.variable_bound_gaps_avg, 15))
    x.variable_bound_gaps_l2_norm !== zero(Float64) && (encoded_size += PB._encoded_size(x.variable_bound_gaps_l2_norm, 26))
    x.objective_vector_abs_max !== zero(Float64) && (encoded_size += PB._encoded_size(x.objective_vector_abs_max, 16))
    x.objective_vector_abs_min !== zero(Float64) && (encoded_size += PB._encoded_size(x.objective_vector_abs_min, 17))
    x.objective_vector_abs_avg !== zero(Float64) && (encoded_size += PB._encoded_size(x.objective_vector_abs_avg, 18))
    x.objective_vector_l2_norm !== zero(Float64) && (encoded_size += PB._encoded_size(x.objective_vector_l2_norm, 23))
    x.objective_matrix_num_nonzeros != zero(Int64) && (encoded_size += PB._encoded_size(x.objective_matrix_num_nonzeros, 19))
    x.objective_matrix_abs_max !== zero(Float64) && (encoded_size += PB._encoded_size(x.objective_matrix_abs_max, 20))
    x.objective_matrix_abs_min !== zero(Float64) && (encoded_size += PB._encoded_size(x.objective_matrix_abs_min, 21))
    x.objective_matrix_abs_avg !== zero(Float64) && (encoded_size += PB._encoded_size(x.objective_matrix_abs_avg, 22))
    x.objective_matrix_l2_norm !== zero(Float64) && (encoded_size += PB._encoded_size(x.objective_matrix_l2_norm, 27))
    return encoded_size
end

@enumx PolishingPhaseType POLISHING_PHASE_TYPE_UNSPECIFIED=0 POLISHING_PHASE_TYPE_PRIMAL_FEASIBILITY=1 POLISHING_PHASE_TYPE_DUAL_FEASIBILITY=2

@enumx PointType POINT_TYPE_UNSPECIFIED=0 POINT_TYPE_CURRENT_ITERATE=1 POINT_TYPE_ITERATE_DIFFERENCE=2 POINT_TYPE_AVERAGE_ITERATE=3 POINT_TYPE_NONE=4 POINT_TYPE_PRESOLVER_SOLUTION=5 POINT_TYPE_FEASIBILITY_POLISHING_SOLUTION=6

@enumx TerminationReason TERMINATION_REASON_UNSPECIFIED=0 TERMINATION_REASON_OPTIMAL=1 TERMINATION_REASON_PRIMAL_INFEASIBLE=2 TERMINATION_REASON_DUAL_INFEASIBLE=3 TERMINATION_REASON_TIME_LIMIT=4 TERMINATION_REASON_ITERATION_LIMIT=5 TERMINATION_REASON_KKT_MATRIX_PASS_LIMIT=8 TERMINATION_REASON_INTERRUPTED_BY_USER=12 TERMINATION_REASON_NUMERICAL_ERROR=6 TERMINATION_REASON_INVALID_PROBLEM=9 TERMINATION_REASON_INVALID_INITIAL_SOLUTION=13 TERMINATION_REASON_INVALID_PARAMETER=10 TERMINATION_REASON_OTHER=7 TERMINATION_REASON_PRIMAL_OR_DUAL_INFEASIBLE=11

@enumx RestartChoice RESTART_CHOICE_UNSPECIFIED=0 RESTART_CHOICE_NO_RESTART=1 RESTART_CHOICE_WEIGHTED_AVERAGE_RESET=2 RESTART_CHOICE_RESTART_TO_AVERAGE=3

struct PointMetadata
    point_type::PointType.T
    random_primal_projections::Vector{Float64}
    random_dual_projections::Vector{Float64}
    active_primal_variable_count::Int64
    active_dual_variable_count::Int64
    active_primal_variable_change::Int64
    active_dual_variable_change::Int64
end
PB.default_values(::Type{PointMetadata}) = (;point_type = PointType.POINT_TYPE_UNSPECIFIED, random_primal_projections = Vector{Float64}(), random_dual_projections = Vector{Float64}(), active_primal_variable_count = zero(Int64), active_dual_variable_count = zero(Int64), active_primal_variable_change = zero(Int64), active_dual_variable_change = zero(Int64))
PB.field_numbers(::Type{PointMetadata}) = (;point_type = 1, random_primal_projections = 2, random_dual_projections = 3, active_primal_variable_count = 4, active_dual_variable_count = 5, active_primal_variable_change = 6, active_dual_variable_change = 7)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:PointMetadata})
    point_type = PointType.POINT_TYPE_UNSPECIFIED
    random_primal_projections = PB.BufferedVector{Float64}()
    random_dual_projections = PB.BufferedVector{Float64}()
    active_primal_variable_count = zero(Int64)
    active_dual_variable_count = zero(Int64)
    active_primal_variable_change = zero(Int64)
    active_dual_variable_change = zero(Int64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            point_type = PB.decode(d, PointType.T)
        elseif field_number == 2
            PB.decode!(d, wire_type, random_primal_projections)
        elseif field_number == 3
            PB.decode!(d, wire_type, random_dual_projections)
        elseif field_number == 4
            active_primal_variable_count = PB.decode(d, Int64)
        elseif field_number == 5
            active_dual_variable_count = PB.decode(d, Int64)
        elseif field_number == 6
            active_primal_variable_change = PB.decode(d, Int64)
        elseif field_number == 7
            active_dual_variable_change = PB.decode(d, Int64)
        else
            PB.skip(d, wire_type)
        end
    end
    return PointMetadata(point_type, random_primal_projections[], random_dual_projections[], active_primal_variable_count, active_dual_variable_count, active_primal_variable_change, active_dual_variable_change)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::PointMetadata)
    initpos = position(e.io)
    x.point_type != PointType.POINT_TYPE_UNSPECIFIED && PB.encode(e, 1, x.point_type)
    !isempty(x.random_primal_projections) && PB.encode(e, 2, x.random_primal_projections)
    !isempty(x.random_dual_projections) && PB.encode(e, 3, x.random_dual_projections)
    x.active_primal_variable_count != zero(Int64) && PB.encode(e, 4, x.active_primal_variable_count)
    x.active_dual_variable_count != zero(Int64) && PB.encode(e, 5, x.active_dual_variable_count)
    x.active_primal_variable_change != zero(Int64) && PB.encode(e, 6, x.active_primal_variable_change)
    x.active_dual_variable_change != zero(Int64) && PB.encode(e, 7, x.active_dual_variable_change)
    return position(e.io) - initpos
end
function PB._encoded_size(x::PointMetadata)
    encoded_size = 0
    x.point_type != PointType.POINT_TYPE_UNSPECIFIED && (encoded_size += PB._encoded_size(x.point_type, 1))
    !isempty(x.random_primal_projections) && (encoded_size += PB._encoded_size(x.random_primal_projections, 2))
    !isempty(x.random_dual_projections) && (encoded_size += PB._encoded_size(x.random_dual_projections, 3))
    x.active_primal_variable_count != zero(Int64) && (encoded_size += PB._encoded_size(x.active_primal_variable_count, 4))
    x.active_dual_variable_count != zero(Int64) && (encoded_size += PB._encoded_size(x.active_dual_variable_count, 5))
    x.active_primal_variable_change != zero(Int64) && (encoded_size += PB._encoded_size(x.active_primal_variable_change, 6))
    x.active_dual_variable_change != zero(Int64) && (encoded_size += PB._encoded_size(x.active_dual_variable_change, 7))
    return encoded_size
end

struct InfeasibilityInformation
    max_primal_ray_infeasibility::Float64
    primal_ray_linear_objective::Float64
    primal_ray_quadratic_norm::Float64
    max_dual_ray_infeasibility::Float64
    dual_ray_objective::Float64
    candidate_type::PointType.T
end
PB.reserved_fields(::Type{InfeasibilityInformation}) = (names = String[], numbers = Union{Int,UnitRange{Int}}[7, 8])
PB.default_values(::Type{InfeasibilityInformation}) = (;max_primal_ray_infeasibility = zero(Float64), primal_ray_linear_objective = zero(Float64), primal_ray_quadratic_norm = zero(Float64), max_dual_ray_infeasibility = zero(Float64), dual_ray_objective = zero(Float64), candidate_type = PointType.POINT_TYPE_UNSPECIFIED)
PB.field_numbers(::Type{InfeasibilityInformation}) = (;max_primal_ray_infeasibility = 1, primal_ray_linear_objective = 2, primal_ray_quadratic_norm = 3, max_dual_ray_infeasibility = 4, dual_ray_objective = 5, candidate_type = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:InfeasibilityInformation})
    max_primal_ray_infeasibility = zero(Float64)
    primal_ray_linear_objective = zero(Float64)
    primal_ray_quadratic_norm = zero(Float64)
    max_dual_ray_infeasibility = zero(Float64)
    dual_ray_objective = zero(Float64)
    candidate_type = PointType.POINT_TYPE_UNSPECIFIED
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            max_primal_ray_infeasibility = PB.decode(d, Float64)
        elseif field_number == 2
            primal_ray_linear_objective = PB.decode(d, Float64)
        elseif field_number == 3
            primal_ray_quadratic_norm = PB.decode(d, Float64)
        elseif field_number == 4
            max_dual_ray_infeasibility = PB.decode(d, Float64)
        elseif field_number == 5
            dual_ray_objective = PB.decode(d, Float64)
        elseif field_number == 6
            candidate_type = PB.decode(d, PointType.T)
        else
            PB.skip(d, wire_type)
        end
    end
    return InfeasibilityInformation(max_primal_ray_infeasibility, primal_ray_linear_objective, primal_ray_quadratic_norm, max_dual_ray_infeasibility, dual_ray_objective, candidate_type)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::InfeasibilityInformation)
    initpos = position(e.io)
    x.max_primal_ray_infeasibility !== zero(Float64) && PB.encode(e, 1, x.max_primal_ray_infeasibility)
    x.primal_ray_linear_objective !== zero(Float64) && PB.encode(e, 2, x.primal_ray_linear_objective)
    x.primal_ray_quadratic_norm !== zero(Float64) && PB.encode(e, 3, x.primal_ray_quadratic_norm)
    x.max_dual_ray_infeasibility !== zero(Float64) && PB.encode(e, 4, x.max_dual_ray_infeasibility)
    x.dual_ray_objective !== zero(Float64) && PB.encode(e, 5, x.dual_ray_objective)
    x.candidate_type != PointType.POINT_TYPE_UNSPECIFIED && PB.encode(e, 6, x.candidate_type)
    return position(e.io) - initpos
end
function PB._encoded_size(x::InfeasibilityInformation)
    encoded_size = 0
    x.max_primal_ray_infeasibility !== zero(Float64) && (encoded_size += PB._encoded_size(x.max_primal_ray_infeasibility, 1))
    x.primal_ray_linear_objective !== zero(Float64) && (encoded_size += PB._encoded_size(x.primal_ray_linear_objective, 2))
    x.primal_ray_quadratic_norm !== zero(Float64) && (encoded_size += PB._encoded_size(x.primal_ray_quadratic_norm, 3))
    x.max_dual_ray_infeasibility !== zero(Float64) && (encoded_size += PB._encoded_size(x.max_dual_ray_infeasibility, 4))
    x.dual_ray_objective !== zero(Float64) && (encoded_size += PB._encoded_size(x.dual_ray_objective, 5))
    x.candidate_type != PointType.POINT_TYPE_UNSPECIFIED && (encoded_size += PB._encoded_size(x.candidate_type, 6))
    return encoded_size
end

struct ConvergenceInformation
    candidate_type::PointType.T
    primal_objective::Float64
    dual_objective::Float64
    corrected_dual_objective::Float64
    l_inf_primal_residual::Float64
    l2_primal_residual::Float64
    l_inf_componentwise_primal_residual::Float64
    l_inf_dual_residual::Float64
    l2_dual_residual::Float64
    l_inf_componentwise_dual_residual::Float64
    l_inf_primal_variable::Float64
    l2_primal_variable::Float64
    l_inf_dual_variable::Float64
    l2_dual_variable::Float64
end
PB.reserved_fields(::Type{ConvergenceInformation}) = (names = String[], numbers = Union{Int,UnitRange{Int}}[9, 10, 11, 12, 13, 18, 19, 20, 21, 22, 23])
PB.default_values(::Type{ConvergenceInformation}) = (;candidate_type = PointType.POINT_TYPE_UNSPECIFIED, primal_objective = zero(Float64), dual_objective = zero(Float64), corrected_dual_objective = zero(Float64), l_inf_primal_residual = zero(Float64), l2_primal_residual = zero(Float64), l_inf_componentwise_primal_residual = zero(Float64), l_inf_dual_residual = zero(Float64), l2_dual_residual = zero(Float64), l_inf_componentwise_dual_residual = zero(Float64), l_inf_primal_variable = zero(Float64), l2_primal_variable = zero(Float64), l_inf_dual_variable = zero(Float64), l2_dual_variable = zero(Float64))
PB.field_numbers(::Type{ConvergenceInformation}) = (;candidate_type = 1, primal_objective = 2, dual_objective = 3, corrected_dual_objective = 4, l_inf_primal_residual = 5, l2_primal_residual = 6, l_inf_componentwise_primal_residual = 24, l_inf_dual_residual = 7, l2_dual_residual = 8, l_inf_componentwise_dual_residual = 25, l_inf_primal_variable = 14, l2_primal_variable = 15, l_inf_dual_variable = 16, l2_dual_variable = 17)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ConvergenceInformation})
    candidate_type = PointType.POINT_TYPE_UNSPECIFIED
    primal_objective = zero(Float64)
    dual_objective = zero(Float64)
    corrected_dual_objective = zero(Float64)
    l_inf_primal_residual = zero(Float64)
    l2_primal_residual = zero(Float64)
    l_inf_componentwise_primal_residual = zero(Float64)
    l_inf_dual_residual = zero(Float64)
    l2_dual_residual = zero(Float64)
    l_inf_componentwise_dual_residual = zero(Float64)
    l_inf_primal_variable = zero(Float64)
    l2_primal_variable = zero(Float64)
    l_inf_dual_variable = zero(Float64)
    l2_dual_variable = zero(Float64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            candidate_type = PB.decode(d, PointType.T)
        elseif field_number == 2
            primal_objective = PB.decode(d, Float64)
        elseif field_number == 3
            dual_objective = PB.decode(d, Float64)
        elseif field_number == 4
            corrected_dual_objective = PB.decode(d, Float64)
        elseif field_number == 5
            l_inf_primal_residual = PB.decode(d, Float64)
        elseif field_number == 6
            l2_primal_residual = PB.decode(d, Float64)
        elseif field_number == 24
            l_inf_componentwise_primal_residual = PB.decode(d, Float64)
        elseif field_number == 7
            l_inf_dual_residual = PB.decode(d, Float64)
        elseif field_number == 8
            l2_dual_residual = PB.decode(d, Float64)
        elseif field_number == 25
            l_inf_componentwise_dual_residual = PB.decode(d, Float64)
        elseif field_number == 14
            l_inf_primal_variable = PB.decode(d, Float64)
        elseif field_number == 15
            l2_primal_variable = PB.decode(d, Float64)
        elseif field_number == 16
            l_inf_dual_variable = PB.decode(d, Float64)
        elseif field_number == 17
            l2_dual_variable = PB.decode(d, Float64)
        else
            PB.skip(d, wire_type)
        end
    end
    return ConvergenceInformation(candidate_type, primal_objective, dual_objective, corrected_dual_objective, l_inf_primal_residual, l2_primal_residual, l_inf_componentwise_primal_residual, l_inf_dual_residual, l2_dual_residual, l_inf_componentwise_dual_residual, l_inf_primal_variable, l2_primal_variable, l_inf_dual_variable, l2_dual_variable)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ConvergenceInformation)
    initpos = position(e.io)
    x.candidate_type != PointType.POINT_TYPE_UNSPECIFIED && PB.encode(e, 1, x.candidate_type)
    x.primal_objective !== zero(Float64) && PB.encode(e, 2, x.primal_objective)
    x.dual_objective !== zero(Float64) && PB.encode(e, 3, x.dual_objective)
    x.corrected_dual_objective !== zero(Float64) && PB.encode(e, 4, x.corrected_dual_objective)
    x.l_inf_primal_residual !== zero(Float64) && PB.encode(e, 5, x.l_inf_primal_residual)
    x.l2_primal_residual !== zero(Float64) && PB.encode(e, 6, x.l2_primal_residual)
    x.l_inf_componentwise_primal_residual !== zero(Float64) && PB.encode(e, 24, x.l_inf_componentwise_primal_residual)
    x.l_inf_dual_residual !== zero(Float64) && PB.encode(e, 7, x.l_inf_dual_residual)
    x.l2_dual_residual !== zero(Float64) && PB.encode(e, 8, x.l2_dual_residual)
    x.l_inf_componentwise_dual_residual !== zero(Float64) && PB.encode(e, 25, x.l_inf_componentwise_dual_residual)
    x.l_inf_primal_variable !== zero(Float64) && PB.encode(e, 14, x.l_inf_primal_variable)
    x.l2_primal_variable !== zero(Float64) && PB.encode(e, 15, x.l2_primal_variable)
    x.l_inf_dual_variable !== zero(Float64) && PB.encode(e, 16, x.l_inf_dual_variable)
    x.l2_dual_variable !== zero(Float64) && PB.encode(e, 17, x.l2_dual_variable)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ConvergenceInformation)
    encoded_size = 0
    x.candidate_type != PointType.POINT_TYPE_UNSPECIFIED && (encoded_size += PB._encoded_size(x.candidate_type, 1))
    x.primal_objective !== zero(Float64) && (encoded_size += PB._encoded_size(x.primal_objective, 2))
    x.dual_objective !== zero(Float64) && (encoded_size += PB._encoded_size(x.dual_objective, 3))
    x.corrected_dual_objective !== zero(Float64) && (encoded_size += PB._encoded_size(x.corrected_dual_objective, 4))
    x.l_inf_primal_residual !== zero(Float64) && (encoded_size += PB._encoded_size(x.l_inf_primal_residual, 5))
    x.l2_primal_residual !== zero(Float64) && (encoded_size += PB._encoded_size(x.l2_primal_residual, 6))
    x.l_inf_componentwise_primal_residual !== zero(Float64) && (encoded_size += PB._encoded_size(x.l_inf_componentwise_primal_residual, 24))
    x.l_inf_dual_residual !== zero(Float64) && (encoded_size += PB._encoded_size(x.l_inf_dual_residual, 7))
    x.l2_dual_residual !== zero(Float64) && (encoded_size += PB._encoded_size(x.l2_dual_residual, 8))
    x.l_inf_componentwise_dual_residual !== zero(Float64) && (encoded_size += PB._encoded_size(x.l_inf_componentwise_dual_residual, 25))
    x.l_inf_primal_variable !== zero(Float64) && (encoded_size += PB._encoded_size(x.l_inf_primal_variable, 14))
    x.l2_primal_variable !== zero(Float64) && (encoded_size += PB._encoded_size(x.l2_primal_variable, 15))
    x.l_inf_dual_variable !== zero(Float64) && (encoded_size += PB._encoded_size(x.l_inf_dual_variable, 16))
    x.l2_dual_variable !== zero(Float64) && (encoded_size += PB._encoded_size(x.l2_dual_variable, 17))
    return encoded_size
end

struct IterationStats
    iteration_number::Int32
    convergence_information::Vector{ConvergenceInformation}
    infeasibility_information::Vector{InfeasibilityInformation}
    point_metadata::Vector{PointMetadata}
    cumulative_kkt_matrix_passes::Float64
    cumulative_rejected_steps::Int32
    cumulative_time_sec::Float64
    restart_used::RestartChoice.T
    step_size::Float64
    primal_weight::Float64
end
PB.reserved_fields(::Type{IterationStats}) = (names = String[], numbers = Union{Int,UnitRange{Int}}[10])
PB.default_values(::Type{IterationStats}) = (;iteration_number = zero(Int32), convergence_information = Vector{ConvergenceInformation}(), infeasibility_information = Vector{InfeasibilityInformation}(), point_metadata = Vector{PointMetadata}(), cumulative_kkt_matrix_passes = zero(Float64), cumulative_rejected_steps = zero(Int32), cumulative_time_sec = zero(Float64), restart_used = RestartChoice.RESTART_CHOICE_UNSPECIFIED, step_size = zero(Float64), primal_weight = zero(Float64))
PB.field_numbers(::Type{IterationStats}) = (;iteration_number = 1, convergence_information = 2, infeasibility_information = 3, point_metadata = 11, cumulative_kkt_matrix_passes = 4, cumulative_rejected_steps = 5, cumulative_time_sec = 6, restart_used = 7, step_size = 8, primal_weight = 9)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:IterationStats})
    iteration_number = zero(Int32)
    convergence_information = PB.BufferedVector{ConvergenceInformation}()
    infeasibility_information = PB.BufferedVector{InfeasibilityInformation}()
    point_metadata = PB.BufferedVector{PointMetadata}()
    cumulative_kkt_matrix_passes = zero(Float64)
    cumulative_rejected_steps = zero(Int32)
    cumulative_time_sec = zero(Float64)
    restart_used = RestartChoice.RESTART_CHOICE_UNSPECIFIED
    step_size = zero(Float64)
    primal_weight = zero(Float64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            iteration_number = PB.decode(d, Int32)
        elseif field_number == 2
            PB.decode!(d, convergence_information)
        elseif field_number == 3
            PB.decode!(d, infeasibility_information)
        elseif field_number == 11
            PB.decode!(d, point_metadata)
        elseif field_number == 4
            cumulative_kkt_matrix_passes = PB.decode(d, Float64)
        elseif field_number == 5
            cumulative_rejected_steps = PB.decode(d, Int32)
        elseif field_number == 6
            cumulative_time_sec = PB.decode(d, Float64)
        elseif field_number == 7
            restart_used = PB.decode(d, RestartChoice.T)
        elseif field_number == 8
            step_size = PB.decode(d, Float64)
        elseif field_number == 9
            primal_weight = PB.decode(d, Float64)
        else
            PB.skip(d, wire_type)
        end
    end
    return IterationStats(iteration_number, convergence_information[], infeasibility_information[], point_metadata[], cumulative_kkt_matrix_passes, cumulative_rejected_steps, cumulative_time_sec, restart_used, step_size, primal_weight)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::IterationStats)
    initpos = position(e.io)
    x.iteration_number != zero(Int32) && PB.encode(e, 1, x.iteration_number)
    !isempty(x.convergence_information) && PB.encode(e, 2, x.convergence_information)
    !isempty(x.infeasibility_information) && PB.encode(e, 3, x.infeasibility_information)
    !isempty(x.point_metadata) && PB.encode(e, 11, x.point_metadata)
    x.cumulative_kkt_matrix_passes !== zero(Float64) && PB.encode(e, 4, x.cumulative_kkt_matrix_passes)
    x.cumulative_rejected_steps != zero(Int32) && PB.encode(e, 5, x.cumulative_rejected_steps)
    x.cumulative_time_sec !== zero(Float64) && PB.encode(e, 6, x.cumulative_time_sec)
    x.restart_used != RestartChoice.RESTART_CHOICE_UNSPECIFIED && PB.encode(e, 7, x.restart_used)
    x.step_size !== zero(Float64) && PB.encode(e, 8, x.step_size)
    x.primal_weight !== zero(Float64) && PB.encode(e, 9, x.primal_weight)
    return position(e.io) - initpos
end
function PB._encoded_size(x::IterationStats)
    encoded_size = 0
    x.iteration_number != zero(Int32) && (encoded_size += PB._encoded_size(x.iteration_number, 1))
    !isempty(x.convergence_information) && (encoded_size += PB._encoded_size(x.convergence_information, 2))
    !isempty(x.infeasibility_information) && (encoded_size += PB._encoded_size(x.infeasibility_information, 3))
    !isempty(x.point_metadata) && (encoded_size += PB._encoded_size(x.point_metadata, 11))
    x.cumulative_kkt_matrix_passes !== zero(Float64) && (encoded_size += PB._encoded_size(x.cumulative_kkt_matrix_passes, 4))
    x.cumulative_rejected_steps != zero(Int32) && (encoded_size += PB._encoded_size(x.cumulative_rejected_steps, 5))
    x.cumulative_time_sec !== zero(Float64) && (encoded_size += PB._encoded_size(x.cumulative_time_sec, 6))
    x.restart_used != RestartChoice.RESTART_CHOICE_UNSPECIFIED && (encoded_size += PB._encoded_size(x.restart_used, 7))
    x.step_size !== zero(Float64) && (encoded_size += PB._encoded_size(x.step_size, 8))
    x.primal_weight !== zero(Float64) && (encoded_size += PB._encoded_size(x.primal_weight, 9))
    return encoded_size
end

struct FeasibilityPolishingDetails
    polishing_phase_type::PolishingPhaseType.T
    main_iteration_count::Int32
    params::Union{Nothing,PrimalDualHybridGradientParams}
    termination_reason::TerminationReason.T
    iteration_count::Int32
    solve_time_sec::Float64
    solution_stats::Union{Nothing,IterationStats}
    solution_type::PointType.T
    iteration_stats::Vector{IterationStats}
end
PB.default_values(::Type{FeasibilityPolishingDetails}) = (;polishing_phase_type = PolishingPhaseType.POLISHING_PHASE_TYPE_UNSPECIFIED, main_iteration_count = zero(Int32), params = nothing, termination_reason = TerminationReason.TERMINATION_REASON_UNSPECIFIED, iteration_count = zero(Int32), solve_time_sec = zero(Float64), solution_stats = nothing, solution_type = PointType.POINT_TYPE_UNSPECIFIED, iteration_stats = Vector{IterationStats}())
PB.field_numbers(::Type{FeasibilityPolishingDetails}) = (;polishing_phase_type = 1, main_iteration_count = 2, params = 3, termination_reason = 4, iteration_count = 5, solve_time_sec = 6, solution_stats = 7, solution_type = 8, iteration_stats = 9)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:FeasibilityPolishingDetails})
    polishing_phase_type = PolishingPhaseType.POLISHING_PHASE_TYPE_UNSPECIFIED
    main_iteration_count = zero(Int32)
    params = Ref{Union{Nothing,PrimalDualHybridGradientParams}}(nothing)
    termination_reason = TerminationReason.TERMINATION_REASON_UNSPECIFIED
    iteration_count = zero(Int32)
    solve_time_sec = zero(Float64)
    solution_stats = Ref{Union{Nothing,IterationStats}}(nothing)
    solution_type = PointType.POINT_TYPE_UNSPECIFIED
    iteration_stats = PB.BufferedVector{IterationStats}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            polishing_phase_type = PB.decode(d, PolishingPhaseType.T)
        elseif field_number == 2
            main_iteration_count = PB.decode(d, Int32)
        elseif field_number == 3
            PB.decode!(d, params)
        elseif field_number == 4
            termination_reason = PB.decode(d, TerminationReason.T)
        elseif field_number == 5
            iteration_count = PB.decode(d, Int32)
        elseif field_number == 6
            solve_time_sec = PB.decode(d, Float64)
        elseif field_number == 7
            PB.decode!(d, solution_stats)
        elseif field_number == 8
            solution_type = PB.decode(d, PointType.T)
        elseif field_number == 9
            PB.decode!(d, iteration_stats)
        else
            PB.skip(d, wire_type)
        end
    end
    return FeasibilityPolishingDetails(polishing_phase_type, main_iteration_count, params[], termination_reason, iteration_count, solve_time_sec, solution_stats[], solution_type, iteration_stats[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::FeasibilityPolishingDetails)
    initpos = position(e.io)
    x.polishing_phase_type != PolishingPhaseType.POLISHING_PHASE_TYPE_UNSPECIFIED && PB.encode(e, 1, x.polishing_phase_type)
    x.main_iteration_count != zero(Int32) && PB.encode(e, 2, x.main_iteration_count)
    !isnothing(x.params) && PB.encode(e, 3, x.params)
    x.termination_reason != TerminationReason.TERMINATION_REASON_UNSPECIFIED && PB.encode(e, 4, x.termination_reason)
    x.iteration_count != zero(Int32) && PB.encode(e, 5, x.iteration_count)
    x.solve_time_sec !== zero(Float64) && PB.encode(e, 6, x.solve_time_sec)
    !isnothing(x.solution_stats) && PB.encode(e, 7, x.solution_stats)
    x.solution_type != PointType.POINT_TYPE_UNSPECIFIED && PB.encode(e, 8, x.solution_type)
    !isempty(x.iteration_stats) && PB.encode(e, 9, x.iteration_stats)
    return position(e.io) - initpos
end
function PB._encoded_size(x::FeasibilityPolishingDetails)
    encoded_size = 0
    x.polishing_phase_type != PolishingPhaseType.POLISHING_PHASE_TYPE_UNSPECIFIED && (encoded_size += PB._encoded_size(x.polishing_phase_type, 1))
    x.main_iteration_count != zero(Int32) && (encoded_size += PB._encoded_size(x.main_iteration_count, 2))
    !isnothing(x.params) && (encoded_size += PB._encoded_size(x.params, 3))
    x.termination_reason != TerminationReason.TERMINATION_REASON_UNSPECIFIED && (encoded_size += PB._encoded_size(x.termination_reason, 4))
    x.iteration_count != zero(Int32) && (encoded_size += PB._encoded_size(x.iteration_count, 5))
    x.solve_time_sec !== zero(Float64) && (encoded_size += PB._encoded_size(x.solve_time_sec, 6))
    !isnothing(x.solution_stats) && (encoded_size += PB._encoded_size(x.solution_stats, 7))
    x.solution_type != PointType.POINT_TYPE_UNSPECIFIED && (encoded_size += PB._encoded_size(x.solution_type, 8))
    !isempty(x.iteration_stats) && (encoded_size += PB._encoded_size(x.iteration_stats, 9))
    return encoded_size
end

struct SolveLog
    instance_name::String
    params::Union{Nothing,PrimalDualHybridGradientParams}
    termination_reason::TerminationReason.T
    termination_string::String
    iteration_count::Int32
    preprocessing_time_sec::Float64
    solve_time_sec::Float64
    solution_stats::Union{Nothing,IterationStats}
    solution_type::PointType.T
    iteration_stats::Vector{IterationStats}
    original_problem_stats::Union{Nothing,QuadraticProgramStats}
    preprocessed_problem_stats::Union{Nothing,QuadraticProgramStats}
    feasibility_polishing_details::Vector{FeasibilityPolishingDetails}
end
PB.reserved_fields(::Type{SolveLog}) = (names = String[], numbers = Union{Int,UnitRange{Int}}[2, 9])
PB.default_values(::Type{SolveLog}) = (;instance_name = "", params = nothing, termination_reason = TerminationReason.TERMINATION_REASON_UNSPECIFIED, termination_string = "", iteration_count = zero(Int32), preprocessing_time_sec = zero(Float64), solve_time_sec = zero(Float64), solution_stats = nothing, solution_type = PointType.POINT_TYPE_UNSPECIFIED, iteration_stats = Vector{IterationStats}(), original_problem_stats = nothing, preprocessed_problem_stats = nothing, feasibility_polishing_details = Vector{FeasibilityPolishingDetails}())
PB.field_numbers(::Type{SolveLog}) = (;instance_name = 1, params = 14, termination_reason = 3, termination_string = 4, iteration_count = 5, preprocessing_time_sec = 13, solve_time_sec = 6, solution_stats = 8, solution_type = 10, iteration_stats = 7, original_problem_stats = 11, preprocessed_problem_stats = 12, feasibility_polishing_details = 15)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SolveLog})
    instance_name = ""
    params = Ref{Union{Nothing,PrimalDualHybridGradientParams}}(nothing)
    termination_reason = TerminationReason.TERMINATION_REASON_UNSPECIFIED
    termination_string = ""
    iteration_count = zero(Int32)
    preprocessing_time_sec = zero(Float64)
    solve_time_sec = zero(Float64)
    solution_stats = Ref{Union{Nothing,IterationStats}}(nothing)
    solution_type = PointType.POINT_TYPE_UNSPECIFIED
    iteration_stats = PB.BufferedVector{IterationStats}()
    original_problem_stats = Ref{Union{Nothing,QuadraticProgramStats}}(nothing)
    preprocessed_problem_stats = Ref{Union{Nothing,QuadraticProgramStats}}(nothing)
    feasibility_polishing_details = PB.BufferedVector{FeasibilityPolishingDetails}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            instance_name = PB.decode(d, String)
        elseif field_number == 14
            PB.decode!(d, params)
        elseif field_number == 3
            termination_reason = PB.decode(d, TerminationReason.T)
        elseif field_number == 4
            termination_string = PB.decode(d, String)
        elseif field_number == 5
            iteration_count = PB.decode(d, Int32)
        elseif field_number == 13
            preprocessing_time_sec = PB.decode(d, Float64)
        elseif field_number == 6
            solve_time_sec = PB.decode(d, Float64)
        elseif field_number == 8
            PB.decode!(d, solution_stats)
        elseif field_number == 10
            solution_type = PB.decode(d, PointType.T)
        elseif field_number == 7
            PB.decode!(d, iteration_stats)
        elseif field_number == 11
            PB.decode!(d, original_problem_stats)
        elseif field_number == 12
            PB.decode!(d, preprocessed_problem_stats)
        elseif field_number == 15
            PB.decode!(d, feasibility_polishing_details)
        else
            PB.skip(d, wire_type)
        end
    end
    return SolveLog(instance_name, params[], termination_reason, termination_string, iteration_count, preprocessing_time_sec, solve_time_sec, solution_stats[], solution_type, iteration_stats[], original_problem_stats[], preprocessed_problem_stats[], feasibility_polishing_details[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SolveLog)
    initpos = position(e.io)
    !isempty(x.instance_name) && PB.encode(e, 1, x.instance_name)
    !isnothing(x.params) && PB.encode(e, 14, x.params)
    x.termination_reason != TerminationReason.TERMINATION_REASON_UNSPECIFIED && PB.encode(e, 3, x.termination_reason)
    !isempty(x.termination_string) && PB.encode(e, 4, x.termination_string)
    x.iteration_count != zero(Int32) && PB.encode(e, 5, x.iteration_count)
    x.preprocessing_time_sec !== zero(Float64) && PB.encode(e, 13, x.preprocessing_time_sec)
    x.solve_time_sec !== zero(Float64) && PB.encode(e, 6, x.solve_time_sec)
    !isnothing(x.solution_stats) && PB.encode(e, 8, x.solution_stats)
    x.solution_type != PointType.POINT_TYPE_UNSPECIFIED && PB.encode(e, 10, x.solution_type)
    !isempty(x.iteration_stats) && PB.encode(e, 7, x.iteration_stats)
    !isnothing(x.original_problem_stats) && PB.encode(e, 11, x.original_problem_stats)
    !isnothing(x.preprocessed_problem_stats) && PB.encode(e, 12, x.preprocessed_problem_stats)
    !isempty(x.feasibility_polishing_details) && PB.encode(e, 15, x.feasibility_polishing_details)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SolveLog)
    encoded_size = 0
    !isempty(x.instance_name) && (encoded_size += PB._encoded_size(x.instance_name, 1))
    !isnothing(x.params) && (encoded_size += PB._encoded_size(x.params, 14))
    x.termination_reason != TerminationReason.TERMINATION_REASON_UNSPECIFIED && (encoded_size += PB._encoded_size(x.termination_reason, 3))
    !isempty(x.termination_string) && (encoded_size += PB._encoded_size(x.termination_string, 4))
    x.iteration_count != zero(Int32) && (encoded_size += PB._encoded_size(x.iteration_count, 5))
    x.preprocessing_time_sec !== zero(Float64) && (encoded_size += PB._encoded_size(x.preprocessing_time_sec, 13))
    x.solve_time_sec !== zero(Float64) && (encoded_size += PB._encoded_size(x.solve_time_sec, 6))
    !isnothing(x.solution_stats) && (encoded_size += PB._encoded_size(x.solution_stats, 8))
    x.solution_type != PointType.POINT_TYPE_UNSPECIFIED && (encoded_size += PB._encoded_size(x.solution_type, 10))
    !isempty(x.iteration_stats) && (encoded_size += PB._encoded_size(x.iteration_stats, 7))
    !isnothing(x.original_problem_stats) && (encoded_size += PB._encoded_size(x.original_problem_stats, 11))
    !isnothing(x.preprocessed_problem_stats) && (encoded_size += PB._encoded_size(x.preprocessed_problem_stats, 12))
    !isempty(x.feasibility_polishing_details) && (encoded_size += PB._encoded_size(x.feasibility_polishing_details, 15))
    return encoded_size
end
