# Autogenerated using ProtoBuf.jl v1.1.1 on 2025-07-02T15:45:01.864
# original file: /usr/local/google/home/tcuvelier/.julia/artifacts/502992654d3e610bc079dfc8ac9e663bff6f3a24/include/ortools/linear_solver/linear_solver.proto (proto2 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export MPQuadraticObjective, MPSolverResponseStatus, MPQuadraticConstraint
export MPConstraintProto, OptionalDouble, var"MPSosConstraint.Type"
export PartialVariableAssignment, var"MPSolverCommonParameters.LPAlgorithmValues"
export var"MPModelRequest.SolverType", MPSolution, MPArrayWithConstantConstraint
export MPAbsConstraint, MPSolveInfo, MPVariableProto
export var"MPModelProto.Annotation.TargetType", MPArrayConstraint, MPIndicatorConstraint
export MPSosConstraint, MPSolverCommonParameters, MPSolutionResponse, MPModelDeltaProto
export var"MPModelProto.Annotation", MPGeneralConstraintProto, MPModelProto, MPModelRequest


struct MPQuadraticObjective
    qvar1_index::Vector{Int32}
    qvar2_index::Vector{Int32}
    coefficient::Vector{Float64}
end
PB.default_values(::Type{MPQuadraticObjective}) = (;qvar1_index = Vector{Int32}(), qvar2_index = Vector{Int32}(), coefficient = Vector{Float64}())
PB.field_numbers(::Type{MPQuadraticObjective}) = (;qvar1_index = 1, qvar2_index = 2, coefficient = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MPQuadraticObjective})
    qvar1_index = PB.BufferedVector{Int32}()
    qvar2_index = PB.BufferedVector{Int32}()
    coefficient = PB.BufferedVector{Float64}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, qvar1_index)
        elseif field_number == 2
            PB.decode!(d, wire_type, qvar2_index)
        elseif field_number == 3
            PB.decode!(d, wire_type, coefficient)
        else
            PB.skip(d, wire_type)
        end
    end
    return MPQuadraticObjective(qvar1_index[], qvar2_index[], coefficient[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MPQuadraticObjective)
    initpos = position(e.io)
    !isempty(x.qvar1_index) && PB.encode(e, 1, x.qvar1_index)
    !isempty(x.qvar2_index) && PB.encode(e, 2, x.qvar2_index)
    !isempty(x.coefficient) && PB.encode(e, 3, x.coefficient)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MPQuadraticObjective)
    encoded_size = 0
    !isempty(x.qvar1_index) && (encoded_size += PB._encoded_size(x.qvar1_index, 1))
    !isempty(x.qvar2_index) && (encoded_size += PB._encoded_size(x.qvar2_index, 2))
    !isempty(x.coefficient) && (encoded_size += PB._encoded_size(x.coefficient, 3))
    return encoded_size
end

@enumx MPSolverResponseStatus MPSOLVER_OPTIMAL=0 MPSOLVER_FEASIBLE=1 MPSOLVER_INFEASIBLE=2 MPSOLVER_UNBOUNDED=3 MPSOLVER_ABNORMAL=4 MPSOLVER_NOT_SOLVED=6 MPSOLVER_MODEL_IS_VALID=97 MPSOLVER_CANCELLED_BY_USER=98 MPSOLVER_UNKNOWN_STATUS=99 MPSOLVER_MODEL_INVALID=5 MPSOLVER_MODEL_INVALID_SOLUTION_HINT=84 MPSOLVER_MODEL_INVALID_SOLVER_PARAMETERS=85 MPSOLVER_SOLVER_TYPE_UNAVAILABLE=7 MPSOLVER_INCOMPATIBLE_OPTIONS=113

struct MPQuadraticConstraint
    var_index::Vector{Int32}
    coefficient::Vector{Float64}
    qvar1_index::Vector{Int32}
    qvar2_index::Vector{Int32}
    qcoefficient::Vector{Float64}
    lower_bound::Float64
    upper_bound::Float64
end
PB.default_values(::Type{MPQuadraticConstraint}) = (;var_index = Vector{Int32}(), coefficient = Vector{Float64}(), qvar1_index = Vector{Int32}(), qvar2_index = Vector{Int32}(), qcoefficient = Vector{Float64}(), lower_bound = Float64(-Inf), upper_bound = Float64(Inf))
PB.field_numbers(::Type{MPQuadraticConstraint}) = (;var_index = 1, coefficient = 2, qvar1_index = 3, qvar2_index = 4, qcoefficient = 5, lower_bound = 6, upper_bound = 7)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MPQuadraticConstraint})
    var_index = PB.BufferedVector{Int32}()
    coefficient = PB.BufferedVector{Float64}()
    qvar1_index = PB.BufferedVector{Int32}()
    qvar2_index = PB.BufferedVector{Int32}()
    qcoefficient = PB.BufferedVector{Float64}()
    lower_bound = Float64(-Inf)
    upper_bound = Float64(Inf)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, var_index)
        elseif field_number == 2
            PB.decode!(d, wire_type, coefficient)
        elseif field_number == 3
            PB.decode!(d, wire_type, qvar1_index)
        elseif field_number == 4
            PB.decode!(d, wire_type, qvar2_index)
        elseif field_number == 5
            PB.decode!(d, wire_type, qcoefficient)
        elseif field_number == 6
            lower_bound = PB.decode(d, Float64)
        elseif field_number == 7
            upper_bound = PB.decode(d, Float64)
        else
            PB.skip(d, wire_type)
        end
    end
    return MPQuadraticConstraint(var_index[], coefficient[], qvar1_index[], qvar2_index[], qcoefficient[], lower_bound, upper_bound)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MPQuadraticConstraint)
    initpos = position(e.io)
    !isempty(x.var_index) && PB.encode(e, 1, x.var_index)
    !isempty(x.coefficient) && PB.encode(e, 2, x.coefficient)
    !isempty(x.qvar1_index) && PB.encode(e, 3, x.qvar1_index)
    !isempty(x.qvar2_index) && PB.encode(e, 4, x.qvar2_index)
    !isempty(x.qcoefficient) && PB.encode(e, 5, x.qcoefficient)
    x.lower_bound !== Float64(-Inf) && PB.encode(e, 6, x.lower_bound)
    x.upper_bound !== Float64(Inf) && PB.encode(e, 7, x.upper_bound)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MPQuadraticConstraint)
    encoded_size = 0
    !isempty(x.var_index) && (encoded_size += PB._encoded_size(x.var_index, 1))
    !isempty(x.coefficient) && (encoded_size += PB._encoded_size(x.coefficient, 2))
    !isempty(x.qvar1_index) && (encoded_size += PB._encoded_size(x.qvar1_index, 3))
    !isempty(x.qvar2_index) && (encoded_size += PB._encoded_size(x.qvar2_index, 4))
    !isempty(x.qcoefficient) && (encoded_size += PB._encoded_size(x.qcoefficient, 5))
    x.lower_bound !== Float64(-Inf) && (encoded_size += PB._encoded_size(x.lower_bound, 6))
    x.upper_bound !== Float64(Inf) && (encoded_size += PB._encoded_size(x.upper_bound, 7))
    return encoded_size
end

struct MPConstraintProto
    var_index::Vector{Int32}
    coefficient::Vector{Float64}
    lower_bound::Float64
    upper_bound::Float64
    name::String
    is_lazy::Bool
end
PB.default_values(::Type{MPConstraintProto}) = (;var_index = Vector{Int32}(), coefficient = Vector{Float64}(), lower_bound = Float64(-Inf), upper_bound = Float64(Inf), name = "", is_lazy = false)
PB.field_numbers(::Type{MPConstraintProto}) = (;var_index = 6, coefficient = 7, lower_bound = 2, upper_bound = 3, name = 4, is_lazy = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MPConstraintProto})
    var_index = PB.BufferedVector{Int32}()
    coefficient = PB.BufferedVector{Float64}()
    lower_bound = Float64(-Inf)
    upper_bound = Float64(Inf)
    name = ""
    is_lazy = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 6
            PB.decode!(d, wire_type, var_index)
        elseif field_number == 7
            PB.decode!(d, wire_type, coefficient)
        elseif field_number == 2
            lower_bound = PB.decode(d, Float64)
        elseif field_number == 3
            upper_bound = PB.decode(d, Float64)
        elseif field_number == 4
            name = PB.decode(d, String)
        elseif field_number == 5
            is_lazy = PB.decode(d, Bool)
        else
            PB.skip(d, wire_type)
        end
    end
    return MPConstraintProto(var_index[], coefficient[], lower_bound, upper_bound, name, is_lazy)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MPConstraintProto)
    initpos = position(e.io)
    !isempty(x.var_index) && PB.encode(e, 6, x.var_index)
    !isempty(x.coefficient) && PB.encode(e, 7, x.coefficient)
    x.lower_bound !== Float64(-Inf) && PB.encode(e, 2, x.lower_bound)
    x.upper_bound !== Float64(Inf) && PB.encode(e, 3, x.upper_bound)
    x.name != "" && PB.encode(e, 4, x.name)
    x.is_lazy != false && PB.encode(e, 5, x.is_lazy)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MPConstraintProto)
    encoded_size = 0
    !isempty(x.var_index) && (encoded_size += PB._encoded_size(x.var_index, 6))
    !isempty(x.coefficient) && (encoded_size += PB._encoded_size(x.coefficient, 7))
    x.lower_bound !== Float64(-Inf) && (encoded_size += PB._encoded_size(x.lower_bound, 2))
    x.upper_bound !== Float64(Inf) && (encoded_size += PB._encoded_size(x.upper_bound, 3))
    x.name != "" && (encoded_size += PB._encoded_size(x.name, 4))
    x.is_lazy != false && (encoded_size += PB._encoded_size(x.is_lazy, 5))
    return encoded_size
end

struct OptionalDouble
    value::Float64
end
PB.default_values(::Type{OptionalDouble}) = (;value = zero(Float64))
PB.field_numbers(::Type{OptionalDouble}) = (;value = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:OptionalDouble})
    value = zero(Float64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            value = PB.decode(d, Float64)
        else
            PB.skip(d, wire_type)
        end
    end
    return OptionalDouble(value)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::OptionalDouble)
    initpos = position(e.io)
    x.value !== zero(Float64) && PB.encode(e, 1, x.value)
    return position(e.io) - initpos
end
function PB._encoded_size(x::OptionalDouble)
    encoded_size = 0
    x.value !== zero(Float64) && (encoded_size += PB._encoded_size(x.value, 1))
    return encoded_size
end

@enumx var"MPSosConstraint.Type" SOS1_DEFAULT=0 SOS2=1

struct PartialVariableAssignment
    var_index::Vector{Int32}
    var_value::Vector{Float64}
end
PB.default_values(::Type{PartialVariableAssignment}) = (;var_index = Vector{Int32}(), var_value = Vector{Float64}())
PB.field_numbers(::Type{PartialVariableAssignment}) = (;var_index = 1, var_value = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:PartialVariableAssignment})
    var_index = PB.BufferedVector{Int32}()
    var_value = PB.BufferedVector{Float64}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, var_index)
        elseif field_number == 2
            PB.decode!(d, wire_type, var_value)
        else
            PB.skip(d, wire_type)
        end
    end
    return PartialVariableAssignment(var_index[], var_value[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::PartialVariableAssignment)
    initpos = position(e.io)
    !isempty(x.var_index) && PB.encode(e, 1, x.var_index)
    !isempty(x.var_value) && PB.encode(e, 2, x.var_value)
    return position(e.io) - initpos
end
function PB._encoded_size(x::PartialVariableAssignment)
    encoded_size = 0
    !isempty(x.var_index) && (encoded_size += PB._encoded_size(x.var_index, 1))
    !isempty(x.var_value) && (encoded_size += PB._encoded_size(x.var_value, 2))
    return encoded_size
end

@enumx var"MPSolverCommonParameters.LPAlgorithmValues" LP_ALGO_UNSPECIFIED=0 LP_ALGO_DUAL=1 LP_ALGO_PRIMAL=2 LP_ALGO_BARRIER=3

@enumx var"MPModelRequest.SolverType" CLP_LINEAR_PROGRAMMING=0 GLOP_LINEAR_PROGRAMMING=2 GLPK_LINEAR_PROGRAMMING=1 GUROBI_LINEAR_PROGRAMMING=6 XPRESS_LINEAR_PROGRAMMING=101 CPLEX_LINEAR_PROGRAMMING=10 HIGHS_LINEAR_PROGRAMMING=15 SCIP_MIXED_INTEGER_PROGRAMMING=3 GLPK_MIXED_INTEGER_PROGRAMMING=4 CBC_MIXED_INTEGER_PROGRAMMING=5 GUROBI_MIXED_INTEGER_PROGRAMMING=7 XPRESS_MIXED_INTEGER_PROGRAMMING=102 CPLEX_MIXED_INTEGER_PROGRAMMING=11 HIGHS_MIXED_INTEGER_PROGRAMMING=16 BOP_INTEGER_PROGRAMMING=12 SAT_INTEGER_PROGRAMMING=14 PDLP_LINEAR_PROGRAMMING=8 KNAPSACK_MIXED_INTEGER_PROGRAMMING=13

struct MPSolution
    objective_value::Float64
    variable_value::Vector{Float64}
end
PB.default_values(::Type{MPSolution}) = (;objective_value = zero(Float64), variable_value = Vector{Float64}())
PB.field_numbers(::Type{MPSolution}) = (;objective_value = 1, variable_value = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MPSolution})
    objective_value = zero(Float64)
    variable_value = PB.BufferedVector{Float64}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            objective_value = PB.decode(d, Float64)
        elseif field_number == 2
            PB.decode!(d, wire_type, variable_value)
        else
            PB.skip(d, wire_type)
        end
    end
    return MPSolution(objective_value, variable_value[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MPSolution)
    initpos = position(e.io)
    x.objective_value !== zero(Float64) && PB.encode(e, 1, x.objective_value)
    !isempty(x.variable_value) && PB.encode(e, 2, x.variable_value)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MPSolution)
    encoded_size = 0
    x.objective_value !== zero(Float64) && (encoded_size += PB._encoded_size(x.objective_value, 1))
    !isempty(x.variable_value) && (encoded_size += PB._encoded_size(x.variable_value, 2))
    return encoded_size
end

struct MPArrayWithConstantConstraint
    var_index::Vector{Int32}
    constant::Float64
    resultant_var_index::Int32
end
PB.default_values(::Type{MPArrayWithConstantConstraint}) = (;var_index = Vector{Int32}(), constant = zero(Float64), resultant_var_index = zero(Int32))
PB.field_numbers(::Type{MPArrayWithConstantConstraint}) = (;var_index = 1, constant = 2, resultant_var_index = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MPArrayWithConstantConstraint})
    var_index = PB.BufferedVector{Int32}()
    constant = zero(Float64)
    resultant_var_index = zero(Int32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, var_index)
        elseif field_number == 2
            constant = PB.decode(d, Float64)
        elseif field_number == 3
            resultant_var_index = PB.decode(d, Int32)
        else
            PB.skip(d, wire_type)
        end
    end
    return MPArrayWithConstantConstraint(var_index[], constant, resultant_var_index)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MPArrayWithConstantConstraint)
    initpos = position(e.io)
    !isempty(x.var_index) && PB.encode(e, 1, x.var_index)
    x.constant !== zero(Float64) && PB.encode(e, 2, x.constant)
    x.resultant_var_index != zero(Int32) && PB.encode(e, 3, x.resultant_var_index)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MPArrayWithConstantConstraint)
    encoded_size = 0
    !isempty(x.var_index) && (encoded_size += PB._encoded_size(x.var_index, 1))
    x.constant !== zero(Float64) && (encoded_size += PB._encoded_size(x.constant, 2))
    x.resultant_var_index != zero(Int32) && (encoded_size += PB._encoded_size(x.resultant_var_index, 3))
    return encoded_size
end

struct MPAbsConstraint
    var_index::Int32
    resultant_var_index::Int32
end
PB.default_values(::Type{MPAbsConstraint}) = (;var_index = zero(Int32), resultant_var_index = zero(Int32))
PB.field_numbers(::Type{MPAbsConstraint}) = (;var_index = 1, resultant_var_index = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MPAbsConstraint})
    var_index = zero(Int32)
    resultant_var_index = zero(Int32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            var_index = PB.decode(d, Int32)
        elseif field_number == 2
            resultant_var_index = PB.decode(d, Int32)
        else
            PB.skip(d, wire_type)
        end
    end
    return MPAbsConstraint(var_index, resultant_var_index)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MPAbsConstraint)
    initpos = position(e.io)
    x.var_index != zero(Int32) && PB.encode(e, 1, x.var_index)
    x.resultant_var_index != zero(Int32) && PB.encode(e, 2, x.resultant_var_index)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MPAbsConstraint)
    encoded_size = 0
    x.var_index != zero(Int32) && (encoded_size += PB._encoded_size(x.var_index, 1))
    x.resultant_var_index != zero(Int32) && (encoded_size += PB._encoded_size(x.resultant_var_index, 2))
    return encoded_size
end

struct MPSolveInfo
    solve_wall_time_seconds::Float64
    solve_user_time_seconds::Float64
end
PB.default_values(::Type{MPSolveInfo}) = (;solve_wall_time_seconds = zero(Float64), solve_user_time_seconds = zero(Float64))
PB.field_numbers(::Type{MPSolveInfo}) = (;solve_wall_time_seconds = 1, solve_user_time_seconds = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MPSolveInfo})
    solve_wall_time_seconds = zero(Float64)
    solve_user_time_seconds = zero(Float64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            solve_wall_time_seconds = PB.decode(d, Float64)
        elseif field_number == 2
            solve_user_time_seconds = PB.decode(d, Float64)
        else
            PB.skip(d, wire_type)
        end
    end
    return MPSolveInfo(solve_wall_time_seconds, solve_user_time_seconds)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MPSolveInfo)
    initpos = position(e.io)
    x.solve_wall_time_seconds !== zero(Float64) && PB.encode(e, 1, x.solve_wall_time_seconds)
    x.solve_user_time_seconds !== zero(Float64) && PB.encode(e, 2, x.solve_user_time_seconds)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MPSolveInfo)
    encoded_size = 0
    x.solve_wall_time_seconds !== zero(Float64) && (encoded_size += PB._encoded_size(x.solve_wall_time_seconds, 1))
    x.solve_user_time_seconds !== zero(Float64) && (encoded_size += PB._encoded_size(x.solve_user_time_seconds, 2))
    return encoded_size
end

struct MPVariableProto
    lower_bound::Float64
    upper_bound::Float64
    objective_coefficient::Float64
    is_integer::Bool
    name::String
    branching_priority::Int32
end
PB.default_values(::Type{MPVariableProto}) = (;lower_bound = Float64(-Inf), upper_bound = Float64(Inf), objective_coefficient = Float64(0.0), is_integer = false, name = "", branching_priority = Int32(0))
PB.field_numbers(::Type{MPVariableProto}) = (;lower_bound = 1, upper_bound = 2, objective_coefficient = 3, is_integer = 4, name = 5, branching_priority = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MPVariableProto})
    lower_bound = Float64(-Inf)
    upper_bound = Float64(Inf)
    objective_coefficient = Float64(0.0)
    is_integer = false
    name = ""
    branching_priority = Int32(0)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            lower_bound = PB.decode(d, Float64)
        elseif field_number == 2
            upper_bound = PB.decode(d, Float64)
        elseif field_number == 3
            objective_coefficient = PB.decode(d, Float64)
        elseif field_number == 4
            is_integer = PB.decode(d, Bool)
        elseif field_number == 5
            name = PB.decode(d, String)
        elseif field_number == 6
            branching_priority = PB.decode(d, Int32)
        else
            PB.skip(d, wire_type)
        end
    end
    return MPVariableProto(lower_bound, upper_bound, objective_coefficient, is_integer, name, branching_priority)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MPVariableProto)
    initpos = position(e.io)
    x.lower_bound !== Float64(-Inf) && PB.encode(e, 1, x.lower_bound)
    x.upper_bound !== Float64(Inf) && PB.encode(e, 2, x.upper_bound)
    x.objective_coefficient !== Float64(0.0) && PB.encode(e, 3, x.objective_coefficient)
    x.is_integer != false && PB.encode(e, 4, x.is_integer)
    x.name != "" && PB.encode(e, 5, x.name)
    x.branching_priority != Int32(0) && PB.encode(e, 6, x.branching_priority)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MPVariableProto)
    encoded_size = 0
    x.lower_bound !== Float64(-Inf) && (encoded_size += PB._encoded_size(x.lower_bound, 1))
    x.upper_bound !== Float64(Inf) && (encoded_size += PB._encoded_size(x.upper_bound, 2))
    x.objective_coefficient !== Float64(0.0) && (encoded_size += PB._encoded_size(x.objective_coefficient, 3))
    x.is_integer != false && (encoded_size += PB._encoded_size(x.is_integer, 4))
    x.name != "" && (encoded_size += PB._encoded_size(x.name, 5))
    x.branching_priority != Int32(0) && (encoded_size += PB._encoded_size(x.branching_priority, 6))
    return encoded_size
end

@enumx var"MPModelProto.Annotation.TargetType" VARIABLE_DEFAULT=0 CONSTRAINT=1 GENERAL_CONSTRAINT=2

struct MPArrayConstraint
    var_index::Vector{Int32}
    resultant_var_index::Int32
end
PB.default_values(::Type{MPArrayConstraint}) = (;var_index = Vector{Int32}(), resultant_var_index = zero(Int32))
PB.field_numbers(::Type{MPArrayConstraint}) = (;var_index = 1, resultant_var_index = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MPArrayConstraint})
    var_index = PB.BufferedVector{Int32}()
    resultant_var_index = zero(Int32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, var_index)
        elseif field_number == 2
            resultant_var_index = PB.decode(d, Int32)
        else
            PB.skip(d, wire_type)
        end
    end
    return MPArrayConstraint(var_index[], resultant_var_index)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MPArrayConstraint)
    initpos = position(e.io)
    !isempty(x.var_index) && PB.encode(e, 1, x.var_index)
    x.resultant_var_index != zero(Int32) && PB.encode(e, 2, x.resultant_var_index)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MPArrayConstraint)
    encoded_size = 0
    !isempty(x.var_index) && (encoded_size += PB._encoded_size(x.var_index, 1))
    x.resultant_var_index != zero(Int32) && (encoded_size += PB._encoded_size(x.resultant_var_index, 2))
    return encoded_size
end

struct MPIndicatorConstraint
    var_index::Int32
    var_value::Int32
    constraint::Union{Nothing,MPConstraintProto}
end
PB.default_values(::Type{MPIndicatorConstraint}) = (;var_index = zero(Int32), var_value = zero(Int32), constraint = nothing)
PB.field_numbers(::Type{MPIndicatorConstraint}) = (;var_index = 1, var_value = 2, constraint = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MPIndicatorConstraint})
    var_index = zero(Int32)
    var_value = zero(Int32)
    constraint = Ref{Union{Nothing,MPConstraintProto}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            var_index = PB.decode(d, Int32)
        elseif field_number == 2
            var_value = PB.decode(d, Int32)
        elseif field_number == 3
            PB.decode!(d, constraint)
        else
            PB.skip(d, wire_type)
        end
    end
    return MPIndicatorConstraint(var_index, var_value, constraint[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MPIndicatorConstraint)
    initpos = position(e.io)
    x.var_index != zero(Int32) && PB.encode(e, 1, x.var_index)
    x.var_value != zero(Int32) && PB.encode(e, 2, x.var_value)
    !isnothing(x.constraint) && PB.encode(e, 3, x.constraint)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MPIndicatorConstraint)
    encoded_size = 0
    x.var_index != zero(Int32) && (encoded_size += PB._encoded_size(x.var_index, 1))
    x.var_value != zero(Int32) && (encoded_size += PB._encoded_size(x.var_value, 2))
    !isnothing(x.constraint) && (encoded_size += PB._encoded_size(x.constraint, 3))
    return encoded_size
end

struct MPSosConstraint
    var"#type"::var"MPSosConstraint.Type".T
    var_index::Vector{Int32}
    weight::Vector{Float64}
end
PB.default_values(::Type{MPSosConstraint}) = (;var"#type" = var"MPSosConstraint.Type".SOS1_DEFAULT, var_index = Vector{Int32}(), weight = Vector{Float64}())
PB.field_numbers(::Type{MPSosConstraint}) = (;var"#type" = 1, var_index = 2, weight = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MPSosConstraint})
    var"#type" = var"MPSosConstraint.Type".SOS1_DEFAULT
    var_index = PB.BufferedVector{Int32}()
    weight = PB.BufferedVector{Float64}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            var"#type" = PB.decode(d, var"MPSosConstraint.Type".T)
        elseif field_number == 2
            PB.decode!(d, wire_type, var_index)
        elseif field_number == 3
            PB.decode!(d, wire_type, weight)
        else
            PB.skip(d, wire_type)
        end
    end
    return MPSosConstraint(var"#type", var_index[], weight[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MPSosConstraint)
    initpos = position(e.io)
    x.var"#type" != var"MPSosConstraint.Type".SOS1_DEFAULT && PB.encode(e, 1, x.var"#type")
    !isempty(x.var_index) && PB.encode(e, 2, x.var_index)
    !isempty(x.weight) && PB.encode(e, 3, x.weight)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MPSosConstraint)
    encoded_size = 0
    x.var"#type" != var"MPSosConstraint.Type".SOS1_DEFAULT && (encoded_size += PB._encoded_size(x.var"#type", 1))
    !isempty(x.var_index) && (encoded_size += PB._encoded_size(x.var_index, 2))
    !isempty(x.weight) && (encoded_size += PB._encoded_size(x.weight, 3))
    return encoded_size
end

struct MPSolverCommonParameters
    relative_mip_gap::Union{Nothing,OptionalDouble}
    primal_tolerance::Union{Nothing,OptionalDouble}
    dual_tolerance::Union{Nothing,OptionalDouble}
    lp_algorithm::var"MPSolverCommonParameters.LPAlgorithmValues".T
    presolve::OptionalBoolean.T
    scaling::OptionalBoolean.T
end
PB.default_values(::Type{MPSolverCommonParameters}) = (;relative_mip_gap = nothing, primal_tolerance = nothing, dual_tolerance = nothing, lp_algorithm = var"MPSolverCommonParameters.LPAlgorithmValues".LP_ALGO_UNSPECIFIED, presolve = OptionalBoolean.BOOL_UNSPECIFIED, scaling = OptionalBoolean.BOOL_UNSPECIFIED)
PB.field_numbers(::Type{MPSolverCommonParameters}) = (;relative_mip_gap = 1, primal_tolerance = 2, dual_tolerance = 3, lp_algorithm = 4, presolve = 5, scaling = 7)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MPSolverCommonParameters})
    relative_mip_gap = Ref{Union{Nothing,OptionalDouble}}(nothing)
    primal_tolerance = Ref{Union{Nothing,OptionalDouble}}(nothing)
    dual_tolerance = Ref{Union{Nothing,OptionalDouble}}(nothing)
    lp_algorithm = var"MPSolverCommonParameters.LPAlgorithmValues".LP_ALGO_UNSPECIFIED
    presolve = OptionalBoolean.BOOL_UNSPECIFIED
    scaling = OptionalBoolean.BOOL_UNSPECIFIED
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, relative_mip_gap)
        elseif field_number == 2
            PB.decode!(d, primal_tolerance)
        elseif field_number == 3
            PB.decode!(d, dual_tolerance)
        elseif field_number == 4
            lp_algorithm = PB.decode(d, var"MPSolverCommonParameters.LPAlgorithmValues".T)
        elseif field_number == 5
            presolve = PB.decode(d, OptionalBoolean.T)
        elseif field_number == 7
            scaling = PB.decode(d, OptionalBoolean.T)
        else
            PB.skip(d, wire_type)
        end
    end
    return MPSolverCommonParameters(relative_mip_gap[], primal_tolerance[], dual_tolerance[], lp_algorithm, presolve, scaling)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MPSolverCommonParameters)
    initpos = position(e.io)
    !isnothing(x.relative_mip_gap) && PB.encode(e, 1, x.relative_mip_gap)
    !isnothing(x.primal_tolerance) && PB.encode(e, 2, x.primal_tolerance)
    !isnothing(x.dual_tolerance) && PB.encode(e, 3, x.dual_tolerance)
    x.lp_algorithm != var"MPSolverCommonParameters.LPAlgorithmValues".LP_ALGO_UNSPECIFIED && PB.encode(e, 4, x.lp_algorithm)
    x.presolve != OptionalBoolean.BOOL_UNSPECIFIED && PB.encode(e, 5, x.presolve)
    x.scaling != OptionalBoolean.BOOL_UNSPECIFIED && PB.encode(e, 7, x.scaling)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MPSolverCommonParameters)
    encoded_size = 0
    !isnothing(x.relative_mip_gap) && (encoded_size += PB._encoded_size(x.relative_mip_gap, 1))
    !isnothing(x.primal_tolerance) && (encoded_size += PB._encoded_size(x.primal_tolerance, 2))
    !isnothing(x.dual_tolerance) && (encoded_size += PB._encoded_size(x.dual_tolerance, 3))
    x.lp_algorithm != var"MPSolverCommonParameters.LPAlgorithmValues".LP_ALGO_UNSPECIFIED && (encoded_size += PB._encoded_size(x.lp_algorithm, 4))
    x.presolve != OptionalBoolean.BOOL_UNSPECIFIED && (encoded_size += PB._encoded_size(x.presolve, 5))
    x.scaling != OptionalBoolean.BOOL_UNSPECIFIED && (encoded_size += PB._encoded_size(x.scaling, 7))
    return encoded_size
end

struct MPSolutionResponse
    status::MPSolverResponseStatus.T
    status_str::String
    objective_value::Float64
    best_objective_bound::Float64
    variable_value::Vector{Float64}
    solve_info::Union{Nothing,MPSolveInfo}
    solver_specific_info::Vector{UInt8}
    dual_value::Vector{Float64}
    reduced_cost::Vector{Float64}
    additional_solutions::Vector{MPSolution}
end
PB.default_values(::Type{MPSolutionResponse}) = (;status = MPSolverResponseStatus.MPSOLVER_UNKNOWN_STATUS, status_str = "", objective_value = zero(Float64), best_objective_bound = zero(Float64), variable_value = Vector{Float64}(), solve_info = nothing, solver_specific_info = UInt8[], dual_value = Vector{Float64}(), reduced_cost = Vector{Float64}(), additional_solutions = Vector{MPSolution}())
PB.field_numbers(::Type{MPSolutionResponse}) = (;status = 1, status_str = 7, objective_value = 2, best_objective_bound = 5, variable_value = 3, solve_info = 10, solver_specific_info = 11, dual_value = 4, reduced_cost = 6, additional_solutions = 8)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MPSolutionResponse})
    status = MPSolverResponseStatus.MPSOLVER_UNKNOWN_STATUS
    status_str = ""
    objective_value = zero(Float64)
    best_objective_bound = zero(Float64)
    variable_value = PB.BufferedVector{Float64}()
    solve_info = Ref{Union{Nothing,MPSolveInfo}}(nothing)
    solver_specific_info = UInt8[]
    dual_value = PB.BufferedVector{Float64}()
    reduced_cost = PB.BufferedVector{Float64}()
    additional_solutions = PB.BufferedVector{MPSolution}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            status = PB.decode(d, MPSolverResponseStatus.T)
        elseif field_number == 7
            status_str = PB.decode(d, String)
        elseif field_number == 2
            objective_value = PB.decode(d, Float64)
        elseif field_number == 5
            best_objective_bound = PB.decode(d, Float64)
        elseif field_number == 3
            PB.decode!(d, wire_type, variable_value)
        elseif field_number == 10
            PB.decode!(d, solve_info)
        elseif field_number == 11
            solver_specific_info = PB.decode(d, Vector{UInt8})
        elseif field_number == 4
            PB.decode!(d, wire_type, dual_value)
        elseif field_number == 6
            PB.decode!(d, wire_type, reduced_cost)
        elseif field_number == 8
            PB.decode!(d, additional_solutions)
        else
            PB.skip(d, wire_type)
        end
    end
    return MPSolutionResponse(status, status_str, objective_value, best_objective_bound, variable_value[], solve_info[], solver_specific_info, dual_value[], reduced_cost[], additional_solutions[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MPSolutionResponse)
    initpos = position(e.io)
    x.status != MPSolverResponseStatus.MPSOLVER_UNKNOWN_STATUS && PB.encode(e, 1, x.status)
    !isempty(x.status_str) && PB.encode(e, 7, x.status_str)
    x.objective_value !== zero(Float64) && PB.encode(e, 2, x.objective_value)
    x.best_objective_bound !== zero(Float64) && PB.encode(e, 5, x.best_objective_bound)
    !isempty(x.variable_value) && PB.encode(e, 3, x.variable_value)
    !isnothing(x.solve_info) && PB.encode(e, 10, x.solve_info)
    !isempty(x.solver_specific_info) && PB.encode(e, 11, x.solver_specific_info)
    !isempty(x.dual_value) && PB.encode(e, 4, x.dual_value)
    !isempty(x.reduced_cost) && PB.encode(e, 6, x.reduced_cost)
    !isempty(x.additional_solutions) && PB.encode(e, 8, x.additional_solutions)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MPSolutionResponse)
    encoded_size = 0
    x.status != MPSolverResponseStatus.MPSOLVER_UNKNOWN_STATUS && (encoded_size += PB._encoded_size(x.status, 1))
    !isempty(x.status_str) && (encoded_size += PB._encoded_size(x.status_str, 7))
    x.objective_value !== zero(Float64) && (encoded_size += PB._encoded_size(x.objective_value, 2))
    x.best_objective_bound !== zero(Float64) && (encoded_size += PB._encoded_size(x.best_objective_bound, 5))
    !isempty(x.variable_value) && (encoded_size += PB._encoded_size(x.variable_value, 3))
    !isnothing(x.solve_info) && (encoded_size += PB._encoded_size(x.solve_info, 10))
    !isempty(x.solver_specific_info) && (encoded_size += PB._encoded_size(x.solver_specific_info, 11))
    !isempty(x.dual_value) && (encoded_size += PB._encoded_size(x.dual_value, 4))
    !isempty(x.reduced_cost) && (encoded_size += PB._encoded_size(x.reduced_cost, 6))
    !isempty(x.additional_solutions) && (encoded_size += PB._encoded_size(x.additional_solutions, 8))
    return encoded_size
end

struct MPModelDeltaProto
    baseline_model_file_path::String
    variable_overrides::Dict{Int32,MPVariableProto}
    constraint_overrides::Dict{Int32,MPConstraintProto}
end
PB.default_values(::Type{MPModelDeltaProto}) = (;baseline_model_file_path = "", variable_overrides = Dict{Int32,MPVariableProto}(), constraint_overrides = Dict{Int32,MPConstraintProto}())
PB.field_numbers(::Type{MPModelDeltaProto}) = (;baseline_model_file_path = 1, variable_overrides = 2, constraint_overrides = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MPModelDeltaProto})
    baseline_model_file_path = ""
    variable_overrides = Dict{Int32,MPVariableProto}()
    constraint_overrides = Dict{Int32,MPConstraintProto}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            baseline_model_file_path = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, variable_overrides)
        elseif field_number == 3
            PB.decode!(d, constraint_overrides)
        else
            PB.skip(d, wire_type)
        end
    end
    return MPModelDeltaProto(baseline_model_file_path, variable_overrides, constraint_overrides)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MPModelDeltaProto)
    initpos = position(e.io)
    !isempty(x.baseline_model_file_path) && PB.encode(e, 1, x.baseline_model_file_path)
    !isempty(x.variable_overrides) && PB.encode(e, 2, x.variable_overrides)
    !isempty(x.constraint_overrides) && PB.encode(e, 3, x.constraint_overrides)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MPModelDeltaProto)
    encoded_size = 0
    !isempty(x.baseline_model_file_path) && (encoded_size += PB._encoded_size(x.baseline_model_file_path, 1))
    !isempty(x.variable_overrides) && (encoded_size += PB._encoded_size(x.variable_overrides, 2))
    !isempty(x.constraint_overrides) && (encoded_size += PB._encoded_size(x.constraint_overrides, 3))
    return encoded_size
end

struct var"MPModelProto.Annotation"
    target_type::var"MPModelProto.Annotation.TargetType".T
    target_index::Int32
    target_name::String
    payload_key::String
    payload_value::String
end
PB.default_values(::Type{var"MPModelProto.Annotation"}) = (;target_type = var"MPModelProto.Annotation.TargetType".VARIABLE_DEFAULT, target_index = zero(Int32), target_name = "", payload_key = "", payload_value = "")
PB.field_numbers(::Type{var"MPModelProto.Annotation"}) = (;target_type = 1, target_index = 2, target_name = 3, payload_key = 4, payload_value = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"MPModelProto.Annotation"})
    target_type = var"MPModelProto.Annotation.TargetType".VARIABLE_DEFAULT
    target_index = zero(Int32)
    target_name = ""
    payload_key = ""
    payload_value = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            target_type = PB.decode(d, var"MPModelProto.Annotation.TargetType".T)
        elseif field_number == 2
            target_index = PB.decode(d, Int32)
        elseif field_number == 3
            target_name = PB.decode(d, String)
        elseif field_number == 4
            payload_key = PB.decode(d, String)
        elseif field_number == 5
            payload_value = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"MPModelProto.Annotation"(target_type, target_index, target_name, payload_key, payload_value)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"MPModelProto.Annotation")
    initpos = position(e.io)
    x.target_type != var"MPModelProto.Annotation.TargetType".VARIABLE_DEFAULT && PB.encode(e, 1, x.target_type)
    x.target_index != zero(Int32) && PB.encode(e, 2, x.target_index)
    !isempty(x.target_name) && PB.encode(e, 3, x.target_name)
    !isempty(x.payload_key) && PB.encode(e, 4, x.payload_key)
    !isempty(x.payload_value) && PB.encode(e, 5, x.payload_value)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"MPModelProto.Annotation")
    encoded_size = 0
    x.target_type != var"MPModelProto.Annotation.TargetType".VARIABLE_DEFAULT && (encoded_size += PB._encoded_size(x.target_type, 1))
    x.target_index != zero(Int32) && (encoded_size += PB._encoded_size(x.target_index, 2))
    !isempty(x.target_name) && (encoded_size += PB._encoded_size(x.target_name, 3))
    !isempty(x.payload_key) && (encoded_size += PB._encoded_size(x.payload_key, 4))
    !isempty(x.payload_value) && (encoded_size += PB._encoded_size(x.payload_value, 5))
    return encoded_size
end

struct MPGeneralConstraintProto
    name::String
    general_constraint::Union{Nothing,OneOf{<:Union{MPIndicatorConstraint,MPSosConstraint,MPQuadraticConstraint,MPAbsConstraint,MPArrayConstraint,MPArrayWithConstantConstraint}}}
end
PB.oneof_field_types(::Type{MPGeneralConstraintProto}) = (;
    general_constraint = (;indicator_constraint=MPIndicatorConstraint, sos_constraint=MPSosConstraint, quadratic_constraint=MPQuadraticConstraint, abs_constraint=MPAbsConstraint, and_constraint=MPArrayConstraint, or_constraint=MPArrayConstraint, min_constraint=MPArrayWithConstantConstraint, max_constraint=MPArrayWithConstantConstraint),
)
PB.default_values(::Type{MPGeneralConstraintProto}) = (;name = "", indicator_constraint = nothing, sos_constraint = nothing, quadratic_constraint = nothing, abs_constraint = nothing, and_constraint = nothing, or_constraint = nothing, min_constraint = nothing, max_constraint = nothing)
PB.field_numbers(::Type{MPGeneralConstraintProto}) = (;name = 1, indicator_constraint = 2, sos_constraint = 3, quadratic_constraint = 4, abs_constraint = 5, and_constraint = 6, or_constraint = 7, min_constraint = 8, max_constraint = 9)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MPGeneralConstraintProto})
    name = ""
    general_constraint = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            general_constraint = OneOf(:indicator_constraint, PB.decode(d, Ref{MPIndicatorConstraint}))
        elseif field_number == 3
            general_constraint = OneOf(:sos_constraint, PB.decode(d, Ref{MPSosConstraint}))
        elseif field_number == 4
            general_constraint = OneOf(:quadratic_constraint, PB.decode(d, Ref{MPQuadraticConstraint}))
        elseif field_number == 5
            general_constraint = OneOf(:abs_constraint, PB.decode(d, Ref{MPAbsConstraint}))
        elseif field_number == 6
            general_constraint = OneOf(:and_constraint, PB.decode(d, Ref{MPArrayConstraint}))
        elseif field_number == 7
            general_constraint = OneOf(:or_constraint, PB.decode(d, Ref{MPArrayConstraint}))
        elseif field_number == 8
            general_constraint = OneOf(:min_constraint, PB.decode(d, Ref{MPArrayWithConstantConstraint}))
        elseif field_number == 9
            general_constraint = OneOf(:max_constraint, PB.decode(d, Ref{MPArrayWithConstantConstraint}))
        else
            PB.skip(d, wire_type)
        end
    end
    return MPGeneralConstraintProto(name, general_constraint)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MPGeneralConstraintProto)
    initpos = position(e.io)
    x.name != "" && PB.encode(e, 1, x.name)
    if isnothing(x.general_constraint);
    elseif x.general_constraint.name === :indicator_constraint
        PB.encode(e, 2, x.general_constraint[]::MPIndicatorConstraint)
    elseif x.general_constraint.name === :sos_constraint
        PB.encode(e, 3, x.general_constraint[]::MPSosConstraint)
    elseif x.general_constraint.name === :quadratic_constraint
        PB.encode(e, 4, x.general_constraint[]::MPQuadraticConstraint)
    elseif x.general_constraint.name === :abs_constraint
        PB.encode(e, 5, x.general_constraint[]::MPAbsConstraint)
    elseif x.general_constraint.name === :and_constraint
        PB.encode(e, 6, x.general_constraint[]::MPArrayConstraint)
    elseif x.general_constraint.name === :or_constraint
        PB.encode(e, 7, x.general_constraint[]::MPArrayConstraint)
    elseif x.general_constraint.name === :min_constraint
        PB.encode(e, 8, x.general_constraint[]::MPArrayWithConstantConstraint)
    elseif x.general_constraint.name === :max_constraint
        PB.encode(e, 9, x.general_constraint[]::MPArrayWithConstantConstraint)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::MPGeneralConstraintProto)
    encoded_size = 0
    x.name != "" && (encoded_size += PB._encoded_size(x.name, 1))
    if isnothing(x.general_constraint);
    elseif x.general_constraint.name === :indicator_constraint
        encoded_size += PB._encoded_size(x.general_constraint[]::MPIndicatorConstraint, 2)
    elseif x.general_constraint.name === :sos_constraint
        encoded_size += PB._encoded_size(x.general_constraint[]::MPSosConstraint, 3)
    elseif x.general_constraint.name === :quadratic_constraint
        encoded_size += PB._encoded_size(x.general_constraint[]::MPQuadraticConstraint, 4)
    elseif x.general_constraint.name === :abs_constraint
        encoded_size += PB._encoded_size(x.general_constraint[]::MPAbsConstraint, 5)
    elseif x.general_constraint.name === :and_constraint
        encoded_size += PB._encoded_size(x.general_constraint[]::MPArrayConstraint, 6)
    elseif x.general_constraint.name === :or_constraint
        encoded_size += PB._encoded_size(x.general_constraint[]::MPArrayConstraint, 7)
    elseif x.general_constraint.name === :min_constraint
        encoded_size += PB._encoded_size(x.general_constraint[]::MPArrayWithConstantConstraint, 8)
    elseif x.general_constraint.name === :max_constraint
        encoded_size += PB._encoded_size(x.general_constraint[]::MPArrayWithConstantConstraint, 9)
    end
    return encoded_size
end

struct MPModelProto
    variable::Vector{MPVariableProto}
    constraint::Vector{MPConstraintProto}
    general_constraint::Vector{MPGeneralConstraintProto}
    maximize::Bool
    objective_offset::Float64
    quadratic_objective::Union{Nothing,MPQuadraticObjective}
    name::String
    solution_hint::Union{Nothing,PartialVariableAssignment}
    annotation::Vector{var"MPModelProto.Annotation"}
end
PB.default_values(::Type{MPModelProto}) = (;variable = Vector{MPVariableProto}(), constraint = Vector{MPConstraintProto}(), general_constraint = Vector{MPGeneralConstraintProto}(), maximize = false, objective_offset = Float64(0.0), quadratic_objective = nothing, name = "", solution_hint = nothing, annotation = Vector{var"MPModelProto.Annotation"}())
PB.field_numbers(::Type{MPModelProto}) = (;variable = 3, constraint = 4, general_constraint = 7, maximize = 1, objective_offset = 2, quadratic_objective = 8, name = 5, solution_hint = 6, annotation = 9)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MPModelProto})
    variable = PB.BufferedVector{MPVariableProto}()
    constraint = PB.BufferedVector{MPConstraintProto}()
    general_constraint = PB.BufferedVector{MPGeneralConstraintProto}()
    maximize = false
    objective_offset = Float64(0.0)
    quadratic_objective = Ref{Union{Nothing,MPQuadraticObjective}}(nothing)
    name = ""
    solution_hint = Ref{Union{Nothing,PartialVariableAssignment}}(nothing)
    annotation = PB.BufferedVector{var"MPModelProto.Annotation"}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 3
            PB.decode!(d, variable)
        elseif field_number == 4
            PB.decode!(d, constraint)
        elseif field_number == 7
            PB.decode!(d, general_constraint)
        elseif field_number == 1
            maximize = PB.decode(d, Bool)
        elseif field_number == 2
            objective_offset = PB.decode(d, Float64)
        elseif field_number == 8
            PB.decode!(d, quadratic_objective)
        elseif field_number == 5
            name = PB.decode(d, String)
        elseif field_number == 6
            PB.decode!(d, solution_hint)
        elseif field_number == 9
            PB.decode!(d, annotation)
        else
            PB.skip(d, wire_type)
        end
    end
    return MPModelProto(variable[], constraint[], general_constraint[], maximize, objective_offset, quadratic_objective[], name, solution_hint[], annotation[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MPModelProto)
    initpos = position(e.io)
    !isempty(x.variable) && PB.encode(e, 3, x.variable)
    !isempty(x.constraint) && PB.encode(e, 4, x.constraint)
    !isempty(x.general_constraint) && PB.encode(e, 7, x.general_constraint)
    x.maximize != false && PB.encode(e, 1, x.maximize)
    x.objective_offset !== Float64(0.0) && PB.encode(e, 2, x.objective_offset)
    !isnothing(x.quadratic_objective) && PB.encode(e, 8, x.quadratic_objective)
    x.name != "" && PB.encode(e, 5, x.name)
    !isnothing(x.solution_hint) && PB.encode(e, 6, x.solution_hint)
    !isempty(x.annotation) && PB.encode(e, 9, x.annotation)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MPModelProto)
    encoded_size = 0
    !isempty(x.variable) && (encoded_size += PB._encoded_size(x.variable, 3))
    !isempty(x.constraint) && (encoded_size += PB._encoded_size(x.constraint, 4))
    !isempty(x.general_constraint) && (encoded_size += PB._encoded_size(x.general_constraint, 7))
    x.maximize != false && (encoded_size += PB._encoded_size(x.maximize, 1))
    x.objective_offset !== Float64(0.0) && (encoded_size += PB._encoded_size(x.objective_offset, 2))
    !isnothing(x.quadratic_objective) && (encoded_size += PB._encoded_size(x.quadratic_objective, 8))
    x.name != "" && (encoded_size += PB._encoded_size(x.name, 5))
    !isnothing(x.solution_hint) && (encoded_size += PB._encoded_size(x.solution_hint, 6))
    !isempty(x.annotation) && (encoded_size += PB._encoded_size(x.annotation, 9))
    return encoded_size
end

struct MPModelRequest
    model::Union{Nothing,MPModelProto}
    solver_type::var"MPModelRequest.SolverType".T
    solver_time_limit_seconds::Float64
    enable_internal_solver_output::Bool
    solver_specific_parameters::String
    ignore_solver_specific_parameters_failure::Bool
    model_delta::Union{Nothing,MPModelDeltaProto}
    populate_additional_solutions_up_to::Int32
end
PB.default_values(::Type{MPModelRequest}) = (;model = nothing, solver_type = var"MPModelRequest.SolverType".GLOP_LINEAR_PROGRAMMING, solver_time_limit_seconds = zero(Float64), enable_internal_solver_output = false, solver_specific_parameters = "", ignore_solver_specific_parameters_failure = false, model_delta = nothing, populate_additional_solutions_up_to = Int32(0))
PB.field_numbers(::Type{MPModelRequest}) = (;model = 1, solver_type = 2, solver_time_limit_seconds = 3, enable_internal_solver_output = 4, solver_specific_parameters = 5, ignore_solver_specific_parameters_failure = 9, model_delta = 8, populate_additional_solutions_up_to = 11)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:MPModelRequest})
    model = Ref{Union{Nothing,MPModelProto}}(nothing)
    solver_type = var"MPModelRequest.SolverType".GLOP_LINEAR_PROGRAMMING
    solver_time_limit_seconds = zero(Float64)
    enable_internal_solver_output = false
    solver_specific_parameters = ""
    ignore_solver_specific_parameters_failure = false
    model_delta = Ref{Union{Nothing,MPModelDeltaProto}}(nothing)
    populate_additional_solutions_up_to = Int32(0)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, model)
        elseif field_number == 2
            solver_type = PB.decode(d, var"MPModelRequest.SolverType".T)
        elseif field_number == 3
            solver_time_limit_seconds = PB.decode(d, Float64)
        elseif field_number == 4
            enable_internal_solver_output = PB.decode(d, Bool)
        elseif field_number == 5
            solver_specific_parameters = PB.decode(d, String)
        elseif field_number == 9
            ignore_solver_specific_parameters_failure = PB.decode(d, Bool)
        elseif field_number == 8
            PB.decode!(d, model_delta)
        elseif field_number == 11
            populate_additional_solutions_up_to = PB.decode(d, Int32)
        else
            PB.skip(d, wire_type)
        end
    end
    return MPModelRequest(model[], solver_type, solver_time_limit_seconds, enable_internal_solver_output, solver_specific_parameters, ignore_solver_specific_parameters_failure, model_delta[], populate_additional_solutions_up_to)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::MPModelRequest)
    initpos = position(e.io)
    !isnothing(x.model) && PB.encode(e, 1, x.model)
    x.solver_type != var"MPModelRequest.SolverType".GLOP_LINEAR_PROGRAMMING && PB.encode(e, 2, x.solver_type)
    x.solver_time_limit_seconds !== zero(Float64) && PB.encode(e, 3, x.solver_time_limit_seconds)
    x.enable_internal_solver_output != false && PB.encode(e, 4, x.enable_internal_solver_output)
    !isempty(x.solver_specific_parameters) && PB.encode(e, 5, x.solver_specific_parameters)
    x.ignore_solver_specific_parameters_failure != false && PB.encode(e, 9, x.ignore_solver_specific_parameters_failure)
    !isnothing(x.model_delta) && PB.encode(e, 8, x.model_delta)
    x.populate_additional_solutions_up_to != Int32(0) && PB.encode(e, 11, x.populate_additional_solutions_up_to)
    return position(e.io) - initpos
end
function PB._encoded_size(x::MPModelRequest)
    encoded_size = 0
    !isnothing(x.model) && (encoded_size += PB._encoded_size(x.model, 1))
    x.solver_type != var"MPModelRequest.SolverType".GLOP_LINEAR_PROGRAMMING && (encoded_size += PB._encoded_size(x.solver_type, 2))
    x.solver_time_limit_seconds !== zero(Float64) && (encoded_size += PB._encoded_size(x.solver_time_limit_seconds, 3))
    x.enable_internal_solver_output != false && (encoded_size += PB._encoded_size(x.enable_internal_solver_output, 4))
    !isempty(x.solver_specific_parameters) && (encoded_size += PB._encoded_size(x.solver_specific_parameters, 5))
    x.ignore_solver_specific_parameters_failure != false && (encoded_size += PB._encoded_size(x.ignore_solver_specific_parameters_failure, 9))
    !isnothing(x.model_delta) && (encoded_size += PB._encoded_size(x.model_delta, 8))
    x.populate_additional_solutions_up_to != Int32(0) && (encoded_size += PB._encoded_size(x.populate_additional_solutions_up_to, 11))
    return encoded_size
end
