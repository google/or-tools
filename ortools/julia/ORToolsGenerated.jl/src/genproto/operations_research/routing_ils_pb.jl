# Autogenerated using ProtoBuf.jl v1.1.1 on 2025-07-02T15:45:02.070
# original file: /usr/local/google/home/tcuvelier/.julia/artifacts/502992654d3e610bc079dfc8ac9e663bff6f3a24/include/ortools/constraint_solver/routing_ils.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export SISRRuinStrategy, var"AcceptanceStrategy.Value", AcceptanceStrategy
export var"PerturbationStrategy.Value", var"RuinCompositionStrategy.Value"
export CoolingScheduleStrategy, RuinCompositionStrategy, var"CoolingScheduleStrategy.Value"
export RandomWalkRuinStrategy, PerturbationStrategy, SpatiallyCloseRoutesRuinStrategy
export SimulatedAnnealingParameters, RuinStrategy, RuinRecreateParameters
export IteratedLocalSearchParameters


struct SISRRuinStrategy
    max_removed_sequence_size::UInt32
    avg_num_removed_visits::UInt32
    bypass_factor::Float64
end
PB.default_values(::Type{SISRRuinStrategy}) = (;max_removed_sequence_size = zero(UInt32), avg_num_removed_visits = zero(UInt32), bypass_factor = zero(Float64))
PB.field_numbers(::Type{SISRRuinStrategy}) = (;max_removed_sequence_size = 1, avg_num_removed_visits = 2, bypass_factor = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SISRRuinStrategy})
    max_removed_sequence_size = zero(UInt32)
    avg_num_removed_visits = zero(UInt32)
    bypass_factor = zero(Float64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            max_removed_sequence_size = PB.decode(d, UInt32)
        elseif field_number == 2
            avg_num_removed_visits = PB.decode(d, UInt32)
        elseif field_number == 3
            bypass_factor = PB.decode(d, Float64)
        else
            PB.skip(d, wire_type)
        end
    end
    return SISRRuinStrategy(max_removed_sequence_size, avg_num_removed_visits, bypass_factor)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SISRRuinStrategy)
    initpos = position(e.io)
    x.max_removed_sequence_size != zero(UInt32) && PB.encode(e, 1, x.max_removed_sequence_size)
    x.avg_num_removed_visits != zero(UInt32) && PB.encode(e, 2, x.avg_num_removed_visits)
    x.bypass_factor !== zero(Float64) && PB.encode(e, 3, x.bypass_factor)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SISRRuinStrategy)
    encoded_size = 0
    x.max_removed_sequence_size != zero(UInt32) && (encoded_size += PB._encoded_size(x.max_removed_sequence_size, 1))
    x.avg_num_removed_visits != zero(UInt32) && (encoded_size += PB._encoded_size(x.avg_num_removed_visits, 2))
    x.bypass_factor !== zero(Float64) && (encoded_size += PB._encoded_size(x.bypass_factor, 3))
    return encoded_size
end

@enumx var"AcceptanceStrategy.Value" UNSET=0 GREEDY_DESCENT=1 SIMULATED_ANNEALING=2

struct AcceptanceStrategy end

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:AcceptanceStrategy})
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        PB.skip(d, wire_type)
    end
    return AcceptanceStrategy()
end

function PB.encode(e::PB.AbstractProtoEncoder, x::AcceptanceStrategy)
    initpos = position(e.io)
    return position(e.io) - initpos
end
function PB._encoded_size(x::AcceptanceStrategy)
    encoded_size = 0
    return encoded_size
end

@enumx var"PerturbationStrategy.Value" UNSET=0 RUIN_AND_RECREATE=1

@enumx var"RuinCompositionStrategy.Value" UNSET=0 RUN_ALL_SEQUENTIALLY=1 RUN_ALL_RANDOMLY=2 RUN_ONE_RANDOMLY=3

struct CoolingScheduleStrategy end

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:CoolingScheduleStrategy})
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        PB.skip(d, wire_type)
    end
    return CoolingScheduleStrategy()
end

function PB.encode(e::PB.AbstractProtoEncoder, x::CoolingScheduleStrategy)
    initpos = position(e.io)
    return position(e.io) - initpos
end
function PB._encoded_size(x::CoolingScheduleStrategy)
    encoded_size = 0
    return encoded_size
end

struct RuinCompositionStrategy end

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:RuinCompositionStrategy})
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        PB.skip(d, wire_type)
    end
    return RuinCompositionStrategy()
end

function PB.encode(e::PB.AbstractProtoEncoder, x::RuinCompositionStrategy)
    initpos = position(e.io)
    return position(e.io) - initpos
end
function PB._encoded_size(x::RuinCompositionStrategy)
    encoded_size = 0
    return encoded_size
end

@enumx var"CoolingScheduleStrategy.Value" UNSET=0 EXPONENTIAL=1 LINEAR=2

struct RandomWalkRuinStrategy
    num_removed_visits::UInt32
end
PB.default_values(::Type{RandomWalkRuinStrategy}) = (;num_removed_visits = zero(UInt32))
PB.field_numbers(::Type{RandomWalkRuinStrategy}) = (;num_removed_visits = 7)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:RandomWalkRuinStrategy})
    num_removed_visits = zero(UInt32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 7
            num_removed_visits = PB.decode(d, UInt32)
        else
            PB.skip(d, wire_type)
        end
    end
    return RandomWalkRuinStrategy(num_removed_visits)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::RandomWalkRuinStrategy)
    initpos = position(e.io)
    x.num_removed_visits != zero(UInt32) && PB.encode(e, 7, x.num_removed_visits)
    return position(e.io) - initpos
end
function PB._encoded_size(x::RandomWalkRuinStrategy)
    encoded_size = 0
    x.num_removed_visits != zero(UInt32) && (encoded_size += PB._encoded_size(x.num_removed_visits, 7))
    return encoded_size
end

struct PerturbationStrategy end

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:PerturbationStrategy})
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        PB.skip(d, wire_type)
    end
    return PerturbationStrategy()
end

function PB.encode(e::PB.AbstractProtoEncoder, x::PerturbationStrategy)
    initpos = position(e.io)
    return position(e.io) - initpos
end
function PB._encoded_size(x::PerturbationStrategy)
    encoded_size = 0
    return encoded_size
end

struct SpatiallyCloseRoutesRuinStrategy
    num_ruined_routes::UInt32
end
PB.default_values(::Type{SpatiallyCloseRoutesRuinStrategy}) = (;num_ruined_routes = zero(UInt32))
PB.field_numbers(::Type{SpatiallyCloseRoutesRuinStrategy}) = (;num_ruined_routes = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SpatiallyCloseRoutesRuinStrategy})
    num_ruined_routes = zero(UInt32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 3
            num_ruined_routes = PB.decode(d, UInt32)
        else
            PB.skip(d, wire_type)
        end
    end
    return SpatiallyCloseRoutesRuinStrategy(num_ruined_routes)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SpatiallyCloseRoutesRuinStrategy)
    initpos = position(e.io)
    x.num_ruined_routes != zero(UInt32) && PB.encode(e, 3, x.num_ruined_routes)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SpatiallyCloseRoutesRuinStrategy)
    encoded_size = 0
    x.num_ruined_routes != zero(UInt32) && (encoded_size += PB._encoded_size(x.num_ruined_routes, 3))
    return encoded_size
end

struct SimulatedAnnealingParameters
    cooling_schedule_strategy::var"CoolingScheduleStrategy.Value".T
    initial_temperature::Float64
    final_temperature::Float64
    automatic_temperatures::Bool
end
PB.default_values(::Type{SimulatedAnnealingParameters}) = (;cooling_schedule_strategy = var"CoolingScheduleStrategy.Value".UNSET, initial_temperature = zero(Float64), final_temperature = zero(Float64), automatic_temperatures = false)
PB.field_numbers(::Type{SimulatedAnnealingParameters}) = (;cooling_schedule_strategy = 1, initial_temperature = 2, final_temperature = 3, automatic_temperatures = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SimulatedAnnealingParameters})
    cooling_schedule_strategy = var"CoolingScheduleStrategy.Value".UNSET
    initial_temperature = zero(Float64)
    final_temperature = zero(Float64)
    automatic_temperatures = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            cooling_schedule_strategy = PB.decode(d, var"CoolingScheduleStrategy.Value".T)
        elseif field_number == 2
            initial_temperature = PB.decode(d, Float64)
        elseif field_number == 3
            final_temperature = PB.decode(d, Float64)
        elseif field_number == 4
            automatic_temperatures = PB.decode(d, Bool)
        else
            PB.skip(d, wire_type)
        end
    end
    return SimulatedAnnealingParameters(cooling_schedule_strategy, initial_temperature, final_temperature, automatic_temperatures)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SimulatedAnnealingParameters)
    initpos = position(e.io)
    x.cooling_schedule_strategy != var"CoolingScheduleStrategy.Value".UNSET && PB.encode(e, 1, x.cooling_schedule_strategy)
    x.initial_temperature !== zero(Float64) && PB.encode(e, 2, x.initial_temperature)
    x.final_temperature !== zero(Float64) && PB.encode(e, 3, x.final_temperature)
    x.automatic_temperatures != false && PB.encode(e, 4, x.automatic_temperatures)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SimulatedAnnealingParameters)
    encoded_size = 0
    x.cooling_schedule_strategy != var"CoolingScheduleStrategy.Value".UNSET && (encoded_size += PB._encoded_size(x.cooling_schedule_strategy, 1))
    x.initial_temperature !== zero(Float64) && (encoded_size += PB._encoded_size(x.initial_temperature, 2))
    x.final_temperature !== zero(Float64) && (encoded_size += PB._encoded_size(x.final_temperature, 3))
    x.automatic_temperatures != false && (encoded_size += PB._encoded_size(x.automatic_temperatures, 4))
    return encoded_size
end

struct RuinStrategy
    strategy::Union{Nothing,OneOf{<:Union{SpatiallyCloseRoutesRuinStrategy,RandomWalkRuinStrategy,SISRRuinStrategy}}}
end
PB.oneof_field_types(::Type{RuinStrategy}) = (;
    strategy = (;spatially_close_routes=SpatiallyCloseRoutesRuinStrategy, random_walk=RandomWalkRuinStrategy, sisr=SISRRuinStrategy),
)
PB.default_values(::Type{RuinStrategy}) = (;spatially_close_routes = nothing, random_walk = nothing, sisr = nothing)
PB.field_numbers(::Type{RuinStrategy}) = (;spatially_close_routes = 1, random_walk = 2, sisr = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:RuinStrategy})
    strategy = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            strategy = OneOf(:spatially_close_routes, PB.decode(d, Ref{SpatiallyCloseRoutesRuinStrategy}))
        elseif field_number == 2
            strategy = OneOf(:random_walk, PB.decode(d, Ref{RandomWalkRuinStrategy}))
        elseif field_number == 3
            strategy = OneOf(:sisr, PB.decode(d, Ref{SISRRuinStrategy}))
        else
            PB.skip(d, wire_type)
        end
    end
    return RuinStrategy(strategy)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::RuinStrategy)
    initpos = position(e.io)
    if isnothing(x.strategy);
    elseif x.strategy.name === :spatially_close_routes
        PB.encode(e, 1, x.strategy[]::SpatiallyCloseRoutesRuinStrategy)
    elseif x.strategy.name === :random_walk
        PB.encode(e, 2, x.strategy[]::RandomWalkRuinStrategy)
    elseif x.strategy.name === :sisr
        PB.encode(e, 3, x.strategy[]::SISRRuinStrategy)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::RuinStrategy)
    encoded_size = 0
    if isnothing(x.strategy);
    elseif x.strategy.name === :spatially_close_routes
        encoded_size += PB._encoded_size(x.strategy[]::SpatiallyCloseRoutesRuinStrategy, 1)
    elseif x.strategy.name === :random_walk
        encoded_size += PB._encoded_size(x.strategy[]::RandomWalkRuinStrategy, 2)
    elseif x.strategy.name === :sisr
        encoded_size += PB._encoded_size(x.strategy[]::SISRRuinStrategy, 3)
    end
    return encoded_size
end

struct RuinRecreateParameters
    ruin_strategies::Vector{RuinStrategy}
    ruin_composition_strategy::var"RuinCompositionStrategy.Value".T
    recreate_strategy::var"FirstSolutionStrategy.Value".T
    route_selection_neighbors_ratio::Float64
    route_selection_min_neighbors::UInt32
    route_selection_max_neighbors::UInt32
end
PB.default_values(::Type{RuinRecreateParameters}) = (;ruin_strategies = Vector{RuinStrategy}(), ruin_composition_strategy = var"RuinCompositionStrategy.Value".UNSET, recreate_strategy = var"FirstSolutionStrategy.Value".UNSET, route_selection_neighbors_ratio = zero(Float64), route_selection_min_neighbors = zero(UInt32), route_selection_max_neighbors = zero(UInt32))
PB.field_numbers(::Type{RuinRecreateParameters}) = (;ruin_strategies = 1, ruin_composition_strategy = 2, recreate_strategy = 3, route_selection_neighbors_ratio = 4, route_selection_min_neighbors = 5, route_selection_max_neighbors = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:RuinRecreateParameters})
    ruin_strategies = PB.BufferedVector{RuinStrategy}()
    ruin_composition_strategy = var"RuinCompositionStrategy.Value".UNSET
    recreate_strategy = var"FirstSolutionStrategy.Value".UNSET
    route_selection_neighbors_ratio = zero(Float64)
    route_selection_min_neighbors = zero(UInt32)
    route_selection_max_neighbors = zero(UInt32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, ruin_strategies)
        elseif field_number == 2
            ruin_composition_strategy = PB.decode(d, var"RuinCompositionStrategy.Value".T)
        elseif field_number == 3
            recreate_strategy = PB.decode(d, var"FirstSolutionStrategy.Value".T)
        elseif field_number == 4
            route_selection_neighbors_ratio = PB.decode(d, Float64)
        elseif field_number == 5
            route_selection_min_neighbors = PB.decode(d, UInt32)
        elseif field_number == 6
            route_selection_max_neighbors = PB.decode(d, UInt32)
        else
            PB.skip(d, wire_type)
        end
    end
    return RuinRecreateParameters(ruin_strategies[], ruin_composition_strategy, recreate_strategy, route_selection_neighbors_ratio, route_selection_min_neighbors, route_selection_max_neighbors)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::RuinRecreateParameters)
    initpos = position(e.io)
    !isempty(x.ruin_strategies) && PB.encode(e, 1, x.ruin_strategies)
    x.ruin_composition_strategy != var"RuinCompositionStrategy.Value".UNSET && PB.encode(e, 2, x.ruin_composition_strategy)
    x.recreate_strategy != var"FirstSolutionStrategy.Value".UNSET && PB.encode(e, 3, x.recreate_strategy)
    x.route_selection_neighbors_ratio !== zero(Float64) && PB.encode(e, 4, x.route_selection_neighbors_ratio)
    x.route_selection_min_neighbors != zero(UInt32) && PB.encode(e, 5, x.route_selection_min_neighbors)
    x.route_selection_max_neighbors != zero(UInt32) && PB.encode(e, 6, x.route_selection_max_neighbors)
    return position(e.io) - initpos
end
function PB._encoded_size(x::RuinRecreateParameters)
    encoded_size = 0
    !isempty(x.ruin_strategies) && (encoded_size += PB._encoded_size(x.ruin_strategies, 1))
    x.ruin_composition_strategy != var"RuinCompositionStrategy.Value".UNSET && (encoded_size += PB._encoded_size(x.ruin_composition_strategy, 2))
    x.recreate_strategy != var"FirstSolutionStrategy.Value".UNSET && (encoded_size += PB._encoded_size(x.recreate_strategy, 3))
    x.route_selection_neighbors_ratio !== zero(Float64) && (encoded_size += PB._encoded_size(x.route_selection_neighbors_ratio, 4))
    x.route_selection_min_neighbors != zero(UInt32) && (encoded_size += PB._encoded_size(x.route_selection_min_neighbors, 5))
    x.route_selection_max_neighbors != zero(UInt32) && (encoded_size += PB._encoded_size(x.route_selection_max_neighbors, 6))
    return encoded_size
end

struct IteratedLocalSearchParameters
    perturbation_strategy::var"PerturbationStrategy.Value".T
    ruin_recreate_parameters::Union{Nothing,RuinRecreateParameters}
    improve_perturbed_solution::Bool
    acceptance_strategy::var"AcceptanceStrategy.Value".T
    simulated_annealing_parameters::Union{Nothing,SimulatedAnnealingParameters}
end
PB.default_values(::Type{IteratedLocalSearchParameters}) = (;perturbation_strategy = var"PerturbationStrategy.Value".UNSET, ruin_recreate_parameters = nothing, improve_perturbed_solution = false, acceptance_strategy = var"AcceptanceStrategy.Value".UNSET, simulated_annealing_parameters = nothing)
PB.field_numbers(::Type{IteratedLocalSearchParameters}) = (;perturbation_strategy = 1, ruin_recreate_parameters = 2, improve_perturbed_solution = 3, acceptance_strategy = 4, simulated_annealing_parameters = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:IteratedLocalSearchParameters})
    perturbation_strategy = var"PerturbationStrategy.Value".UNSET
    ruin_recreate_parameters = Ref{Union{Nothing,RuinRecreateParameters}}(nothing)
    improve_perturbed_solution = false
    acceptance_strategy = var"AcceptanceStrategy.Value".UNSET
    simulated_annealing_parameters = Ref{Union{Nothing,SimulatedAnnealingParameters}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            perturbation_strategy = PB.decode(d, var"PerturbationStrategy.Value".T)
        elseif field_number == 2
            PB.decode!(d, ruin_recreate_parameters)
        elseif field_number == 3
            improve_perturbed_solution = PB.decode(d, Bool)
        elseif field_number == 4
            acceptance_strategy = PB.decode(d, var"AcceptanceStrategy.Value".T)
        elseif field_number == 5
            PB.decode!(d, simulated_annealing_parameters)
        else
            PB.skip(d, wire_type)
        end
    end
    return IteratedLocalSearchParameters(perturbation_strategy, ruin_recreate_parameters[], improve_perturbed_solution, acceptance_strategy, simulated_annealing_parameters[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::IteratedLocalSearchParameters)
    initpos = position(e.io)
    x.perturbation_strategy != var"PerturbationStrategy.Value".UNSET && PB.encode(e, 1, x.perturbation_strategy)
    !isnothing(x.ruin_recreate_parameters) && PB.encode(e, 2, x.ruin_recreate_parameters)
    x.improve_perturbed_solution != false && PB.encode(e, 3, x.improve_perturbed_solution)
    x.acceptance_strategy != var"AcceptanceStrategy.Value".UNSET && PB.encode(e, 4, x.acceptance_strategy)
    !isnothing(x.simulated_annealing_parameters) && PB.encode(e, 5, x.simulated_annealing_parameters)
    return position(e.io) - initpos
end
function PB._encoded_size(x::IteratedLocalSearchParameters)
    encoded_size = 0
    x.perturbation_strategy != var"PerturbationStrategy.Value".UNSET && (encoded_size += PB._encoded_size(x.perturbation_strategy, 1))
    !isnothing(x.ruin_recreate_parameters) && (encoded_size += PB._encoded_size(x.ruin_recreate_parameters, 2))
    x.improve_perturbed_solution != false && (encoded_size += PB._encoded_size(x.improve_perturbed_solution, 3))
    x.acceptance_strategy != var"AcceptanceStrategy.Value".UNSET && (encoded_size += PB._encoded_size(x.acceptance_strategy, 4))
    !isnothing(x.simulated_annealing_parameters) && (encoded_size += PB._encoded_size(x.simulated_annealing_parameters, 5))
    return encoded_size
end
