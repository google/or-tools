# Autogenerated using ProtoBuf.jl v1.1.1 on 2025-07-02T15:45:01.863
# original file: /usr/local/google/home/tcuvelier/.julia/artifacts/502992654d3e610bc079dfc8ac9e663bff6f3a24/include/ortools/scheduling/course_scheduling.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export ClassAssignment, Course, CourseSchedulingResultStatus, StudentAssignment, Student
export Room, Teacher, CourseSchedulingResult, CourseSchedulingModel


struct ClassAssignment
    course_index::Int32
    section_number::Int32
    time_slots::Vector{Int32}
    room_indices::Vector{Int32}
end
PB.default_values(::Type{ClassAssignment}) = (;course_index = zero(Int32), section_number = zero(Int32), time_slots = Vector{Int32}(), room_indices = Vector{Int32}())
PB.field_numbers(::Type{ClassAssignment}) = (;course_index = 1, section_number = 2, time_slots = 3, room_indices = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ClassAssignment})
    course_index = zero(Int32)
    section_number = zero(Int32)
    time_slots = PB.BufferedVector{Int32}()
    room_indices = PB.BufferedVector{Int32}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            course_index = PB.decode(d, Int32)
        elseif field_number == 2
            section_number = PB.decode(d, Int32)
        elseif field_number == 3
            PB.decode!(d, wire_type, time_slots)
        elseif field_number == 4
            PB.decode!(d, wire_type, room_indices)
        else
            PB.skip(d, wire_type)
        end
    end
    return ClassAssignment(course_index, section_number, time_slots[], room_indices[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ClassAssignment)
    initpos = position(e.io)
    x.course_index != zero(Int32) && PB.encode(e, 1, x.course_index)
    x.section_number != zero(Int32) && PB.encode(e, 2, x.section_number)
    !isempty(x.time_slots) && PB.encode(e, 3, x.time_slots)
    !isempty(x.room_indices) && PB.encode(e, 4, x.room_indices)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ClassAssignment)
    encoded_size = 0
    x.course_index != zero(Int32) && (encoded_size += PB._encoded_size(x.course_index, 1))
    x.section_number != zero(Int32) && (encoded_size += PB._encoded_size(x.section_number, 2))
    !isempty(x.time_slots) && (encoded_size += PB._encoded_size(x.time_slots, 3))
    !isempty(x.room_indices) && (encoded_size += PB._encoded_size(x.room_indices, 4))
    return encoded_size
end

struct Course
    display_name::String
    meetings_count::Int32
    max_capacity::Int32
    min_capacity::Int32
    consecutive_slots_count::Int32
    teacher_indices::Vector{Int32}
    teacher_section_counts::Vector{Int32}
    room_indices::Vector{Int32}
end
PB.default_values(::Type{Course}) = (;display_name = "", meetings_count = zero(Int32), max_capacity = zero(Int32), min_capacity = zero(Int32), consecutive_slots_count = zero(Int32), teacher_indices = Vector{Int32}(), teacher_section_counts = Vector{Int32}(), room_indices = Vector{Int32}())
PB.field_numbers(::Type{Course}) = (;display_name = 1, meetings_count = 2, max_capacity = 3, min_capacity = 4, consecutive_slots_count = 5, teacher_indices = 6, teacher_section_counts = 7, room_indices = 8)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Course})
    display_name = ""
    meetings_count = zero(Int32)
    max_capacity = zero(Int32)
    min_capacity = zero(Int32)
    consecutive_slots_count = zero(Int32)
    teacher_indices = PB.BufferedVector{Int32}()
    teacher_section_counts = PB.BufferedVector{Int32}()
    room_indices = PB.BufferedVector{Int32}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            display_name = PB.decode(d, String)
        elseif field_number == 2
            meetings_count = PB.decode(d, Int32)
        elseif field_number == 3
            max_capacity = PB.decode(d, Int32)
        elseif field_number == 4
            min_capacity = PB.decode(d, Int32)
        elseif field_number == 5
            consecutive_slots_count = PB.decode(d, Int32)
        elseif field_number == 6
            PB.decode!(d, wire_type, teacher_indices)
        elseif field_number == 7
            PB.decode!(d, wire_type, teacher_section_counts)
        elseif field_number == 8
            PB.decode!(d, wire_type, room_indices)
        else
            PB.skip(d, wire_type)
        end
    end
    return Course(display_name, meetings_count, max_capacity, min_capacity, consecutive_slots_count, teacher_indices[], teacher_section_counts[], room_indices[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Course)
    initpos = position(e.io)
    !isempty(x.display_name) && PB.encode(e, 1, x.display_name)
    x.meetings_count != zero(Int32) && PB.encode(e, 2, x.meetings_count)
    x.max_capacity != zero(Int32) && PB.encode(e, 3, x.max_capacity)
    x.min_capacity != zero(Int32) && PB.encode(e, 4, x.min_capacity)
    x.consecutive_slots_count != zero(Int32) && PB.encode(e, 5, x.consecutive_slots_count)
    !isempty(x.teacher_indices) && PB.encode(e, 6, x.teacher_indices)
    !isempty(x.teacher_section_counts) && PB.encode(e, 7, x.teacher_section_counts)
    !isempty(x.room_indices) && PB.encode(e, 8, x.room_indices)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Course)
    encoded_size = 0
    !isempty(x.display_name) && (encoded_size += PB._encoded_size(x.display_name, 1))
    x.meetings_count != zero(Int32) && (encoded_size += PB._encoded_size(x.meetings_count, 2))
    x.max_capacity != zero(Int32) && (encoded_size += PB._encoded_size(x.max_capacity, 3))
    x.min_capacity != zero(Int32) && (encoded_size += PB._encoded_size(x.min_capacity, 4))
    x.consecutive_slots_count != zero(Int32) && (encoded_size += PB._encoded_size(x.consecutive_slots_count, 5))
    !isempty(x.teacher_indices) && (encoded_size += PB._encoded_size(x.teacher_indices, 6))
    !isempty(x.teacher_section_counts) && (encoded_size += PB._encoded_size(x.teacher_section_counts, 7))
    !isempty(x.room_indices) && (encoded_size += PB._encoded_size(x.room_indices, 8))
    return encoded_size
end

@enumx CourseSchedulingResultStatus COURSE_SCHEDULING_RESULT_STATUS_UNSPECIFIED=0 SOLVER_FEASIBLE=1 SOLVER_OPTIMAL=2 SOLVER_INFEASIBLE=3 SOLVER_MODEL_INVALID=4 SOLVER_NOT_SOLVED=5 ABNORMAL=6

struct StudentAssignment
    student_index::Int32
    course_indices::Vector{Int32}
    section_indices::Vector{Int32}
end
PB.default_values(::Type{StudentAssignment}) = (;student_index = zero(Int32), course_indices = Vector{Int32}(), section_indices = Vector{Int32}())
PB.field_numbers(::Type{StudentAssignment}) = (;student_index = 1, course_indices = 2, section_indices = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:StudentAssignment})
    student_index = zero(Int32)
    course_indices = PB.BufferedVector{Int32}()
    section_indices = PB.BufferedVector{Int32}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            student_index = PB.decode(d, Int32)
        elseif field_number == 2
            PB.decode!(d, wire_type, course_indices)
        elseif field_number == 3
            PB.decode!(d, wire_type, section_indices)
        else
            PB.skip(d, wire_type)
        end
    end
    return StudentAssignment(student_index, course_indices[], section_indices[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::StudentAssignment)
    initpos = position(e.io)
    x.student_index != zero(Int32) && PB.encode(e, 1, x.student_index)
    !isempty(x.course_indices) && PB.encode(e, 2, x.course_indices)
    !isempty(x.section_indices) && PB.encode(e, 3, x.section_indices)
    return position(e.io) - initpos
end
function PB._encoded_size(x::StudentAssignment)
    encoded_size = 0
    x.student_index != zero(Int32) && (encoded_size += PB._encoded_size(x.student_index, 1))
    !isempty(x.course_indices) && (encoded_size += PB._encoded_size(x.course_indices, 2))
    !isempty(x.section_indices) && (encoded_size += PB._encoded_size(x.section_indices, 3))
    return encoded_size
end

struct Student
    display_name::String
    course_indices::Vector{Int32}
end
PB.default_values(::Type{Student}) = (;display_name = "", course_indices = Vector{Int32}())
PB.field_numbers(::Type{Student}) = (;display_name = 1, course_indices = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Student})
    display_name = ""
    course_indices = PB.BufferedVector{Int32}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            display_name = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, wire_type, course_indices)
        else
            PB.skip(d, wire_type)
        end
    end
    return Student(display_name, course_indices[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Student)
    initpos = position(e.io)
    !isempty(x.display_name) && PB.encode(e, 1, x.display_name)
    !isempty(x.course_indices) && PB.encode(e, 2, x.course_indices)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Student)
    encoded_size = 0
    !isempty(x.display_name) && (encoded_size += PB._encoded_size(x.display_name, 1))
    !isempty(x.course_indices) && (encoded_size += PB._encoded_size(x.course_indices, 2))
    return encoded_size
end

struct Room
    display_name::String
    capacity::Int32
end
PB.default_values(::Type{Room}) = (;display_name = "", capacity = zero(Int32))
PB.field_numbers(::Type{Room}) = (;display_name = 1, capacity = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Room})
    display_name = ""
    capacity = zero(Int32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            display_name = PB.decode(d, String)
        elseif field_number == 2
            capacity = PB.decode(d, Int32)
        else
            PB.skip(d, wire_type)
        end
    end
    return Room(display_name, capacity)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Room)
    initpos = position(e.io)
    !isempty(x.display_name) && PB.encode(e, 1, x.display_name)
    x.capacity != zero(Int32) && PB.encode(e, 2, x.capacity)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Room)
    encoded_size = 0
    !isempty(x.display_name) && (encoded_size += PB._encoded_size(x.display_name, 1))
    x.capacity != zero(Int32) && (encoded_size += PB._encoded_size(x.capacity, 2))
    return encoded_size
end

struct Teacher
    display_name::String
    restricted_time_slots::Vector{Int32}
end
PB.default_values(::Type{Teacher}) = (;display_name = "", restricted_time_slots = Vector{Int32}())
PB.field_numbers(::Type{Teacher}) = (;display_name = 1, restricted_time_slots = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:Teacher})
    display_name = ""
    restricted_time_slots = PB.BufferedVector{Int32}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            display_name = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, wire_type, restricted_time_slots)
        else
            PB.skip(d, wire_type)
        end
    end
    return Teacher(display_name, restricted_time_slots[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::Teacher)
    initpos = position(e.io)
    !isempty(x.display_name) && PB.encode(e, 1, x.display_name)
    !isempty(x.restricted_time_slots) && PB.encode(e, 2, x.restricted_time_slots)
    return position(e.io) - initpos
end
function PB._encoded_size(x::Teacher)
    encoded_size = 0
    !isempty(x.display_name) && (encoded_size += PB._encoded_size(x.display_name, 1))
    !isempty(x.restricted_time_slots) && (encoded_size += PB._encoded_size(x.restricted_time_slots, 2))
    return encoded_size
end

struct CourseSchedulingResult
    message::String
    solver_status::CourseSchedulingResultStatus.T
    class_assignments::Vector{ClassAssignment}
    student_assignments::Vector{StudentAssignment}
end
PB.default_values(::Type{CourseSchedulingResult}) = (;message = "", solver_status = CourseSchedulingResultStatus.COURSE_SCHEDULING_RESULT_STATUS_UNSPECIFIED, class_assignments = Vector{ClassAssignment}(), student_assignments = Vector{StudentAssignment}())
PB.field_numbers(::Type{CourseSchedulingResult}) = (;message = 1, solver_status = 2, class_assignments = 3, student_assignments = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:CourseSchedulingResult})
    message = ""
    solver_status = CourseSchedulingResultStatus.COURSE_SCHEDULING_RESULT_STATUS_UNSPECIFIED
    class_assignments = PB.BufferedVector{ClassAssignment}()
    student_assignments = PB.BufferedVector{StudentAssignment}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            message = PB.decode(d, String)
        elseif field_number == 2
            solver_status = PB.decode(d, CourseSchedulingResultStatus.T)
        elseif field_number == 3
            PB.decode!(d, class_assignments)
        elseif field_number == 4
            PB.decode!(d, student_assignments)
        else
            PB.skip(d, wire_type)
        end
    end
    return CourseSchedulingResult(message, solver_status, class_assignments[], student_assignments[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::CourseSchedulingResult)
    initpos = position(e.io)
    !isempty(x.message) && PB.encode(e, 1, x.message)
    x.solver_status != CourseSchedulingResultStatus.COURSE_SCHEDULING_RESULT_STATUS_UNSPECIFIED && PB.encode(e, 2, x.solver_status)
    !isempty(x.class_assignments) && PB.encode(e, 3, x.class_assignments)
    !isempty(x.student_assignments) && PB.encode(e, 4, x.student_assignments)
    return position(e.io) - initpos
end
function PB._encoded_size(x::CourseSchedulingResult)
    encoded_size = 0
    !isempty(x.message) && (encoded_size += PB._encoded_size(x.message, 1))
    x.solver_status != CourseSchedulingResultStatus.COURSE_SCHEDULING_RESULT_STATUS_UNSPECIFIED && (encoded_size += PB._encoded_size(x.solver_status, 2))
    !isempty(x.class_assignments) && (encoded_size += PB._encoded_size(x.class_assignments, 3))
    !isempty(x.student_assignments) && (encoded_size += PB._encoded_size(x.student_assignments, 4))
    return encoded_size
end

struct CourseSchedulingModel
    display_name::String
    days_count::Int32
    daily_time_slot_count::Int32
    courses::Vector{Course}
    teachers::Vector{Teacher}
    students::Vector{Student}
    rooms::Vector{Room}
end
PB.default_values(::Type{CourseSchedulingModel}) = (;display_name = "", days_count = zero(Int32), daily_time_slot_count = zero(Int32), courses = Vector{Course}(), teachers = Vector{Teacher}(), students = Vector{Student}(), rooms = Vector{Room}())
PB.field_numbers(::Type{CourseSchedulingModel}) = (;display_name = 1, days_count = 2, daily_time_slot_count = 3, courses = 4, teachers = 5, students = 6, rooms = 7)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:CourseSchedulingModel})
    display_name = ""
    days_count = zero(Int32)
    daily_time_slot_count = zero(Int32)
    courses = PB.BufferedVector{Course}()
    teachers = PB.BufferedVector{Teacher}()
    students = PB.BufferedVector{Student}()
    rooms = PB.BufferedVector{Room}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            display_name = PB.decode(d, String)
        elseif field_number == 2
            days_count = PB.decode(d, Int32)
        elseif field_number == 3
            daily_time_slot_count = PB.decode(d, Int32)
        elseif field_number == 4
            PB.decode!(d, courses)
        elseif field_number == 5
            PB.decode!(d, teachers)
        elseif field_number == 6
            PB.decode!(d, students)
        elseif field_number == 7
            PB.decode!(d, rooms)
        else
            PB.skip(d, wire_type)
        end
    end
    return CourseSchedulingModel(display_name, days_count, daily_time_slot_count, courses[], teachers[], students[], rooms[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::CourseSchedulingModel)
    initpos = position(e.io)
    !isempty(x.display_name) && PB.encode(e, 1, x.display_name)
    x.days_count != zero(Int32) && PB.encode(e, 2, x.days_count)
    x.daily_time_slot_count != zero(Int32) && PB.encode(e, 3, x.daily_time_slot_count)
    !isempty(x.courses) && PB.encode(e, 4, x.courses)
    !isempty(x.teachers) && PB.encode(e, 5, x.teachers)
    !isempty(x.students) && PB.encode(e, 6, x.students)
    !isempty(x.rooms) && PB.encode(e, 7, x.rooms)
    return position(e.io) - initpos
end
function PB._encoded_size(x::CourseSchedulingModel)
    encoded_size = 0
    !isempty(x.display_name) && (encoded_size += PB._encoded_size(x.display_name, 1))
    x.days_count != zero(Int32) && (encoded_size += PB._encoded_size(x.days_count, 2))
    x.daily_time_slot_count != zero(Int32) && (encoded_size += PB._encoded_size(x.daily_time_slot_count, 3))
    !isempty(x.courses) && (encoded_size += PB._encoded_size(x.courses, 4))
    !isempty(x.teachers) && (encoded_size += PB._encoded_size(x.teachers, 5))
    !isempty(x.students) && (encoded_size += PB._encoded_size(x.students, 6))
    !isempty(x.rooms) && (encoded_size += PB._encoded_size(x.rooms, 7))
    return encoded_size
end
