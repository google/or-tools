# Autogenerated using ProtoBuf.jl v1.1.1 on 2025-07-02T15:45:01.864
# original file: /usr/local/google/home/tcuvelier/.julia/artifacts/502992654d3e610bc079dfc8ac9e663bff6f3a24/include/ortools/constraint_solver/assignment.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export IntVarAssignment, SequenceVarAssignment, IntervalVarAssignment, WorkerInfo
export AssignmentProto


struct IntVarAssignment
    var_id::String
    min::Int64
    max::Int64
    active::Bool
end
PB.default_values(::Type{IntVarAssignment}) = (;var_id = "", min = zero(Int64), max = zero(Int64), active = false)
PB.field_numbers(::Type{IntVarAssignment}) = (;var_id = 1, min = 2, max = 3, active = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:IntVarAssignment})
    var_id = ""
    min = zero(Int64)
    max = zero(Int64)
    active = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            var_id = PB.decode(d, String)
        elseif field_number == 2
            min = PB.decode(d, Int64)
        elseif field_number == 3
            max = PB.decode(d, Int64)
        elseif field_number == 4
            active = PB.decode(d, Bool)
        else
            PB.skip(d, wire_type)
        end
    end
    return IntVarAssignment(var_id, min, max, active)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::IntVarAssignment)
    initpos = position(e.io)
    !isempty(x.var_id) && PB.encode(e, 1, x.var_id)
    x.min != zero(Int64) && PB.encode(e, 2, x.min)
    x.max != zero(Int64) && PB.encode(e, 3, x.max)
    x.active != false && PB.encode(e, 4, x.active)
    return position(e.io) - initpos
end
function PB._encoded_size(x::IntVarAssignment)
    encoded_size = 0
    !isempty(x.var_id) && (encoded_size += PB._encoded_size(x.var_id, 1))
    x.min != zero(Int64) && (encoded_size += PB._encoded_size(x.min, 2))
    x.max != zero(Int64) && (encoded_size += PB._encoded_size(x.max, 3))
    x.active != false && (encoded_size += PB._encoded_size(x.active, 4))
    return encoded_size
end

struct SequenceVarAssignment
    var_id::String
    forward_sequence::Vector{Int32}
    backward_sequence::Vector{Int32}
    unperformed::Vector{Int32}
    active::Bool
end
PB.default_values(::Type{SequenceVarAssignment}) = (;var_id = "", forward_sequence = Vector{Int32}(), backward_sequence = Vector{Int32}(), unperformed = Vector{Int32}(), active = false)
PB.field_numbers(::Type{SequenceVarAssignment}) = (;var_id = 1, forward_sequence = 2, backward_sequence = 3, unperformed = 4, active = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SequenceVarAssignment})
    var_id = ""
    forward_sequence = PB.BufferedVector{Int32}()
    backward_sequence = PB.BufferedVector{Int32}()
    unperformed = PB.BufferedVector{Int32}()
    active = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            var_id = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, wire_type, forward_sequence)
        elseif field_number == 3
            PB.decode!(d, wire_type, backward_sequence)
        elseif field_number == 4
            PB.decode!(d, wire_type, unperformed)
        elseif field_number == 5
            active = PB.decode(d, Bool)
        else
            PB.skip(d, wire_type)
        end
    end
    return SequenceVarAssignment(var_id, forward_sequence[], backward_sequence[], unperformed[], active)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SequenceVarAssignment)
    initpos = position(e.io)
    !isempty(x.var_id) && PB.encode(e, 1, x.var_id)
    !isempty(x.forward_sequence) && PB.encode(e, 2, x.forward_sequence)
    !isempty(x.backward_sequence) && PB.encode(e, 3, x.backward_sequence)
    !isempty(x.unperformed) && PB.encode(e, 4, x.unperformed)
    x.active != false && PB.encode(e, 5, x.active)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SequenceVarAssignment)
    encoded_size = 0
    !isempty(x.var_id) && (encoded_size += PB._encoded_size(x.var_id, 1))
    !isempty(x.forward_sequence) && (encoded_size += PB._encoded_size(x.forward_sequence, 2))
    !isempty(x.backward_sequence) && (encoded_size += PB._encoded_size(x.backward_sequence, 3))
    !isempty(x.unperformed) && (encoded_size += PB._encoded_size(x.unperformed, 4))
    x.active != false && (encoded_size += PB._encoded_size(x.active, 5))
    return encoded_size
end

struct IntervalVarAssignment
    var_id::String
    start_min::Int64
    start_max::Int64
    duration_min::Int64
    duration_max::Int64
    end_min::Int64
    end_max::Int64
    performed_min::Int64
    performed_max::Int64
    active::Bool
end
PB.default_values(::Type{IntervalVarAssignment}) = (;var_id = "", start_min = zero(Int64), start_max = zero(Int64), duration_min = zero(Int64), duration_max = zero(Int64), end_min = zero(Int64), end_max = zero(Int64), performed_min = zero(Int64), performed_max = zero(Int64), active = false)
PB.field_numbers(::Type{IntervalVarAssignment}) = (;var_id = 1, start_min = 2, start_max = 3, duration_min = 4, duration_max = 5, end_min = 6, end_max = 7, performed_min = 8, performed_max = 9, active = 10)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:IntervalVarAssignment})
    var_id = ""
    start_min = zero(Int64)
    start_max = zero(Int64)
    duration_min = zero(Int64)
    duration_max = zero(Int64)
    end_min = zero(Int64)
    end_max = zero(Int64)
    performed_min = zero(Int64)
    performed_max = zero(Int64)
    active = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            var_id = PB.decode(d, String)
        elseif field_number == 2
            start_min = PB.decode(d, Int64)
        elseif field_number == 3
            start_max = PB.decode(d, Int64)
        elseif field_number == 4
            duration_min = PB.decode(d, Int64)
        elseif field_number == 5
            duration_max = PB.decode(d, Int64)
        elseif field_number == 6
            end_min = PB.decode(d, Int64)
        elseif field_number == 7
            end_max = PB.decode(d, Int64)
        elseif field_number == 8
            performed_min = PB.decode(d, Int64)
        elseif field_number == 9
            performed_max = PB.decode(d, Int64)
        elseif field_number == 10
            active = PB.decode(d, Bool)
        else
            PB.skip(d, wire_type)
        end
    end
    return IntervalVarAssignment(var_id, start_min, start_max, duration_min, duration_max, end_min, end_max, performed_min, performed_max, active)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::IntervalVarAssignment)
    initpos = position(e.io)
    !isempty(x.var_id) && PB.encode(e, 1, x.var_id)
    x.start_min != zero(Int64) && PB.encode(e, 2, x.start_min)
    x.start_max != zero(Int64) && PB.encode(e, 3, x.start_max)
    x.duration_min != zero(Int64) && PB.encode(e, 4, x.duration_min)
    x.duration_max != zero(Int64) && PB.encode(e, 5, x.duration_max)
    x.end_min != zero(Int64) && PB.encode(e, 6, x.end_min)
    x.end_max != zero(Int64) && PB.encode(e, 7, x.end_max)
    x.performed_min != zero(Int64) && PB.encode(e, 8, x.performed_min)
    x.performed_max != zero(Int64) && PB.encode(e, 9, x.performed_max)
    x.active != false && PB.encode(e, 10, x.active)
    return position(e.io) - initpos
end
function PB._encoded_size(x::IntervalVarAssignment)
    encoded_size = 0
    !isempty(x.var_id) && (encoded_size += PB._encoded_size(x.var_id, 1))
    x.start_min != zero(Int64) && (encoded_size += PB._encoded_size(x.start_min, 2))
    x.start_max != zero(Int64) && (encoded_size += PB._encoded_size(x.start_max, 3))
    x.duration_min != zero(Int64) && (encoded_size += PB._encoded_size(x.duration_min, 4))
    x.duration_max != zero(Int64) && (encoded_size += PB._encoded_size(x.duration_max, 5))
    x.end_min != zero(Int64) && (encoded_size += PB._encoded_size(x.end_min, 6))
    x.end_max != zero(Int64) && (encoded_size += PB._encoded_size(x.end_max, 7))
    x.performed_min != zero(Int64) && (encoded_size += PB._encoded_size(x.performed_min, 8))
    x.performed_max != zero(Int64) && (encoded_size += PB._encoded_size(x.performed_max, 9))
    x.active != false && (encoded_size += PB._encoded_size(x.active, 10))
    return encoded_size
end

struct WorkerInfo
    worker_id::Int32
    bns::String
end
PB.default_values(::Type{WorkerInfo}) = (;worker_id = zero(Int32), bns = "")
PB.field_numbers(::Type{WorkerInfo}) = (;worker_id = 1, bns = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:WorkerInfo})
    worker_id = zero(Int32)
    bns = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            worker_id = PB.decode(d, Int32)
        elseif field_number == 2
            bns = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return WorkerInfo(worker_id, bns)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::WorkerInfo)
    initpos = position(e.io)
    x.worker_id != zero(Int32) && PB.encode(e, 1, x.worker_id)
    !isempty(x.bns) && PB.encode(e, 2, x.bns)
    return position(e.io) - initpos
end
function PB._encoded_size(x::WorkerInfo)
    encoded_size = 0
    x.worker_id != zero(Int32) && (encoded_size += PB._encoded_size(x.worker_id, 1))
    !isempty(x.bns) && (encoded_size += PB._encoded_size(x.bns, 2))
    return encoded_size
end

struct AssignmentProto
    int_var_assignment::Vector{IntVarAssignment}
    interval_var_assignment::Vector{IntervalVarAssignment}
    sequence_var_assignment::Vector{SequenceVarAssignment}
    objective::Vector{IntVarAssignment}
    worker_info::Union{Nothing,WorkerInfo}
    is_valid::Bool
end
PB.default_values(::Type{AssignmentProto}) = (;int_var_assignment = Vector{IntVarAssignment}(), interval_var_assignment = Vector{IntervalVarAssignment}(), sequence_var_assignment = Vector{SequenceVarAssignment}(), objective = Vector{IntVarAssignment}(), worker_info = nothing, is_valid = false)
PB.field_numbers(::Type{AssignmentProto}) = (;int_var_assignment = 1, interval_var_assignment = 2, sequence_var_assignment = 6, objective = 3, worker_info = 4, is_valid = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:AssignmentProto})
    int_var_assignment = PB.BufferedVector{IntVarAssignment}()
    interval_var_assignment = PB.BufferedVector{IntervalVarAssignment}()
    sequence_var_assignment = PB.BufferedVector{SequenceVarAssignment}()
    objective = PB.BufferedVector{IntVarAssignment}()
    worker_info = Ref{Union{Nothing,WorkerInfo}}(nothing)
    is_valid = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, int_var_assignment)
        elseif field_number == 2
            PB.decode!(d, interval_var_assignment)
        elseif field_number == 6
            PB.decode!(d, sequence_var_assignment)
        elseif field_number == 3
            PB.decode!(d, objective)
        elseif field_number == 4
            PB.decode!(d, worker_info)
        elseif field_number == 5
            is_valid = PB.decode(d, Bool)
        else
            PB.skip(d, wire_type)
        end
    end
    return AssignmentProto(int_var_assignment[], interval_var_assignment[], sequence_var_assignment[], objective[], worker_info[], is_valid)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::AssignmentProto)
    initpos = position(e.io)
    !isempty(x.int_var_assignment) && PB.encode(e, 1, x.int_var_assignment)
    !isempty(x.interval_var_assignment) && PB.encode(e, 2, x.interval_var_assignment)
    !isempty(x.sequence_var_assignment) && PB.encode(e, 6, x.sequence_var_assignment)
    !isempty(x.objective) && PB.encode(e, 3, x.objective)
    !isnothing(x.worker_info) && PB.encode(e, 4, x.worker_info)
    x.is_valid != false && PB.encode(e, 5, x.is_valid)
    return position(e.io) - initpos
end
function PB._encoded_size(x::AssignmentProto)
    encoded_size = 0
    !isempty(x.int_var_assignment) && (encoded_size += PB._encoded_size(x.int_var_assignment, 1))
    !isempty(x.interval_var_assignment) && (encoded_size += PB._encoded_size(x.interval_var_assignment, 2))
    !isempty(x.sequence_var_assignment) && (encoded_size += PB._encoded_size(x.sequence_var_assignment, 6))
    !isempty(x.objective) && (encoded_size += PB._encoded_size(x.objective, 3))
    !isnothing(x.worker_info) && (encoded_size += PB._encoded_size(x.worker_info, 4))
    x.is_valid != false && (encoded_size += PB._encoded_size(x.is_valid, 5))
    return encoded_size
end
