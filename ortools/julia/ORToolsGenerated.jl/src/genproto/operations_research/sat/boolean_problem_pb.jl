# Autogenerated using ProtoBuf.jl v1.1.1 on 2025-07-02T15:45:02.134
# original file: /usr/local/google/home/tcuvelier/.julia/artifacts/502992654d3e610bc079dfc8ac9e663bff6f3a24/include/ortools/sat/boolean_problem.proto (proto2 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export BooleanAssignment, LinearObjective, LinearBooleanConstraint, LinearBooleanProblem


struct BooleanAssignment
    literals::Vector{Int32}
end
PB.default_values(::Type{BooleanAssignment}) = (;literals = Vector{Int32}())
PB.field_numbers(::Type{BooleanAssignment}) = (;literals = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:BooleanAssignment})
    literals = PB.BufferedVector{Int32}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, literals)
        else
            PB.skip(d, wire_type)
        end
    end
    return BooleanAssignment(literals[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::BooleanAssignment)
    initpos = position(e.io)
    !isempty(x.literals) && PB.encode(e, 1, x.literals)
    return position(e.io) - initpos
end
function PB._encoded_size(x::BooleanAssignment)
    encoded_size = 0
    !isempty(x.literals) && (encoded_size += PB._encoded_size(x.literals, 1))
    return encoded_size
end

struct LinearObjective
    literals::Vector{Int32}
    coefficients::Vector{Int64}
    offset::Float64
    scaling_factor::Float64
end
PB.default_values(::Type{LinearObjective}) = (;literals = Vector{Int32}(), coefficients = Vector{Int64}(), offset = Float64(0.0), scaling_factor = Float64(1.0))
PB.field_numbers(::Type{LinearObjective}) = (;literals = 1, coefficients = 2, offset = 3, scaling_factor = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:LinearObjective})
    literals = PB.BufferedVector{Int32}()
    coefficients = PB.BufferedVector{Int64}()
    offset = Float64(0.0)
    scaling_factor = Float64(1.0)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, literals)
        elseif field_number == 2
            PB.decode!(d, wire_type, coefficients)
        elseif field_number == 3
            offset = PB.decode(d, Float64)
        elseif field_number == 4
            scaling_factor = PB.decode(d, Float64)
        else
            PB.skip(d, wire_type)
        end
    end
    return LinearObjective(literals[], coefficients[], offset, scaling_factor)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::LinearObjective)
    initpos = position(e.io)
    !isempty(x.literals) && PB.encode(e, 1, x.literals)
    !isempty(x.coefficients) && PB.encode(e, 2, x.coefficients)
    x.offset !== Float64(0.0) && PB.encode(e, 3, x.offset)
    x.scaling_factor !== Float64(1.0) && PB.encode(e, 4, x.scaling_factor)
    return position(e.io) - initpos
end
function PB._encoded_size(x::LinearObjective)
    encoded_size = 0
    !isempty(x.literals) && (encoded_size += PB._encoded_size(x.literals, 1))
    !isempty(x.coefficients) && (encoded_size += PB._encoded_size(x.coefficients, 2))
    x.offset !== Float64(0.0) && (encoded_size += PB._encoded_size(x.offset, 3))
    x.scaling_factor !== Float64(1.0) && (encoded_size += PB._encoded_size(x.scaling_factor, 4))
    return encoded_size
end

struct LinearBooleanConstraint
    literals::Vector{Int32}
    coefficients::Vector{Int64}
    lower_bound::Int64
    upper_bound::Int64
    name::String
end
PB.default_values(::Type{LinearBooleanConstraint}) = (;literals = Vector{Int32}(), coefficients = Vector{Int64}(), lower_bound = zero(Int64), upper_bound = zero(Int64), name = "")
PB.field_numbers(::Type{LinearBooleanConstraint}) = (;literals = 1, coefficients = 2, lower_bound = 3, upper_bound = 4, name = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:LinearBooleanConstraint})
    literals = PB.BufferedVector{Int32}()
    coefficients = PB.BufferedVector{Int64}()
    lower_bound = zero(Int64)
    upper_bound = zero(Int64)
    name = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, literals)
        elseif field_number == 2
            PB.decode!(d, wire_type, coefficients)
        elseif field_number == 3
            lower_bound = PB.decode(d, Int64)
        elseif field_number == 4
            upper_bound = PB.decode(d, Int64)
        elseif field_number == 5
            name = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return LinearBooleanConstraint(literals[], coefficients[], lower_bound, upper_bound, name)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::LinearBooleanConstraint)
    initpos = position(e.io)
    !isempty(x.literals) && PB.encode(e, 1, x.literals)
    !isempty(x.coefficients) && PB.encode(e, 2, x.coefficients)
    x.lower_bound != zero(Int64) && PB.encode(e, 3, x.lower_bound)
    x.upper_bound != zero(Int64) && PB.encode(e, 4, x.upper_bound)
    x.name != "" && PB.encode(e, 5, x.name)
    return position(e.io) - initpos
end
function PB._encoded_size(x::LinearBooleanConstraint)
    encoded_size = 0
    !isempty(x.literals) && (encoded_size += PB._encoded_size(x.literals, 1))
    !isempty(x.coefficients) && (encoded_size += PB._encoded_size(x.coefficients, 2))
    x.lower_bound != zero(Int64) && (encoded_size += PB._encoded_size(x.lower_bound, 3))
    x.upper_bound != zero(Int64) && (encoded_size += PB._encoded_size(x.upper_bound, 4))
    x.name != "" && (encoded_size += PB._encoded_size(x.name, 5))
    return encoded_size
end

struct LinearBooleanProblem
    name::String
    num_variables::Int32
    constraints::Vector{LinearBooleanConstraint}
    objective::Union{Nothing,LinearObjective}
    var_names::Vector{String}
    assignment::Union{Nothing,BooleanAssignment}
    original_num_variables::Int32
end
PB.default_values(::Type{LinearBooleanProblem}) = (;name = "", num_variables = zero(Int32), constraints = Vector{LinearBooleanConstraint}(), objective = nothing, var_names = Vector{String}(), assignment = nothing, original_num_variables = zero(Int32))
PB.field_numbers(::Type{LinearBooleanProblem}) = (;name = 1, num_variables = 3, constraints = 4, objective = 5, var_names = 6, assignment = 7, original_num_variables = 8)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:LinearBooleanProblem})
    name = ""
    num_variables = zero(Int32)
    constraints = PB.BufferedVector{LinearBooleanConstraint}()
    objective = Ref{Union{Nothing,LinearObjective}}(nothing)
    var_names = PB.BufferedVector{String}()
    assignment = Ref{Union{Nothing,BooleanAssignment}}(nothing)
    original_num_variables = zero(Int32)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 3
            num_variables = PB.decode(d, Int32)
        elseif field_number == 4
            PB.decode!(d, constraints)
        elseif field_number == 5
            PB.decode!(d, objective)
        elseif field_number == 6
            PB.decode!(d, var_names)
        elseif field_number == 7
            PB.decode!(d, assignment)
        elseif field_number == 8
            original_num_variables = PB.decode(d, Int32)
        else
            PB.skip(d, wire_type)
        end
    end
    return LinearBooleanProblem(name, num_variables, constraints[], objective[], var_names[], assignment[], original_num_variables)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::LinearBooleanProblem)
    initpos = position(e.io)
    x.name != "" && PB.encode(e, 1, x.name)
    x.num_variables != zero(Int32) && PB.encode(e, 3, x.num_variables)
    !isempty(x.constraints) && PB.encode(e, 4, x.constraints)
    !isnothing(x.objective) && PB.encode(e, 5, x.objective)
    !isempty(x.var_names) && PB.encode(e, 6, x.var_names)
    !isnothing(x.assignment) && PB.encode(e, 7, x.assignment)
    x.original_num_variables != zero(Int32) && PB.encode(e, 8, x.original_num_variables)
    return position(e.io) - initpos
end
function PB._encoded_size(x::LinearBooleanProblem)
    encoded_size = 0
    x.name != "" && (encoded_size += PB._encoded_size(x.name, 1))
    x.num_variables != zero(Int32) && (encoded_size += PB._encoded_size(x.num_variables, 3))
    !isempty(x.constraints) && (encoded_size += PB._encoded_size(x.constraints, 4))
    !isnothing(x.objective) && (encoded_size += PB._encoded_size(x.objective, 5))
    !isempty(x.var_names) && (encoded_size += PB._encoded_size(x.var_names, 6))
    !isnothing(x.assignment) && (encoded_size += PB._encoded_size(x.assignment, 7))
    x.original_num_variables != zero(Int32) && (encoded_size += PB._encoded_size(x.original_num_variables, 8))
    return encoded_size
end
