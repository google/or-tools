# Autogenerated using ProtoBuf.jl v1.1.1 on 2025-07-02T15:45:02.137
# original file: /usr/local/google/home/tcuvelier/.julia/artifacts/502992654d3e610bc079dfc8ac9e663bff6f3a24/include/ortools/sat/cp_model.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export LinearExpressionProto, CpSolverSolution, SparsePermutationProto
export IntegerVariableProto, BoolArgumentProto, FloatObjectiveProto
export PartialVariableAssignment, LinearConstraintProto, CpObjectiveProto
export InverseConstraintProto, var"DecisionStrategyProto.VariableSelectionStrategy"
export DenseMatrixProto, ListOfVariablesProto, CpSolverStatus, NoOverlap2DConstraintProto
export CircuitConstraintProto, NoOverlapConstraintProto
export var"DecisionStrategyProto.DomainReductionStrategy", LinearArgumentProto
export IntervalConstraintProto, AllDifferentConstraintProto, ReservoirConstraintProto
export ElementConstraintProto, TableConstraintProto, AutomatonConstraintProto
export CumulativeConstraintProto, var"RoutesConstraintProto.NodeExpressions", SymmetryProto
export CpSolverResponse, DecisionStrategyProto, RoutesConstraintProto, ConstraintProto
export CpModelProto


struct LinearExpressionProto
    vars::Vector{Int32}
    coeffs::Vector{Int64}
    offset::Int64
end
PB.default_values(::Type{LinearExpressionProto}) = (;vars = Vector{Int32}(), coeffs = Vector{Int64}(), offset = zero(Int64))
PB.field_numbers(::Type{LinearExpressionProto}) = (;vars = 1, coeffs = 2, offset = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:LinearExpressionProto})
    vars = PB.BufferedVector{Int32}()
    coeffs = PB.BufferedVector{Int64}()
    offset = zero(Int64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, vars)
        elseif field_number == 2
            PB.decode!(d, wire_type, coeffs)
        elseif field_number == 3
            offset = PB.decode(d, Int64)
        else
            PB.skip(d, wire_type)
        end
    end
    return LinearExpressionProto(vars[], coeffs[], offset)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::LinearExpressionProto)
    initpos = position(e.io)
    !isempty(x.vars) && PB.encode(e, 1, x.vars)
    !isempty(x.coeffs) && PB.encode(e, 2, x.coeffs)
    x.offset != zero(Int64) && PB.encode(e, 3, x.offset)
    return position(e.io) - initpos
end
function PB._encoded_size(x::LinearExpressionProto)
    encoded_size = 0
    !isempty(x.vars) && (encoded_size += PB._encoded_size(x.vars, 1))
    !isempty(x.coeffs) && (encoded_size += PB._encoded_size(x.coeffs, 2))
    x.offset != zero(Int64) && (encoded_size += PB._encoded_size(x.offset, 3))
    return encoded_size
end

struct CpSolverSolution
    values::Vector{Int64}
end
PB.default_values(::Type{CpSolverSolution}) = (;values = Vector{Int64}())
PB.field_numbers(::Type{CpSolverSolution}) = (;values = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:CpSolverSolution})
    values = PB.BufferedVector{Int64}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, values)
        else
            PB.skip(d, wire_type)
        end
    end
    return CpSolverSolution(values[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::CpSolverSolution)
    initpos = position(e.io)
    !isempty(x.values) && PB.encode(e, 1, x.values)
    return position(e.io) - initpos
end
function PB._encoded_size(x::CpSolverSolution)
    encoded_size = 0
    !isempty(x.values) && (encoded_size += PB._encoded_size(x.values, 1))
    return encoded_size
end

struct SparsePermutationProto
    support::Vector{Int32}
    cycle_sizes::Vector{Int32}
end
PB.default_values(::Type{SparsePermutationProto}) = (;support = Vector{Int32}(), cycle_sizes = Vector{Int32}())
PB.field_numbers(::Type{SparsePermutationProto}) = (;support = 1, cycle_sizes = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SparsePermutationProto})
    support = PB.BufferedVector{Int32}()
    cycle_sizes = PB.BufferedVector{Int32}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, support)
        elseif field_number == 2
            PB.decode!(d, wire_type, cycle_sizes)
        else
            PB.skip(d, wire_type)
        end
    end
    return SparsePermutationProto(support[], cycle_sizes[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SparsePermutationProto)
    initpos = position(e.io)
    !isempty(x.support) && PB.encode(e, 1, x.support)
    !isempty(x.cycle_sizes) && PB.encode(e, 2, x.cycle_sizes)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SparsePermutationProto)
    encoded_size = 0
    !isempty(x.support) && (encoded_size += PB._encoded_size(x.support, 1))
    !isempty(x.cycle_sizes) && (encoded_size += PB._encoded_size(x.cycle_sizes, 2))
    return encoded_size
end

struct IntegerVariableProto
    name::String
    domain::Vector{Int64}
end
PB.default_values(::Type{IntegerVariableProto}) = (;name = "", domain = Vector{Int64}())
PB.field_numbers(::Type{IntegerVariableProto}) = (;name = 1, domain = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:IntegerVariableProto})
    name = ""
    domain = PB.BufferedVector{Int64}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, wire_type, domain)
        else
            PB.skip(d, wire_type)
        end
    end
    return IntegerVariableProto(name, domain[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::IntegerVariableProto)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.domain) && PB.encode(e, 2, x.domain)
    return position(e.io) - initpos
end
function PB._encoded_size(x::IntegerVariableProto)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.domain) && (encoded_size += PB._encoded_size(x.domain, 2))
    return encoded_size
end

struct BoolArgumentProto
    literals::Vector{Int32}
end
PB.default_values(::Type{BoolArgumentProto}) = (;literals = Vector{Int32}())
PB.field_numbers(::Type{BoolArgumentProto}) = (;literals = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:BoolArgumentProto})
    literals = PB.BufferedVector{Int32}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, literals)
        else
            PB.skip(d, wire_type)
        end
    end
    return BoolArgumentProto(literals[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::BoolArgumentProto)
    initpos = position(e.io)
    !isempty(x.literals) && PB.encode(e, 1, x.literals)
    return position(e.io) - initpos
end
function PB._encoded_size(x::BoolArgumentProto)
    encoded_size = 0
    !isempty(x.literals) && (encoded_size += PB._encoded_size(x.literals, 1))
    return encoded_size
end

struct FloatObjectiveProto
    vars::Vector{Int32}
    coeffs::Vector{Float64}
    offset::Float64
    maximize::Bool
end
PB.default_values(::Type{FloatObjectiveProto}) = (;vars = Vector{Int32}(), coeffs = Vector{Float64}(), offset = zero(Float64), maximize = false)
PB.field_numbers(::Type{FloatObjectiveProto}) = (;vars = 1, coeffs = 2, offset = 3, maximize = 4)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:FloatObjectiveProto})
    vars = PB.BufferedVector{Int32}()
    coeffs = PB.BufferedVector{Float64}()
    offset = zero(Float64)
    maximize = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, vars)
        elseif field_number == 2
            PB.decode!(d, wire_type, coeffs)
        elseif field_number == 3
            offset = PB.decode(d, Float64)
        elseif field_number == 4
            maximize = PB.decode(d, Bool)
        else
            PB.skip(d, wire_type)
        end
    end
    return FloatObjectiveProto(vars[], coeffs[], offset, maximize)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::FloatObjectiveProto)
    initpos = position(e.io)
    !isempty(x.vars) && PB.encode(e, 1, x.vars)
    !isempty(x.coeffs) && PB.encode(e, 2, x.coeffs)
    x.offset !== zero(Float64) && PB.encode(e, 3, x.offset)
    x.maximize != false && PB.encode(e, 4, x.maximize)
    return position(e.io) - initpos
end
function PB._encoded_size(x::FloatObjectiveProto)
    encoded_size = 0
    !isempty(x.vars) && (encoded_size += PB._encoded_size(x.vars, 1))
    !isempty(x.coeffs) && (encoded_size += PB._encoded_size(x.coeffs, 2))
    x.offset !== zero(Float64) && (encoded_size += PB._encoded_size(x.offset, 3))
    x.maximize != false && (encoded_size += PB._encoded_size(x.maximize, 4))
    return encoded_size
end

struct PartialVariableAssignment
    vars::Vector{Int32}
    values::Vector{Int64}
end
PB.default_values(::Type{PartialVariableAssignment}) = (;vars = Vector{Int32}(), values = Vector{Int64}())
PB.field_numbers(::Type{PartialVariableAssignment}) = (;vars = 1, values = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:PartialVariableAssignment})
    vars = PB.BufferedVector{Int32}()
    values = PB.BufferedVector{Int64}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, vars)
        elseif field_number == 2
            PB.decode!(d, wire_type, values)
        else
            PB.skip(d, wire_type)
        end
    end
    return PartialVariableAssignment(vars[], values[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::PartialVariableAssignment)
    initpos = position(e.io)
    !isempty(x.vars) && PB.encode(e, 1, x.vars)
    !isempty(x.values) && PB.encode(e, 2, x.values)
    return position(e.io) - initpos
end
function PB._encoded_size(x::PartialVariableAssignment)
    encoded_size = 0
    !isempty(x.vars) && (encoded_size += PB._encoded_size(x.vars, 1))
    !isempty(x.values) && (encoded_size += PB._encoded_size(x.values, 2))
    return encoded_size
end

struct LinearConstraintProto
    vars::Vector{Int32}
    coeffs::Vector{Int64}
    domain::Vector{Int64}
end
PB.default_values(::Type{LinearConstraintProto}) = (;vars = Vector{Int32}(), coeffs = Vector{Int64}(), domain = Vector{Int64}())
PB.field_numbers(::Type{LinearConstraintProto}) = (;vars = 1, coeffs = 2, domain = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:LinearConstraintProto})
    vars = PB.BufferedVector{Int32}()
    coeffs = PB.BufferedVector{Int64}()
    domain = PB.BufferedVector{Int64}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, vars)
        elseif field_number == 2
            PB.decode!(d, wire_type, coeffs)
        elseif field_number == 3
            PB.decode!(d, wire_type, domain)
        else
            PB.skip(d, wire_type)
        end
    end
    return LinearConstraintProto(vars[], coeffs[], domain[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::LinearConstraintProto)
    initpos = position(e.io)
    !isempty(x.vars) && PB.encode(e, 1, x.vars)
    !isempty(x.coeffs) && PB.encode(e, 2, x.coeffs)
    !isempty(x.domain) && PB.encode(e, 3, x.domain)
    return position(e.io) - initpos
end
function PB._encoded_size(x::LinearConstraintProto)
    encoded_size = 0
    !isempty(x.vars) && (encoded_size += PB._encoded_size(x.vars, 1))
    !isempty(x.coeffs) && (encoded_size += PB._encoded_size(x.coeffs, 2))
    !isempty(x.domain) && (encoded_size += PB._encoded_size(x.domain, 3))
    return encoded_size
end

struct CpObjectiveProto
    vars::Vector{Int32}
    coeffs::Vector{Int64}
    offset::Float64
    scaling_factor::Float64
    domain::Vector{Int64}
    scaling_was_exact::Bool
    integer_before_offset::Int64
    integer_after_offset::Int64
    integer_scaling_factor::Int64
end
PB.default_values(::Type{CpObjectiveProto}) = (;vars = Vector{Int32}(), coeffs = Vector{Int64}(), offset = zero(Float64), scaling_factor = zero(Float64), domain = Vector{Int64}(), scaling_was_exact = false, integer_before_offset = zero(Int64), integer_after_offset = zero(Int64), integer_scaling_factor = zero(Int64))
PB.field_numbers(::Type{CpObjectiveProto}) = (;vars = 1, coeffs = 4, offset = 2, scaling_factor = 3, domain = 5, scaling_was_exact = 6, integer_before_offset = 7, integer_after_offset = 9, integer_scaling_factor = 8)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:CpObjectiveProto})
    vars = PB.BufferedVector{Int32}()
    coeffs = PB.BufferedVector{Int64}()
    offset = zero(Float64)
    scaling_factor = zero(Float64)
    domain = PB.BufferedVector{Int64}()
    scaling_was_exact = false
    integer_before_offset = zero(Int64)
    integer_after_offset = zero(Int64)
    integer_scaling_factor = zero(Int64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, vars)
        elseif field_number == 4
            PB.decode!(d, wire_type, coeffs)
        elseif field_number == 2
            offset = PB.decode(d, Float64)
        elseif field_number == 3
            scaling_factor = PB.decode(d, Float64)
        elseif field_number == 5
            PB.decode!(d, wire_type, domain)
        elseif field_number == 6
            scaling_was_exact = PB.decode(d, Bool)
        elseif field_number == 7
            integer_before_offset = PB.decode(d, Int64)
        elseif field_number == 9
            integer_after_offset = PB.decode(d, Int64)
        elseif field_number == 8
            integer_scaling_factor = PB.decode(d, Int64)
        else
            PB.skip(d, wire_type)
        end
    end
    return CpObjectiveProto(vars[], coeffs[], offset, scaling_factor, domain[], scaling_was_exact, integer_before_offset, integer_after_offset, integer_scaling_factor)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::CpObjectiveProto)
    initpos = position(e.io)
    !isempty(x.vars) && PB.encode(e, 1, x.vars)
    !isempty(x.coeffs) && PB.encode(e, 4, x.coeffs)
    x.offset !== zero(Float64) && PB.encode(e, 2, x.offset)
    x.scaling_factor !== zero(Float64) && PB.encode(e, 3, x.scaling_factor)
    !isempty(x.domain) && PB.encode(e, 5, x.domain)
    x.scaling_was_exact != false && PB.encode(e, 6, x.scaling_was_exact)
    x.integer_before_offset != zero(Int64) && PB.encode(e, 7, x.integer_before_offset)
    x.integer_after_offset != zero(Int64) && PB.encode(e, 9, x.integer_after_offset)
    x.integer_scaling_factor != zero(Int64) && PB.encode(e, 8, x.integer_scaling_factor)
    return position(e.io) - initpos
end
function PB._encoded_size(x::CpObjectiveProto)
    encoded_size = 0
    !isempty(x.vars) && (encoded_size += PB._encoded_size(x.vars, 1))
    !isempty(x.coeffs) && (encoded_size += PB._encoded_size(x.coeffs, 4))
    x.offset !== zero(Float64) && (encoded_size += PB._encoded_size(x.offset, 2))
    x.scaling_factor !== zero(Float64) && (encoded_size += PB._encoded_size(x.scaling_factor, 3))
    !isempty(x.domain) && (encoded_size += PB._encoded_size(x.domain, 5))
    x.scaling_was_exact != false && (encoded_size += PB._encoded_size(x.scaling_was_exact, 6))
    x.integer_before_offset != zero(Int64) && (encoded_size += PB._encoded_size(x.integer_before_offset, 7))
    x.integer_after_offset != zero(Int64) && (encoded_size += PB._encoded_size(x.integer_after_offset, 9))
    x.integer_scaling_factor != zero(Int64) && (encoded_size += PB._encoded_size(x.integer_scaling_factor, 8))
    return encoded_size
end

struct InverseConstraintProto
    f_direct::Vector{Int32}
    f_inverse::Vector{Int32}
end
PB.default_values(::Type{InverseConstraintProto}) = (;f_direct = Vector{Int32}(), f_inverse = Vector{Int32}())
PB.field_numbers(::Type{InverseConstraintProto}) = (;f_direct = 1, f_inverse = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:InverseConstraintProto})
    f_direct = PB.BufferedVector{Int32}()
    f_inverse = PB.BufferedVector{Int32}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, f_direct)
        elseif field_number == 2
            PB.decode!(d, wire_type, f_inverse)
        else
            PB.skip(d, wire_type)
        end
    end
    return InverseConstraintProto(f_direct[], f_inverse[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::InverseConstraintProto)
    initpos = position(e.io)
    !isempty(x.f_direct) && PB.encode(e, 1, x.f_direct)
    !isempty(x.f_inverse) && PB.encode(e, 2, x.f_inverse)
    return position(e.io) - initpos
end
function PB._encoded_size(x::InverseConstraintProto)
    encoded_size = 0
    !isempty(x.f_direct) && (encoded_size += PB._encoded_size(x.f_direct, 1))
    !isempty(x.f_inverse) && (encoded_size += PB._encoded_size(x.f_inverse, 2))
    return encoded_size
end

@enumx var"DecisionStrategyProto.VariableSelectionStrategy" CHOOSE_FIRST=0 CHOOSE_LOWEST_MIN=1 CHOOSE_HIGHEST_MAX=2 CHOOSE_MIN_DOMAIN_SIZE=3 CHOOSE_MAX_DOMAIN_SIZE=4

struct DenseMatrixProto
    num_rows::Int32
    num_cols::Int32
    entries::Vector{Int32}
end
PB.default_values(::Type{DenseMatrixProto}) = (;num_rows = zero(Int32), num_cols = zero(Int32), entries = Vector{Int32}())
PB.field_numbers(::Type{DenseMatrixProto}) = (;num_rows = 1, num_cols = 2, entries = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:DenseMatrixProto})
    num_rows = zero(Int32)
    num_cols = zero(Int32)
    entries = PB.BufferedVector{Int32}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            num_rows = PB.decode(d, Int32)
        elseif field_number == 2
            num_cols = PB.decode(d, Int32)
        elseif field_number == 3
            PB.decode!(d, wire_type, entries)
        else
            PB.skip(d, wire_type)
        end
    end
    return DenseMatrixProto(num_rows, num_cols, entries[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::DenseMatrixProto)
    initpos = position(e.io)
    x.num_rows != zero(Int32) && PB.encode(e, 1, x.num_rows)
    x.num_cols != zero(Int32) && PB.encode(e, 2, x.num_cols)
    !isempty(x.entries) && PB.encode(e, 3, x.entries)
    return position(e.io) - initpos
end
function PB._encoded_size(x::DenseMatrixProto)
    encoded_size = 0
    x.num_rows != zero(Int32) && (encoded_size += PB._encoded_size(x.num_rows, 1))
    x.num_cols != zero(Int32) && (encoded_size += PB._encoded_size(x.num_cols, 2))
    !isempty(x.entries) && (encoded_size += PB._encoded_size(x.entries, 3))
    return encoded_size
end

struct ListOfVariablesProto
    vars::Vector{Int32}
end
PB.default_values(::Type{ListOfVariablesProto}) = (;vars = Vector{Int32}())
PB.field_numbers(::Type{ListOfVariablesProto}) = (;vars = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ListOfVariablesProto})
    vars = PB.BufferedVector{Int32}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, vars)
        else
            PB.skip(d, wire_type)
        end
    end
    return ListOfVariablesProto(vars[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ListOfVariablesProto)
    initpos = position(e.io)
    !isempty(x.vars) && PB.encode(e, 1, x.vars)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ListOfVariablesProto)
    encoded_size = 0
    !isempty(x.vars) && (encoded_size += PB._encoded_size(x.vars, 1))
    return encoded_size
end

@enumx CpSolverStatus UNKNOWN=0 MODEL_INVALID=1 FEASIBLE=2 INFEASIBLE=3 OPTIMAL=4

struct NoOverlap2DConstraintProto
    x_intervals::Vector{Int32}
    y_intervals::Vector{Int32}
end
PB.default_values(::Type{NoOverlap2DConstraintProto}) = (;x_intervals = Vector{Int32}(), y_intervals = Vector{Int32}())
PB.field_numbers(::Type{NoOverlap2DConstraintProto}) = (;x_intervals = 1, y_intervals = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:NoOverlap2DConstraintProto})
    x_intervals = PB.BufferedVector{Int32}()
    y_intervals = PB.BufferedVector{Int32}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, x_intervals)
        elseif field_number == 2
            PB.decode!(d, wire_type, y_intervals)
        else
            PB.skip(d, wire_type)
        end
    end
    return NoOverlap2DConstraintProto(x_intervals[], y_intervals[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::NoOverlap2DConstraintProto)
    initpos = position(e.io)
    !isempty(x.x_intervals) && PB.encode(e, 1, x.x_intervals)
    !isempty(x.y_intervals) && PB.encode(e, 2, x.y_intervals)
    return position(e.io) - initpos
end
function PB._encoded_size(x::NoOverlap2DConstraintProto)
    encoded_size = 0
    !isempty(x.x_intervals) && (encoded_size += PB._encoded_size(x.x_intervals, 1))
    !isempty(x.y_intervals) && (encoded_size += PB._encoded_size(x.y_intervals, 2))
    return encoded_size
end

struct CircuitConstraintProto
    tails::Vector{Int32}
    heads::Vector{Int32}
    literals::Vector{Int32}
end
PB.default_values(::Type{CircuitConstraintProto}) = (;tails = Vector{Int32}(), heads = Vector{Int32}(), literals = Vector{Int32}())
PB.field_numbers(::Type{CircuitConstraintProto}) = (;tails = 3, heads = 4, literals = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:CircuitConstraintProto})
    tails = PB.BufferedVector{Int32}()
    heads = PB.BufferedVector{Int32}()
    literals = PB.BufferedVector{Int32}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 3
            PB.decode!(d, wire_type, tails)
        elseif field_number == 4
            PB.decode!(d, wire_type, heads)
        elseif field_number == 5
            PB.decode!(d, wire_type, literals)
        else
            PB.skip(d, wire_type)
        end
    end
    return CircuitConstraintProto(tails[], heads[], literals[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::CircuitConstraintProto)
    initpos = position(e.io)
    !isempty(x.tails) && PB.encode(e, 3, x.tails)
    !isempty(x.heads) && PB.encode(e, 4, x.heads)
    !isempty(x.literals) && PB.encode(e, 5, x.literals)
    return position(e.io) - initpos
end
function PB._encoded_size(x::CircuitConstraintProto)
    encoded_size = 0
    !isempty(x.tails) && (encoded_size += PB._encoded_size(x.tails, 3))
    !isempty(x.heads) && (encoded_size += PB._encoded_size(x.heads, 4))
    !isempty(x.literals) && (encoded_size += PB._encoded_size(x.literals, 5))
    return encoded_size
end

struct NoOverlapConstraintProto
    intervals::Vector{Int32}
end
PB.default_values(::Type{NoOverlapConstraintProto}) = (;intervals = Vector{Int32}())
PB.field_numbers(::Type{NoOverlapConstraintProto}) = (;intervals = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:NoOverlapConstraintProto})
    intervals = PB.BufferedVector{Int32}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, intervals)
        else
            PB.skip(d, wire_type)
        end
    end
    return NoOverlapConstraintProto(intervals[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::NoOverlapConstraintProto)
    initpos = position(e.io)
    !isempty(x.intervals) && PB.encode(e, 1, x.intervals)
    return position(e.io) - initpos
end
function PB._encoded_size(x::NoOverlapConstraintProto)
    encoded_size = 0
    !isempty(x.intervals) && (encoded_size += PB._encoded_size(x.intervals, 1))
    return encoded_size
end

@enumx var"DecisionStrategyProto.DomainReductionStrategy" SELECT_MIN_VALUE=0 SELECT_MAX_VALUE=1 SELECT_LOWER_HALF=2 SELECT_UPPER_HALF=3 SELECT_MEDIAN_VALUE=4 SELECT_RANDOM_HALF=5

struct LinearArgumentProto
    target::Union{Nothing,LinearExpressionProto}
    exprs::Vector{LinearExpressionProto}
end
PB.default_values(::Type{LinearArgumentProto}) = (;target = nothing, exprs = Vector{LinearExpressionProto}())
PB.field_numbers(::Type{LinearArgumentProto}) = (;target = 1, exprs = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:LinearArgumentProto})
    target = Ref{Union{Nothing,LinearExpressionProto}}(nothing)
    exprs = PB.BufferedVector{LinearExpressionProto}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, target)
        elseif field_number == 2
            PB.decode!(d, exprs)
        else
            PB.skip(d, wire_type)
        end
    end
    return LinearArgumentProto(target[], exprs[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::LinearArgumentProto)
    initpos = position(e.io)
    !isnothing(x.target) && PB.encode(e, 1, x.target)
    !isempty(x.exprs) && PB.encode(e, 2, x.exprs)
    return position(e.io) - initpos
end
function PB._encoded_size(x::LinearArgumentProto)
    encoded_size = 0
    !isnothing(x.target) && (encoded_size += PB._encoded_size(x.target, 1))
    !isempty(x.exprs) && (encoded_size += PB._encoded_size(x.exprs, 2))
    return encoded_size
end

struct IntervalConstraintProto
    start::Union{Nothing,LinearExpressionProto}
    var"#end"::Union{Nothing,LinearExpressionProto}
    size::Union{Nothing,LinearExpressionProto}
end
PB.default_values(::Type{IntervalConstraintProto}) = (;start = nothing, var"#end" = nothing, size = nothing)
PB.field_numbers(::Type{IntervalConstraintProto}) = (;start = 4, var"#end" = 5, size = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:IntervalConstraintProto})
    start = Ref{Union{Nothing,LinearExpressionProto}}(nothing)
    var"#end" = Ref{Union{Nothing,LinearExpressionProto}}(nothing)
    size = Ref{Union{Nothing,LinearExpressionProto}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 4
            PB.decode!(d, start)
        elseif field_number == 5
            PB.decode!(d, var"#end")
        elseif field_number == 6
            PB.decode!(d, size)
        else
            PB.skip(d, wire_type)
        end
    end
    return IntervalConstraintProto(start[], var"#end"[], size[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::IntervalConstraintProto)
    initpos = position(e.io)
    !isnothing(x.start) && PB.encode(e, 4, x.start)
    !isnothing(x.var"#end") && PB.encode(e, 5, x.var"#end")
    !isnothing(x.size) && PB.encode(e, 6, x.size)
    return position(e.io) - initpos
end
function PB._encoded_size(x::IntervalConstraintProto)
    encoded_size = 0
    !isnothing(x.start) && (encoded_size += PB._encoded_size(x.start, 4))
    !isnothing(x.var"#end") && (encoded_size += PB._encoded_size(x.var"#end", 5))
    !isnothing(x.size) && (encoded_size += PB._encoded_size(x.size, 6))
    return encoded_size
end

struct AllDifferentConstraintProto
    exprs::Vector{LinearExpressionProto}
end
PB.default_values(::Type{AllDifferentConstraintProto}) = (;exprs = Vector{LinearExpressionProto}())
PB.field_numbers(::Type{AllDifferentConstraintProto}) = (;exprs = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:AllDifferentConstraintProto})
    exprs = PB.BufferedVector{LinearExpressionProto}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, exprs)
        else
            PB.skip(d, wire_type)
        end
    end
    return AllDifferentConstraintProto(exprs[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::AllDifferentConstraintProto)
    initpos = position(e.io)
    !isempty(x.exprs) && PB.encode(e, 1, x.exprs)
    return position(e.io) - initpos
end
function PB._encoded_size(x::AllDifferentConstraintProto)
    encoded_size = 0
    !isempty(x.exprs) && (encoded_size += PB._encoded_size(x.exprs, 1))
    return encoded_size
end

struct ReservoirConstraintProto
    min_level::Int64
    max_level::Int64
    time_exprs::Vector{LinearExpressionProto}
    level_changes::Vector{LinearExpressionProto}
    active_literals::Vector{Int32}
end
PB.reserved_fields(::Type{ReservoirConstraintProto}) = (names = String[], numbers = Union{Int,UnitRange{Int}}[4])
PB.default_values(::Type{ReservoirConstraintProto}) = (;min_level = zero(Int64), max_level = zero(Int64), time_exprs = Vector{LinearExpressionProto}(), level_changes = Vector{LinearExpressionProto}(), active_literals = Vector{Int32}())
PB.field_numbers(::Type{ReservoirConstraintProto}) = (;min_level = 1, max_level = 2, time_exprs = 3, level_changes = 6, active_literals = 5)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ReservoirConstraintProto})
    min_level = zero(Int64)
    max_level = zero(Int64)
    time_exprs = PB.BufferedVector{LinearExpressionProto}()
    level_changes = PB.BufferedVector{LinearExpressionProto}()
    active_literals = PB.BufferedVector{Int32}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            min_level = PB.decode(d, Int64)
        elseif field_number == 2
            max_level = PB.decode(d, Int64)
        elseif field_number == 3
            PB.decode!(d, time_exprs)
        elseif field_number == 6
            PB.decode!(d, level_changes)
        elseif field_number == 5
            PB.decode!(d, wire_type, active_literals)
        else
            PB.skip(d, wire_type)
        end
    end
    return ReservoirConstraintProto(min_level, max_level, time_exprs[], level_changes[], active_literals[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ReservoirConstraintProto)
    initpos = position(e.io)
    x.min_level != zero(Int64) && PB.encode(e, 1, x.min_level)
    x.max_level != zero(Int64) && PB.encode(e, 2, x.max_level)
    !isempty(x.time_exprs) && PB.encode(e, 3, x.time_exprs)
    !isempty(x.level_changes) && PB.encode(e, 6, x.level_changes)
    !isempty(x.active_literals) && PB.encode(e, 5, x.active_literals)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ReservoirConstraintProto)
    encoded_size = 0
    x.min_level != zero(Int64) && (encoded_size += PB._encoded_size(x.min_level, 1))
    x.max_level != zero(Int64) && (encoded_size += PB._encoded_size(x.max_level, 2))
    !isempty(x.time_exprs) && (encoded_size += PB._encoded_size(x.time_exprs, 3))
    !isempty(x.level_changes) && (encoded_size += PB._encoded_size(x.level_changes, 6))
    !isempty(x.active_literals) && (encoded_size += PB._encoded_size(x.active_literals, 5))
    return encoded_size
end

struct ElementConstraintProto
    index::Int32
    target::Int32
    vars::Vector{Int32}
    linear_index::Union{Nothing,LinearExpressionProto}
    linear_target::Union{Nothing,LinearExpressionProto}
    exprs::Vector{LinearExpressionProto}
end
PB.default_values(::Type{ElementConstraintProto}) = (;index = zero(Int32), target = zero(Int32), vars = Vector{Int32}(), linear_index = nothing, linear_target = nothing, exprs = Vector{LinearExpressionProto}())
PB.field_numbers(::Type{ElementConstraintProto}) = (;index = 1, target = 2, vars = 3, linear_index = 4, linear_target = 5, exprs = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ElementConstraintProto})
    index = zero(Int32)
    target = zero(Int32)
    vars = PB.BufferedVector{Int32}()
    linear_index = Ref{Union{Nothing,LinearExpressionProto}}(nothing)
    linear_target = Ref{Union{Nothing,LinearExpressionProto}}(nothing)
    exprs = PB.BufferedVector{LinearExpressionProto}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            index = PB.decode(d, Int32)
        elseif field_number == 2
            target = PB.decode(d, Int32)
        elseif field_number == 3
            PB.decode!(d, wire_type, vars)
        elseif field_number == 4
            PB.decode!(d, linear_index)
        elseif field_number == 5
            PB.decode!(d, linear_target)
        elseif field_number == 6
            PB.decode!(d, exprs)
        else
            PB.skip(d, wire_type)
        end
    end
    return ElementConstraintProto(index, target, vars[], linear_index[], linear_target[], exprs[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ElementConstraintProto)
    initpos = position(e.io)
    x.index != zero(Int32) && PB.encode(e, 1, x.index)
    x.target != zero(Int32) && PB.encode(e, 2, x.target)
    !isempty(x.vars) && PB.encode(e, 3, x.vars)
    !isnothing(x.linear_index) && PB.encode(e, 4, x.linear_index)
    !isnothing(x.linear_target) && PB.encode(e, 5, x.linear_target)
    !isempty(x.exprs) && PB.encode(e, 6, x.exprs)
    return position(e.io) - initpos
end
function PB._encoded_size(x::ElementConstraintProto)
    encoded_size = 0
    x.index != zero(Int32) && (encoded_size += PB._encoded_size(x.index, 1))
    x.target != zero(Int32) && (encoded_size += PB._encoded_size(x.target, 2))
    !isempty(x.vars) && (encoded_size += PB._encoded_size(x.vars, 3))
    !isnothing(x.linear_index) && (encoded_size += PB._encoded_size(x.linear_index, 4))
    !isnothing(x.linear_target) && (encoded_size += PB._encoded_size(x.linear_target, 5))
    !isempty(x.exprs) && (encoded_size += PB._encoded_size(x.exprs, 6))
    return encoded_size
end

struct TableConstraintProto
    vars::Vector{Int32}
    values::Vector{Int64}
    exprs::Vector{LinearExpressionProto}
    negated::Bool
end
PB.default_values(::Type{TableConstraintProto}) = (;vars = Vector{Int32}(), values = Vector{Int64}(), exprs = Vector{LinearExpressionProto}(), negated = false)
PB.field_numbers(::Type{TableConstraintProto}) = (;vars = 1, values = 2, exprs = 4, negated = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:TableConstraintProto})
    vars = PB.BufferedVector{Int32}()
    values = PB.BufferedVector{Int64}()
    exprs = PB.BufferedVector{LinearExpressionProto}()
    negated = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, vars)
        elseif field_number == 2
            PB.decode!(d, wire_type, values)
        elseif field_number == 4
            PB.decode!(d, exprs)
        elseif field_number == 3
            negated = PB.decode(d, Bool)
        else
            PB.skip(d, wire_type)
        end
    end
    return TableConstraintProto(vars[], values[], exprs[], negated)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::TableConstraintProto)
    initpos = position(e.io)
    !isempty(x.vars) && PB.encode(e, 1, x.vars)
    !isempty(x.values) && PB.encode(e, 2, x.values)
    !isempty(x.exprs) && PB.encode(e, 4, x.exprs)
    x.negated != false && PB.encode(e, 3, x.negated)
    return position(e.io) - initpos
end
function PB._encoded_size(x::TableConstraintProto)
    encoded_size = 0
    !isempty(x.vars) && (encoded_size += PB._encoded_size(x.vars, 1))
    !isempty(x.values) && (encoded_size += PB._encoded_size(x.values, 2))
    !isempty(x.exprs) && (encoded_size += PB._encoded_size(x.exprs, 4))
    x.negated != false && (encoded_size += PB._encoded_size(x.negated, 3))
    return encoded_size
end

struct AutomatonConstraintProto
    starting_state::Int64
    final_states::Vector{Int64}
    transition_tail::Vector{Int64}
    transition_head::Vector{Int64}
    transition_label::Vector{Int64}
    vars::Vector{Int32}
    exprs::Vector{LinearExpressionProto}
end
PB.default_values(::Type{AutomatonConstraintProto}) = (;starting_state = zero(Int64), final_states = Vector{Int64}(), transition_tail = Vector{Int64}(), transition_head = Vector{Int64}(), transition_label = Vector{Int64}(), vars = Vector{Int32}(), exprs = Vector{LinearExpressionProto}())
PB.field_numbers(::Type{AutomatonConstraintProto}) = (;starting_state = 2, final_states = 3, transition_tail = 4, transition_head = 5, transition_label = 6, vars = 7, exprs = 8)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:AutomatonConstraintProto})
    starting_state = zero(Int64)
    final_states = PB.BufferedVector{Int64}()
    transition_tail = PB.BufferedVector{Int64}()
    transition_head = PB.BufferedVector{Int64}()
    transition_label = PB.BufferedVector{Int64}()
    vars = PB.BufferedVector{Int32}()
    exprs = PB.BufferedVector{LinearExpressionProto}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 2
            starting_state = PB.decode(d, Int64)
        elseif field_number == 3
            PB.decode!(d, wire_type, final_states)
        elseif field_number == 4
            PB.decode!(d, wire_type, transition_tail)
        elseif field_number == 5
            PB.decode!(d, wire_type, transition_head)
        elseif field_number == 6
            PB.decode!(d, wire_type, transition_label)
        elseif field_number == 7
            PB.decode!(d, wire_type, vars)
        elseif field_number == 8
            PB.decode!(d, exprs)
        else
            PB.skip(d, wire_type)
        end
    end
    return AutomatonConstraintProto(starting_state, final_states[], transition_tail[], transition_head[], transition_label[], vars[], exprs[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::AutomatonConstraintProto)
    initpos = position(e.io)
    x.starting_state != zero(Int64) && PB.encode(e, 2, x.starting_state)
    !isempty(x.final_states) && PB.encode(e, 3, x.final_states)
    !isempty(x.transition_tail) && PB.encode(e, 4, x.transition_tail)
    !isempty(x.transition_head) && PB.encode(e, 5, x.transition_head)
    !isempty(x.transition_label) && PB.encode(e, 6, x.transition_label)
    !isempty(x.vars) && PB.encode(e, 7, x.vars)
    !isempty(x.exprs) && PB.encode(e, 8, x.exprs)
    return position(e.io) - initpos
end
function PB._encoded_size(x::AutomatonConstraintProto)
    encoded_size = 0
    x.starting_state != zero(Int64) && (encoded_size += PB._encoded_size(x.starting_state, 2))
    !isempty(x.final_states) && (encoded_size += PB._encoded_size(x.final_states, 3))
    !isempty(x.transition_tail) && (encoded_size += PB._encoded_size(x.transition_tail, 4))
    !isempty(x.transition_head) && (encoded_size += PB._encoded_size(x.transition_head, 5))
    !isempty(x.transition_label) && (encoded_size += PB._encoded_size(x.transition_label, 6))
    !isempty(x.vars) && (encoded_size += PB._encoded_size(x.vars, 7))
    !isempty(x.exprs) && (encoded_size += PB._encoded_size(x.exprs, 8))
    return encoded_size
end

struct CumulativeConstraintProto
    capacity::Union{Nothing,LinearExpressionProto}
    intervals::Vector{Int32}
    demands::Vector{LinearExpressionProto}
end
PB.default_values(::Type{CumulativeConstraintProto}) = (;capacity = nothing, intervals = Vector{Int32}(), demands = Vector{LinearExpressionProto}())
PB.field_numbers(::Type{CumulativeConstraintProto}) = (;capacity = 1, intervals = 2, demands = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:CumulativeConstraintProto})
    capacity = Ref{Union{Nothing,LinearExpressionProto}}(nothing)
    intervals = PB.BufferedVector{Int32}()
    demands = PB.BufferedVector{LinearExpressionProto}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, capacity)
        elseif field_number == 2
            PB.decode!(d, wire_type, intervals)
        elseif field_number == 3
            PB.decode!(d, demands)
        else
            PB.skip(d, wire_type)
        end
    end
    return CumulativeConstraintProto(capacity[], intervals[], demands[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::CumulativeConstraintProto)
    initpos = position(e.io)
    !isnothing(x.capacity) && PB.encode(e, 1, x.capacity)
    !isempty(x.intervals) && PB.encode(e, 2, x.intervals)
    !isempty(x.demands) && PB.encode(e, 3, x.demands)
    return position(e.io) - initpos
end
function PB._encoded_size(x::CumulativeConstraintProto)
    encoded_size = 0
    !isnothing(x.capacity) && (encoded_size += PB._encoded_size(x.capacity, 1))
    !isempty(x.intervals) && (encoded_size += PB._encoded_size(x.intervals, 2))
    !isempty(x.demands) && (encoded_size += PB._encoded_size(x.demands, 3))
    return encoded_size
end

struct var"RoutesConstraintProto.NodeExpressions"
    exprs::Vector{LinearExpressionProto}
end
PB.default_values(::Type{var"RoutesConstraintProto.NodeExpressions"}) = (;exprs = Vector{LinearExpressionProto}())
PB.field_numbers(::Type{var"RoutesConstraintProto.NodeExpressions"}) = (;exprs = 1)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:var"RoutesConstraintProto.NodeExpressions"})
    exprs = PB.BufferedVector{LinearExpressionProto}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, exprs)
        else
            PB.skip(d, wire_type)
        end
    end
    return var"RoutesConstraintProto.NodeExpressions"(exprs[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::var"RoutesConstraintProto.NodeExpressions")
    initpos = position(e.io)
    !isempty(x.exprs) && PB.encode(e, 1, x.exprs)
    return position(e.io) - initpos
end
function PB._encoded_size(x::var"RoutesConstraintProto.NodeExpressions")
    encoded_size = 0
    !isempty(x.exprs) && (encoded_size += PB._encoded_size(x.exprs, 1))
    return encoded_size
end

struct SymmetryProto
    permutations::Vector{SparsePermutationProto}
    orbitopes::Vector{DenseMatrixProto}
end
PB.default_values(::Type{SymmetryProto}) = (;permutations = Vector{SparsePermutationProto}(), orbitopes = Vector{DenseMatrixProto}())
PB.field_numbers(::Type{SymmetryProto}) = (;permutations = 1, orbitopes = 2)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:SymmetryProto})
    permutations = PB.BufferedVector{SparsePermutationProto}()
    orbitopes = PB.BufferedVector{DenseMatrixProto}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, permutations)
        elseif field_number == 2
            PB.decode!(d, orbitopes)
        else
            PB.skip(d, wire_type)
        end
    end
    return SymmetryProto(permutations[], orbitopes[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::SymmetryProto)
    initpos = position(e.io)
    !isempty(x.permutations) && PB.encode(e, 1, x.permutations)
    !isempty(x.orbitopes) && PB.encode(e, 2, x.orbitopes)
    return position(e.io) - initpos
end
function PB._encoded_size(x::SymmetryProto)
    encoded_size = 0
    !isempty(x.permutations) && (encoded_size += PB._encoded_size(x.permutations, 1))
    !isempty(x.orbitopes) && (encoded_size += PB._encoded_size(x.orbitopes, 2))
    return encoded_size
end

struct CpSolverResponse
    status::CpSolverStatus.T
    solution::Vector{Int64}
    objective_value::Float64
    best_objective_bound::Float64
    additional_solutions::Vector{CpSolverSolution}
    tightened_variables::Vector{IntegerVariableProto}
    sufficient_assumptions_for_infeasibility::Vector{Int32}
    integer_objective::Union{Nothing,CpObjectiveProto}
    inner_objective_lower_bound::Int64
    num_integers::Int64
    num_booleans::Int64
    num_fixed_booleans::Int64
    num_conflicts::Int64
    num_branches::Int64
    num_binary_propagations::Int64
    num_integer_propagations::Int64
    num_restarts::Int64
    num_lp_iterations::Int64
    wall_time::Float64
    user_time::Float64
    deterministic_time::Float64
    gap_integral::Float64
    solution_info::String
    solve_log::String
end
PB.default_values(::Type{CpSolverResponse}) = (;status = CpSolverStatus.UNKNOWN, solution = Vector{Int64}(), objective_value = zero(Float64), best_objective_bound = zero(Float64), additional_solutions = Vector{CpSolverSolution}(), tightened_variables = Vector{IntegerVariableProto}(), sufficient_assumptions_for_infeasibility = Vector{Int32}(), integer_objective = nothing, inner_objective_lower_bound = zero(Int64), num_integers = zero(Int64), num_booleans = zero(Int64), num_fixed_booleans = zero(Int64), num_conflicts = zero(Int64), num_branches = zero(Int64), num_binary_propagations = zero(Int64), num_integer_propagations = zero(Int64), num_restarts = zero(Int64), num_lp_iterations = zero(Int64), wall_time = zero(Float64), user_time = zero(Float64), deterministic_time = zero(Float64), gap_integral = zero(Float64), solution_info = "", solve_log = "")
PB.field_numbers(::Type{CpSolverResponse}) = (;status = 1, solution = 2, objective_value = 3, best_objective_bound = 4, additional_solutions = 27, tightened_variables = 21, sufficient_assumptions_for_infeasibility = 23, integer_objective = 28, inner_objective_lower_bound = 29, num_integers = 30, num_booleans = 10, num_fixed_booleans = 31, num_conflicts = 11, num_branches = 12, num_binary_propagations = 13, num_integer_propagations = 14, num_restarts = 24, num_lp_iterations = 25, wall_time = 15, user_time = 16, deterministic_time = 17, gap_integral = 22, solution_info = 20, solve_log = 26)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:CpSolverResponse})
    status = CpSolverStatus.UNKNOWN
    solution = PB.BufferedVector{Int64}()
    objective_value = zero(Float64)
    best_objective_bound = zero(Float64)
    additional_solutions = PB.BufferedVector{CpSolverSolution}()
    tightened_variables = PB.BufferedVector{IntegerVariableProto}()
    sufficient_assumptions_for_infeasibility = PB.BufferedVector{Int32}()
    integer_objective = Ref{Union{Nothing,CpObjectiveProto}}(nothing)
    inner_objective_lower_bound = zero(Int64)
    num_integers = zero(Int64)
    num_booleans = zero(Int64)
    num_fixed_booleans = zero(Int64)
    num_conflicts = zero(Int64)
    num_branches = zero(Int64)
    num_binary_propagations = zero(Int64)
    num_integer_propagations = zero(Int64)
    num_restarts = zero(Int64)
    num_lp_iterations = zero(Int64)
    wall_time = zero(Float64)
    user_time = zero(Float64)
    deterministic_time = zero(Float64)
    gap_integral = zero(Float64)
    solution_info = ""
    solve_log = ""
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            status = PB.decode(d, CpSolverStatus.T)
        elseif field_number == 2
            PB.decode!(d, wire_type, solution)
        elseif field_number == 3
            objective_value = PB.decode(d, Float64)
        elseif field_number == 4
            best_objective_bound = PB.decode(d, Float64)
        elseif field_number == 27
            PB.decode!(d, additional_solutions)
        elseif field_number == 21
            PB.decode!(d, tightened_variables)
        elseif field_number == 23
            PB.decode!(d, wire_type, sufficient_assumptions_for_infeasibility)
        elseif field_number == 28
            PB.decode!(d, integer_objective)
        elseif field_number == 29
            inner_objective_lower_bound = PB.decode(d, Int64)
        elseif field_number == 30
            num_integers = PB.decode(d, Int64)
        elseif field_number == 10
            num_booleans = PB.decode(d, Int64)
        elseif field_number == 31
            num_fixed_booleans = PB.decode(d, Int64)
        elseif field_number == 11
            num_conflicts = PB.decode(d, Int64)
        elseif field_number == 12
            num_branches = PB.decode(d, Int64)
        elseif field_number == 13
            num_binary_propagations = PB.decode(d, Int64)
        elseif field_number == 14
            num_integer_propagations = PB.decode(d, Int64)
        elseif field_number == 24
            num_restarts = PB.decode(d, Int64)
        elseif field_number == 25
            num_lp_iterations = PB.decode(d, Int64)
        elseif field_number == 15
            wall_time = PB.decode(d, Float64)
        elseif field_number == 16
            user_time = PB.decode(d, Float64)
        elseif field_number == 17
            deterministic_time = PB.decode(d, Float64)
        elseif field_number == 22
            gap_integral = PB.decode(d, Float64)
        elseif field_number == 20
            solution_info = PB.decode(d, String)
        elseif field_number == 26
            solve_log = PB.decode(d, String)
        else
            PB.skip(d, wire_type)
        end
    end
    return CpSolverResponse(status, solution[], objective_value, best_objective_bound, additional_solutions[], tightened_variables[], sufficient_assumptions_for_infeasibility[], integer_objective[], inner_objective_lower_bound, num_integers, num_booleans, num_fixed_booleans, num_conflicts, num_branches, num_binary_propagations, num_integer_propagations, num_restarts, num_lp_iterations, wall_time, user_time, deterministic_time, gap_integral, solution_info, solve_log)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::CpSolverResponse)
    initpos = position(e.io)
    x.status != CpSolverStatus.UNKNOWN && PB.encode(e, 1, x.status)
    !isempty(x.solution) && PB.encode(e, 2, x.solution)
    x.objective_value !== zero(Float64) && PB.encode(e, 3, x.objective_value)
    x.best_objective_bound !== zero(Float64) && PB.encode(e, 4, x.best_objective_bound)
    !isempty(x.additional_solutions) && PB.encode(e, 27, x.additional_solutions)
    !isempty(x.tightened_variables) && PB.encode(e, 21, x.tightened_variables)
    !isempty(x.sufficient_assumptions_for_infeasibility) && PB.encode(e, 23, x.sufficient_assumptions_for_infeasibility)
    !isnothing(x.integer_objective) && PB.encode(e, 28, x.integer_objective)
    x.inner_objective_lower_bound != zero(Int64) && PB.encode(e, 29, x.inner_objective_lower_bound)
    x.num_integers != zero(Int64) && PB.encode(e, 30, x.num_integers)
    x.num_booleans != zero(Int64) && PB.encode(e, 10, x.num_booleans)
    x.num_fixed_booleans != zero(Int64) && PB.encode(e, 31, x.num_fixed_booleans)
    x.num_conflicts != zero(Int64) && PB.encode(e, 11, x.num_conflicts)
    x.num_branches != zero(Int64) && PB.encode(e, 12, x.num_branches)
    x.num_binary_propagations != zero(Int64) && PB.encode(e, 13, x.num_binary_propagations)
    x.num_integer_propagations != zero(Int64) && PB.encode(e, 14, x.num_integer_propagations)
    x.num_restarts != zero(Int64) && PB.encode(e, 24, x.num_restarts)
    x.num_lp_iterations != zero(Int64) && PB.encode(e, 25, x.num_lp_iterations)
    x.wall_time !== zero(Float64) && PB.encode(e, 15, x.wall_time)
    x.user_time !== zero(Float64) && PB.encode(e, 16, x.user_time)
    x.deterministic_time !== zero(Float64) && PB.encode(e, 17, x.deterministic_time)
    x.gap_integral !== zero(Float64) && PB.encode(e, 22, x.gap_integral)
    !isempty(x.solution_info) && PB.encode(e, 20, x.solution_info)
    !isempty(x.solve_log) && PB.encode(e, 26, x.solve_log)
    return position(e.io) - initpos
end
function PB._encoded_size(x::CpSolverResponse)
    encoded_size = 0
    x.status != CpSolverStatus.UNKNOWN && (encoded_size += PB._encoded_size(x.status, 1))
    !isempty(x.solution) && (encoded_size += PB._encoded_size(x.solution, 2))
    x.objective_value !== zero(Float64) && (encoded_size += PB._encoded_size(x.objective_value, 3))
    x.best_objective_bound !== zero(Float64) && (encoded_size += PB._encoded_size(x.best_objective_bound, 4))
    !isempty(x.additional_solutions) && (encoded_size += PB._encoded_size(x.additional_solutions, 27))
    !isempty(x.tightened_variables) && (encoded_size += PB._encoded_size(x.tightened_variables, 21))
    !isempty(x.sufficient_assumptions_for_infeasibility) && (encoded_size += PB._encoded_size(x.sufficient_assumptions_for_infeasibility, 23))
    !isnothing(x.integer_objective) && (encoded_size += PB._encoded_size(x.integer_objective, 28))
    x.inner_objective_lower_bound != zero(Int64) && (encoded_size += PB._encoded_size(x.inner_objective_lower_bound, 29))
    x.num_integers != zero(Int64) && (encoded_size += PB._encoded_size(x.num_integers, 30))
    x.num_booleans != zero(Int64) && (encoded_size += PB._encoded_size(x.num_booleans, 10))
    x.num_fixed_booleans != zero(Int64) && (encoded_size += PB._encoded_size(x.num_fixed_booleans, 31))
    x.num_conflicts != zero(Int64) && (encoded_size += PB._encoded_size(x.num_conflicts, 11))
    x.num_branches != zero(Int64) && (encoded_size += PB._encoded_size(x.num_branches, 12))
    x.num_binary_propagations != zero(Int64) && (encoded_size += PB._encoded_size(x.num_binary_propagations, 13))
    x.num_integer_propagations != zero(Int64) && (encoded_size += PB._encoded_size(x.num_integer_propagations, 14))
    x.num_restarts != zero(Int64) && (encoded_size += PB._encoded_size(x.num_restarts, 24))
    x.num_lp_iterations != zero(Int64) && (encoded_size += PB._encoded_size(x.num_lp_iterations, 25))
    x.wall_time !== zero(Float64) && (encoded_size += PB._encoded_size(x.wall_time, 15))
    x.user_time !== zero(Float64) && (encoded_size += PB._encoded_size(x.user_time, 16))
    x.deterministic_time !== zero(Float64) && (encoded_size += PB._encoded_size(x.deterministic_time, 17))
    x.gap_integral !== zero(Float64) && (encoded_size += PB._encoded_size(x.gap_integral, 22))
    !isempty(x.solution_info) && (encoded_size += PB._encoded_size(x.solution_info, 20))
    !isempty(x.solve_log) && (encoded_size += PB._encoded_size(x.solve_log, 26))
    return encoded_size
end

struct DecisionStrategyProto
    variables::Vector{Int32}
    exprs::Vector{LinearExpressionProto}
    variable_selection_strategy::var"DecisionStrategyProto.VariableSelectionStrategy".T
    domain_reduction_strategy::var"DecisionStrategyProto.DomainReductionStrategy".T
end
PB.default_values(::Type{DecisionStrategyProto}) = (;variables = Vector{Int32}(), exprs = Vector{LinearExpressionProto}(), variable_selection_strategy = var"DecisionStrategyProto.VariableSelectionStrategy".CHOOSE_FIRST, domain_reduction_strategy = var"DecisionStrategyProto.DomainReductionStrategy".SELECT_MIN_VALUE)
PB.field_numbers(::Type{DecisionStrategyProto}) = (;variables = 1, exprs = 5, variable_selection_strategy = 2, domain_reduction_strategy = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:DecisionStrategyProto})
    variables = PB.BufferedVector{Int32}()
    exprs = PB.BufferedVector{LinearExpressionProto}()
    variable_selection_strategy = var"DecisionStrategyProto.VariableSelectionStrategy".CHOOSE_FIRST
    domain_reduction_strategy = var"DecisionStrategyProto.DomainReductionStrategy".SELECT_MIN_VALUE
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, variables)
        elseif field_number == 5
            PB.decode!(d, exprs)
        elseif field_number == 2
            variable_selection_strategy = PB.decode(d, var"DecisionStrategyProto.VariableSelectionStrategy".T)
        elseif field_number == 3
            domain_reduction_strategy = PB.decode(d, var"DecisionStrategyProto.DomainReductionStrategy".T)
        else
            PB.skip(d, wire_type)
        end
    end
    return DecisionStrategyProto(variables[], exprs[], variable_selection_strategy, domain_reduction_strategy)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::DecisionStrategyProto)
    initpos = position(e.io)
    !isempty(x.variables) && PB.encode(e, 1, x.variables)
    !isempty(x.exprs) && PB.encode(e, 5, x.exprs)
    x.variable_selection_strategy != var"DecisionStrategyProto.VariableSelectionStrategy".CHOOSE_FIRST && PB.encode(e, 2, x.variable_selection_strategy)
    x.domain_reduction_strategy != var"DecisionStrategyProto.DomainReductionStrategy".SELECT_MIN_VALUE && PB.encode(e, 3, x.domain_reduction_strategy)
    return position(e.io) - initpos
end
function PB._encoded_size(x::DecisionStrategyProto)
    encoded_size = 0
    !isempty(x.variables) && (encoded_size += PB._encoded_size(x.variables, 1))
    !isempty(x.exprs) && (encoded_size += PB._encoded_size(x.exprs, 5))
    x.variable_selection_strategy != var"DecisionStrategyProto.VariableSelectionStrategy".CHOOSE_FIRST && (encoded_size += PB._encoded_size(x.variable_selection_strategy, 2))
    x.domain_reduction_strategy != var"DecisionStrategyProto.DomainReductionStrategy".SELECT_MIN_VALUE && (encoded_size += PB._encoded_size(x.domain_reduction_strategy, 3))
    return encoded_size
end

struct RoutesConstraintProto
    tails::Vector{Int32}
    heads::Vector{Int32}
    literals::Vector{Int32}
    demands::Vector{Int32}
    capacity::Int64
    dimensions::Vector{var"RoutesConstraintProto.NodeExpressions"}
end
PB.default_values(::Type{RoutesConstraintProto}) = (;tails = Vector{Int32}(), heads = Vector{Int32}(), literals = Vector{Int32}(), demands = Vector{Int32}(), capacity = zero(Int64), dimensions = Vector{var"RoutesConstraintProto.NodeExpressions"}())
PB.field_numbers(::Type{RoutesConstraintProto}) = (;tails = 1, heads = 2, literals = 3, demands = 4, capacity = 5, dimensions = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:RoutesConstraintProto})
    tails = PB.BufferedVector{Int32}()
    heads = PB.BufferedVector{Int32}()
    literals = PB.BufferedVector{Int32}()
    demands = PB.BufferedVector{Int32}()
    capacity = zero(Int64)
    dimensions = PB.BufferedVector{var"RoutesConstraintProto.NodeExpressions"}()
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            PB.decode!(d, wire_type, tails)
        elseif field_number == 2
            PB.decode!(d, wire_type, heads)
        elseif field_number == 3
            PB.decode!(d, wire_type, literals)
        elseif field_number == 4
            PB.decode!(d, wire_type, demands)
        elseif field_number == 5
            capacity = PB.decode(d, Int64)
        elseif field_number == 6
            PB.decode!(d, dimensions)
        else
            PB.skip(d, wire_type)
        end
    end
    return RoutesConstraintProto(tails[], heads[], literals[], demands[], capacity, dimensions[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::RoutesConstraintProto)
    initpos = position(e.io)
    !isempty(x.tails) && PB.encode(e, 1, x.tails)
    !isempty(x.heads) && PB.encode(e, 2, x.heads)
    !isempty(x.literals) && PB.encode(e, 3, x.literals)
    !isempty(x.demands) && PB.encode(e, 4, x.demands)
    x.capacity != zero(Int64) && PB.encode(e, 5, x.capacity)
    !isempty(x.dimensions) && PB.encode(e, 6, x.dimensions)
    return position(e.io) - initpos
end
function PB._encoded_size(x::RoutesConstraintProto)
    encoded_size = 0
    !isempty(x.tails) && (encoded_size += PB._encoded_size(x.tails, 1))
    !isempty(x.heads) && (encoded_size += PB._encoded_size(x.heads, 2))
    !isempty(x.literals) && (encoded_size += PB._encoded_size(x.literals, 3))
    !isempty(x.demands) && (encoded_size += PB._encoded_size(x.demands, 4))
    x.capacity != zero(Int64) && (encoded_size += PB._encoded_size(x.capacity, 5))
    !isempty(x.dimensions) && (encoded_size += PB._encoded_size(x.dimensions, 6))
    return encoded_size
end

struct ConstraintProto
    name::String
    enforcement_literal::Vector{Int32}
    constraint::Union{Nothing,OneOf{<:Union{BoolArgumentProto,LinearArgumentProto,LinearConstraintProto,AllDifferentConstraintProto,ElementConstraintProto,CircuitConstraintProto,RoutesConstraintProto,TableConstraintProto,AutomatonConstraintProto,InverseConstraintProto,ReservoirConstraintProto,IntervalConstraintProto,NoOverlapConstraintProto,NoOverlap2DConstraintProto,CumulativeConstraintProto,ListOfVariablesProto}}}
end
PB.oneof_field_types(::Type{ConstraintProto}) = (;
    constraint = (;bool_or=BoolArgumentProto, bool_and=BoolArgumentProto, at_most_one=BoolArgumentProto, exactly_one=BoolArgumentProto, bool_xor=BoolArgumentProto, int_div=LinearArgumentProto, int_mod=LinearArgumentProto, int_prod=LinearArgumentProto, lin_max=LinearArgumentProto, linear=LinearConstraintProto, all_diff=AllDifferentConstraintProto, element=ElementConstraintProto, circuit=CircuitConstraintProto, routes=RoutesConstraintProto, table=TableConstraintProto, automaton=AutomatonConstraintProto, inverse=InverseConstraintProto, reservoir=ReservoirConstraintProto, interval=IntervalConstraintProto, no_overlap=NoOverlapConstraintProto, no_overlap_2d=NoOverlap2DConstraintProto, cumulative=CumulativeConstraintProto, dummy_constraint=ListOfVariablesProto),
)
PB.default_values(::Type{ConstraintProto}) = (;name = "", enforcement_literal = Vector{Int32}(), bool_or = nothing, bool_and = nothing, at_most_one = nothing, exactly_one = nothing, bool_xor = nothing, int_div = nothing, int_mod = nothing, int_prod = nothing, lin_max = nothing, linear = nothing, all_diff = nothing, element = nothing, circuit = nothing, routes = nothing, table = nothing, automaton = nothing, inverse = nothing, reservoir = nothing, interval = nothing, no_overlap = nothing, no_overlap_2d = nothing, cumulative = nothing, dummy_constraint = nothing)
PB.field_numbers(::Type{ConstraintProto}) = (;name = 1, enforcement_literal = 2, bool_or = 3, bool_and = 4, at_most_one = 26, exactly_one = 29, bool_xor = 5, int_div = 7, int_mod = 8, int_prod = 11, lin_max = 27, linear = 12, all_diff = 13, element = 14, circuit = 15, routes = 23, table = 16, automaton = 17, inverse = 18, reservoir = 24, interval = 19, no_overlap = 20, no_overlap_2d = 21, cumulative = 22, dummy_constraint = 30)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:ConstraintProto})
    name = ""
    enforcement_literal = PB.BufferedVector{Int32}()
    constraint = nothing
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, wire_type, enforcement_literal)
        elseif field_number == 3
            constraint = OneOf(:bool_or, PB.decode(d, Ref{BoolArgumentProto}))
        elseif field_number == 4
            constraint = OneOf(:bool_and, PB.decode(d, Ref{BoolArgumentProto}))
        elseif field_number == 26
            constraint = OneOf(:at_most_one, PB.decode(d, Ref{BoolArgumentProto}))
        elseif field_number == 29
            constraint = OneOf(:exactly_one, PB.decode(d, Ref{BoolArgumentProto}))
        elseif field_number == 5
            constraint = OneOf(:bool_xor, PB.decode(d, Ref{BoolArgumentProto}))
        elseif field_number == 7
            constraint = OneOf(:int_div, PB.decode(d, Ref{LinearArgumentProto}))
        elseif field_number == 8
            constraint = OneOf(:int_mod, PB.decode(d, Ref{LinearArgumentProto}))
        elseif field_number == 11
            constraint = OneOf(:int_prod, PB.decode(d, Ref{LinearArgumentProto}))
        elseif field_number == 27
            constraint = OneOf(:lin_max, PB.decode(d, Ref{LinearArgumentProto}))
        elseif field_number == 12
            constraint = OneOf(:linear, PB.decode(d, Ref{LinearConstraintProto}))
        elseif field_number == 13
            constraint = OneOf(:all_diff, PB.decode(d, Ref{AllDifferentConstraintProto}))
        elseif field_number == 14
            constraint = OneOf(:element, PB.decode(d, Ref{ElementConstraintProto}))
        elseif field_number == 15
            constraint = OneOf(:circuit, PB.decode(d, Ref{CircuitConstraintProto}))
        elseif field_number == 23
            constraint = OneOf(:routes, PB.decode(d, Ref{RoutesConstraintProto}))
        elseif field_number == 16
            constraint = OneOf(:table, PB.decode(d, Ref{TableConstraintProto}))
        elseif field_number == 17
            constraint = OneOf(:automaton, PB.decode(d, Ref{AutomatonConstraintProto}))
        elseif field_number == 18
            constraint = OneOf(:inverse, PB.decode(d, Ref{InverseConstraintProto}))
        elseif field_number == 24
            constraint = OneOf(:reservoir, PB.decode(d, Ref{ReservoirConstraintProto}))
        elseif field_number == 19
            constraint = OneOf(:interval, PB.decode(d, Ref{IntervalConstraintProto}))
        elseif field_number == 20
            constraint = OneOf(:no_overlap, PB.decode(d, Ref{NoOverlapConstraintProto}))
        elseif field_number == 21
            constraint = OneOf(:no_overlap_2d, PB.decode(d, Ref{NoOverlap2DConstraintProto}))
        elseif field_number == 22
            constraint = OneOf(:cumulative, PB.decode(d, Ref{CumulativeConstraintProto}))
        elseif field_number == 30
            constraint = OneOf(:dummy_constraint, PB.decode(d, Ref{ListOfVariablesProto}))
        else
            PB.skip(d, wire_type)
        end
    end
    return ConstraintProto(name, enforcement_literal[], constraint)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::ConstraintProto)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.enforcement_literal) && PB.encode(e, 2, x.enforcement_literal)
    if isnothing(x.constraint);
    elseif x.constraint.name === :bool_or
        PB.encode(e, 3, x.constraint[]::BoolArgumentProto)
    elseif x.constraint.name === :bool_and
        PB.encode(e, 4, x.constraint[]::BoolArgumentProto)
    elseif x.constraint.name === :at_most_one
        PB.encode(e, 26, x.constraint[]::BoolArgumentProto)
    elseif x.constraint.name === :exactly_one
        PB.encode(e, 29, x.constraint[]::BoolArgumentProto)
    elseif x.constraint.name === :bool_xor
        PB.encode(e, 5, x.constraint[]::BoolArgumentProto)
    elseif x.constraint.name === :int_div
        PB.encode(e, 7, x.constraint[]::LinearArgumentProto)
    elseif x.constraint.name === :int_mod
        PB.encode(e, 8, x.constraint[]::LinearArgumentProto)
    elseif x.constraint.name === :int_prod
        PB.encode(e, 11, x.constraint[]::LinearArgumentProto)
    elseif x.constraint.name === :lin_max
        PB.encode(e, 27, x.constraint[]::LinearArgumentProto)
    elseif x.constraint.name === :linear
        PB.encode(e, 12, x.constraint[]::LinearConstraintProto)
    elseif x.constraint.name === :all_diff
        PB.encode(e, 13, x.constraint[]::AllDifferentConstraintProto)
    elseif x.constraint.name === :element
        PB.encode(e, 14, x.constraint[]::ElementConstraintProto)
    elseif x.constraint.name === :circuit
        PB.encode(e, 15, x.constraint[]::CircuitConstraintProto)
    elseif x.constraint.name === :routes
        PB.encode(e, 23, x.constraint[]::RoutesConstraintProto)
    elseif x.constraint.name === :table
        PB.encode(e, 16, x.constraint[]::TableConstraintProto)
    elseif x.constraint.name === :automaton
        PB.encode(e, 17, x.constraint[]::AutomatonConstraintProto)
    elseif x.constraint.name === :inverse
        PB.encode(e, 18, x.constraint[]::InverseConstraintProto)
    elseif x.constraint.name === :reservoir
        PB.encode(e, 24, x.constraint[]::ReservoirConstraintProto)
    elseif x.constraint.name === :interval
        PB.encode(e, 19, x.constraint[]::IntervalConstraintProto)
    elseif x.constraint.name === :no_overlap
        PB.encode(e, 20, x.constraint[]::NoOverlapConstraintProto)
    elseif x.constraint.name === :no_overlap_2d
        PB.encode(e, 21, x.constraint[]::NoOverlap2DConstraintProto)
    elseif x.constraint.name === :cumulative
        PB.encode(e, 22, x.constraint[]::CumulativeConstraintProto)
    elseif x.constraint.name === :dummy_constraint
        PB.encode(e, 30, x.constraint[]::ListOfVariablesProto)
    end
    return position(e.io) - initpos
end
function PB._encoded_size(x::ConstraintProto)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.enforcement_literal) && (encoded_size += PB._encoded_size(x.enforcement_literal, 2))
    if isnothing(x.constraint);
    elseif x.constraint.name === :bool_or
        encoded_size += PB._encoded_size(x.constraint[]::BoolArgumentProto, 3)
    elseif x.constraint.name === :bool_and
        encoded_size += PB._encoded_size(x.constraint[]::BoolArgumentProto, 4)
    elseif x.constraint.name === :at_most_one
        encoded_size += PB._encoded_size(x.constraint[]::BoolArgumentProto, 26)
    elseif x.constraint.name === :exactly_one
        encoded_size += PB._encoded_size(x.constraint[]::BoolArgumentProto, 29)
    elseif x.constraint.name === :bool_xor
        encoded_size += PB._encoded_size(x.constraint[]::BoolArgumentProto, 5)
    elseif x.constraint.name === :int_div
        encoded_size += PB._encoded_size(x.constraint[]::LinearArgumentProto, 7)
    elseif x.constraint.name === :int_mod
        encoded_size += PB._encoded_size(x.constraint[]::LinearArgumentProto, 8)
    elseif x.constraint.name === :int_prod
        encoded_size += PB._encoded_size(x.constraint[]::LinearArgumentProto, 11)
    elseif x.constraint.name === :lin_max
        encoded_size += PB._encoded_size(x.constraint[]::LinearArgumentProto, 27)
    elseif x.constraint.name === :linear
        encoded_size += PB._encoded_size(x.constraint[]::LinearConstraintProto, 12)
    elseif x.constraint.name === :all_diff
        encoded_size += PB._encoded_size(x.constraint[]::AllDifferentConstraintProto, 13)
    elseif x.constraint.name === :element
        encoded_size += PB._encoded_size(x.constraint[]::ElementConstraintProto, 14)
    elseif x.constraint.name === :circuit
        encoded_size += PB._encoded_size(x.constraint[]::CircuitConstraintProto, 15)
    elseif x.constraint.name === :routes
        encoded_size += PB._encoded_size(x.constraint[]::RoutesConstraintProto, 23)
    elseif x.constraint.name === :table
        encoded_size += PB._encoded_size(x.constraint[]::TableConstraintProto, 16)
    elseif x.constraint.name === :automaton
        encoded_size += PB._encoded_size(x.constraint[]::AutomatonConstraintProto, 17)
    elseif x.constraint.name === :inverse
        encoded_size += PB._encoded_size(x.constraint[]::InverseConstraintProto, 18)
    elseif x.constraint.name === :reservoir
        encoded_size += PB._encoded_size(x.constraint[]::ReservoirConstraintProto, 24)
    elseif x.constraint.name === :interval
        encoded_size += PB._encoded_size(x.constraint[]::IntervalConstraintProto, 19)
    elseif x.constraint.name === :no_overlap
        encoded_size += PB._encoded_size(x.constraint[]::NoOverlapConstraintProto, 20)
    elseif x.constraint.name === :no_overlap_2d
        encoded_size += PB._encoded_size(x.constraint[]::NoOverlap2DConstraintProto, 21)
    elseif x.constraint.name === :cumulative
        encoded_size += PB._encoded_size(x.constraint[]::CumulativeConstraintProto, 22)
    elseif x.constraint.name === :dummy_constraint
        encoded_size += PB._encoded_size(x.constraint[]::ListOfVariablesProto, 30)
    end
    return encoded_size
end

struct CpModelProto
    name::String
    variables::Vector{IntegerVariableProto}
    constraints::Vector{ConstraintProto}
    objective::Union{Nothing,CpObjectiveProto}
    floating_point_objective::Union{Nothing,FloatObjectiveProto}
    search_strategy::Vector{DecisionStrategyProto}
    solution_hint::Union{Nothing,PartialVariableAssignment}
    assumptions::Vector{Int32}
    symmetry::Union{Nothing,SymmetryProto}
end
PB.default_values(::Type{CpModelProto}) = (;name = "", variables = Vector{IntegerVariableProto}(), constraints = Vector{ConstraintProto}(), objective = nothing, floating_point_objective = nothing, search_strategy = Vector{DecisionStrategyProto}(), solution_hint = nothing, assumptions = Vector{Int32}(), symmetry = nothing)
PB.field_numbers(::Type{CpModelProto}) = (;name = 1, variables = 2, constraints = 3, objective = 4, floating_point_objective = 9, search_strategy = 5, solution_hint = 6, assumptions = 7, symmetry = 8)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:CpModelProto})
    name = ""
    variables = PB.BufferedVector{IntegerVariableProto}()
    constraints = PB.BufferedVector{ConstraintProto}()
    objective = Ref{Union{Nothing,CpObjectiveProto}}(nothing)
    floating_point_objective = Ref{Union{Nothing,FloatObjectiveProto}}(nothing)
    search_strategy = PB.BufferedVector{DecisionStrategyProto}()
    solution_hint = Ref{Union{Nothing,PartialVariableAssignment}}(nothing)
    assumptions = PB.BufferedVector{Int32}()
    symmetry = Ref{Union{Nothing,SymmetryProto}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            name = PB.decode(d, String)
        elseif field_number == 2
            PB.decode!(d, variables)
        elseif field_number == 3
            PB.decode!(d, constraints)
        elseif field_number == 4
            PB.decode!(d, objective)
        elseif field_number == 9
            PB.decode!(d, floating_point_objective)
        elseif field_number == 5
            PB.decode!(d, search_strategy)
        elseif field_number == 6
            PB.decode!(d, solution_hint)
        elseif field_number == 7
            PB.decode!(d, wire_type, assumptions)
        elseif field_number == 8
            PB.decode!(d, symmetry)
        else
            PB.skip(d, wire_type)
        end
    end
    return CpModelProto(name, variables[], constraints[], objective[], floating_point_objective[], search_strategy[], solution_hint[], assumptions[], symmetry[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::CpModelProto)
    initpos = position(e.io)
    !isempty(x.name) && PB.encode(e, 1, x.name)
    !isempty(x.variables) && PB.encode(e, 2, x.variables)
    !isempty(x.constraints) && PB.encode(e, 3, x.constraints)
    !isnothing(x.objective) && PB.encode(e, 4, x.objective)
    !isnothing(x.floating_point_objective) && PB.encode(e, 9, x.floating_point_objective)
    !isempty(x.search_strategy) && PB.encode(e, 5, x.search_strategy)
    !isnothing(x.solution_hint) && PB.encode(e, 6, x.solution_hint)
    !isempty(x.assumptions) && PB.encode(e, 7, x.assumptions)
    !isnothing(x.symmetry) && PB.encode(e, 8, x.symmetry)
    return position(e.io) - initpos
end
function PB._encoded_size(x::CpModelProto)
    encoded_size = 0
    !isempty(x.name) && (encoded_size += PB._encoded_size(x.name, 1))
    !isempty(x.variables) && (encoded_size += PB._encoded_size(x.variables, 2))
    !isempty(x.constraints) && (encoded_size += PB._encoded_size(x.constraints, 3))
    !isnothing(x.objective) && (encoded_size += PB._encoded_size(x.objective, 4))
    !isnothing(x.floating_point_objective) && (encoded_size += PB._encoded_size(x.floating_point_objective, 9))
    !isempty(x.search_strategy) && (encoded_size += PB._encoded_size(x.search_strategy, 5))
    !isnothing(x.solution_hint) && (encoded_size += PB._encoded_size(x.solution_hint, 6))
    !isempty(x.assumptions) && (encoded_size += PB._encoded_size(x.assumptions, 7))
    !isnothing(x.symmetry) && (encoded_size += PB._encoded_size(x.symmetry, 8))
    return encoded_size
end
