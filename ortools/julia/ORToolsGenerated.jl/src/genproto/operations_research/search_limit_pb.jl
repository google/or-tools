# Autogenerated using ProtoBuf.jl v1.1.1 on 2025-07-02T15:45:01.862
# original file: /usr/local/google/home/tcuvelier/.julia/artifacts/502992654d3e610bc079dfc8ac9e663bff6f3a24/include/ortools/constraint_solver/search_limit.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export RegularLimitParameters


struct RegularLimitParameters
    time::Int64
    branches::Int64
    failures::Int64
    solutions::Int64
    smart_time_check::Bool
    cumulative::Bool
end
PB.default_values(::Type{RegularLimitParameters}) = (;time = zero(Int64), branches = zero(Int64), failures = zero(Int64), solutions = zero(Int64), smart_time_check = false, cumulative = false)
PB.field_numbers(::Type{RegularLimitParameters}) = (;time = 1, branches = 2, failures = 3, solutions = 4, smart_time_check = 5, cumulative = 6)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:RegularLimitParameters})
    time = zero(Int64)
    branches = zero(Int64)
    failures = zero(Int64)
    solutions = zero(Int64)
    smart_time_check = false
    cumulative = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            time = PB.decode(d, Int64)
        elseif field_number == 2
            branches = PB.decode(d, Int64)
        elseif field_number == 3
            failures = PB.decode(d, Int64)
        elseif field_number == 4
            solutions = PB.decode(d, Int64)
        elseif field_number == 5
            smart_time_check = PB.decode(d, Bool)
        elseif field_number == 6
            cumulative = PB.decode(d, Bool)
        else
            PB.skip(d, wire_type)
        end
    end
    return RegularLimitParameters(time, branches, failures, solutions, smart_time_check, cumulative)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::RegularLimitParameters)
    initpos = position(e.io)
    x.time != zero(Int64) && PB.encode(e, 1, x.time)
    x.branches != zero(Int64) && PB.encode(e, 2, x.branches)
    x.failures != zero(Int64) && PB.encode(e, 3, x.failures)
    x.solutions != zero(Int64) && PB.encode(e, 4, x.solutions)
    x.smart_time_check != false && PB.encode(e, 5, x.smart_time_check)
    x.cumulative != false && PB.encode(e, 6, x.cumulative)
    return position(e.io) - initpos
end
function PB._encoded_size(x::RegularLimitParameters)
    encoded_size = 0
    x.time != zero(Int64) && (encoded_size += PB._encoded_size(x.time, 1))
    x.branches != zero(Int64) && (encoded_size += PB._encoded_size(x.branches, 2))
    x.failures != zero(Int64) && (encoded_size += PB._encoded_size(x.failures, 3))
    x.solutions != zero(Int64) && (encoded_size += PB._encoded_size(x.solutions, 4))
    x.smart_time_check != false && (encoded_size += PB._encoded_size(x.smart_time_check, 5))
    x.cumulative != false && (encoded_size += PB._encoded_size(x.cumulative, 6))
    return encoded_size
end
