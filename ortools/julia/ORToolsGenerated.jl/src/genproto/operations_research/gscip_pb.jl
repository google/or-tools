# Autogenerated using ProtoBuf.jl v1.1.1 on 2025-07-02T15:45:01.771
# original file: /usr/local/google/home/tcuvelier/.julia/artifacts/502992654d3e610bc079dfc8ac9e663bff6f3a24/include/ortools/gscip/gscip.proto (proto3 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export var"GScipParameters.MetaParamValue", var"GScipParameters.Emphasis"
export GScipSolvingStats, var"GScipOutput.Status", GScipParameters, GScipOutput


@enumx var"GScipParameters.MetaParamValue" DEFAULT_META_PARAM_VALUE=0 AGGRESSIVE=1 FAST=2 OFF=3

@enumx var"GScipParameters.Emphasis" DEFAULT_EMPHASIS=0 COUNTER=1 CP_SOLVER=2 EASY_CIP=3 FEASIBILITY=4 HARD_LP=5 OPTIMALITY=6 PHASE_FEAS=7 PHASE_IMPROVE=8 PHASE_PROOF=9

struct GScipSolvingStats
    best_objective::Float64
    best_bound::Float64
    primal_simplex_iterations::Int64
    dual_simplex_iterations::Int64
    barrier_iterations::Int64
    total_lp_iterations::Int64
    node_count::Int64
    first_lp_relaxation_bound::Float64
    root_node_bound::Float64
    deterministic_time::Float64
end
PB.default_values(::Type{GScipSolvingStats}) = (;best_objective = zero(Float64), best_bound = zero(Float64), primal_simplex_iterations = zero(Int64), dual_simplex_iterations = zero(Int64), barrier_iterations = zero(Int64), total_lp_iterations = zero(Int64), node_count = zero(Int64), first_lp_relaxation_bound = zero(Float64), root_node_bound = zero(Float64), deterministic_time = zero(Float64))
PB.field_numbers(::Type{GScipSolvingStats}) = (;best_objective = 1, best_bound = 2, primal_simplex_iterations = 3, dual_simplex_iterations = 4, barrier_iterations = 10, total_lp_iterations = 5, node_count = 6, first_lp_relaxation_bound = 7, root_node_bound = 8, deterministic_time = 9)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:GScipSolvingStats})
    best_objective = zero(Float64)
    best_bound = zero(Float64)
    primal_simplex_iterations = zero(Int64)
    dual_simplex_iterations = zero(Int64)
    barrier_iterations = zero(Int64)
    total_lp_iterations = zero(Int64)
    node_count = zero(Int64)
    first_lp_relaxation_bound = zero(Float64)
    root_node_bound = zero(Float64)
    deterministic_time = zero(Float64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            best_objective = PB.decode(d, Float64)
        elseif field_number == 2
            best_bound = PB.decode(d, Float64)
        elseif field_number == 3
            primal_simplex_iterations = PB.decode(d, Int64)
        elseif field_number == 4
            dual_simplex_iterations = PB.decode(d, Int64)
        elseif field_number == 10
            barrier_iterations = PB.decode(d, Int64)
        elseif field_number == 5
            total_lp_iterations = PB.decode(d, Int64)
        elseif field_number == 6
            node_count = PB.decode(d, Int64)
        elseif field_number == 7
            first_lp_relaxation_bound = PB.decode(d, Float64)
        elseif field_number == 8
            root_node_bound = PB.decode(d, Float64)
        elseif field_number == 9
            deterministic_time = PB.decode(d, Float64)
        else
            PB.skip(d, wire_type)
        end
    end
    return GScipSolvingStats(best_objective, best_bound, primal_simplex_iterations, dual_simplex_iterations, barrier_iterations, total_lp_iterations, node_count, first_lp_relaxation_bound, root_node_bound, deterministic_time)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::GScipSolvingStats)
    initpos = position(e.io)
    x.best_objective !== zero(Float64) && PB.encode(e, 1, x.best_objective)
    x.best_bound !== zero(Float64) && PB.encode(e, 2, x.best_bound)
    x.primal_simplex_iterations != zero(Int64) && PB.encode(e, 3, x.primal_simplex_iterations)
    x.dual_simplex_iterations != zero(Int64) && PB.encode(e, 4, x.dual_simplex_iterations)
    x.barrier_iterations != zero(Int64) && PB.encode(e, 10, x.barrier_iterations)
    x.total_lp_iterations != zero(Int64) && PB.encode(e, 5, x.total_lp_iterations)
    x.node_count != zero(Int64) && PB.encode(e, 6, x.node_count)
    x.first_lp_relaxation_bound !== zero(Float64) && PB.encode(e, 7, x.first_lp_relaxation_bound)
    x.root_node_bound !== zero(Float64) && PB.encode(e, 8, x.root_node_bound)
    x.deterministic_time !== zero(Float64) && PB.encode(e, 9, x.deterministic_time)
    return position(e.io) - initpos
end
function PB._encoded_size(x::GScipSolvingStats)
    encoded_size = 0
    x.best_objective !== zero(Float64) && (encoded_size += PB._encoded_size(x.best_objective, 1))
    x.best_bound !== zero(Float64) && (encoded_size += PB._encoded_size(x.best_bound, 2))
    x.primal_simplex_iterations != zero(Int64) && (encoded_size += PB._encoded_size(x.primal_simplex_iterations, 3))
    x.dual_simplex_iterations != zero(Int64) && (encoded_size += PB._encoded_size(x.dual_simplex_iterations, 4))
    x.barrier_iterations != zero(Int64) && (encoded_size += PB._encoded_size(x.barrier_iterations, 10))
    x.total_lp_iterations != zero(Int64) && (encoded_size += PB._encoded_size(x.total_lp_iterations, 5))
    x.node_count != zero(Int64) && (encoded_size += PB._encoded_size(x.node_count, 6))
    x.first_lp_relaxation_bound !== zero(Float64) && (encoded_size += PB._encoded_size(x.first_lp_relaxation_bound, 7))
    x.root_node_bound !== zero(Float64) && (encoded_size += PB._encoded_size(x.root_node_bound, 8))
    x.deterministic_time !== zero(Float64) && (encoded_size += PB._encoded_size(x.deterministic_time, 9))
    return encoded_size
end

@enumx var"GScipOutput.Status" UNKNOWN=0 USER_INTERRUPT=1 NODE_LIMIT=2 TOTAL_NODE_LIMIT=3 STALL_NODE_LIMIT=4 TIME_LIMIT=5 MEM_LIMIT=6 GAP_LIMIT=7 SOL_LIMIT=8 BEST_SOL_LIMIT=9 RESTART_LIMIT=10 OPTIMAL=11 INFEASIBLE=12 UNBOUNDED=13 INF_OR_UNBD=14 TERMINATE=15 INVALID_SOLVER_PARAMETERS=16

struct GScipParameters
    emphasis::var"GScipParameters.Emphasis".T
    heuristics::var"GScipParameters.MetaParamValue".T
    presolve::var"GScipParameters.MetaParamValue".T
    separating::var"GScipParameters.MetaParamValue".T
    bool_params::Dict{String,Bool}
    int_params::Dict{String,Int32}
    long_params::Dict{String,Int64}
    real_params::Dict{String,Float64}
    char_params::Dict{String,String}
    string_params::Dict{String,String}
    silence_output::Bool
    print_detailed_solving_stats::Bool
    print_scip_model::Bool
    search_logs_filename::String
    detailed_solving_stats_filename::String
    scip_model_filename::String
    num_solutions::Int32
    objective_limit::Float64
end
PB.default_values(::Type{GScipParameters}) = (;emphasis = var"GScipParameters.Emphasis".DEFAULT_EMPHASIS, heuristics = var"GScipParameters.MetaParamValue".DEFAULT_META_PARAM_VALUE, presolve = var"GScipParameters.MetaParamValue".DEFAULT_META_PARAM_VALUE, separating = var"GScipParameters.MetaParamValue".DEFAULT_META_PARAM_VALUE, bool_params = Dict{String,Bool}(), int_params = Dict{String,Int32}(), long_params = Dict{String,Int64}(), real_params = Dict{String,Float64}(), char_params = Dict{String,String}(), string_params = Dict{String,String}(), silence_output = false, print_detailed_solving_stats = false, print_scip_model = false, search_logs_filename = "", detailed_solving_stats_filename = "", scip_model_filename = "", num_solutions = zero(Int32), objective_limit = zero(Float64))
PB.field_numbers(::Type{GScipParameters}) = (;emphasis = 1, heuristics = 2, presolve = 3, separating = 4, bool_params = 5, int_params = 6, long_params = 7, real_params = 8, char_params = 9, string_params = 10, silence_output = 11, print_detailed_solving_stats = 12, print_scip_model = 13, search_logs_filename = 14, detailed_solving_stats_filename = 15, scip_model_filename = 16, num_solutions = 17, objective_limit = 18)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:GScipParameters})
    emphasis = var"GScipParameters.Emphasis".DEFAULT_EMPHASIS
    heuristics = var"GScipParameters.MetaParamValue".DEFAULT_META_PARAM_VALUE
    presolve = var"GScipParameters.MetaParamValue".DEFAULT_META_PARAM_VALUE
    separating = var"GScipParameters.MetaParamValue".DEFAULT_META_PARAM_VALUE
    bool_params = Dict{String,Bool}()
    int_params = Dict{String,Int32}()
    long_params = Dict{String,Int64}()
    real_params = Dict{String,Float64}()
    char_params = Dict{String,String}()
    string_params = Dict{String,String}()
    silence_output = false
    print_detailed_solving_stats = false
    print_scip_model = false
    search_logs_filename = ""
    detailed_solving_stats_filename = ""
    scip_model_filename = ""
    num_solutions = zero(Int32)
    objective_limit = zero(Float64)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            emphasis = PB.decode(d, var"GScipParameters.Emphasis".T)
        elseif field_number == 2
            heuristics = PB.decode(d, var"GScipParameters.MetaParamValue".T)
        elseif field_number == 3
            presolve = PB.decode(d, var"GScipParameters.MetaParamValue".T)
        elseif field_number == 4
            separating = PB.decode(d, var"GScipParameters.MetaParamValue".T)
        elseif field_number == 5
            PB.decode!(d, bool_params)
        elseif field_number == 6
            PB.decode!(d, int_params)
        elseif field_number == 7
            PB.decode!(d, long_params)
        elseif field_number == 8
            PB.decode!(d, real_params)
        elseif field_number == 9
            PB.decode!(d, char_params)
        elseif field_number == 10
            PB.decode!(d, string_params)
        elseif field_number == 11
            silence_output = PB.decode(d, Bool)
        elseif field_number == 12
            print_detailed_solving_stats = PB.decode(d, Bool)
        elseif field_number == 13
            print_scip_model = PB.decode(d, Bool)
        elseif field_number == 14
            search_logs_filename = PB.decode(d, String)
        elseif field_number == 15
            detailed_solving_stats_filename = PB.decode(d, String)
        elseif field_number == 16
            scip_model_filename = PB.decode(d, String)
        elseif field_number == 17
            num_solutions = PB.decode(d, Int32)
        elseif field_number == 18
            objective_limit = PB.decode(d, Float64)
        else
            PB.skip(d, wire_type)
        end
    end
    return GScipParameters(emphasis, heuristics, presolve, separating, bool_params, int_params, long_params, real_params, char_params, string_params, silence_output, print_detailed_solving_stats, print_scip_model, search_logs_filename, detailed_solving_stats_filename, scip_model_filename, num_solutions, objective_limit)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::GScipParameters)
    initpos = position(e.io)
    x.emphasis != var"GScipParameters.Emphasis".DEFAULT_EMPHASIS && PB.encode(e, 1, x.emphasis)
    x.heuristics != var"GScipParameters.MetaParamValue".DEFAULT_META_PARAM_VALUE && PB.encode(e, 2, x.heuristics)
    x.presolve != var"GScipParameters.MetaParamValue".DEFAULT_META_PARAM_VALUE && PB.encode(e, 3, x.presolve)
    x.separating != var"GScipParameters.MetaParamValue".DEFAULT_META_PARAM_VALUE && PB.encode(e, 4, x.separating)
    !isempty(x.bool_params) && PB.encode(e, 5, x.bool_params)
    !isempty(x.int_params) && PB.encode(e, 6, x.int_params)
    !isempty(x.long_params) && PB.encode(e, 7, x.long_params)
    !isempty(x.real_params) && PB.encode(e, 8, x.real_params)
    !isempty(x.char_params) && PB.encode(e, 9, x.char_params)
    !isempty(x.string_params) && PB.encode(e, 10, x.string_params)
    x.silence_output != false && PB.encode(e, 11, x.silence_output)
    x.print_detailed_solving_stats != false && PB.encode(e, 12, x.print_detailed_solving_stats)
    x.print_scip_model != false && PB.encode(e, 13, x.print_scip_model)
    !isempty(x.search_logs_filename) && PB.encode(e, 14, x.search_logs_filename)
    !isempty(x.detailed_solving_stats_filename) && PB.encode(e, 15, x.detailed_solving_stats_filename)
    !isempty(x.scip_model_filename) && PB.encode(e, 16, x.scip_model_filename)
    x.num_solutions != zero(Int32) && PB.encode(e, 17, x.num_solutions)
    x.objective_limit !== zero(Float64) && PB.encode(e, 18, x.objective_limit)
    return position(e.io) - initpos
end
function PB._encoded_size(x::GScipParameters)
    encoded_size = 0
    x.emphasis != var"GScipParameters.Emphasis".DEFAULT_EMPHASIS && (encoded_size += PB._encoded_size(x.emphasis, 1))
    x.heuristics != var"GScipParameters.MetaParamValue".DEFAULT_META_PARAM_VALUE && (encoded_size += PB._encoded_size(x.heuristics, 2))
    x.presolve != var"GScipParameters.MetaParamValue".DEFAULT_META_PARAM_VALUE && (encoded_size += PB._encoded_size(x.presolve, 3))
    x.separating != var"GScipParameters.MetaParamValue".DEFAULT_META_PARAM_VALUE && (encoded_size += PB._encoded_size(x.separating, 4))
    !isempty(x.bool_params) && (encoded_size += PB._encoded_size(x.bool_params, 5))
    !isempty(x.int_params) && (encoded_size += PB._encoded_size(x.int_params, 6))
    !isempty(x.long_params) && (encoded_size += PB._encoded_size(x.long_params, 7))
    !isempty(x.real_params) && (encoded_size += PB._encoded_size(x.real_params, 8))
    !isempty(x.char_params) && (encoded_size += PB._encoded_size(x.char_params, 9))
    !isempty(x.string_params) && (encoded_size += PB._encoded_size(x.string_params, 10))
    x.silence_output != false && (encoded_size += PB._encoded_size(x.silence_output, 11))
    x.print_detailed_solving_stats != false && (encoded_size += PB._encoded_size(x.print_detailed_solving_stats, 12))
    x.print_scip_model != false && (encoded_size += PB._encoded_size(x.print_scip_model, 13))
    !isempty(x.search_logs_filename) && (encoded_size += PB._encoded_size(x.search_logs_filename, 14))
    !isempty(x.detailed_solving_stats_filename) && (encoded_size += PB._encoded_size(x.detailed_solving_stats_filename, 15))
    !isempty(x.scip_model_filename) && (encoded_size += PB._encoded_size(x.scip_model_filename, 16))
    x.num_solutions != zero(Int32) && (encoded_size += PB._encoded_size(x.num_solutions, 17))
    x.objective_limit !== zero(Float64) && (encoded_size += PB._encoded_size(x.objective_limit, 18))
    return encoded_size
end

struct GScipOutput
    status::var"GScipOutput.Status".T
    status_detail::String
    stats::Union{Nothing,GScipSolvingStats}
end
PB.default_values(::Type{GScipOutput}) = (;status = var"GScipOutput.Status".UNKNOWN, status_detail = "", stats = nothing)
PB.field_numbers(::Type{GScipOutput}) = (;status = 1, status_detail = 2, stats = 3)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:GScipOutput})
    status = var"GScipOutput.Status".UNKNOWN
    status_detail = ""
    stats = Ref{Union{Nothing,GScipSolvingStats}}(nothing)
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 1
            status = PB.decode(d, var"GScipOutput.Status".T)
        elseif field_number == 2
            status_detail = PB.decode(d, String)
        elseif field_number == 3
            PB.decode!(d, stats)
        else
            PB.skip(d, wire_type)
        end
    end
    return GScipOutput(status, status_detail, stats[])
end

function PB.encode(e::PB.AbstractProtoEncoder, x::GScipOutput)
    initpos = position(e.io)
    x.status != var"GScipOutput.Status".UNKNOWN && PB.encode(e, 1, x.status)
    !isempty(x.status_detail) && PB.encode(e, 2, x.status_detail)
    !isnothing(x.stats) && PB.encode(e, 3, x.stats)
    return position(e.io) - initpos
end
function PB._encoded_size(x::GScipOutput)
    encoded_size = 0
    x.status != var"GScipOutput.Status".UNKNOWN && (encoded_size += PB._encoded_size(x.status, 1))
    !isempty(x.status_detail) && (encoded_size += PB._encoded_size(x.status_detail, 2))
    !isnothing(x.stats) && (encoded_size += PB._encoded_size(x.stats, 3))
    return encoded_size
end
