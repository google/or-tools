# Autogenerated using ProtoBuf.jl v1.1.1 on 2025-07-02T15:45:02.112
# original file: /usr/local/google/home/tcuvelier/.julia/artifacts/502992654d3e610bc079dfc8ac9e663bff6f3a24/include/ortools/glop/parameters.proto (proto2 syntax)

import ProtoBuf as PB
using ProtoBuf: OneOf
using ProtoBuf.EnumX: @enumx

export var"GlopParameters.PricingRule", var"GlopParameters.SolverBehavior"
export var"GlopParameters.CostScalingAlgorithm", var"GlopParameters.ScalingAlgorithm"
export var"GlopParameters.InitialBasisHeuristic", GlopParameters


@enumx var"GlopParameters.PricingRule" DANTZIG=0 STEEPEST_EDGE=1 DEVEX=2

@enumx var"GlopParameters.SolverBehavior" ALWAYS_DO=0 NEVER_DO=1 LET_SOLVER_DECIDE=2

@enumx var"GlopParameters.CostScalingAlgorithm" NO_COST_SCALING=0 CONTAIN_ONE_COST_SCALING=1 MEAN_COST_SCALING=2 MEDIAN_COST_SCALING=3

@enumx var"GlopParameters.ScalingAlgorithm" DEFAULT=0 EQUILIBRATION=1 LINEAR_PROGRAM=2

@enumx var"GlopParameters.InitialBasisHeuristic" NONE=0 BIXBY=1 TRIANGULAR=2 MAROS=3

struct GlopParameters
    scaling_method::var"GlopParameters.ScalingAlgorithm".T
    feasibility_rule::var"GlopParameters.PricingRule".T
    optimization_rule::var"GlopParameters.PricingRule".T
    refactorization_threshold::Float64
    recompute_reduced_costs_threshold::Float64
    recompute_edges_norm_threshold::Float64
    primal_feasibility_tolerance::Float64
    dual_feasibility_tolerance::Float64
    ratio_test_zero_threshold::Float64
    harris_tolerance_ratio::Float64
    small_pivot_threshold::Float64
    minimum_acceptable_pivot::Float64
    drop_tolerance::Float64
    use_scaling::Bool
    cost_scaling::var"GlopParameters.CostScalingAlgorithm".T
    initial_basis::var"GlopParameters.InitialBasisHeuristic".T
    use_transposed_matrix::Bool
    basis_refactorization_period::Int32
    dynamically_adjust_refactorization_period::Bool
    solve_dual_problem::var"GlopParameters.SolverBehavior".T
    dualizer_threshold::Float64
    solution_feasibility_tolerance::Float64
    provide_strong_optimal_guarantee::Bool
    change_status_to_imprecise::Bool
    max_number_of_reoptimizations::Float64
    lu_factorization_pivot_threshold::Float64
    max_time_in_seconds::Float64
    max_deterministic_time::Float64
    max_number_of_iterations::Int64
    markowitz_zlatev_parameter::Int32
    markowitz_singularity_threshold::Float64
    use_dual_simplex::Bool
    allow_simplex_algorithm_change::Bool
    devex_weights_reset_period::Int32
    use_preprocessing::Bool
    use_middle_product_form_update::Bool
    initialize_devex_with_column_norms::Bool
    exploit_singleton_column_in_initial_basis::Bool
    dual_small_pivot_threshold::Float64
    preprocessor_zero_tolerance::Float64
    objective_lower_limit::Float64
    objective_upper_limit::Float64
    degenerate_ministep_factor::Float64
    random_seed::Int32
    use_absl_random::Bool
    num_omp_threads::Int32
    perturb_costs_in_dual_simplex::Bool
    use_dedicated_dual_feasibility_algorithm::Bool
    relative_cost_perturbation::Float64
    relative_max_cost_perturbation::Float64
    initial_condition_number_threshold::Float64
    log_search_progress::Bool
    log_to_stdout::Bool
    crossover_bound_snapping_distance::Float64
    push_to_vertex::Bool
    use_implied_free_preprocessor::Bool
    max_valid_magnitude::Float64
    drop_magnitude::Float64
    dual_price_prioritize_norm::Bool
end
PB.default_values(::Type{GlopParameters}) = (;scaling_method = var"GlopParameters.ScalingAlgorithm".EQUILIBRATION, feasibility_rule = var"GlopParameters.PricingRule".STEEPEST_EDGE, optimization_rule = var"GlopParameters.PricingRule".STEEPEST_EDGE, refactorization_threshold = Float64(1e-9), recompute_reduced_costs_threshold = Float64(1e-8), recompute_edges_norm_threshold = Float64(100.0), primal_feasibility_tolerance = Float64(1e-8), dual_feasibility_tolerance = Float64(1e-8), ratio_test_zero_threshold = Float64(1e-9), harris_tolerance_ratio = Float64(0.5), small_pivot_threshold = Float64(1e-6), minimum_acceptable_pivot = Float64(1e-6), drop_tolerance = Float64(1e-14), use_scaling = true, cost_scaling = var"GlopParameters.CostScalingAlgorithm".CONTAIN_ONE_COST_SCALING, initial_basis = var"GlopParameters.InitialBasisHeuristic".TRIANGULAR, use_transposed_matrix = true, basis_refactorization_period = Int32(64), dynamically_adjust_refactorization_period = true, solve_dual_problem = var"GlopParameters.SolverBehavior".LET_SOLVER_DECIDE, dualizer_threshold = Float64(1.5), solution_feasibility_tolerance = Float64(1e-6), provide_strong_optimal_guarantee = true, change_status_to_imprecise = true, max_number_of_reoptimizations = Float64(40), lu_factorization_pivot_threshold = Float64(0.01), max_time_in_seconds = Float64(Inf), max_deterministic_time = Float64(Inf), max_number_of_iterations = Int64(-1), markowitz_zlatev_parameter = Int32(3), markowitz_singularity_threshold = Float64(1e-15), use_dual_simplex = false, allow_simplex_algorithm_change = false, devex_weights_reset_period = Int32(150), use_preprocessing = true, use_middle_product_form_update = true, initialize_devex_with_column_norms = true, exploit_singleton_column_in_initial_basis = true, dual_small_pivot_threshold = Float64(1e-4), preprocessor_zero_tolerance = Float64(1e-9), objective_lower_limit = Float64(-Inf), objective_upper_limit = Float64(Inf), degenerate_ministep_factor = Float64(0.01), random_seed = Int32(1), use_absl_random = false, num_omp_threads = Int32(1), perturb_costs_in_dual_simplex = false, use_dedicated_dual_feasibility_algorithm = true, relative_cost_perturbation = Float64(1e-5), relative_max_cost_perturbation = Float64(1e-7), initial_condition_number_threshold = Float64(1e50), log_search_progress = false, log_to_stdout = true, crossover_bound_snapping_distance = Float64(Inf), push_to_vertex = true, use_implied_free_preprocessor = true, max_valid_magnitude = Float64(1e30), drop_magnitude = Float64(1e-30), dual_price_prioritize_norm = false)
PB.field_numbers(::Type{GlopParameters}) = (;scaling_method = 57, feasibility_rule = 1, optimization_rule = 2, refactorization_threshold = 6, recompute_reduced_costs_threshold = 8, recompute_edges_norm_threshold = 9, primal_feasibility_tolerance = 10, dual_feasibility_tolerance = 11, ratio_test_zero_threshold = 12, harris_tolerance_ratio = 13, small_pivot_threshold = 14, minimum_acceptable_pivot = 15, drop_tolerance = 52, use_scaling = 16, cost_scaling = 60, initial_basis = 17, use_transposed_matrix = 18, basis_refactorization_period = 19, dynamically_adjust_refactorization_period = 63, solve_dual_problem = 20, dualizer_threshold = 21, solution_feasibility_tolerance = 22, provide_strong_optimal_guarantee = 24, change_status_to_imprecise = 58, max_number_of_reoptimizations = 56, lu_factorization_pivot_threshold = 25, max_time_in_seconds = 26, max_deterministic_time = 45, max_number_of_iterations = 27, markowitz_zlatev_parameter = 29, markowitz_singularity_threshold = 30, use_dual_simplex = 31, allow_simplex_algorithm_change = 32, devex_weights_reset_period = 33, use_preprocessing = 34, use_middle_product_form_update = 35, initialize_devex_with_column_norms = 36, exploit_singleton_column_in_initial_basis = 37, dual_small_pivot_threshold = 38, preprocessor_zero_tolerance = 39, objective_lower_limit = 40, objective_upper_limit = 41, degenerate_ministep_factor = 42, random_seed = 43, use_absl_random = 72, num_omp_threads = 44, perturb_costs_in_dual_simplex = 53, use_dedicated_dual_feasibility_algorithm = 62, relative_cost_perturbation = 54, relative_max_cost_perturbation = 55, initial_condition_number_threshold = 59, log_search_progress = 61, log_to_stdout = 66, crossover_bound_snapping_distance = 64, push_to_vertex = 65, use_implied_free_preprocessor = 67, max_valid_magnitude = 70, drop_magnitude = 71, dual_price_prioritize_norm = 69)

function PB.decode(d::PB.AbstractProtoDecoder, ::Type{<:GlopParameters})
    scaling_method = var"GlopParameters.ScalingAlgorithm".EQUILIBRATION
    feasibility_rule = var"GlopParameters.PricingRule".STEEPEST_EDGE
    optimization_rule = var"GlopParameters.PricingRule".STEEPEST_EDGE
    refactorization_threshold = Float64(1e-9)
    recompute_reduced_costs_threshold = Float64(1e-8)
    recompute_edges_norm_threshold = Float64(100.0)
    primal_feasibility_tolerance = Float64(1e-8)
    dual_feasibility_tolerance = Float64(1e-8)
    ratio_test_zero_threshold = Float64(1e-9)
    harris_tolerance_ratio = Float64(0.5)
    small_pivot_threshold = Float64(1e-6)
    minimum_acceptable_pivot = Float64(1e-6)
    drop_tolerance = Float64(1e-14)
    use_scaling = true
    cost_scaling = var"GlopParameters.CostScalingAlgorithm".CONTAIN_ONE_COST_SCALING
    initial_basis = var"GlopParameters.InitialBasisHeuristic".TRIANGULAR
    use_transposed_matrix = true
    basis_refactorization_period = Int32(64)
    dynamically_adjust_refactorization_period = true
    solve_dual_problem = var"GlopParameters.SolverBehavior".LET_SOLVER_DECIDE
    dualizer_threshold = Float64(1.5)
    solution_feasibility_tolerance = Float64(1e-6)
    provide_strong_optimal_guarantee = true
    change_status_to_imprecise = true
    max_number_of_reoptimizations = Float64(40)
    lu_factorization_pivot_threshold = Float64(0.01)
    max_time_in_seconds = Float64(Inf)
    max_deterministic_time = Float64(Inf)
    max_number_of_iterations = Int64(-1)
    markowitz_zlatev_parameter = Int32(3)
    markowitz_singularity_threshold = Float64(1e-15)
    use_dual_simplex = false
    allow_simplex_algorithm_change = false
    devex_weights_reset_period = Int32(150)
    use_preprocessing = true
    use_middle_product_form_update = true
    initialize_devex_with_column_norms = true
    exploit_singleton_column_in_initial_basis = true
    dual_small_pivot_threshold = Float64(1e-4)
    preprocessor_zero_tolerance = Float64(1e-9)
    objective_lower_limit = Float64(-Inf)
    objective_upper_limit = Float64(Inf)
    degenerate_ministep_factor = Float64(0.01)
    random_seed = Int32(1)
    use_absl_random = false
    num_omp_threads = Int32(1)
    perturb_costs_in_dual_simplex = false
    use_dedicated_dual_feasibility_algorithm = true
    relative_cost_perturbation = Float64(1e-5)
    relative_max_cost_perturbation = Float64(1e-7)
    initial_condition_number_threshold = Float64(1e50)
    log_search_progress = false
    log_to_stdout = true
    crossover_bound_snapping_distance = Float64(Inf)
    push_to_vertex = true
    use_implied_free_preprocessor = true
    max_valid_magnitude = Float64(1e30)
    drop_magnitude = Float64(1e-30)
    dual_price_prioritize_norm = false
    while !PB.message_done(d)
        field_number, wire_type = PB.decode_tag(d)
        if field_number == 57
            scaling_method = PB.decode(d, var"GlopParameters.ScalingAlgorithm".T)
        elseif field_number == 1
            feasibility_rule = PB.decode(d, var"GlopParameters.PricingRule".T)
        elseif field_number == 2
            optimization_rule = PB.decode(d, var"GlopParameters.PricingRule".T)
        elseif field_number == 6
            refactorization_threshold = PB.decode(d, Float64)
        elseif field_number == 8
            recompute_reduced_costs_threshold = PB.decode(d, Float64)
        elseif field_number == 9
            recompute_edges_norm_threshold = PB.decode(d, Float64)
        elseif field_number == 10
            primal_feasibility_tolerance = PB.decode(d, Float64)
        elseif field_number == 11
            dual_feasibility_tolerance = PB.decode(d, Float64)
        elseif field_number == 12
            ratio_test_zero_threshold = PB.decode(d, Float64)
        elseif field_number == 13
            harris_tolerance_ratio = PB.decode(d, Float64)
        elseif field_number == 14
            small_pivot_threshold = PB.decode(d, Float64)
        elseif field_number == 15
            minimum_acceptable_pivot = PB.decode(d, Float64)
        elseif field_number == 52
            drop_tolerance = PB.decode(d, Float64)
        elseif field_number == 16
            use_scaling = PB.decode(d, Bool)
        elseif field_number == 60
            cost_scaling = PB.decode(d, var"GlopParameters.CostScalingAlgorithm".T)
        elseif field_number == 17
            initial_basis = PB.decode(d, var"GlopParameters.InitialBasisHeuristic".T)
        elseif field_number == 18
            use_transposed_matrix = PB.decode(d, Bool)
        elseif field_number == 19
            basis_refactorization_period = PB.decode(d, Int32)
        elseif field_number == 63
            dynamically_adjust_refactorization_period = PB.decode(d, Bool)
        elseif field_number == 20
            solve_dual_problem = PB.decode(d, var"GlopParameters.SolverBehavior".T)
        elseif field_number == 21
            dualizer_threshold = PB.decode(d, Float64)
        elseif field_number == 22
            solution_feasibility_tolerance = PB.decode(d, Float64)
        elseif field_number == 24
            provide_strong_optimal_guarantee = PB.decode(d, Bool)
        elseif field_number == 58
            change_status_to_imprecise = PB.decode(d, Bool)
        elseif field_number == 56
            max_number_of_reoptimizations = PB.decode(d, Float64)
        elseif field_number == 25
            lu_factorization_pivot_threshold = PB.decode(d, Float64)
        elseif field_number == 26
            max_time_in_seconds = PB.decode(d, Float64)
        elseif field_number == 45
            max_deterministic_time = PB.decode(d, Float64)
        elseif field_number == 27
            max_number_of_iterations = PB.decode(d, Int64)
        elseif field_number == 29
            markowitz_zlatev_parameter = PB.decode(d, Int32)
        elseif field_number == 30
            markowitz_singularity_threshold = PB.decode(d, Float64)
        elseif field_number == 31
            use_dual_simplex = PB.decode(d, Bool)
        elseif field_number == 32
            allow_simplex_algorithm_change = PB.decode(d, Bool)
        elseif field_number == 33
            devex_weights_reset_period = PB.decode(d, Int32)
        elseif field_number == 34
            use_preprocessing = PB.decode(d, Bool)
        elseif field_number == 35
            use_middle_product_form_update = PB.decode(d, Bool)
        elseif field_number == 36
            initialize_devex_with_column_norms = PB.decode(d, Bool)
        elseif field_number == 37
            exploit_singleton_column_in_initial_basis = PB.decode(d, Bool)
        elseif field_number == 38
            dual_small_pivot_threshold = PB.decode(d, Float64)
        elseif field_number == 39
            preprocessor_zero_tolerance = PB.decode(d, Float64)
        elseif field_number == 40
            objective_lower_limit = PB.decode(d, Float64)
        elseif field_number == 41
            objective_upper_limit = PB.decode(d, Float64)
        elseif field_number == 42
            degenerate_ministep_factor = PB.decode(d, Float64)
        elseif field_number == 43
            random_seed = PB.decode(d, Int32)
        elseif field_number == 72
            use_absl_random = PB.decode(d, Bool)
        elseif field_number == 44
            num_omp_threads = PB.decode(d, Int32)
        elseif field_number == 53
            perturb_costs_in_dual_simplex = PB.decode(d, Bool)
        elseif field_number == 62
            use_dedicated_dual_feasibility_algorithm = PB.decode(d, Bool)
        elseif field_number == 54
            relative_cost_perturbation = PB.decode(d, Float64)
        elseif field_number == 55
            relative_max_cost_perturbation = PB.decode(d, Float64)
        elseif field_number == 59
            initial_condition_number_threshold = PB.decode(d, Float64)
        elseif field_number == 61
            log_search_progress = PB.decode(d, Bool)
        elseif field_number == 66
            log_to_stdout = PB.decode(d, Bool)
        elseif field_number == 64
            crossover_bound_snapping_distance = PB.decode(d, Float64)
        elseif field_number == 65
            push_to_vertex = PB.decode(d, Bool)
        elseif field_number == 67
            use_implied_free_preprocessor = PB.decode(d, Bool)
        elseif field_number == 70
            max_valid_magnitude = PB.decode(d, Float64)
        elseif field_number == 71
            drop_magnitude = PB.decode(d, Float64)
        elseif field_number == 69
            dual_price_prioritize_norm = PB.decode(d, Bool)
        else
            PB.skip(d, wire_type)
        end
    end
    return GlopParameters(scaling_method, feasibility_rule, optimization_rule, refactorization_threshold, recompute_reduced_costs_threshold, recompute_edges_norm_threshold, primal_feasibility_tolerance, dual_feasibility_tolerance, ratio_test_zero_threshold, harris_tolerance_ratio, small_pivot_threshold, minimum_acceptable_pivot, drop_tolerance, use_scaling, cost_scaling, initial_basis, use_transposed_matrix, basis_refactorization_period, dynamically_adjust_refactorization_period, solve_dual_problem, dualizer_threshold, solution_feasibility_tolerance, provide_strong_optimal_guarantee, change_status_to_imprecise, max_number_of_reoptimizations, lu_factorization_pivot_threshold, max_time_in_seconds, max_deterministic_time, max_number_of_iterations, markowitz_zlatev_parameter, markowitz_singularity_threshold, use_dual_simplex, allow_simplex_algorithm_change, devex_weights_reset_period, use_preprocessing, use_middle_product_form_update, initialize_devex_with_column_norms, exploit_singleton_column_in_initial_basis, dual_small_pivot_threshold, preprocessor_zero_tolerance, objective_lower_limit, objective_upper_limit, degenerate_ministep_factor, random_seed, use_absl_random, num_omp_threads, perturb_costs_in_dual_simplex, use_dedicated_dual_feasibility_algorithm, relative_cost_perturbation, relative_max_cost_perturbation, initial_condition_number_threshold, log_search_progress, log_to_stdout, crossover_bound_snapping_distance, push_to_vertex, use_implied_free_preprocessor, max_valid_magnitude, drop_magnitude, dual_price_prioritize_norm)
end

function PB.encode(e::PB.AbstractProtoEncoder, x::GlopParameters)
    initpos = position(e.io)
    x.scaling_method != var"GlopParameters.ScalingAlgorithm".EQUILIBRATION && PB.encode(e, 57, x.scaling_method)
    x.feasibility_rule != var"GlopParameters.PricingRule".STEEPEST_EDGE && PB.encode(e, 1, x.feasibility_rule)
    x.optimization_rule != var"GlopParameters.PricingRule".STEEPEST_EDGE && PB.encode(e, 2, x.optimization_rule)
    x.refactorization_threshold !== Float64(1e-9) && PB.encode(e, 6, x.refactorization_threshold)
    x.recompute_reduced_costs_threshold !== Float64(1e-8) && PB.encode(e, 8, x.recompute_reduced_costs_threshold)
    x.recompute_edges_norm_threshold !== Float64(100.0) && PB.encode(e, 9, x.recompute_edges_norm_threshold)
    x.primal_feasibility_tolerance !== Float64(1e-8) && PB.encode(e, 10, x.primal_feasibility_tolerance)
    x.dual_feasibility_tolerance !== Float64(1e-8) && PB.encode(e, 11, x.dual_feasibility_tolerance)
    x.ratio_test_zero_threshold !== Float64(1e-9) && PB.encode(e, 12, x.ratio_test_zero_threshold)
    x.harris_tolerance_ratio !== Float64(0.5) && PB.encode(e, 13, x.harris_tolerance_ratio)
    x.small_pivot_threshold !== Float64(1e-6) && PB.encode(e, 14, x.small_pivot_threshold)
    x.minimum_acceptable_pivot !== Float64(1e-6) && PB.encode(e, 15, x.minimum_acceptable_pivot)
    x.drop_tolerance !== Float64(1e-14) && PB.encode(e, 52, x.drop_tolerance)
    x.use_scaling != true && PB.encode(e, 16, x.use_scaling)
    x.cost_scaling != var"GlopParameters.CostScalingAlgorithm".CONTAIN_ONE_COST_SCALING && PB.encode(e, 60, x.cost_scaling)
    x.initial_basis != var"GlopParameters.InitialBasisHeuristic".TRIANGULAR && PB.encode(e, 17, x.initial_basis)
    x.use_transposed_matrix != true && PB.encode(e, 18, x.use_transposed_matrix)
    x.basis_refactorization_period != Int32(64) && PB.encode(e, 19, x.basis_refactorization_period)
    x.dynamically_adjust_refactorization_period != true && PB.encode(e, 63, x.dynamically_adjust_refactorization_period)
    x.solve_dual_problem != var"GlopParameters.SolverBehavior".LET_SOLVER_DECIDE && PB.encode(e, 20, x.solve_dual_problem)
    x.dualizer_threshold !== Float64(1.5) && PB.encode(e, 21, x.dualizer_threshold)
    x.solution_feasibility_tolerance !== Float64(1e-6) && PB.encode(e, 22, x.solution_feasibility_tolerance)
    x.provide_strong_optimal_guarantee != true && PB.encode(e, 24, x.provide_strong_optimal_guarantee)
    x.change_status_to_imprecise != true && PB.encode(e, 58, x.change_status_to_imprecise)
    x.max_number_of_reoptimizations !== Float64(40) && PB.encode(e, 56, x.max_number_of_reoptimizations)
    x.lu_factorization_pivot_threshold !== Float64(0.01) && PB.encode(e, 25, x.lu_factorization_pivot_threshold)
    x.max_time_in_seconds !== Float64(Inf) && PB.encode(e, 26, x.max_time_in_seconds)
    x.max_deterministic_time !== Float64(Inf) && PB.encode(e, 45, x.max_deterministic_time)
    x.max_number_of_iterations != Int64(-1) && PB.encode(e, 27, x.max_number_of_iterations)
    x.markowitz_zlatev_parameter != Int32(3) && PB.encode(e, 29, x.markowitz_zlatev_parameter)
    x.markowitz_singularity_threshold !== Float64(1e-15) && PB.encode(e, 30, x.markowitz_singularity_threshold)
    x.use_dual_simplex != false && PB.encode(e, 31, x.use_dual_simplex)
    x.allow_simplex_algorithm_change != false && PB.encode(e, 32, x.allow_simplex_algorithm_change)
    x.devex_weights_reset_period != Int32(150) && PB.encode(e, 33, x.devex_weights_reset_period)
    x.use_preprocessing != true && PB.encode(e, 34, x.use_preprocessing)
    x.use_middle_product_form_update != true && PB.encode(e, 35, x.use_middle_product_form_update)
    x.initialize_devex_with_column_norms != true && PB.encode(e, 36, x.initialize_devex_with_column_norms)
    x.exploit_singleton_column_in_initial_basis != true && PB.encode(e, 37, x.exploit_singleton_column_in_initial_basis)
    x.dual_small_pivot_threshold !== Float64(1e-4) && PB.encode(e, 38, x.dual_small_pivot_threshold)
    x.preprocessor_zero_tolerance !== Float64(1e-9) && PB.encode(e, 39, x.preprocessor_zero_tolerance)
    x.objective_lower_limit !== Float64(-Inf) && PB.encode(e, 40, x.objective_lower_limit)
    x.objective_upper_limit !== Float64(Inf) && PB.encode(e, 41, x.objective_upper_limit)
    x.degenerate_ministep_factor !== Float64(0.01) && PB.encode(e, 42, x.degenerate_ministep_factor)
    x.random_seed != Int32(1) && PB.encode(e, 43, x.random_seed)
    x.use_absl_random != false && PB.encode(e, 72, x.use_absl_random)
    x.num_omp_threads != Int32(1) && PB.encode(e, 44, x.num_omp_threads)
    x.perturb_costs_in_dual_simplex != false && PB.encode(e, 53, x.perturb_costs_in_dual_simplex)
    x.use_dedicated_dual_feasibility_algorithm != true && PB.encode(e, 62, x.use_dedicated_dual_feasibility_algorithm)
    x.relative_cost_perturbation !== Float64(1e-5) && PB.encode(e, 54, x.relative_cost_perturbation)
    x.relative_max_cost_perturbation !== Float64(1e-7) && PB.encode(e, 55, x.relative_max_cost_perturbation)
    x.initial_condition_number_threshold !== Float64(1e50) && PB.encode(e, 59, x.initial_condition_number_threshold)
    x.log_search_progress != false && PB.encode(e, 61, x.log_search_progress)
    x.log_to_stdout != true && PB.encode(e, 66, x.log_to_stdout)
    x.crossover_bound_snapping_distance !== Float64(Inf) && PB.encode(e, 64, x.crossover_bound_snapping_distance)
    x.push_to_vertex != true && PB.encode(e, 65, x.push_to_vertex)
    x.use_implied_free_preprocessor != true && PB.encode(e, 67, x.use_implied_free_preprocessor)
    x.max_valid_magnitude !== Float64(1e30) && PB.encode(e, 70, x.max_valid_magnitude)
    x.drop_magnitude !== Float64(1e-30) && PB.encode(e, 71, x.drop_magnitude)
    x.dual_price_prioritize_norm != false && PB.encode(e, 69, x.dual_price_prioritize_norm)
    return position(e.io) - initpos
end
function PB._encoded_size(x::GlopParameters)
    encoded_size = 0
    x.scaling_method != var"GlopParameters.ScalingAlgorithm".EQUILIBRATION && (encoded_size += PB._encoded_size(x.scaling_method, 57))
    x.feasibility_rule != var"GlopParameters.PricingRule".STEEPEST_EDGE && (encoded_size += PB._encoded_size(x.feasibility_rule, 1))
    x.optimization_rule != var"GlopParameters.PricingRule".STEEPEST_EDGE && (encoded_size += PB._encoded_size(x.optimization_rule, 2))
    x.refactorization_threshold !== Float64(1e-9) && (encoded_size += PB._encoded_size(x.refactorization_threshold, 6))
    x.recompute_reduced_costs_threshold !== Float64(1e-8) && (encoded_size += PB._encoded_size(x.recompute_reduced_costs_threshold, 8))
    x.recompute_edges_norm_threshold !== Float64(100.0) && (encoded_size += PB._encoded_size(x.recompute_edges_norm_threshold, 9))
    x.primal_feasibility_tolerance !== Float64(1e-8) && (encoded_size += PB._encoded_size(x.primal_feasibility_tolerance, 10))
    x.dual_feasibility_tolerance !== Float64(1e-8) && (encoded_size += PB._encoded_size(x.dual_feasibility_tolerance, 11))
    x.ratio_test_zero_threshold !== Float64(1e-9) && (encoded_size += PB._encoded_size(x.ratio_test_zero_threshold, 12))
    x.harris_tolerance_ratio !== Float64(0.5) && (encoded_size += PB._encoded_size(x.harris_tolerance_ratio, 13))
    x.small_pivot_threshold !== Float64(1e-6) && (encoded_size += PB._encoded_size(x.small_pivot_threshold, 14))
    x.minimum_acceptable_pivot !== Float64(1e-6) && (encoded_size += PB._encoded_size(x.minimum_acceptable_pivot, 15))
    x.drop_tolerance !== Float64(1e-14) && (encoded_size += PB._encoded_size(x.drop_tolerance, 52))
    x.use_scaling != true && (encoded_size += PB._encoded_size(x.use_scaling, 16))
    x.cost_scaling != var"GlopParameters.CostScalingAlgorithm".CONTAIN_ONE_COST_SCALING && (encoded_size += PB._encoded_size(x.cost_scaling, 60))
    x.initial_basis != var"GlopParameters.InitialBasisHeuristic".TRIANGULAR && (encoded_size += PB._encoded_size(x.initial_basis, 17))
    x.use_transposed_matrix != true && (encoded_size += PB._encoded_size(x.use_transposed_matrix, 18))
    x.basis_refactorization_period != Int32(64) && (encoded_size += PB._encoded_size(x.basis_refactorization_period, 19))
    x.dynamically_adjust_refactorization_period != true && (encoded_size += PB._encoded_size(x.dynamically_adjust_refactorization_period, 63))
    x.solve_dual_problem != var"GlopParameters.SolverBehavior".LET_SOLVER_DECIDE && (encoded_size += PB._encoded_size(x.solve_dual_problem, 20))
    x.dualizer_threshold !== Float64(1.5) && (encoded_size += PB._encoded_size(x.dualizer_threshold, 21))
    x.solution_feasibility_tolerance !== Float64(1e-6) && (encoded_size += PB._encoded_size(x.solution_feasibility_tolerance, 22))
    x.provide_strong_optimal_guarantee != true && (encoded_size += PB._encoded_size(x.provide_strong_optimal_guarantee, 24))
    x.change_status_to_imprecise != true && (encoded_size += PB._encoded_size(x.change_status_to_imprecise, 58))
    x.max_number_of_reoptimizations !== Float64(40) && (encoded_size += PB._encoded_size(x.max_number_of_reoptimizations, 56))
    x.lu_factorization_pivot_threshold !== Float64(0.01) && (encoded_size += PB._encoded_size(x.lu_factorization_pivot_threshold, 25))
    x.max_time_in_seconds !== Float64(Inf) && (encoded_size += PB._encoded_size(x.max_time_in_seconds, 26))
    x.max_deterministic_time !== Float64(Inf) && (encoded_size += PB._encoded_size(x.max_deterministic_time, 45))
    x.max_number_of_iterations != Int64(-1) && (encoded_size += PB._encoded_size(x.max_number_of_iterations, 27))
    x.markowitz_zlatev_parameter != Int32(3) && (encoded_size += PB._encoded_size(x.markowitz_zlatev_parameter, 29))
    x.markowitz_singularity_threshold !== Float64(1e-15) && (encoded_size += PB._encoded_size(x.markowitz_singularity_threshold, 30))
    x.use_dual_simplex != false && (encoded_size += PB._encoded_size(x.use_dual_simplex, 31))
    x.allow_simplex_algorithm_change != false && (encoded_size += PB._encoded_size(x.allow_simplex_algorithm_change, 32))
    x.devex_weights_reset_period != Int32(150) && (encoded_size += PB._encoded_size(x.devex_weights_reset_period, 33))
    x.use_preprocessing != true && (encoded_size += PB._encoded_size(x.use_preprocessing, 34))
    x.use_middle_product_form_update != true && (encoded_size += PB._encoded_size(x.use_middle_product_form_update, 35))
    x.initialize_devex_with_column_norms != true && (encoded_size += PB._encoded_size(x.initialize_devex_with_column_norms, 36))
    x.exploit_singleton_column_in_initial_basis != true && (encoded_size += PB._encoded_size(x.exploit_singleton_column_in_initial_basis, 37))
    x.dual_small_pivot_threshold !== Float64(1e-4) && (encoded_size += PB._encoded_size(x.dual_small_pivot_threshold, 38))
    x.preprocessor_zero_tolerance !== Float64(1e-9) && (encoded_size += PB._encoded_size(x.preprocessor_zero_tolerance, 39))
    x.objective_lower_limit !== Float64(-Inf) && (encoded_size += PB._encoded_size(x.objective_lower_limit, 40))
    x.objective_upper_limit !== Float64(Inf) && (encoded_size += PB._encoded_size(x.objective_upper_limit, 41))
    x.degenerate_ministep_factor !== Float64(0.01) && (encoded_size += PB._encoded_size(x.degenerate_ministep_factor, 42))
    x.random_seed != Int32(1) && (encoded_size += PB._encoded_size(x.random_seed, 43))
    x.use_absl_random != false && (encoded_size += PB._encoded_size(x.use_absl_random, 72))
    x.num_omp_threads != Int32(1) && (encoded_size += PB._encoded_size(x.num_omp_threads, 44))
    x.perturb_costs_in_dual_simplex != false && (encoded_size += PB._encoded_size(x.perturb_costs_in_dual_simplex, 53))
    x.use_dedicated_dual_feasibility_algorithm != true && (encoded_size += PB._encoded_size(x.use_dedicated_dual_feasibility_algorithm, 62))
    x.relative_cost_perturbation !== Float64(1e-5) && (encoded_size += PB._encoded_size(x.relative_cost_perturbation, 54))
    x.relative_max_cost_perturbation !== Float64(1e-7) && (encoded_size += PB._encoded_size(x.relative_max_cost_perturbation, 55))
    x.initial_condition_number_threshold !== Float64(1e50) && (encoded_size += PB._encoded_size(x.initial_condition_number_threshold, 59))
    x.log_search_progress != false && (encoded_size += PB._encoded_size(x.log_search_progress, 61))
    x.log_to_stdout != true && (encoded_size += PB._encoded_size(x.log_to_stdout, 66))
    x.crossover_bound_snapping_distance !== Float64(Inf) && (encoded_size += PB._encoded_size(x.crossover_bound_snapping_distance, 64))
    x.push_to_vertex != true && (encoded_size += PB._encoded_size(x.push_to_vertex, 65))
    x.use_implied_free_preprocessor != true && (encoded_size += PB._encoded_size(x.use_implied_free_preprocessor, 67))
    x.max_valid_magnitude !== Float64(1e30) && (encoded_size += PB._encoded_size(x.max_valid_magnitude, 70))
    x.drop_magnitude !== Float64(1e-30) && (encoded_size += PB._encoded_size(x.drop_magnitude, 71))
    x.dual_price_prioritize_norm != false && (encoded_size += PB._encoded_size(x.dual_price_prioritize_norm, 69))
    return encoded_size
end
