<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>OR-Tools</title>
        <meta http-equiv="Content-Type" content="text/html;"/>
        <meta charset="utf-8"/>
        <!--<link rel='stylesheet' type='text/css' href="https://fonts.googleapis.com/css?family=Ubuntu:400,700,400italic"/>-->
        <link rel="stylesheet" type="text/css" href="ortools.css" title="default" media="screen,print" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
    </head>
    <body>
        <div id="banner-container">
            <div id="banner">
                <span id="sfml">OR-Tools 7.2</span>
            </div>
        </div>
        <link rel="icon" href="https://developers.google.com/optimization/images/orLogo.png">
        <div id="content">
<!-- Generated by Doxygen 1.8.15 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('classoperations__research_1_1MPSolver.html','');});
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classoperations__research_1_1MPSolver-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">operations_research::MPSolver Class Reference</div>  </div>
</div><!--header-->
<div class="contents">
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This mathematical programming (MP) solver class is the main class though which users build and solve problems. </p>

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00174">174</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a42c406c7e6fba381aa2bb41aae4b44f2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a42c406c7e6fba381aa2bb41aae4b44f2">OptimizationProblemType</a> { <br />
&#160;&#160;<a class="el" href="classoperations__research_1_1MPSolver.html#a42c406c7e6fba381aa2bb41aae4b44f2a91bb43cabe6c49465bd7138189f3ea84">CLP_LINEAR_PROGRAMMING</a> = 0, 
<a class="el" href="classoperations__research_1_1MPSolver.html#a42c406c7e6fba381aa2bb41aae4b44f2a32049e26d1ea6f68624fc478b88d98c9">GLOP_LINEAR_PROGRAMMING</a> = 2, 
<a class="el" href="classoperations__research_1_1MPSolver.html#a42c406c7e6fba381aa2bb41aae4b44f2a357b78ac84d42c93f2be55c89ed685dc">SCIP_MIXED_INTEGER_PROGRAMMING</a> = 3, 
<a class="el" href="classoperations__research_1_1MPSolver.html#a42c406c7e6fba381aa2bb41aae4b44f2a6f8b8f9d64ae299e8cfccf4917bf5282">CBC_MIXED_INTEGER_PROGRAMMING</a> = 5, 
<br />
&#160;&#160;<a class="el" href="classoperations__research_1_1MPSolver.html#a42c406c7e6fba381aa2bb41aae4b44f2aaef5b33a2d88606a978524ebc7b1cb7b">BOP_INTEGER_PROGRAMMING</a> = 12
<br />
 }</td></tr>
<tr class="memdesc:a42c406c7e6fba381aa2bb41aae4b44f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of problems (LP or MIP) that will be solved and the underlying solver (GLOP, GLPK, CLP, CBC or SCIP) that will solve them.  <a href="classoperations__research_1_1MPSolver.html#a42c406c7e6fba381aa2bb41aae4b44f2">More...</a><br /></td></tr>
<tr class="separator:a42c406c7e6fba381aa2bb41aae4b44f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16bca30fdb1b048d987631b757c63192"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a16bca30fdb1b048d987631b757c63192">ResultStatus</a> { <br />
&#160;&#160;<a class="el" href="classoperations__research_1_1MPSolver.html#a16bca30fdb1b048d987631b757c63192a7a765c1340de9cc37e22c68a2da7d390">OPTIMAL</a>, 
<a class="el" href="classoperations__research_1_1MPSolver.html#a16bca30fdb1b048d987631b757c63192a5930d45ccc1bc78ad06bcd15cbca6a29">FEASIBLE</a>, 
<a class="el" href="classoperations__research_1_1MPSolver.html#a16bca30fdb1b048d987631b757c63192a84e96d7264feeb2b6577400bc379d9db">INFEASIBLE</a>, 
<a class="el" href="classoperations__research_1_1MPSolver.html#a16bca30fdb1b048d987631b757c63192a88c7283cc752b51ed05c21c73f8fe100">UNBOUNDED</a>, 
<br />
&#160;&#160;<a class="el" href="classoperations__research_1_1MPSolver.html#a16bca30fdb1b048d987631b757c63192ae7c84444803ea46da465b68fb6e974fa">ABNORMAL</a>, 
<a class="el" href="classoperations__research_1_1MPSolver.html#a16bca30fdb1b048d987631b757c63192a0ce4e033c6bca973cb026780cdb7daa2">MODEL_INVALID</a>, 
<a class="el" href="classoperations__research_1_1MPSolver.html#a16bca30fdb1b048d987631b757c63192a5c14184aabfffdb489347ab0486c8492">NOT_SOLVED</a> = 6
<br />
 }</td></tr>
<tr class="memdesc:a16bca30fdb1b048d987631b757c63192"><td class="mdescLeft">&#160;</td><td class="mdescRight">The status of solving the problem.  <a href="classoperations__research_1_1MPSolver.html#a16bca30fdb1b048d987631b757c63192">More...</a><br /></td></tr>
<tr class="separator:a16bca30fdb1b048d987631b757c63192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e2a34816b22749e70e23d26f49cf743"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a7e2a34816b22749e70e23d26f49cf743">BasisStatus</a> { <br />
&#160;&#160;<a class="el" href="classoperations__research_1_1MPSolver.html#a7e2a34816b22749e70e23d26f49cf743a642d0b5abe3faed060b4ec237df381a0">FREE</a> = 0, 
<a class="el" href="classoperations__research_1_1MPSolver.html#a7e2a34816b22749e70e23d26f49cf743a32b9b4f5f09a5dbdeed585318e8d97f2">AT_LOWER_BOUND</a>, 
<a class="el" href="classoperations__research_1_1MPSolver.html#a7e2a34816b22749e70e23d26f49cf743a578f080f1d30ca7ce7ba6c5b050ddd56">AT_UPPER_BOUND</a>, 
<a class="el" href="classoperations__research_1_1MPSolver.html#a7e2a34816b22749e70e23d26f49cf743aeca9b511e54f58239988d6affd62afa8">FIXED_VALUE</a>, 
<br />
&#160;&#160;<a class="el" href="classoperations__research_1_1MPSolver.html#a7e2a34816b22749e70e23d26f49cf743a0185d5946c48b9852d8a02a7493f4dcf">BASIC</a>
<br />
 }</td></tr>
<tr class="memdesc:a7e2a34816b22749e70e23d26f49cf743"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advanced usage: possible basis status values for a variable and the slack variable of a linear constraint.  <a href="classoperations__research_1_1MPSolver.html#a7e2a34816b22749e70e23d26f49cf743">More...</a><br /></td></tr>
<tr class="separator:a7e2a34816b22749e70e23d26f49cf743"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab6a8a6c57eefce8c07c8a52e053b035b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#ab6a8a6c57eefce8c07c8a52e053b035b">MPSolver</a> (const std::string &amp;name, <a class="el" href="classoperations__research_1_1MPSolver.html#a42c406c7e6fba381aa2bb41aae4b44f2">OptimizationProblemType</a> problem_type)</td></tr>
<tr class="memdesc:ab6a8a6c57eefce8c07c8a52e053b035b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a solver with the given name and underlying solver backend.  <a href="#ab6a8a6c57eefce8c07c8a52e053b035b">More...</a><br /></td></tr>
<tr class="separator:ab6a8a6c57eefce8c07c8a52e053b035b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee7aedeeff79cd0645a5c7e8c0200834"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#aee7aedeeff79cd0645a5c7e8c0200834">~MPSolver</a> ()</td></tr>
<tr class="separator:aee7aedeeff79cd0645a5c7e8c0200834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24caaef373d3715d5bce9fb0da2c203d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a24caaef373d3715d5bce9fb0da2c203d">IsMIP</a> () const</td></tr>
<tr class="separator:a24caaef373d3715d5bce9fb0da2c203d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d6101b365c33fb1f73a4c953abeb0ed"><td class="memItemLeft" align="right" valign="top">const std::string &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a1d6101b365c33fb1f73a4c953abeb0ed">Name</a> () const</td></tr>
<tr class="memdesc:a1d6101b365c33fb1f73a4c953abeb0ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the name of the model set at construction.  <a href="#a1d6101b365c33fb1f73a4c953abeb0ed">More...</a><br /></td></tr>
<tr class="separator:a1d6101b365c33fb1f73a4c953abeb0ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e8b352edd37540f788c3fc473fa875"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classoperations__research_1_1MPSolver.html#a42c406c7e6fba381aa2bb41aae4b44f2">OptimizationProblemType</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a54e8b352edd37540f788c3fc473fa875">ProblemType</a> () const</td></tr>
<tr class="memdesc:a54e8b352edd37540f788c3fc473fa875"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the optimization problem type set at construction.  <a href="#a54e8b352edd37540f788c3fc473fa875">More...</a><br /></td></tr>
<tr class="separator:a54e8b352edd37540f788c3fc473fa875"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fb5381d2f4a764660365168622e4955"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a4fb5381d2f4a764660365168622e4955">Clear</a> ()</td></tr>
<tr class="memdesc:a4fb5381d2f4a764660365168622e4955"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the objective (including the optimization direction), all variables and constraints.  <a href="#a4fb5381d2f4a764660365168622e4955">More...</a><br /></td></tr>
<tr class="separator:a4fb5381d2f4a764660365168622e4955"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ba0685c817d5c5910c80492dd1a7050"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a0ba0685c817d5c5910c80492dd1a7050">NumVariables</a> () const</td></tr>
<tr class="memdesc:a0ba0685c817d5c5910c80492dd1a7050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of variables.  <a href="#a0ba0685c817d5c5910c80492dd1a7050">More...</a><br /></td></tr>
<tr class="separator:a0ba0685c817d5c5910c80492dd1a7050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1593ede4c9cd1da430f606127dc9a642"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a1593ede4c9cd1da430f606127dc9a642">variables</a> () const</td></tr>
<tr class="memdesc:a1593ede4c9cd1da430f606127dc9a642"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the array of variables handled by the <a class="el" href="classoperations__research_1_1MPSolver.html" title="This mathematical programming (MP) solver class is the main class though which users build and solve ...">MPSolver</a>.  <a href="#a1593ede4c9cd1da430f606127dc9a642">More...</a><br /></td></tr>
<tr class="separator:a1593ede4c9cd1da430f606127dc9a642"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae384aa3d9095f883a93f5e2e830e0077"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#ae384aa3d9095f883a93f5e2e830e0077">LookupVariableOrNull</a> (const std::string &amp;var_name) const</td></tr>
<tr class="memdesc:ae384aa3d9095f883a93f5e2e830e0077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks up a variable by name, and returns nullptr if it does not exist.  <a href="#ae384aa3d9095f883a93f5e2e830e0077">More...</a><br /></td></tr>
<tr class="separator:ae384aa3d9095f883a93f5e2e830e0077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6bb7605c749ba485b040b02a37f6728"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#ad6bb7605c749ba485b040b02a37f6728">MakeVar</a> (double lb, double ub, bool integer, const std::string &amp;name)</td></tr>
<tr class="memdesc:ad6bb7605c749ba485b040b02a37f6728"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a variable with the given bounds, integrality requirement and name.  <a href="#ad6bb7605c749ba485b040b02a37f6728">More...</a><br /></td></tr>
<tr class="separator:ad6bb7605c749ba485b040b02a37f6728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54d66e99fdc2424e812d910e7c2f225a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a54d66e99fdc2424e812d910e7c2f225a">MakeNumVar</a> (double lb, double ub, const std::string &amp;name)</td></tr>
<tr class="memdesc:a54d66e99fdc2424e812d910e7c2f225a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a continuous variable.  <a href="#a54d66e99fdc2424e812d910e7c2f225a">More...</a><br /></td></tr>
<tr class="separator:a54d66e99fdc2424e812d910e7c2f225a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf84ccc5151ce164a571d2f31f30960c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#acf84ccc5151ce164a571d2f31f30960c">MakeIntVar</a> (double lb, double ub, const std::string &amp;name)</td></tr>
<tr class="memdesc:acf84ccc5151ce164a571d2f31f30960c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an integer variable.  <a href="#acf84ccc5151ce164a571d2f31f30960c">More...</a><br /></td></tr>
<tr class="separator:acf84ccc5151ce164a571d2f31f30960c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7176be8ce0481d880a8d30a2d7a1c09e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a7176be8ce0481d880a8d30a2d7a1c09e">MakeBoolVar</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:a7176be8ce0481d880a8d30a2d7a1c09e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a boolean variable.  <a href="#a7176be8ce0481d880a8d30a2d7a1c09e">More...</a><br /></td></tr>
<tr class="separator:a7176be8ce0481d880a8d30a2d7a1c09e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c58f52acd6216131582c60aae3625ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a2c58f52acd6216131582c60aae3625ee">MakeVarArray</a> (int nb, double lb, double ub, bool integer, const std::string &amp;name_prefix, std::vector&lt; <a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a> * &gt; *vars)</td></tr>
<tr class="memdesc:a2c58f52acd6216131582c60aae3625ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an array of variables.  <a href="#a2c58f52acd6216131582c60aae3625ee">More...</a><br /></td></tr>
<tr class="separator:a2c58f52acd6216131582c60aae3625ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aebea4f022e7a685322e7db70b76e5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a7aebea4f022e7a685322e7db70b76e5e">MakeNumVarArray</a> (int nb, double lb, double ub, const std::string &amp;name, std::vector&lt; <a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a> * &gt; *vars)</td></tr>
<tr class="memdesc:a7aebea4f022e7a685322e7db70b76e5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an array of continuous variables.  <a href="#a7aebea4f022e7a685322e7db70b76e5e">More...</a><br /></td></tr>
<tr class="separator:a7aebea4f022e7a685322e7db70b76e5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eefc88942fd284ff2962564224d5f8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a5eefc88942fd284ff2962564224d5f8e">MakeIntVarArray</a> (int nb, double lb, double ub, const std::string &amp;name, std::vector&lt; <a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a> * &gt; *vars)</td></tr>
<tr class="memdesc:a5eefc88942fd284ff2962564224d5f8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an array of integer variables.  <a href="#a5eefc88942fd284ff2962564224d5f8e">More...</a><br /></td></tr>
<tr class="separator:a5eefc88942fd284ff2962564224d5f8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5c55776ce47479f8904480cd815a6d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#af5c55776ce47479f8904480cd815a6d5">MakeBoolVarArray</a> (int nb, const std::string &amp;name, std::vector&lt; <a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a> * &gt; *vars)</td></tr>
<tr class="memdesc:af5c55776ce47479f8904480cd815a6d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates an array of boolean variables.  <a href="#af5c55776ce47479f8904480cd815a6d5">More...</a><br /></td></tr>
<tr class="separator:af5c55776ce47479f8904480cd815a6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a3cee848c033e365ebb1cf50bb97cd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a16a3cee848c033e365ebb1cf50bb97cd">NumConstraints</a> () const</td></tr>
<tr class="memdesc:a16a3cee848c033e365ebb1cf50bb97cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of constraints.  <a href="#a16a3cee848c033e365ebb1cf50bb97cd">More...</a><br /></td></tr>
<tr class="separator:a16a3cee848c033e365ebb1cf50bb97cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebc45909b1f377ab86295578ec417a17"><td class="memItemLeft" align="right" valign="top">const std::vector&lt; <a class="el" href="classoperations__research_1_1MPConstraint.html">MPConstraint</a> * &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#aebc45909b1f377ab86295578ec417a17">constraints</a> () const</td></tr>
<tr class="memdesc:aebc45909b1f377ab86295578ec417a17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the array of constraints handled by the <a class="el" href="classoperations__research_1_1MPSolver.html" title="This mathematical programming (MP) solver class is the main class though which users build and solve ...">MPSolver</a>.  <a href="#aebc45909b1f377ab86295578ec417a17">More...</a><br /></td></tr>
<tr class="separator:aebc45909b1f377ab86295578ec417a17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a299502e4b0e4e6608330fdbe4fb86c94"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1MPConstraint.html">MPConstraint</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a299502e4b0e4e6608330fdbe4fb86c94">LookupConstraintOrNull</a> (const std::string &amp;constraint_name) const</td></tr>
<tr class="memdesc:a299502e4b0e4e6608330fdbe4fb86c94"><td class="mdescLeft">&#160;</td><td class="mdescRight">Looks up a constraint by name, and returns nullptr if it does not exist.  <a href="#a299502e4b0e4e6608330fdbe4fb86c94">More...</a><br /></td></tr>
<tr class="separator:a299502e4b0e4e6608330fdbe4fb86c94"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9afcc9a30bf7c360066d7936c121acd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1MPConstraint.html">MPConstraint</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a9afcc9a30bf7c360066d7936c121acd0">MakeRowConstraint</a> (double lb, double ub)</td></tr>
<tr class="memdesc:a9afcc9a30bf7c360066d7936c121acd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a linear constraint with given bounds.  <a href="#a9afcc9a30bf7c360066d7936c121acd0">More...</a><br /></td></tr>
<tr class="separator:a9afcc9a30bf7c360066d7936c121acd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef93893d198901ce104d74794dde123"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1MPConstraint.html">MPConstraint</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a9ef93893d198901ce104d74794dde123">MakeRowConstraint</a> ()</td></tr>
<tr class="memdesc:a9ef93893d198901ce104d74794dde123"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a constraint with -infinity and +infinity bounds.  <a href="#a9ef93893d198901ce104d74794dde123">More...</a><br /></td></tr>
<tr class="separator:a9ef93893d198901ce104d74794dde123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7dc5e8edf7f3a96c2faadc738d52c41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1MPConstraint.html">MPConstraint</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#ac7dc5e8edf7f3a96c2faadc738d52c41">MakeRowConstraint</a> (double lb, double ub, const std::string &amp;name)</td></tr>
<tr class="memdesc:ac7dc5e8edf7f3a96c2faadc738d52c41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a named constraint with given bounds.  <a href="#ac7dc5e8edf7f3a96c2faadc738d52c41">More...</a><br /></td></tr>
<tr class="separator:ac7dc5e8edf7f3a96c2faadc738d52c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abad1058684a6996ba3035c0011b4cc41"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1MPConstraint.html">MPConstraint</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#abad1058684a6996ba3035c0011b4cc41">MakeRowConstraint</a> (const std::string &amp;name)</td></tr>
<tr class="memdesc:abad1058684a6996ba3035c0011b4cc41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a named constraint with -infinity and +infinity bounds.  <a href="#abad1058684a6996ba3035c0011b4cc41">More...</a><br /></td></tr>
<tr class="separator:abad1058684a6996ba3035c0011b4cc41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae31ac8b47142ee8685a39a608a9190d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1MPConstraint.html">MPConstraint</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#ae31ac8b47142ee8685a39a608a9190d1">MakeRowConstraint</a> (const <a class="el" href="classoperations__research_1_1LinearRange.html">LinearRange</a> &amp;range)</td></tr>
<tr class="memdesc:ae31ac8b47142ee8685a39a608a9190d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a constraint owned by <a class="el" href="classoperations__research_1_1MPSolver.html" title="This mathematical programming (MP) solver class is the main class though which users build and solve ...">MPSolver</a> enforcing: range.lower_bound() &lt;= range.linear_expr() &lt;= range.upper_bound()  <a href="#ae31ac8b47142ee8685a39a608a9190d1">More...</a><br /></td></tr>
<tr class="separator:ae31ac8b47142ee8685a39a608a9190d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c54bb9041abac99c35b92dc5386b7a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1MPConstraint.html">MPConstraint</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a4c54bb9041abac99c35b92dc5386b7a7">MakeRowConstraint</a> (const <a class="el" href="classoperations__research_1_1LinearRange.html">LinearRange</a> &amp;range, const std::string &amp;name)</td></tr>
<tr class="memdesc:a4c54bb9041abac99c35b92dc5386b7a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">As above, but also names the constraint.  <a href="#a4c54bb9041abac99c35b92dc5386b7a7">More...</a><br /></td></tr>
<tr class="separator:a4c54bb9041abac99c35b92dc5386b7a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4834a6747544a7053110a0b20d79dac2"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classoperations__research_1_1MPObjective.html">MPObjective</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a4834a6747544a7053110a0b20d79dac2">Objective</a> () const</td></tr>
<tr class="memdesc:a4834a6747544a7053110a0b20d79dac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the objective object.  <a href="#a4834a6747544a7053110a0b20d79dac2">More...</a><br /></td></tr>
<tr class="separator:a4834a6747544a7053110a0b20d79dac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467f89af3bae743dc9d628ee4e74f0c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1MPObjective.html">MPObjective</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a467f89af3bae743dc9d628ee4e74f0c9">MutableObjective</a> ()</td></tr>
<tr class="memdesc:a467f89af3bae743dc9d628ee4e74f0c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the mutable objective object.  <a href="#a467f89af3bae743dc9d628ee4e74f0c9">More...</a><br /></td></tr>
<tr class="separator:a467f89af3bae743dc9d628ee4e74f0c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1535b2a46d5cff6f9727c08085cfbb1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1MPSolver.html#a16bca30fdb1b048d987631b757c63192">ResultStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a1535b2a46d5cff6f9727c08085cfbb1f">Solve</a> ()</td></tr>
<tr class="memdesc:a1535b2a46d5cff6f9727c08085cfbb1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the problem using default parameter values.  <a href="#a1535b2a46d5cff6f9727c08085cfbb1f">More...</a><br /></td></tr>
<tr class="separator:a1535b2a46d5cff6f9727c08085cfbb1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe9e4c330b12131b53d72f41506ddaf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1MPSolver.html#a16bca30fdb1b048d987631b757c63192">ResultStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#acfe9e4c330b12131b53d72f41506ddaf">Solve</a> (const <a class="el" href="classoperations__research_1_1MPSolverParameters.html">MPSolverParameters</a> &amp;param)</td></tr>
<tr class="memdesc:acfe9e4c330b12131b53d72f41506ddaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the problem using the specified parameter values.  <a href="#acfe9e4c330b12131b53d72f41506ddaf">More...</a><br /></td></tr>
<tr class="separator:acfe9e4c330b12131b53d72f41506ddaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad40ba327269cfff827f23ac4d94414d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#ad40ba327269cfff827f23ac4d94414d9">Write</a> (const std::string &amp;file_name)</td></tr>
<tr class="memdesc:ad40ba327269cfff827f23ac4d94414d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes the model using the solver internal write function.  <a href="#ad40ba327269cfff827f23ac4d94414d9">More...</a><br /></td></tr>
<tr class="separator:ad40ba327269cfff827f23ac4d94414d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad07e28e347a4b2d94d53ca96ae201d70"><td class="memItemLeft" align="right" valign="top">std::vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#ad07e28e347a4b2d94d53ca96ae201d70">ComputeConstraintActivities</a> () const</td></tr>
<tr class="memdesc:ad07e28e347a4b2d94d53ca96ae201d70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advanced usage: compute the "activities" of all constraints, which are the sums of their linear terms.  <a href="#ad07e28e347a4b2d94d53ca96ae201d70">More...</a><br /></td></tr>
<tr class="separator:ad07e28e347a4b2d94d53ca96ae201d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4a0234b5830d4ea82d549b3b6b5baf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a2a4a0234b5830d4ea82d549b3b6b5baf">VerifySolution</a> (double tolerance, bool log_errors) const</td></tr>
<tr class="memdesc:a2a4a0234b5830d4ea82d549b3b6b5baf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advanced usage: Verifies the <em>correctness</em> of the solution.  <a href="#a2a4a0234b5830d4ea82d549b3b6b5baf">More...</a><br /></td></tr>
<tr class="separator:a2a4a0234b5830d4ea82d549b3b6b5baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bade4bbf46f4e35513650d38a0a3208"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a0bade4bbf46f4e35513650d38a0a3208">Reset</a> ()</td></tr>
<tr class="memdesc:a0bade4bbf46f4e35513650d38a0a3208"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advanced usage: resets extracted model to solve from scratch.  <a href="#a0bade4bbf46f4e35513650d38a0a3208">More...</a><br /></td></tr>
<tr class="separator:a0bade4bbf46f4e35513650d38a0a3208"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4413905b5839d17823e756cff10d0ffe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a4413905b5839d17823e756cff10d0ffe">InterruptSolve</a> ()</td></tr>
<tr class="memdesc:a4413905b5839d17823e756cff10d0ffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interrupts the <a class="el" href="classoperations__research_1_1MPSolver.html#a1535b2a46d5cff6f9727c08085cfbb1f" title="Solves the problem using default parameter values.">Solve()</a> execution to terminate processing if possible.  <a href="#a4413905b5839d17823e756cff10d0ffe">More...</a><br /></td></tr>
<tr class="separator:a4413905b5839d17823e756cff10d0ffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9eb46d78f04fa12da7ac27c14becb7d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceoperations__research.html#a8cc975b7db5017319901da0f63a114aa">MPSolverResponseStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#af9eb46d78f04fa12da7ac27c14becb7d">LoadModelFromProto</a> (const <a class="el" href="classoperations__research_1_1MPModelProto.html">MPModelProto</a> &amp;input_model, std::string *error_message)</td></tr>
<tr class="memdesc:af9eb46d78f04fa12da7ac27c14becb7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads model from protocol buffer.  <a href="#af9eb46d78f04fa12da7ac27c14becb7d">More...</a><br /></td></tr>
<tr class="separator:af9eb46d78f04fa12da7ac27c14becb7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51b5d57f310db13d800e4440ca3c0d0b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceoperations__research.html#a8cc975b7db5017319901da0f63a114aa">MPSolverResponseStatus</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a51b5d57f310db13d800e4440ca3c0d0b">LoadModelFromProtoWithUniqueNamesOrDie</a> (const <a class="el" href="classoperations__research_1_1MPModelProto.html">MPModelProto</a> &amp;input_model, std::string *error_message)</td></tr>
<tr class="memdesc:a51b5d57f310db13d800e4440ca3c0d0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loads model from protocol buffer.  <a href="#a51b5d57f310db13d800e4440ca3c0d0b">More...</a><br /></td></tr>
<tr class="separator:a51b5d57f310db13d800e4440ca3c0d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91c69a1b2e9098f3835b9fe1c4fead59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a91c69a1b2e9098f3835b9fe1c4fead59">FillSolutionResponseProto</a> (<a class="el" href="classoperations__research_1_1MPSolutionResponse.html">MPSolutionResponse</a> *response) const</td></tr>
<tr class="memdesc:a91c69a1b2e9098f3835b9fe1c4fead59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encodes the current solution in a solution response protocol buffer.  <a href="#a91c69a1b2e9098f3835b9fe1c4fead59">More...</a><br /></td></tr>
<tr class="separator:a91c69a1b2e9098f3835b9fe1c4fead59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8cc8b3c36fe9c08d8e0eefbc98b774"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a9c8cc8b3c36fe9c08d8e0eefbc98b774">ExportModelToProto</a> (<a class="el" href="classoperations__research_1_1MPModelProto.html">MPModelProto</a> *output_model) const</td></tr>
<tr class="memdesc:a9c8cc8b3c36fe9c08d8e0eefbc98b774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Exports model to protocol buffer.  <a href="#a9c8cc8b3c36fe9c08d8e0eefbc98b774">More...</a><br /></td></tr>
<tr class="separator:a9c8cc8b3c36fe9c08d8e0eefbc98b774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa20b60665bd7e137dac446b2b1400838"><td class="memItemLeft" align="right" valign="top">util::Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#aa20b60665bd7e137dac446b2b1400838">LoadSolutionFromProto</a> (const <a class="el" href="classoperations__research_1_1MPSolutionResponse.html">MPSolutionResponse</a> &amp;response, double tolerance=<a class="el" href="namespaceoperations__research.html#a07189276cc680928dad51ed197142077">kDefaultPrimalTolerance</a>)</td></tr>
<tr class="memdesc:aa20b60665bd7e137dac446b2b1400838"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a solution encoded in a protocol buffer onto this solver for easy access via the <a class="el" href="classoperations__research_1_1MPSolver.html" title="This mathematical programming (MP) solver class is the main class though which users build and solve ...">MPSolver</a> interface.  <a href="#aa20b60665bd7e137dac446b2b1400838">More...</a><br /></td></tr>
<tr class="separator:aa20b60665bd7e137dac446b2b1400838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27312cbf1394d779305d016e2ea2753e"><td class="memItemLeft" align="right" valign="top">util::Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a27312cbf1394d779305d016e2ea2753e">ClampSolutionWithinBounds</a> ()</td></tr>
<tr class="memdesc:a27312cbf1394d779305d016e2ea2753e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets values of out of bound variables to the corresponding bound and returns an error if any of the variables have NaN value.  <a href="#a27312cbf1394d779305d016e2ea2753e">More...</a><br /></td></tr>
<tr class="separator:a27312cbf1394d779305d016e2ea2753e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a393a84863fe633baa3c7af4e71c8b147"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a393a84863fe633baa3c7af4e71c8b147">ExportModelAsLpFormat</a> (bool obfuscate, std::string *model_str) const</td></tr>
<tr class="memdesc:a393a84863fe633baa3c7af4e71c8b147"><td class="mdescLeft">&#160;</td><td class="mdescRight">Shortcuts to the homonymous MPModelProtoExporter methods, via exporting to a <a class="el" href="classoperations__research_1_1MPModelProto.html">MPModelProto</a> with <a class="el" href="classoperations__research_1_1MPSolver.html#a9c8cc8b3c36fe9c08d8e0eefbc98b774" title="Exports model to protocol buffer.">ExportModelToProto()</a> (see above).  <a href="#a393a84863fe633baa3c7af4e71c8b147">More...</a><br /></td></tr>
<tr class="separator:a393a84863fe633baa3c7af4e71c8b147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae06ddd4e79e6a985b2644eff14747484"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#ae06ddd4e79e6a985b2644eff14747484">ExportModelAsMpsFormat</a> (bool fixed_format, bool obfuscate, std::string *model_str) const</td></tr>
<tr class="separator:ae06ddd4e79e6a985b2644eff14747484"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6394f5b0c08af038bfd9610d2bc4be90"><td class="memItemLeft" align="right" valign="top">util::Status&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a6394f5b0c08af038bfd9610d2bc4be90">SetNumThreads</a> (int num_threads)</td></tr>
<tr class="memdesc:a6394f5b0c08af038bfd9610d2bc4be90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the number of threads to use by the underlying solver.  <a href="#a6394f5b0c08af038bfd9610d2bc4be90">More...</a><br /></td></tr>
<tr class="separator:a6394f5b0c08af038bfd9610d2bc4be90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ddf26ba2c9524de319f6f307cfde60"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a88ddf26ba2c9524de319f6f307cfde60">GetNumThreads</a> () const</td></tr>
<tr class="memdesc:a88ddf26ba2c9524de319f6f307cfde60"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of threads to be used during solve.  <a href="#a88ddf26ba2c9524de319f6f307cfde60">More...</a><br /></td></tr>
<tr class="separator:a88ddf26ba2c9524de319f6f307cfde60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a532d2fb86e5cdc4710e1a168acbbe7f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a532d2fb86e5cdc4710e1a168acbbe7f6">SetSolverSpecificParametersAsString</a> (const std::string &amp;parameters)</td></tr>
<tr class="memdesc:a532d2fb86e5cdc4710e1a168acbbe7f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advanced usage: pass solver specific parameters in text format.  <a href="#a532d2fb86e5cdc4710e1a168acbbe7f6">More...</a><br /></td></tr>
<tr class="separator:a532d2fb86e5cdc4710e1a168acbbe7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64bc5e50054e619d3399956df3ed110f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a64bc5e50054e619d3399956df3ed110f">GetSolverSpecificParametersAsString</a> () const</td></tr>
<tr class="separator:a64bc5e50054e619d3399956df3ed110f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4255929ea45766c51cf6138758b277"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#abf4255929ea45766c51cf6138758b277">SetHint</a> (std::vector&lt; std::pair&lt; const <a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a> *, double &gt; &gt; hint)</td></tr>
<tr class="memdesc:abf4255929ea45766c51cf6138758b277"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a hint for solution.  <a href="#abf4255929ea45766c51cf6138758b277">More...</a><br /></td></tr>
<tr class="separator:abf4255929ea45766c51cf6138758b277"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a76240b36c39f04ff64104c482990f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a11a76240b36c39f04ff64104c482990f">SetStartingLpBasis</a> (const std::vector&lt; <a class="el" href="classoperations__research_1_1MPSolver.html#a7e2a34816b22749e70e23d26f49cf743">MPSolver::BasisStatus</a> &gt; &amp;variable_statuses, const std::vector&lt; <a class="el" href="classoperations__research_1_1MPSolver.html#a7e2a34816b22749e70e23d26f49cf743">MPSolver::BasisStatus</a> &gt; &amp;constraint_statuses)</td></tr>
<tr class="memdesc:a11a76240b36c39f04ff64104c482990f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advanced usage: Incrementality.  <a href="#a11a76240b36c39f04ff64104c482990f">More...</a><br /></td></tr>
<tr class="separator:a11a76240b36c39f04ff64104c482990f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90a00b370b9abc4a43bfefd7f6a895b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#aa90a00b370b9abc4a43bfefd7f6a895b">OutputIsEnabled</a> () const</td></tr>
<tr class="memdesc:aa90a00b370b9abc4a43bfefd7f6a895b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Controls (or queries) the amount of output produced by the underlying solver.  <a href="#aa90a00b370b9abc4a43bfefd7f6a895b">More...</a><br /></td></tr>
<tr class="separator:aa90a00b370b9abc4a43bfefd7f6a895b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc2c48c807107ccfdfa8c1b50ae16c41"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#abc2c48c807107ccfdfa8c1b50ae16c41">EnableOutput</a> ()</td></tr>
<tr class="separator:abc2c48c807107ccfdfa8c1b50ae16c41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfaa014d3c3ca883e3c8a17110372801"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#abfaa014d3c3ca883e3c8a17110372801">SuppressOutput</a> ()</td></tr>
<tr class="memdesc:abfaa014d3c3ca883e3c8a17110372801"><td class="mdescLeft">&#160;</td><td class="mdescRight">Suppress output.  <a href="#abfaa014d3c3ca883e3c8a17110372801">More...</a><br /></td></tr>
<tr class="separator:abfaa014d3c3ca883e3c8a17110372801"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae2fbd44c86451dadfc256f000772394"><td class="memItemLeft" align="right" valign="top">absl::Duration&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#aae2fbd44c86451dadfc256f000772394">TimeLimit</a> () const</td></tr>
<tr class="separator:aae2fbd44c86451dadfc256f000772394"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47a5516ca826adbc25bd5bf1d7935fd1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a47a5516ca826adbc25bd5bf1d7935fd1">SetTimeLimit</a> (absl::Duration <a class="el" href="classoperations__research_1_1MPSolver.html#a258c821fae2869693b58440145125aba">time_limit</a>)</td></tr>
<tr class="separator:a47a5516ca826adbc25bd5bf1d7935fd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a68e7fab8751978c9faa30867f91241"><td class="memItemLeft" align="right" valign="top">absl::Duration&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a6a68e7fab8751978c9faa30867f91241">DurationSinceConstruction</a> () const</td></tr>
<tr class="separator:a6a68e7fab8751978c9faa30867f91241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15001c5a8f5c0086dddcc4626a5a5ad7"><td class="memItemLeft" align="right" valign="top">int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a15001c5a8f5c0086dddcc4626a5a5ad7">iterations</a> () const</td></tr>
<tr class="memdesc:a15001c5a8f5c0086dddcc4626a5a5ad7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of simplex iterations.  <a href="#a15001c5a8f5c0086dddcc4626a5a5ad7">More...</a><br /></td></tr>
<tr class="separator:a15001c5a8f5c0086dddcc4626a5a5ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6837e7545ac2c5cfe95ca9a1c0f013e3"><td class="memItemLeft" align="right" valign="top">int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a6837e7545ac2c5cfe95ca9a1c0f013e3">nodes</a> () const</td></tr>
<tr class="memdesc:a6837e7545ac2c5cfe95ca9a1c0f013e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of branch-and-bound nodes evaluated during the solve.  <a href="#a6837e7545ac2c5cfe95ca9a1c0f013e3">More...</a><br /></td></tr>
<tr class="separator:a6837e7545ac2c5cfe95ca9a1c0f013e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee22680c23e591329e9ac50ff78f572d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#aee22680c23e591329e9ac50ff78f572d">SolverVersion</a> () const</td></tr>
<tr class="memdesc:aee22680c23e591329e9ac50ff78f572d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a std::string describing the underlying solver and its version.  <a href="#aee22680c23e591329e9ac50ff78f572d">More...</a><br /></td></tr>
<tr class="separator:aee22680c23e591329e9ac50ff78f572d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3bc5e39b383336fb3ca88b1a0c6cc5"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a3d3bc5e39b383336fb3ca88b1a0c6cc5">underlying_solver</a> ()</td></tr>
<tr class="memdesc:a3d3bc5e39b383336fb3ca88b1a0c6cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advanced usage: returns the underlying solver.  <a href="#a3d3bc5e39b383336fb3ca88b1a0c6cc5">More...</a><br /></td></tr>
<tr class="separator:a3d3bc5e39b383336fb3ca88b1a0c6cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6390f93d9c4e88775d98ec8353ef0979"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a6390f93d9c4e88775d98ec8353ef0979">ComputeExactConditionNumber</a> () const</td></tr>
<tr class="memdesc:a6390f93d9c4e88775d98ec8353ef0979"><td class="mdescLeft">&#160;</td><td class="mdescRight">Advanced usage: computes the exact condition number of the current scaled basis: L1norm(B) * L1norm(inverse(B)), where B is the scaled basis.  <a href="#a6390f93d9c4e88775d98ec8353ef0979">More...</a><br /></td></tr>
<tr class="separator:a6390f93d9c4e88775d98ec8353ef0979"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b11747bf657bf074d1e710121810d13"><td class="memItemLeft" align="right" valign="top">ABSL_MUST_USE_RESULT bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a4b11747bf657bf074d1e710121810d13">NextSolution</a> ()</td></tr>
<tr class="memdesc:a4b11747bf657bf074d1e710121810d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Some solvers (MIP only, not LP) can produce multiple solutions to the problem.  <a href="#a4b11747bf657bf074d1e710121810d13">More...</a><br /></td></tr>
<tr class="separator:a4b11747bf657bf074d1e710121810d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a258c821fae2869693b58440145125aba"><td class="memItemLeft" align="right" valign="top">int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a258c821fae2869693b58440145125aba">time_limit</a> () const</td></tr>
<tr class="separator:a258c821fae2869693b58440145125aba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae99e29fcc045ab27c8fecbdc422e6133"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#ae99e29fcc045ab27c8fecbdc422e6133">set_time_limit</a> (int64 time_limit_milliseconds)</td></tr>
<tr class="separator:ae99e29fcc045ab27c8fecbdc422e6133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0177cee53f52d09df990920d532b0772"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a0177cee53f52d09df990920d532b0772">time_limit_in_secs</a> () const</td></tr>
<tr class="separator:a0177cee53f52d09df990920d532b0772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce69ce989942416f35a7d3577b5edd8"><td class="memItemLeft" align="right" valign="top">int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a1ce69ce989942416f35a7d3577b5edd8">wall_time</a> () const</td></tr>
<tr class="separator:a1ce69ce989942416f35a7d3577b5edd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78606aaae8d97a0def488e696fdb2d2b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a78606aaae8d97a0def488e696fdb2d2b">OwnsVariable</a> (const <a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a> *var) const</td></tr>
<tr class="separator:a78606aaae8d97a0def488e696fdb2d2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ae96df0f02a46493eba93d2e70709911a"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#ae96df0f02a46493eba93d2e70709911a">SupportsProblemType</a> (<a class="el" href="classoperations__research_1_1MPSolver.html#a42c406c7e6fba381aa2bb41aae4b44f2">OptimizationProblemType</a> problem_type)</td></tr>
<tr class="memdesc:ae96df0f02a46493eba93d2e70709911a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the given problem type is supported (this will depend on the targets that you linked).  <a href="#ae96df0f02a46493eba93d2e70709911a">More...</a><br /></td></tr>
<tr class="separator:ae96df0f02a46493eba93d2e70709911a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a650dd472cb06be9f9abcf5bc0833437d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a650dd472cb06be9f9abcf5bc0833437d">ParseSolverType</a> (absl::string_view solver, <a class="el" href="classoperations__research_1_1MPSolver.html#a42c406c7e6fba381aa2bb41aae4b44f2">OptimizationProblemType</a> *type)</td></tr>
<tr class="memdesc:a650dd472cb06be9f9abcf5bc0833437d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses the name of the solver.  <a href="#a650dd472cb06be9f9abcf5bc0833437d">More...</a><br /></td></tr>
<tr class="separator:a650dd472cb06be9f9abcf5bc0833437d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aaa8bdb57173a9d933ed5f62bb60f42"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a3aaa8bdb57173a9d933ed5f62bb60f42">SolveWithProto</a> (const <a class="el" href="classoperations__research_1_1MPModelRequest.html">MPModelRequest</a> &amp;model_request, <a class="el" href="classoperations__research_1_1MPSolutionResponse.html">MPSolutionResponse</a> *response)</td></tr>
<tr class="memdesc:a3aaa8bdb57173a9d933ed5f62bb60f42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solves the model encoded by a <a class="el" href="classoperations__research_1_1MPModelRequest.html">MPModelRequest</a> protocol buffer and fills the solution encoded as a <a class="el" href="classoperations__research_1_1MPSolutionResponse.html">MPSolutionResponse</a>.  <a href="#a3aaa8bdb57173a9d933ed5f62bb60f42">More...</a><br /></td></tr>
<tr class="separator:a3aaa8bdb57173a9d933ed5f62bb60f42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b15f7248e2b72d474bae0444a613033"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a5b15f7248e2b72d474bae0444a613033">infinity</a> ()</td></tr>
<tr class="memdesc:a5b15f7248e2b72d474bae0444a613033"><td class="mdescLeft">&#160;</td><td class="mdescRight">Infinity.  <a href="#a5b15f7248e2b72d474bae0444a613033">More...</a><br /></td></tr>
<tr class="separator:a5b15f7248e2b72d474bae0444a613033"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ae1a3e0a695903c8e6effd524a7f92784"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#ae1a3e0a695903c8e6effd524a7f92784">GLPKInterface</a></td></tr>
<tr class="separator:ae1a3e0a695903c8e6effd524a7f92784"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60944ecdcad88cfb4d4d32feea70c9b5"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a60944ecdcad88cfb4d4d32feea70c9b5">CLPInterface</a></td></tr>
<tr class="separator:a60944ecdcad88cfb4d4d32feea70c9b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a7cf0c655f37c0b388a2ddcf32ac3e"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#af5a7cf0c655f37c0b388a2ddcf32ac3e">CBCInterface</a></td></tr>
<tr class="separator:af5a7cf0c655f37c0b388a2ddcf32ac3e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a236f9752f4df4c5134617330a040ec8a"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a236f9752f4df4c5134617330a040ec8a">SCIPInterface</a></td></tr>
<tr class="separator:a236f9752f4df4c5134617330a040ec8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28a56eeedb62d070578a9231f1875ea"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#ac28a56eeedb62d070578a9231f1875ea">GurobiInterface</a></td></tr>
<tr class="separator:ac28a56eeedb62d070578a9231f1875ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7cbd08108e1636184f28c1a71c42393"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#ae7cbd08108e1636184f28c1a71c42393">CplexInterface</a></td></tr>
<tr class="separator:ae7cbd08108e1636184f28c1a71c42393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c083b37243075a00bf909840dc7c933"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a5c083b37243075a00bf909840dc7c933">SLMInterface</a></td></tr>
<tr class="separator:a5c083b37243075a00bf909840dc7c933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0aea0786e75adbb2d24c41c15e7456c"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#ac0aea0786e75adbb2d24c41c15e7456c">MPSolverInterface</a></td></tr>
<tr class="separator:ac0aea0786e75adbb2d24c41c15e7456c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c754b527a347994b06eeb49a09ac222"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a6c754b527a347994b06eeb49a09ac222">GLOPInterface</a></td></tr>
<tr class="separator:a6c754b527a347994b06eeb49a09ac222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7383308e6b9b63b18196798db342ce8a"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#a7383308e6b9b63b18196798db342ce8a">BopInterface</a></td></tr>
<tr class="separator:a7383308e6b9b63b18196798db342ce8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbd4413b1370baca9c45aecb0cb8ebd2"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#acbd4413b1370baca9c45aecb0cb8ebd2">SatInterface</a></td></tr>
<tr class="separator:acbd4413b1370baca9c45aecb0cb8ebd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee1ddf25e86286c16face31551751bda"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MPSolver.html#aee1ddf25e86286c16face31551751bda">KnapsackInterface</a></td></tr>
<tr class="separator:aee1ddf25e86286c16face31551751bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a7e2a34816b22749e70e23d26f49cf743"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e2a34816b22749e70e23d26f49cf743">&#9670;&nbsp;</a></span>BasisStatus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classoperations__research_1_1MPSolver.html#a7e2a34816b22749e70e23d26f49cf743">operations_research::MPSolver::BasisStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advanced usage: possible basis status values for a variable and the slack variable of a linear constraint. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a7e2a34816b22749e70e23d26f49cf743a642d0b5abe3faed060b4ec237df381a0"></a>FREE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7e2a34816b22749e70e23d26f49cf743a32b9b4f5f09a5dbdeed585318e8d97f2"></a>AT_LOWER_BOUND&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7e2a34816b22749e70e23d26f49cf743a578f080f1d30ca7ce7ba6c5b050ddd56"></a>AT_UPPER_BOUND&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7e2a34816b22749e70e23d26f49cf743aeca9b511e54f58239988d6affd62afa8"></a>FIXED_VALUE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a7e2a34816b22749e70e23d26f49cf743a0185d5946c48b9852d8a02a7493f4dcf"></a>BASIC&#160;</td><td class="fielddoc"></td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00612">612</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="a42c406c7e6fba381aa2bb41aae4b44f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42c406c7e6fba381aa2bb41aae4b44f2">&#9670;&nbsp;</a></span>OptimizationProblemType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classoperations__research_1_1MPSolver.html#a42c406c7e6fba381aa2bb41aae4b44f2">operations_research::MPSolver::OptimizationProblemType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of problems (LP or MIP) that will be solved and the underlying solver (GLOP, GLPK, CLP, CBC or SCIP) that will solve them. </p>
<p>This must remain consistent with MPModelRequest::OptimizationProblemType (take particular care of the open-source version). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a42c406c7e6fba381aa2bb41aae4b44f2a91bb43cabe6c49465bd7138189f3ea84"></a>CLP_LINEAR_PROGRAMMING&#160;</td><td class="fielddoc"><p>Linear Programming solver using Coin CBC. </p>
</td></tr>
<tr><td class="fieldname"><a id="a42c406c7e6fba381aa2bb41aae4b44f2a32049e26d1ea6f68624fc478b88d98c9"></a>GLOP_LINEAR_PROGRAMMING&#160;</td><td class="fielddoc"><p>Linear Programming solver using GLOP (Recommended solver). </p>
</td></tr>
<tr><td class="fieldname"><a id="a42c406c7e6fba381aa2bb41aae4b44f2a357b78ac84d42c93f2be55c89ed685dc"></a>SCIP_MIXED_INTEGER_PROGRAMMING&#160;</td><td class="fielddoc"><p>Mixed integer Programming Solver using SCIP. </p>
</td></tr>
<tr><td class="fieldname"><a id="a42c406c7e6fba381aa2bb41aae4b44f2a6f8b8f9d64ae299e8cfccf4917bf5282"></a>CBC_MIXED_INTEGER_PROGRAMMING&#160;</td><td class="fielddoc"><p>Mixed integer Programming Solver using Coin CBC. </p>
</td></tr>
<tr><td class="fieldname"><a id="a42c406c7e6fba381aa2bb41aae4b44f2aaef5b33a2d88606a978524ebc7b1cb7b"></a>BOP_INTEGER_PROGRAMMING&#160;</td><td class="fielddoc"><p>Linear Boolean Programming Solver. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00182">182</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="a16bca30fdb1b048d987631b757c63192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16bca30fdb1b048d987631b757c63192">&#9670;&nbsp;</a></span>ResultStatus</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classoperations__research_1_1MPSolver.html#a16bca30fdb1b048d987631b757c63192">operations_research::MPSolver::ResultStatus</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The status of solving the problem. </p>
<p>The straightforward translation to homonymous enum values of MPSolverResponseStatus (see ./linear_solver.proto) is guaranteed by ./enum_consistency_test.cc, you may rely on it. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a16bca30fdb1b048d987631b757c63192a7a765c1340de9cc37e22c68a2da7d390"></a>OPTIMAL&#160;</td><td class="fielddoc"><p>optimal. </p>
</td></tr>
<tr><td class="fieldname"><a id="a16bca30fdb1b048d987631b757c63192a5930d45ccc1bc78ad06bcd15cbca6a29"></a>FEASIBLE&#160;</td><td class="fielddoc"><p>feasible, or stopped by limit. </p>
</td></tr>
<tr><td class="fieldname"><a id="a16bca30fdb1b048d987631b757c63192a84e96d7264feeb2b6577400bc379d9db"></a>INFEASIBLE&#160;</td><td class="fielddoc"><p>proven infeasible. </p>
</td></tr>
<tr><td class="fieldname"><a id="a16bca30fdb1b048d987631b757c63192a88c7283cc752b51ed05c21c73f8fe100"></a>UNBOUNDED&#160;</td><td class="fielddoc"><p>proven unbounded. </p>
</td></tr>
<tr><td class="fieldname"><a id="a16bca30fdb1b048d987631b757c63192ae7c84444803ea46da465b68fb6e974fa"></a>ABNORMAL&#160;</td><td class="fielddoc"><p>abnormal, i.e., error of some kind. </p>
</td></tr>
<tr><td class="fieldname"><a id="a16bca30fdb1b048d987631b757c63192a0ce4e033c6bca973cb026780cdb7daa2"></a>MODEL_INVALID&#160;</td><td class="fielddoc"><p>the model is trivially invalid (NaN coefficients, etc). </p>
</td></tr>
<tr><td class="fieldname"><a id="a16bca30fdb1b048d987631b757c63192a5c14184aabfffdb489347ab0486c8492"></a>NOT_SOLVED&#160;</td><td class="fielddoc"><p>not been solved yet. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00399">399</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab6a8a6c57eefce8c07c8a52e053b035b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6a8a6c57eefce8c07c8a52e053b035b">&#9670;&nbsp;</a></span>MPSolver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">operations_research::MPSolver::MPSolver </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1MPSolver.html#a42c406c7e6fba381aa2bb41aae4b44f2">OptimizationProblemType</a>&#160;</td>
          <td class="paramname"><em>problem_type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a solver with the given name and underlying solver backend. </p>

</div>
</div>
<a id="aee7aedeeff79cd0645a5c7e8c0200834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee7aedeeff79cd0645a5c7e8c0200834">&#9670;&nbsp;</a></span>~MPSolver()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual operations_research::MPSolver::~MPSolver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a27312cbf1394d779305d016e2ea2753e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27312cbf1394d779305d016e2ea2753e">&#9670;&nbsp;</a></span>ClampSolutionWithinBounds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::Status operations_research::MPSolver::ClampSolutionWithinBounds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resets values of out of bound variables to the corresponding bound and returns an error if any of the variables have NaN value. </p>

</div>
</div>
<a id="a4fb5381d2f4a764660365168622e4955"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fb5381d2f4a764660365168622e4955">&#9670;&nbsp;</a></span>Clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::MPSolver::Clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clears the objective (including the optimization direction), all variables and constraints. </p>
<p>All the other properties of the <a class="el" href="classoperations__research_1_1MPSolver.html" title="This mathematical programming (MP) solver class is the main class though which users build and solve ...">MPSolver</a> (like the time limit) are kept untouched. </p>

</div>
</div>
<a id="ad07e28e347a4b2d94d53ca96ae201d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad07e28e347a4b2d94d53ca96ae201d70">&#9670;&nbsp;</a></span>ComputeConstraintActivities()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;double&gt; operations_research::MPSolver::ComputeConstraintActivities </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advanced usage: compute the "activities" of all constraints, which are the sums of their linear terms. </p>
<p>The activities are returned in the same order as <a class="el" href="classoperations__research_1_1MPSolver.html#aebc45909b1f377ab86295578ec417a17" title="Returns the array of constraints handled by the MPSolver.">constraints()</a>, which is the order in which constraints were added; but you can also use <a class="el" href="classoperations__research_1_1MPConstraint.html#abdf2c9c953fd4d118e7871a716445600" title="Returns the index of the constraint in the MPSolver::constraints_.">MPConstraint::index()</a> to get a constraint's index. </p>

</div>
</div>
<a id="a6390f93d9c4e88775d98ec8353ef0979"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6390f93d9c4e88775d98ec8353ef0979">&#9670;&nbsp;</a></span>ComputeExactConditionNumber()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::MPSolver::ComputeExactConditionNumber </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advanced usage: computes the exact condition number of the current scaled basis: L1norm(B) * L1norm(inverse(B)), where B is the scaled basis. </p>
<p>This method requires that a basis exists: it should be called after Solve. It is only available for continuous problems. It is implemented for GLPK but not CLP because CLP does not provide the API for doing it.</p>
<p>The condition number measures how well the constraint matrix is conditioned and can be used to predict whether numerical issues will arise during the solve: the model is declared infeasible whereas it is feasible (or vice-versa), the solution obtained is not optimal or violates some constraints, the resolution is slow because of repeated singularities.</p>
<p>The rule of thumb to interpret the condition number kappa is:</p><ul>
<li>o kappa &lt;= 1e7: virtually no chance of numerical issues</li>
<li>o 1e7 &lt; kappa &lt;= 1e10: small chance of numerical issues</li>
<li>o 1e10 &lt; kappa &lt;= 1e13: medium chance of numerical issues</li>
<li>o kappa &gt; 1e13: high chance of numerical issues</li>
</ul>
<p>The computation of the condition number depends on the quality of the LU decomposition, so it is not very accurate when the matrix is ill conditioned. </p>

</div>
</div>
<a id="aebc45909b1f377ab86295578ec417a17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebc45909b1f377ab86295578ec417a17">&#9670;&nbsp;</a></span>constraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classoperations__research_1_1MPConstraint.html">MPConstraint</a>*&gt;&amp; operations_research::MPSolver::constraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the array of constraints handled by the <a class="el" href="classoperations__research_1_1MPSolver.html" title="This mathematical programming (MP) solver class is the main class though which users build and solve ...">MPSolver</a>. </p>
<p>They are listed in the order in which they were created. </p>

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00340">340</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="a6a68e7fab8751978c9faa30867f91241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a68e7fab8751978c9faa30867f91241">&#9670;&nbsp;</a></span>DurationSinceConstruction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">absl::Duration operations_research::MPSolver::DurationSinceConstruction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00663">663</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="abc2c48c807107ccfdfa8c1b50ae16c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc2c48c807107ccfdfa8c1b50ae16c41">&#9670;&nbsp;</a></span>EnableOutput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::MPSolver::EnableOutput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a393a84863fe633baa3c7af4e71c8b147"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a393a84863fe633baa3c7af4e71c8b147">&#9670;&nbsp;</a></span>ExportModelAsLpFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::MPSolver::ExportModelAsLpFormat </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>obfuscate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>model_str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Shortcuts to the homonymous MPModelProtoExporter methods, via exporting to a <a class="el" href="classoperations__research_1_1MPModelProto.html">MPModelProto</a> with <a class="el" href="classoperations__research_1_1MPSolver.html#a9c8cc8b3c36fe9c08d8e0eefbc98b774" title="Exports model to protocol buffer.">ExportModelToProto()</a> (see above). </p>
<p>Produces empty std::string on portable platforms (e.g. android, ios). </p>

</div>
</div>
<a id="ae06ddd4e79e6a985b2644eff14747484"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae06ddd4e79e6a985b2644eff14747484">&#9670;&nbsp;</a></span>ExportModelAsMpsFormat()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::MPSolver::ExportModelAsMpsFormat </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fixed_format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>obfuscate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>model_str</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c8cc8b3c36fe9c08d8e0eefbc98b774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c8cc8b3c36fe9c08d8e0eefbc98b774">&#9670;&nbsp;</a></span>ExportModelToProto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::MPSolver::ExportModelToProto </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1MPModelProto.html">MPModelProto</a> *&#160;</td>
          <td class="paramname"><em>output_model</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Exports model to protocol buffer. </p>

</div>
</div>
<a id="a91c69a1b2e9098f3835b9fe1c4fead59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91c69a1b2e9098f3835b9fe1c4fead59">&#9670;&nbsp;</a></span>FillSolutionResponseProto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::MPSolver::FillSolutionResponseProto </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1MPSolutionResponse.html">MPSolutionResponse</a> *&#160;</td>
          <td class="paramname"><em>response</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encodes the current solution in a solution response protocol buffer. </p>

</div>
</div>
<a id="a88ddf26ba2c9524de319f6f307cfde60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88ddf26ba2c9524de319f6f307cfde60">&#9670;&nbsp;</a></span>GetNumThreads()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::MPSolver::GetNumThreads </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of threads to be used during solve. </p>

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00576">576</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="a64bc5e50054e619d3399956df3ed110f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64bc5e50054e619d3399956df3ed110f">&#9670;&nbsp;</a></span>GetSolverSpecificParametersAsString()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string operations_research::MPSolver::GetSolverSpecificParametersAsString </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00589">589</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="a5b15f7248e2b72d474bae0444a613033"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b15f7248e2b72d474bae0444a613033">&#9670;&nbsp;</a></span>infinity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double operations_research::MPSolver::infinity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Infinity. </p>
<p>You can use -<a class="el" href="classoperations__research_1_1MPSolver.html#a5b15f7248e2b72d474bae0444a613033" title="Infinity.">MPSolver::infinity()</a> for negative infinity. </p>

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00640">640</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="a4413905b5839d17823e756cff10d0ffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4413905b5839d17823e756cff10d0ffe">&#9670;&nbsp;</a></span>InterruptSolve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::MPSolver::InterruptSolve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interrupts the <a class="el" href="classoperations__research_1_1MPSolver.html#a1535b2a46d5cff6f9727c08085cfbb1f" title="Solves the problem using default parameter values.">Solve()</a> execution to terminate processing if possible. </p>
<p>If the underlying interface supports interruption; it does that and returns true regardless of whether there's an ongoing <a class="el" href="classoperations__research_1_1MPSolver.html#a1535b2a46d5cff6f9727c08085cfbb1f" title="Solves the problem using default parameter values.">Solve()</a> or not. The <a class="el" href="classoperations__research_1_1MPSolver.html#a1535b2a46d5cff6f9727c08085cfbb1f" title="Solves the problem using default parameter values.">Solve()</a> call may still linger for a while depending on the conditions. If interruption is not supported; returns false and does nothing. </p>

</div>
</div>
<a id="a24caaef373d3715d5bce9fb0da2c203d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24caaef373d3715d5bce9fb0da2c203d">&#9670;&nbsp;</a></span>IsMIP()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::MPSolver::IsMIP </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a15001c5a8f5c0086dddcc4626a5a5ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15001c5a8f5c0086dddcc4626a5a5ad7">&#9670;&nbsp;</a></span>iterations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64 operations_research::MPSolver::iterations </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of simplex iterations. </p>

</div>
</div>
<a id="af9eb46d78f04fa12da7ac27c14becb7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9eb46d78f04fa12da7ac27c14becb7d">&#9670;&nbsp;</a></span>LoadModelFromProto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceoperations__research.html#a8cc975b7db5017319901da0f63a114aa">MPSolverResponseStatus</a> operations_research::MPSolver::LoadModelFromProto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1MPModelProto.html">MPModelProto</a> &amp;&#160;</td>
          <td class="paramname"><em>input_model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>error_message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads model from protocol buffer. </p>
<p>Returns MPSOLVER_MODEL_IS_VALID if the model is valid, and another status otherwise (currently only MPSOLVER_MODEL_INVALID and MPSOLVER_INFEASIBLE). If the model isn't valid, populates "error_message". </p>

</div>
</div>
<a id="a51b5d57f310db13d800e4440ca3c0d0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51b5d57f310db13d800e4440ca3c0d0b">&#9670;&nbsp;</a></span>LoadModelFromProtoWithUniqueNamesOrDie()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceoperations__research.html#a8cc975b7db5017319901da0f63a114aa">MPSolverResponseStatus</a> operations_research::MPSolver::LoadModelFromProtoWithUniqueNamesOrDie </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1MPModelProto.html">MPModelProto</a> &amp;&#160;</td>
          <td class="paramname"><em>input_model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string *&#160;</td>
          <td class="paramname"><em>error_message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Loads model from protocol buffer. </p>
<p>The same as above, except that the loading keeps original variable and constraint names. Caller should make sure that all variable names and constraint names are unique, respectively. </p>

</div>
</div>
<a id="aa20b60665bd7e137dac446b2b1400838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa20b60665bd7e137dac446b2b1400838">&#9670;&nbsp;</a></span>LoadSolutionFromProto()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::Status operations_research::MPSolver::LoadSolutionFromProto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1MPSolutionResponse.html">MPSolutionResponse</a> &amp;&#160;</td>
          <td class="paramname"><em>response</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em> = <code><a class="el" href="namespaceoperations__research.html#a07189276cc680928dad51ed197142077">kDefaultPrimalTolerance</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a solution encoded in a protocol buffer onto this solver for easy access via the <a class="el" href="classoperations__research_1_1MPSolver.html" title="This mathematical programming (MP) solver class is the main class though which users build and solve ...">MPSolver</a> interface. </p>
<p>IMPORTANT: This may only be used in conjunction with ExportModel(), following this example:</p>
<div class="fragment"><div class="line"><a class="code" href="classoperations__research_1_1MPSolver.html#ab6a8a6c57eefce8c07c8a52e053b035b">MPSolver</a> my_solver;</div><div class="line">... add <a class="code" href="classoperations__research_1_1MPSolver.html#a1593ede4c9cd1da430f606127dc9a642">variables</a> and <a class="code" href="classoperations__research_1_1MPSolver.html#aebc45909b1f377ab86295578ec417a17">constraints</a> ...</div><div class="line">MPModelProto model_proto;</div><div class="line">my_solver.ExportModelToProto(&amp;model_proto);</div><div class="line">MPSolutionResponse solver_response;</div><div class="line"><a class="code" href="classoperations__research_1_1MPSolver.html#a3aaa8bdb57173a9d933ed5f62bb60f42">MPSolver::SolveWithProto</a>(model_proto, &amp;solver_response);</div><div class="line"><span class="keywordflow">if</span> (solver_response.result_status() == MPSolutionResponse::OPTIMAL) {</div><div class="line">  CHECK_OK(my_solver.LoadSolutionFromProto(solver_response));</div><div class="line">  ... inspect the solution <span class="keyword">using</span> the usual API: solution_value(), etc...</div><div class="line">}</div></div><!-- fragment --><p>The response must be in OPTIMAL or FEASIBLE status.</p>
<p>Returns a non-OK status if a problem arised (typically, if it wasn't used like it should be):</p><ul>
<li>loading a solution whose variables don't correspond to the solver's current variables</li>
<li>loading a solution with a status other than OPTIMAL / FEASIBLE.</li>
</ul>
<p>Note: the objective value isn't checked. You can use <a class="el" href="classoperations__research_1_1MPSolver.html#a2a4a0234b5830d4ea82d549b3b6b5baf" title="Advanced usage: Verifies the correctness of the solution.">VerifySolution()</a> for that. </p>

</div>
</div>
<a id="a299502e4b0e4e6608330fdbe4fb86c94"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a299502e4b0e4e6608330fdbe4fb86c94">&#9670;&nbsp;</a></span>LookupConstraintOrNull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1MPConstraint.html">MPConstraint</a>* operations_research::MPSolver::LookupConstraintOrNull </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>constraint_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks up a constraint by name, and returns nullptr if it does not exist. </p>
<p>The first call has a O(n) complexity, as the constraint name index is lazily created upon first use. Will crash if constraint names are not unique. </p>

</div>
</div>
<a id="ae384aa3d9095f883a93f5e2e830e0077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae384aa3d9095f883a93f5e2e830e0077">&#9670;&nbsp;</a></span>LookupVariableOrNull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a>* operations_research::MPSolver::LookupVariableOrNull </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>var_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Looks up a variable by name, and returns nullptr if it does not exist. </p>
<p>The first call has a O(n) complexity, as the variable name index is lazily created upon first use. Will crash if variable names are not unique. </p>

</div>
</div>
<a id="a7176be8ce0481d880a8d30a2d7a1c09e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7176be8ce0481d880a8d30a2d7a1c09e">&#9670;&nbsp;</a></span>MakeBoolVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a>* operations_research::MPSolver::MakeBoolVar </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a boolean variable. </p>

</div>
</div>
<a id="af5c55776ce47479f8904480cd815a6d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5c55776ce47479f8904480cd815a6d5">&#9670;&nbsp;</a></span>MakeBoolVarArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::MPSolver::MakeBoolVarArray </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a> * &gt; *&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an array of boolean variables. </p>

</div>
</div>
<a id="acf84ccc5151ce164a571d2f31f30960c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf84ccc5151ce164a571d2f31f30960c">&#9670;&nbsp;</a></span>MakeIntVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a>* operations_research::MPSolver::MakeIntVar </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an integer variable. </p>

</div>
</div>
<a id="a5eefc88942fd284ff2962564224d5f8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eefc88942fd284ff2962564224d5f8e">&#9670;&nbsp;</a></span>MakeIntVarArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::MPSolver::MakeIntVarArray </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a> * &gt; *&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an array of integer variables. </p>

</div>
</div>
<a id="a54d66e99fdc2424e812d910e7c2f225a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54d66e99fdc2424e812d910e7c2f225a">&#9670;&nbsp;</a></span>MakeNumVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a>* operations_research::MPSolver::MakeNumVar </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a continuous variable. </p>

</div>
</div>
<a id="a7aebea4f022e7a685322e7db70b76e5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aebea4f022e7a685322e7db70b76e5e">&#9670;&nbsp;</a></span>MakeNumVarArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::MPSolver::MakeNumVarArray </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a> * &gt; *&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an array of continuous variables. </p>

</div>
</div>
<a id="a9afcc9a30bf7c360066d7936c121acd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9afcc9a30bf7c360066d7936c121acd0">&#9670;&nbsp;</a></span>MakeRowConstraint() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1MPConstraint.html">MPConstraint</a>* operations_research::MPSolver::MakeRowConstraint </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a linear constraint with given bounds. </p>
<p>Bounds can be finite or +/- <a class="el" href="classoperations__research_1_1MPSolver.html#a5b15f7248e2b72d474bae0444a613033" title="Infinity.">MPSolver::infinity()</a>. The <a class="el" href="classoperations__research_1_1MPSolver.html" title="This mathematical programming (MP) solver class is the main class though which users build and solve ...">MPSolver</a> class assumes ownership of the constraint.</p>
<dl class="section return"><dt>Returns</dt><dd>a pointer to the newly created constraint. </dd></dl>

</div>
</div>
<a id="a9ef93893d198901ce104d74794dde123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ef93893d198901ce104d74794dde123">&#9670;&nbsp;</a></span>MakeRowConstraint() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1MPConstraint.html">MPConstraint</a>* operations_research::MPSolver::MakeRowConstraint </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a constraint with -infinity and +infinity bounds. </p>

</div>
</div>
<a id="ac7dc5e8edf7f3a96c2faadc738d52c41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7dc5e8edf7f3a96c2faadc738d52c41">&#9670;&nbsp;</a></span>MakeRowConstraint() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1MPConstraint.html">MPConstraint</a>* operations_research::MPSolver::MakeRowConstraint </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a named constraint with given bounds. </p>

</div>
</div>
<a id="abad1058684a6996ba3035c0011b4cc41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abad1058684a6996ba3035c0011b4cc41">&#9670;&nbsp;</a></span>MakeRowConstraint() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1MPConstraint.html">MPConstraint</a>* operations_research::MPSolver::MakeRowConstraint </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a named constraint with -infinity and +infinity bounds. </p>

</div>
</div>
<a id="ae31ac8b47142ee8685a39a608a9190d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae31ac8b47142ee8685a39a608a9190d1">&#9670;&nbsp;</a></span>MakeRowConstraint() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1MPConstraint.html">MPConstraint</a>* operations_research::MPSolver::MakeRowConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1LinearRange.html">LinearRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a constraint owned by <a class="el" href="classoperations__research_1_1MPSolver.html" title="This mathematical programming (MP) solver class is the main class though which users build and solve ...">MPSolver</a> enforcing: range.lower_bound() &lt;= range.linear_expr() &lt;= range.upper_bound() </p>

</div>
</div>
<a id="a4c54bb9041abac99c35b92dc5386b7a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c54bb9041abac99c35b92dc5386b7a7">&#9670;&nbsp;</a></span>MakeRowConstraint() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1MPConstraint.html">MPConstraint</a>* operations_research::MPSolver::MakeRowConstraint </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1LinearRange.html">LinearRange</a> &amp;&#160;</td>
          <td class="paramname"><em>range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>As above, but also names the constraint. </p>

</div>
</div>
<a id="ad6bb7605c749ba485b040b02a37f6728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6bb7605c749ba485b040b02a37f6728">&#9670;&nbsp;</a></span>MakeVar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a>* operations_research::MPSolver::MakeVar </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>integer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a variable with the given bounds, integrality requirement and name. </p>
<p>Bounds can be finite or +/- <a class="el" href="classoperations__research_1_1MPSolver.html#a5b15f7248e2b72d474bae0444a613033" title="Infinity.">MPSolver::infinity()</a>. The <a class="el" href="classoperations__research_1_1MPSolver.html" title="This mathematical programming (MP) solver class is the main class though which users build and solve ...">MPSolver</a> owns the variable (i.e. the returned pointer is borrowed). Variable names are optional. If you give an empty name, name() will auto-generate one for you upon request. </p>

</div>
</div>
<a id="a2c58f52acd6216131582c60aae3625ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c58f52acd6216131582c60aae3625ee">&#9670;&nbsp;</a></span>MakeVarArray()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::MPSolver::MakeVarArray </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>integer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name_prefix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a> * &gt; *&#160;</td>
          <td class="paramname"><em>vars</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates an array of variables. </p>
<p>All variables created have the same bounds and integrality requirement. If nb &lt;= 0, no variables are created, the function crashes in non-opt mode.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">nb</td><td>the number of variables to create. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">lb</td><td>the lower bound of created variables </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">ub</td><td>the upper bound of created variables </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">integer</td><td>controls whether the created variables are continuous or integral. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">name_prefix</td><td>the prefix of the variable names. Variables are named name_prefix0, name_prefix1, ... </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">vars</td><td>the vector of variables to fill with variables. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a467f89af3bae743dc9d628ee4e74f0c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a467f89af3bae743dc9d628ee4e74f0c9">&#9670;&nbsp;</a></span>MutableObjective()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1MPObjective.html">MPObjective</a>* operations_research::MPSolver::MutableObjective </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the mutable objective object. </p>

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00391">391</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="a1d6101b365c33fb1f73a4c953abeb0ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d6101b365c33fb1f73a4c953abeb0ed">&#9670;&nbsp;</a></span>Name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::string&amp; operations_research::MPSolver::Name </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the name of the model set at construction. </p>

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00251">251</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="a4b11747bf657bf074d1e710121810d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b11747bf657bf074d1e710121810d13">&#9670;&nbsp;</a></span>NextSolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ABSL_MUST_USE_RESULT bool operations_research::MPSolver::NextSolution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Some solvers (MIP only, not LP) can produce multiple solutions to the problem. </p>
<p>Returns true when another solution is available, and updates the MPVariable* objects to make the new solution queryable. Call only after calling solve.</p>
<p>The optimality properties of the additional solutions found, and whether or not the solver computes them ahead of time or when <a class="el" href="classoperations__research_1_1MPSolver.html#a4b11747bf657bf074d1e710121810d13" title="Some solvers (MIP only, not LP) can produce multiple solutions to the problem.">NextSolution()</a> is called is solver specific.</p>
<p>As of 2018-08-09, only Gurobi supports <a class="el" href="classoperations__research_1_1MPSolver.html#a4b11747bf657bf074d1e710121810d13" title="Some solvers (MIP only, not LP) can produce multiple solutions to the problem.">NextSolution()</a>, see linear_solver_underlying_gurobi_test for an example of how to configure Gurobi for this purpose. The other solvers return false unconditionally. </p>

</div>
</div>
<a id="a6837e7545ac2c5cfe95ca9a1c0f013e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6837e7545ac2c5cfe95ca9a1c0f013e3">&#9670;&nbsp;</a></span>nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64 operations_research::MPSolver::nodes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of branch-and-bound nodes evaluated during the solve. </p>
<p>Only available for discrete problems. </p>

</div>
</div>
<a id="a16a3cee848c033e365ebb1cf50bb97cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a3cee848c033e365ebb1cf50bb97cd">&#9670;&nbsp;</a></span>NumConstraints()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::MPSolver::NumConstraints </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of constraints. </p>

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00333">333</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="a0ba0685c817d5c5910c80492dd1a7050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ba0685c817d5c5910c80492dd1a7050">&#9670;&nbsp;</a></span>NumVariables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int operations_research::MPSolver::NumVariables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of variables. </p>

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00268">268</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="a4834a6747544a7053110a0b20d79dac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4834a6747544a7053110a0b20d79dac2">&#9670;&nbsp;</a></span>Objective()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classoperations__research_1_1MPObjective.html">MPObjective</a>&amp; operations_research::MPSolver::Objective </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the objective object. </p>
<p>Note that the objective is owned by the solver, and is initialized to its default value (see the <a class="el" href="classoperations__research_1_1MPObjective.html" title="A class to express a linear objective.">MPObjective</a> class below) at construction. </p>

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00388">388</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="aa90a00b370b9abc4a43bfefd7f6a895b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa90a00b370b9abc4a43bfefd7f6a895b">&#9670;&nbsp;</a></span>OutputIsEnabled()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::MPSolver::OutputIsEnabled </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Controls (or queries) the amount of output produced by the underlying solver. </p>
<p>The output can surface to LOGs, or to stdout or stderr, depending on the implementation. The amount of output will greatly vary with each implementation and each problem.</p>
<p>Output is suppressed by default. </p>

</div>
</div>
<a id="a78606aaae8d97a0def488e696fdb2d2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78606aaae8d97a0def488e696fdb2d2b">&#9670;&nbsp;</a></span>OwnsVariable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::MPSolver::OwnsVariable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a> *&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a650dd472cb06be9f9abcf5bc0833437d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a650dd472cb06be9f9abcf5bc0833437d">&#9670;&nbsp;</a></span>ParseSolverType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool operations_research::MPSolver::ParseSolverType </td>
          <td>(</td>
          <td class="paramtype">absl::string_view&#160;</td>
          <td class="paramname"><em>solver</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1MPSolver.html#a42c406c7e6fba381aa2bb41aae4b44f2">OptimizationProblemType</a> *&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parses the name of the solver. </p>
<p>Returns true if the solver type is successfully parsed as one of the OptimizationProblemType. </p>

</div>
</div>
<a id="a54e8b352edd37540f788c3fc473fa875"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54e8b352edd37540f788c3fc473fa875">&#9670;&nbsp;</a></span>ProblemType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classoperations__research_1_1MPSolver.html#a42c406c7e6fba381aa2bb41aae4b44f2">OptimizationProblemType</a> operations_research::MPSolver::ProblemType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the optimization problem type set at construction. </p>

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00256">256</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="a0bade4bbf46f4e35513650d38a0a3208"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bade4bbf46f4e35513650d38a0a3208">&#9670;&nbsp;</a></span>Reset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::MPSolver::Reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advanced usage: resets extracted model to solve from scratch. </p>
<p>This won't reset the parameters that were set with <a class="el" href="classoperations__research_1_1MPSolver.html#a532d2fb86e5cdc4710e1a168acbbe7f6" title="Advanced usage: pass solver specific parameters in text format.">SetSolverSpecificParametersAsString()</a> or <a class="el" href="classoperations__research_1_1MPSolver.html#ae99e29fcc045ab27c8fecbdc422e6133">set_time_limit()</a> or even clear the linear program. It will just make sure that next <a class="el" href="classoperations__research_1_1MPSolver.html#a1535b2a46d5cff6f9727c08085cfbb1f" title="Solves the problem using default parameter values.">Solve()</a> will be as if everything was reconstructed from scratch. </p>

</div>
</div>
<a id="ae99e29fcc045ab27c8fecbdc422e6133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae99e29fcc045ab27c8fecbdc422e6133">&#9670;&nbsp;</a></span>set_time_limit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::MPSolver::set_time_limit </td>
          <td>(</td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>time_limit_milliseconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00744">744</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="abf4255929ea45766c51cf6138758b277"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4255929ea45766c51cf6138758b277">&#9670;&nbsp;</a></span>SetHint()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::MPSolver::SetHint </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::pair&lt; const <a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a> *, double &gt; &gt;&#160;</td>
          <td class="paramname"><em>hint</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a hint for solution. </p>
<p>If a feasible or almost-feasible solution to the problem is already known, it may be helpful to pass it to the solver so that it can be used. A solver that supports this feature will try to use this information to create its initial feasible solution.</p>
<p>Note: It may not always be faster to give a hint like this to the solver. There is also no guarantee that the solver will use this hint or try to return a solution "close" to this assignment in case of multiple optimal solutions. </p>

</div>
</div>
<a id="a6394f5b0c08af038bfd9610d2bc4be90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6394f5b0c08af038bfd9610d2bc4be90">&#9670;&nbsp;</a></span>SetNumThreads()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::Status operations_research::MPSolver::SetNumThreads </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_threads</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the number of threads to use by the underlying solver. </p>
<p>Returns OkStatus if the operation was successful. num_threads must be equal to or greater than 1. Note that the behaviour of this call depends on the underlying solver. E.g., it may set the exact number of threads or the max number of threads (check the solver's interface implementation for details). Also, some solvers may not (yet) support this function, but still enable multi-threading via <a class="el" href="classoperations__research_1_1MPSolver.html#a532d2fb86e5cdc4710e1a168acbbe7f6" title="Advanced usage: pass solver specific parameters in text format.">SetSolverSpecificParametersAsString()</a>. </p>

</div>
</div>
<a id="a532d2fb86e5cdc4710e1a168acbbe7f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a532d2fb86e5cdc4710e1a168acbbe7f6">&#9670;&nbsp;</a></span>SetSolverSpecificParametersAsString()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::MPSolver::SetSolverSpecificParametersAsString </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>parameters</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advanced usage: pass solver specific parameters in text format. </p>
<p>The format is solver-specific and is the same as the corresponding solver configuration file format. Returns true if the operation was successful.</p>
<p>TODO(user): Currently SCIP will always return true even if the format is wrong (you can check the log if you suspect an issue there). This seems to be a bug in SCIP though. </p>

</div>
</div>
<a id="a11a76240b36c39f04ff64104c482990f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11a76240b36c39f04ff64104c482990f">&#9670;&nbsp;</a></span>SetStartingLpBasis()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::MPSolver::SetStartingLpBasis </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classoperations__research_1_1MPSolver.html#a7e2a34816b22749e70e23d26f49cf743">MPSolver::BasisStatus</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>variable_statuses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classoperations__research_1_1MPSolver.html#a7e2a34816b22749e70e23d26f49cf743">MPSolver::BasisStatus</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>constraint_statuses</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advanced usage: Incrementality. </p>
<p>This function takes a starting basis to be used in the next LP <a class="el" href="classoperations__research_1_1MPSolver.html#a1535b2a46d5cff6f9727c08085cfbb1f" title="Solves the problem using default parameter values.">Solve()</a> call. The statuses of a current solution can be retrieved via the basis_status() function of a <a class="el" href="classoperations__research_1_1MPVariable.html" title="The class for variables of a Mathematical Programming (MP) model.">MPVariable</a> or a <a class="el" href="classoperations__research_1_1MPConstraint.html" title="The class for constraints of a Mathematical Programming (MP) model.">MPConstraint</a>.</p>
<p>WARNING: With Glop, you should disable presolve when using this because this information will not be modified in sync with the presolve and will likely not mean much on the presolved problem. </p>

</div>
</div>
<a id="a47a5516ca826adbc25bd5bf1d7935fd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47a5516ca826adbc25bd5bf1d7935fd1">&#9670;&nbsp;</a></span>SetTimeLimit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::MPSolver::SetTimeLimit </td>
          <td>(</td>
          <td class="paramtype">absl::Duration&#160;</td>
          <td class="paramname"><em>time_limit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00658">658</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="a1535b2a46d5cff6f9727c08085cfbb1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1535b2a46d5cff6f9727c08085cfbb1f">&#9670;&nbsp;</a></span>Solve() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1MPSolver.html#a16bca30fdb1b048d987631b757c63192">ResultStatus</a> operations_research::MPSolver::Solve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the problem using default parameter values. </p>

</div>
</div>
<a id="acfe9e4c330b12131b53d72f41506ddaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe9e4c330b12131b53d72f41506ddaf">&#9670;&nbsp;</a></span>Solve() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1MPSolver.html#a16bca30fdb1b048d987631b757c63192">ResultStatus</a> operations_research::MPSolver::Solve </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1MPSolverParameters.html">MPSolverParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>param</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solves the problem using the specified parameter values. </p>

</div>
</div>
<a id="aee22680c23e591329e9ac50ff78f572d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee22680c23e591329e9ac50ff78f572d">&#9670;&nbsp;</a></span>SolverVersion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string operations_research::MPSolver::SolverVersion </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a std::string describing the underlying solver and its version. </p>

</div>
</div>
<a id="a3aaa8bdb57173a9d933ed5f62bb60f42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aaa8bdb57173a9d933ed5f62bb60f42">&#9670;&nbsp;</a></span>SolveWithProto()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void operations_research::MPSolver::SolveWithProto </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classoperations__research_1_1MPModelRequest.html">MPModelRequest</a> &amp;&#160;</td>
          <td class="paramname"><em>model_request</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1MPSolutionResponse.html">MPSolutionResponse</a> *&#160;</td>
          <td class="paramname"><em>response</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solves the model encoded by a <a class="el" href="classoperations__research_1_1MPModelRequest.html">MPModelRequest</a> protocol buffer and fills the solution encoded as a <a class="el" href="classoperations__research_1_1MPSolutionResponse.html">MPSolutionResponse</a>. </p>
<p>Note(user): This creates a temporary <a class="el" href="classoperations__research_1_1MPSolver.html" title="This mathematical programming (MP) solver class is the main class though which users build and solve ...">MPSolver</a> and destroys it at the end. If you want to keep the <a class="el" href="classoperations__research_1_1MPSolver.html" title="This mathematical programming (MP) solver class is the main class though which users build and solve ...">MPSolver</a> alive (for debugging, or for incremental solving), you should write another version of this function that creates the <a class="el" href="classoperations__research_1_1MPSolver.html" title="This mathematical programming (MP) solver class is the main class though which users build and solve ...">MPSolver</a> object on the heap and returns it. </p>

</div>
</div>
<a id="ae96df0f02a46493eba93d2e70709911a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae96df0f02a46493eba93d2e70709911a">&#9670;&nbsp;</a></span>SupportsProblemType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool operations_research::MPSolver::SupportsProblemType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classoperations__research_1_1MPSolver.html#a42c406c7e6fba381aa2bb41aae4b44f2">OptimizationProblemType</a>&#160;</td>
          <td class="paramname"><em>problem_type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the given problem type is supported (this will depend on the targets that you linked). </p>

</div>
</div>
<a id="abfaa014d3c3ca883e3c8a17110372801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfaa014d3c3ca883e3c8a17110372801">&#9670;&nbsp;</a></span>SuppressOutput()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::MPSolver::SuppressOutput </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Suppress output. </p>

</div>
</div>
<a id="a258c821fae2869693b58440145125aba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a258c821fae2869693b58440145125aba">&#9670;&nbsp;</a></span>time_limit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64 operations_research::MPSolver::time_limit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00739">739</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="a0177cee53f52d09df990920d532b0772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0177cee53f52d09df990920d532b0772">&#9670;&nbsp;</a></span>time_limit_in_secs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double operations_research::MPSolver::time_limit_in_secs </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00749">749</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="aae2fbd44c86451dadfc256f000772394"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae2fbd44c86451dadfc256f000772394">&#9670;&nbsp;</a></span>TimeLimit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">absl::Duration operations_research::MPSolver::TimeLimit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00657">657</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="a3d3bc5e39b383336fb3ca88b1a0c6cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d3bc5e39b383336fb3ca88b1a0c6cc5">&#9670;&nbsp;</a></span>underlying_solver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* operations_research::MPSolver::underlying_solver </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advanced usage: returns the underlying solver. </p>
<p>Returns the underlying solver so that the user can use solver-specific features or features that are not exposed in the simple API of <a class="el" href="classoperations__research_1_1MPSolver.html" title="This mathematical programming (MP) solver class is the main class though which users build and solve ...">MPSolver</a>. This method is for advanced users, use at your own risk! In particular, if you modify the model or the solution by accessing the underlying solver directly, then the underlying solver will be out of sync with the information kept in the wrapper (<a class="el" href="classoperations__research_1_1MPSolver.html" title="This mathematical programming (MP) solver class is the main class though which users build and solve ...">MPSolver</a>, <a class="el" href="classoperations__research_1_1MPVariable.html" title="The class for variables of a Mathematical Programming (MP) model.">MPVariable</a>, <a class="el" href="classoperations__research_1_1MPConstraint.html" title="The class for constraints of a Mathematical Programming (MP) model.">MPConstraint</a>, <a class="el" href="classoperations__research_1_1MPObjective.html" title="A class to express a linear objective.">MPObjective</a>). You need to cast the void* returned back to its original type that depends on the interface (CBC: OsiClpSolverInterface*, CLP: ClpSimplex*, GLPK: glp_prob*, SCIP: SCIP*). </p>

</div>
</div>
<a id="a1593ede4c9cd1da430f606127dc9a642"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1593ede4c9cd1da430f606127dc9a642">&#9670;&nbsp;</a></span>variables()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::vector&lt;<a class="el" href="classoperations__research_1_1MPVariable.html">MPVariable</a>*&gt;&amp; operations_research::MPSolver::variables </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the array of variables handled by the <a class="el" href="classoperations__research_1_1MPSolver.html" title="This mathematical programming (MP) solver class is the main class though which users build and solve ...">MPSolver</a>. </p>
<p>(They are listed in the order in which they were created.) </p>

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00274">274</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="a2a4a0234b5830d4ea82d549b3b6b5baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a4a0234b5830d4ea82d549b3b6b5baf">&#9670;&nbsp;</a></span>VerifySolution()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::MPSolver::VerifySolution </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>log_errors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Advanced usage: Verifies the <em>correctness</em> of the solution. </p>
<p>It verifies that all variables must be within their domains, all constraints must be satisfied, and the reported objective value must be accurate.</p>
<p>Usage:</p><ul>
<li>This can only be called after <a class="el" href="classoperations__research_1_1MPSolver.html#a1535b2a46d5cff6f9727c08085cfbb1f" title="Solves the problem using default parameter values.">Solve()</a> was called.</li>
<li>"tolerance" is interpreted as an absolute error threshold.</li>
<li>For the objective value only, if the absolute error is too large, the tolerance is interpreted as a relative error threshold instead.</li>
<li>If "log_errors" is true, every single violation will be logged.</li>
<li>If "tolerance" is negative, it will be set to <a class="el" href="classoperations__research_1_1MPSolver.html#a5b15f7248e2b72d474bae0444a613033" title="Infinity.">infinity()</a>.</li>
</ul>
<p>Most users should just set the &ndash;verify_solution flag and not bother using this method directly. </p>

</div>
</div>
<a id="a1ce69ce989942416f35a7d3577b5edd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ce69ce989942416f35a7d3577b5edd8">&#9670;&nbsp;</a></span>wall_time()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64 operations_research::MPSolver::wall_time </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00754">754</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="ad40ba327269cfff827f23ac4d94414d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad40ba327269cfff827f23ac4d94414d9">&#9670;&nbsp;</a></span>Write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::MPSolver::Write </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes the model using the solver internal write function. </p>
<p>Currently only available for Gurobi. </p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a7383308e6b9b63b18196798db342ce8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7383308e6b9b63b18196798db342ce8a">&#9670;&nbsp;</a></span>BopInterface</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class BopInterface</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00767">767</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="af5a7cf0c655f37c0b388a2ddcf32ac3e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a7cf0c655f37c0b388a2ddcf32ac3e">&#9670;&nbsp;</a></span>CBCInterface</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class CBCInterface</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00760">760</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="a60944ecdcad88cfb4d4d32feea70c9b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60944ecdcad88cfb4d4d32feea70c9b5">&#9670;&nbsp;</a></span>CLPInterface</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class CLPInterface</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00759">759</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="ae7cbd08108e1636184f28c1a71c42393"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7cbd08108e1636184f28c1a71c42393">&#9670;&nbsp;</a></span>CplexInterface</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class CplexInterface</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00763">763</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="a6c754b527a347994b06eeb49a09ac222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c754b527a347994b06eeb49a09ac222">&#9670;&nbsp;</a></span>GLOPInterface</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class GLOPInterface</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00766">766</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="ae1a3e0a695903c8e6effd524a7f92784"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a3e0a695903c8e6effd524a7f92784">&#9670;&nbsp;</a></span>GLPKInterface</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class GLPKInterface</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00758">758</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="ac28a56eeedb62d070578a9231f1875ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac28a56eeedb62d070578a9231f1875ea">&#9670;&nbsp;</a></span>GurobiInterface</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class GurobiInterface</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00762">762</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="aee1ddf25e86286c16face31551751bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee1ddf25e86286c16face31551751bda">&#9670;&nbsp;</a></span>KnapsackInterface</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class KnapsackInterface</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00769">769</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="ac0aea0786e75adbb2d24c41c15e7456c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0aea0786e75adbb2d24c41c15e7456c">&#9670;&nbsp;</a></span>MPSolverInterface</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classoperations__research_1_1MPSolverInterface.html">MPSolverInterface</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00765">765</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="acbd4413b1370baca9c45aecb0cb8ebd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd4413b1370baca9c45aecb0cb8ebd2">&#9670;&nbsp;</a></span>SatInterface</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class SatInterface</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00768">768</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="a236f9752f4df4c5134617330a040ec8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a236f9752f4df4c5134617330a040ec8a">&#9670;&nbsp;</a></span>SCIPInterface</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class SCIPInterface</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00761">761</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<a id="a5c083b37243075a00bf909840dc7c933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c083b37243075a00bf909840dc7c933">&#9670;&nbsp;</a></span>SLMInterface</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class SLMInterface</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="linear__solver_8h_source.html#l00764">764</a> of file <a class="el" href="linear__solver_8h_source.html">linear_solver.h</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="linear__solver_8h_source.html">linear_solver.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
        </div>
        <div id="footer-container">
            <div id="footer">
            </div>
        </div>
    </body>
</html>
