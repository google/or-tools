<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="pdoc 8.0.0" />
    <title>pywrapcp API documentation</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2264%22%20height%3D%2264%22%20viewBox%3D%2244.5%202.5%2015%2015%22%3E%3Cpath%20d%3D%22M49.351%2021.041c-.233-.721-.546-2.408-.772-4.076-.042-.09-.067-.187-.046-.288-.166-1.347-.277-2.625-.241-3.351-1.378-1.008-2.271-2.586-2.271-4.362%200-.976.272-1.935.788-2.774.057-.094.122-.18.184-.268-.033-.167-.052-.339-.052-.516%200-1.477%201.202-2.679%202.679-2.679.791%200%201.496.352%201.987.9a6.3%206.3%200%200%201%201.001.029c.492-.564%201.207-.929%202.012-.929%201.477%200%202.679%201.202%202.679%202.679a2.65%202.65%200%200%201-.269%201.148c.383.747.595%201.572.595%202.41%200%202.311-1.507%204.29-3.635%205.107.037.699.147%202.27.423%203.294l.137.461c.156%202.136-4.612%205.166-5.199%203.215zm.127-4.919a4.78%204.78%200%200%200%20.775-.584c-.172-.115-.505-.254-.88-.378zm.331%202.302l.828-.502c-.202-.143-.576-.328-.984-.49zm.45%202.157l.701-.403c-.214-.115-.536-.249-.891-.376l.19.779zM49.13%204.141c0%20.152.123.276.276.276s.275-.124.275-.276-.123-.276-.276-.276-.275.124-.275.276zm.735-.389a1.15%201.15%200%200%201%20.314.783%201.16%201.16%200%200%201-1.162%201.162c-.457%200-.842-.27-1.032-.653-.026.117-.042.238-.042.362a1.68%201.68%200%200%200%201.679%201.679%201.68%201.68%200%200%200%201.679-1.679c0-.843-.626-1.535-1.436-1.654zm3.076%201.654a1.68%201.68%200%200%200%201.679%201.679%201.68%201.68%200%200%200%201.679-1.679c0-.037-.009-.072-.011-.109-.21.3-.541.508-.935.508a1.16%201.16%200%200%201-1.162-1.162%201.14%201.14%200%200%201%20.474-.912c-.015%200-.03-.005-.045-.005-.926.001-1.679.754-1.679%201.68zm1.861-1.265c0%20.152.123.276.276.276s.275-.124.275-.276-.123-.276-.276-.276-.275.124-.275.276zm1.823%204.823c0-.52-.103-1.035-.288-1.52-.466.394-1.06.64-1.717.64-1.144%200-2.116-.725-2.499-1.738-.383%201.012-1.355%201.738-2.499%201.738-.867%200-1.631-.421-2.121-1.062-.307.605-.478%201.267-.478%201.942%200%202.486%202.153%204.51%204.801%204.51s4.801-2.023%204.801-4.51zm-3.032%209.156l-.146-.492c-.276-1.02-.395-2.457-.444-3.268a6.11%206.11%200%200%201-1.18.115%206.01%206.01%200%200%201-2.536-.562l.006.175c.802.215%201.848.612%202.021%201.25.079.295-.021.601-.274.837l-.598.501c.667.304%201.243.698%201.311%201.179.02.144.022.507-.393.787l-.564.365c1.285.521%201.361.96%201.381%201.126.018.142.011.496-.427.746l-.854.489c.064-1.19%201.985-2.585%202.697-3.248zM49.34%209.925c0-.667%201-.667%201%200%200%20.653.818%201.205%201.787%201.205s1.787-.552%201.787-1.205c0-.667%201-.667%201%200%200%201.216-1.25%202.205-2.787%202.205s-2.787-.989-2.787-2.205zm-.887-7.633c-.093.077-.205.114-.317.114a.5.5%200%200%201-.318-.886L49.183.397a.5.5%200%200%201%20.703.068.5.5%200%200%201-.069.703zm7.661-.065c-.086%200-.173-.022-.253-.068l-1.523-.893c-.575-.337-.069-1.2.506-.863l1.523.892a.5.5%200%200%201%20.179.685c-.094.158-.261.247-.432.247z%22%20fill%3D%22%233bb300%22/%3E%3C/svg%3E"/>


<style>/*! * Bootstrap Reboot v5.0.0 (https://getbootstrap.com/) * Copyright 2011-2021 The Bootstrap Authors * Copyright 2011-2021 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md) */*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;background-color:#fff;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}hr{margin:1rem 0;color:inherit;background-color:currentColor;border:0;opacity:.25}hr:not([size]){height:1px}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem;font-weight:500;line-height:1.2}h1{font-size:calc(1.375rem + 1.5vw)}@media (min-width:1200px){h1{font-size:2.5rem}}h2{font-size:calc(1.325rem + .9vw)}@media (min-width:1200px){h2{font-size:2rem}}h3{font-size:calc(1.3rem + .6vw)}@media (min-width:1200px){h3{font-size:1.75rem}}h4{font-size:calc(1.275rem + .3vw)}@media (min-width:1200px){h4{font-size:1.5rem}}h5{font-size:1.25rem}h6{font-size:1rem}p{margin-top:0;margin-bottom:1rem}abbr[data-bs-original-title],abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;-webkit-text-decoration-skip-ink:none;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}ol,ul{padding-left:2rem}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}b,strong{font-weight:bolder}small{font-size:.875em}mark{padding:.2em;background-color:#fcf8e3}sub,sup{position:relative;font-size:.75em;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#0d6efd;text-decoration:underline}a:hover{color:#0a58ca}a:not([href]):not([class]),a:not([href]):not([class]):hover{color:inherit;text-decoration:none}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:1em;direction:ltr;unicode-bidi:bidi-override}pre{display:block;margin-top:0;margin-bottom:1rem;overflow:auto;font-size:.875em}pre code{font-size:inherit;color:inherit;word-break:normal}code{font-size:.875em;color:#d63384;word-wrap:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:.875em;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:1em;font-weight:700}figure{margin:0 0 1rem}img,svg{vertical-align:middle}table{caption-side:bottom;border-collapse:collapse}caption{padding-top:.5rem;padding-bottom:.5rem;color:#6c757d;text-align:left}th{text-align:inherit;text-align:-webkit-match-parent}tbody,td,tfoot,th,thead,tr{border-color:inherit;border-style:solid;border-width:0}label{display:inline-block}button{border-radius:0}button:focus:not(:focus-visible){outline:0}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,select{text-transform:none}[role=button]{cursor:pointer}select{word-wrap:normal}select:disabled{opacity:1}[list]::-webkit-calendar-picker-indicator{display:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled),button:not(:disabled){cursor:pointer}::-moz-focus-inner{padding:0;border-style:none}textarea{resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{float:left;width:100%;padding:0;margin-bottom:.5rem;font-size:calc(1.275rem + .3vw);line-height:inherit}@media (min-width:1200px){legend{font-size:1.5rem}}legend+*{clear:left}::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-fields-wrapper,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-text,::-webkit-datetime-edit-year-field{padding:0}::-webkit-inner-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-color-swatch-wrapper{padding:0}::file-selector-button{font:inherit}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}iframe{border:0}summary{display:list-item;cursor:pointer}progress{vertical-align:baseline}[hidden]{display:none!important}</style>
<style>/*! pygments syntax highlighting */pre{line-height:125%;}td.linenos pre{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}span.linenos{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}td.linenos pre.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}span.linenos.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}.pdoc .hll{background-color:#ffffcc}.pdoc{background:#f8f8f8;}.pdoc .c{color:#408080; font-style:italic}.pdoc .err{border:1px solid #FF0000}.pdoc .k{color:#008000; font-weight:bold}.pdoc .o{color:#666666}.pdoc .ch{color:#408080; font-style:italic}.pdoc .cm{color:#408080; font-style:italic}.pdoc .cp{color:#BC7A00}.pdoc .cpf{color:#408080; font-style:italic}.pdoc .c1{color:#408080; font-style:italic}.pdoc .cs{color:#408080; font-style:italic}.pdoc .gd{color:#A00000}.pdoc .ge{font-style:italic}.pdoc .gr{color:#FF0000}.pdoc .gh{color:#000080; font-weight:bold}.pdoc .gi{color:#00A000}.pdoc .go{color:#888888}.pdoc .gp{color:#000080; font-weight:bold}.pdoc .gs{font-weight:bold}.pdoc .gu{color:#800080; font-weight:bold}.pdoc .gt{color:#0044DD}.pdoc .kc{color:#008000; font-weight:bold}.pdoc .kd{color:#008000; font-weight:bold}.pdoc .kn{color:#008000; font-weight:bold}.pdoc .kp{color:#008000}.pdoc .kr{color:#008000; font-weight:bold}.pdoc .kt{color:#B00040}.pdoc .m{color:#666666}.pdoc .s{color:#BA2121}.pdoc .na{color:#7D9029}.pdoc .nb{color:#008000}.pdoc .nc{color:#0000FF; font-weight:bold}.pdoc .no{color:#880000}.pdoc .nd{color:#AA22FF}.pdoc .ni{color:#999999; font-weight:bold}.pdoc .ne{color:#D2413A; font-weight:bold}.pdoc .nf{color:#0000FF}.pdoc .nl{color:#A0A000}.pdoc .nn{color:#0000FF; font-weight:bold}.pdoc .nt{color:#008000; font-weight:bold}.pdoc .nv{color:#19177C}.pdoc .ow{color:#AA22FF; font-weight:bold}.pdoc .w{color:#bbbbbb}.pdoc .mb{color:#666666}.pdoc .mf{color:#666666}.pdoc .mh{color:#666666}.pdoc .mi{color:#666666}.pdoc .mo{color:#666666}.pdoc .sa{color:#BA2121}.pdoc .sb{color:#BA2121}.pdoc .sc{color:#BA2121}.pdoc .dl{color:#BA2121}.pdoc .sd{color:#BA2121; font-style:italic}.pdoc .s2{color:#BA2121}.pdoc .se{color:#BB6622; font-weight:bold}.pdoc .sh{color:#BA2121}.pdoc .si{color:#BB6688; font-weight:bold}.pdoc .sx{color:#008000}.pdoc .sr{color:#BB6688}.pdoc .s1{color:#BA2121}.pdoc .ss{color:#19177C}.pdoc .bp{color:#008000}.pdoc .fm{color:#0000FF}.pdoc .vc{color:#19177C}.pdoc .vg{color:#19177C}.pdoc .vi{color:#19177C}.pdoc .vm{color:#19177C}.pdoc .il{color:#666666}</style>
<style>/*! pdoc */:root{--pdoc-background:#fff;}.pdoc{--text:#212529;--muted:#6c757d;--link:#3660a5;--link-hover:#1659c5;--code:#f7f7f7;--active:#fff598;--accent:#eee;--accent2:#c1c1c1;--nav-hover:rgba(255, 255, 255, 0.5);--name:#0066BB;--def:#008800;--annotation:#007020;}body{background-color:var(--pdoc-background);}html, body{width:100%;height:100%;}@media (max-width:769px){#navtoggle{cursor:pointer;position:absolute;width:50px;height:40px;top:1rem;right:1rem;border-color:var(--text);color:var(--text);display:flex;opacity:0.8;}#navtoggle:hover{opacity:1;}#togglestate + div{display:none;}#togglestate:checked + div{display:inherit;}main, header{padding:2rem 3vw;}.git-button{display:none !important;}nav input[type="search"]:valid ~ *{display:none !important;}}@media (min-width:770px){:root{--sidebar-width:clamp(12.5rem, 28vw, 22rem);}nav{position:fixed;overflow:auto;height:100vh;width:var(--sidebar-width);}main, header{padding:3rem 2rem 3rem calc(var(--sidebar-width) + 3rem);width:calc(54rem + var(--sidebar-width));max-width:100%;}#navtoggle{display:none;}}#togglestate{display:none;}nav.pdoc{--pad:1.75rem;--indent:1.5rem;background-color:var(--accent);border-right:1px solid var(--accent2);box-shadow:0 0 20px rgba(50, 50, 50, .2) inset;padding:0 0 0 var(--pad);overflow-wrap:anywhere;scrollbar-width:thin; scrollbar-color:var(--accent2) transparent }nav.pdoc::-webkit-scrollbar{width:.4rem; }nav.pdoc::-webkit-scrollbar-thumb{background-color:var(--accent2); }nav.pdoc > div{padding:var(--pad) 0;}nav.pdoc .module-list-button{display:inline-flex;align-items:center;color:var(--text);border-color:var(--muted);margin-bottom:1rem;}nav.pdoc .module-list-button:hover{border-color:var(--text);}nav.pdoc input[type=search]{display:block;outline-offset:0;width:calc(100% - var(--pad));}nav.pdoc .logo{max-width:calc(100% - var(--pad));max-height:35vh;display:block;margin:0 auto 1rem;transform:translate(calc(-.5 * var(--pad)), 0);}nav.pdoc ul{list-style:none;padding-left:0;}nav.pdoc li{display:block;margin:0;padding:.2rem 0 .2rem var(--indent);transition:all 100ms;}nav.pdoc > div > ul > li{padding-left:0;}nav.pdoc li:hover{background-color:var(--nav-hover);}nav.pdoc a, nav.pdoc a:hover{color:var(--text);}nav.pdoc a{display:block;}nav.pdoc > h2:first-of-type{margin-top:1.5rem;}nav.pdoc .class:before{content:"class ";color:var(--muted);}nav.pdoc .function:after{content:"()";color:var(--muted);}nav.pdoc footer:before{content:"";display:block;width:calc(100% - var(--pad));border-top:solid var(--accent2) 1px;margin-top:1.5rem;padding-top:.5rem;}nav.pdoc footer{font-size:small;}html, main{scroll-behavior:smooth;}.pdoc{color:var(--text);box-sizing:border-box;line-height:1.5;background:none;}.pdoc .pdoc-button{display:inline-block;border:solid black 1px;border-radius:2px;font-size:.75rem;padding:calc(0.5em - 1px) 1em;transition:100ms all;}.pdoc .visually-hidden{position:absolute !important;width:1px !important;height:1px !important;padding:0 !important;margin:-1px !important;overflow:hidden !important;clip:rect(0, 0, 0, 0) !important;white-space:nowrap !important;border:0 !important;}.pdoc h1, .pdoc h2, .pdoc h3{font-weight:300;margin:.3em 0;padding:.2em 0;}.pdoc a{text-decoration:none;color:var(--link);}.pdoc a:hover{color:var(--link-hover);}.pdoc blockquote{margin-left:2rem;}.pdoc pre{background-color:var(--code);border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto;}.pdoc code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--code);border-radius:6px;}.pdoc a > code{color:inherit;}.pdoc pre > code{display:inline-block;font-size:inherit;background:none;border:none;padding:0;}.pdoc .modulename{margin-top:0;font-weight:bold;}.pdoc .modulename a{color:var(--link);transition:100ms all;}.pdoc .git-button{float:right;border:solid var(--link) 1px;}.pdoc .git-button:hover{background-color:var(--link);color:var(--pdoc-background);}.pdoc details{--shift:-40px;text-align:right;margin-top:var(--shift);margin-bottom:calc(0px - var(--shift));clear:both;filter:opacity(1);}.pdoc details:not([open]){height:0;overflow:visible;}.pdoc details > summary{font-size:.75rem;cursor:pointer;color:var(--muted);border-width:0;padding:0 .7em;display:inline-block;display:inline list-item;user-select:none;}.pdoc details > summary:focus{outline:0;}.pdoc details > div{margin-top:calc(0px - var(--shift) / 2);text-align:left;}.pdoc .docstring{margin-bottom:1.5rem;}.pdoc > section:first-of-type > .docstring{margin-bottom:3rem;}.pdoc .docstring pre{margin-left:1em;margin-right:1em;}.pdoc h1:target,.pdoc h2:target,.pdoc h3:target,.pdoc h4:target,.pdoc h5:target,.pdoc h6:target{background-color:var(--active);box-shadow:-1rem 0 0 0 var(--active);}.pdoc div:target > .attr,.pdoc section:target > .attr,.pdoc dd:target > a{background-color:var(--active);}.pdoc .attr:hover{filter:contrast(0.95);}.pdoc .headerlink{position:absolute;width:0;margin-left:-1.5rem;line-height:1.4rem;font-size:1.5rem;font-weight:normal;transition:all 100ms ease-in-out;opacity:0;}.pdoc .attr > .headerlink{margin-left:-2.5rem;}.pdoc *:hover > .headerlink,.pdoc *:target > .attr > .headerlink{opacity:1;}.pdoc .attr{display:block;color:var(--text);margin:1rem 0 .5rem;padding:.4rem 5rem .4rem 1rem;background-color:var(--accent);}.pdoc .classattr{margin-left:2rem;}.pdoc .name{color:var(--name);font-weight:bold;}.pdoc .def{color:var(--def);font-weight:bold;}.pdoc .signature{white-space:pre-wrap;}.pdoc .annotation{color:var(--annotation);}.pdoc .inherited{margin-left:2rem;}.pdoc .inherited dt{font-weight:700;}.pdoc .inherited dt, .pdoc .inherited dd{display:inline;margin-left:0;margin-bottom:.5rem;}.pdoc .inherited dd:not(:last-child):after{content:", ";}.pdoc .inherited .class:before{content:"class ";}.pdoc .inherited .function a:after{content:"()";}.pdoc .search-result .docstring{overflow:auto;max-height:25vh;}.pdoc .search-result.focused > .attr{background-color:var(--active);}.pdoc .attribution{margin-top:2rem;display:block;opacity:0.5;transition:all 200ms;filter:grayscale(100%);}.pdoc .attribution:hover{opacity:1;filter:grayscale(0%);}.pdoc .attribution img{margin-left:5px;height:35px;vertical-align:middle;width:70px;transition:all 200ms;}</style>
</head>
<body>        <nav class="pdoc">
            <label id="navtoggle" for="togglestate" class="pdoc-button"><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'><path stroke-linecap='round' stroke="currentColor" stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/></svg></label>
            <input id="togglestate" type="checkbox">
            <div>

                        <img src="https://developers.google.com/optimization/images/orLogo.png" class="logo" alt="project logo"/>




                    <h2>API Documentation</h2>
                        <ul class="memberlist">
            <li>
                    <a class="class" href="#DefaultPhaseParameters">DefaultPhaseParameters</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#DefaultPhaseParameters.__init__">DefaultPhaseParameters</a>
                        </li>
                        <li>
                                <a class="variable" href="#DefaultPhaseParameters.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="variable" href="#DefaultPhaseParameters.CHOOSE_MAX_SUM_IMPACT">CHOOSE_MAX_SUM_IMPACT</a>
                        </li>
                        <li>
                                <a class="variable" href="#DefaultPhaseParameters.CHOOSE_MAX_AVERAGE_IMPACT">CHOOSE_MAX_AVERAGE_IMPACT</a>
                        </li>
                        <li>
                                <a class="variable" href="#DefaultPhaseParameters.CHOOSE_MAX_VALUE_IMPACT">CHOOSE_MAX_VALUE_IMPACT</a>
                        </li>
                        <li>
                                <a class="variable" href="#DefaultPhaseParameters.SELECT_MIN_IMPACT">SELECT_MIN_IMPACT</a>
                        </li>
                        <li>
                                <a class="variable" href="#DefaultPhaseParameters.SELECT_MAX_IMPACT">SELECT_MAX_IMPACT</a>
                        </li>
                        <li>
                                <a class="variable" href="#DefaultPhaseParameters.NONE">NONE</a>
                        </li>
                        <li>
                                <a class="variable" href="#DefaultPhaseParameters.NORMAL">NORMAL</a>
                        </li>
                        <li>
                                <a class="variable" href="#DefaultPhaseParameters.VERBOSE">VERBOSE</a>
                        </li>
                        <li>
                                <a class="variable" href="#DefaultPhaseParameters.var_selection_schema">var_selection_schema</a>
                        </li>
                        <li>
                                <a class="variable" href="#DefaultPhaseParameters.value_selection_schema">value_selection_schema</a>
                        </li>
                        <li>
                                <a class="variable" href="#DefaultPhaseParameters.initialization_splits">initialization_splits</a>
                        </li>
                        <li>
                                <a class="variable" href="#DefaultPhaseParameters.run_all_heuristics">run_all_heuristics</a>
                        </li>
                        <li>
                                <a class="variable" href="#DefaultPhaseParameters.heuristic_period">heuristic_period</a>
                        </li>
                        <li>
                                <a class="variable" href="#DefaultPhaseParameters.heuristic_num_failures_limit">heuristic_num_failures_limit</a>
                        </li>
                        <li>
                                <a class="variable" href="#DefaultPhaseParameters.persistent_impact">persistent_impact</a>
                        </li>
                        <li>
                                <a class="variable" href="#DefaultPhaseParameters.random_seed">random_seed</a>
                        </li>
                        <li>
                                <a class="variable" href="#DefaultPhaseParameters.display_level">display_level</a>
                        </li>
                        <li>
                                <a class="variable" href="#DefaultPhaseParameters.decision_builder">decision_builder</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#Solver">Solver</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#Solver.__init__">Solver</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.INT_VAR_DEFAULT">INT_VAR_DEFAULT</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.INT_VAR_SIMPLE">INT_VAR_SIMPLE</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.CHOOSE_FIRST_UNBOUND">CHOOSE_FIRST_UNBOUND</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.CHOOSE_RANDOM">CHOOSE_RANDOM</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.CHOOSE_MIN_SIZE_LOWEST_MIN">CHOOSE_MIN_SIZE_LOWEST_MIN</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.CHOOSE_MIN_SIZE_HIGHEST_MIN">CHOOSE_MIN_SIZE_HIGHEST_MIN</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.CHOOSE_MIN_SIZE_LOWEST_MAX">CHOOSE_MIN_SIZE_LOWEST_MAX</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.CHOOSE_MIN_SIZE_HIGHEST_MAX">CHOOSE_MIN_SIZE_HIGHEST_MAX</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.CHOOSE_LOWEST_MIN">CHOOSE_LOWEST_MIN</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.CHOOSE_HIGHEST_MAX">CHOOSE_HIGHEST_MAX</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.CHOOSE_MIN_SIZE">CHOOSE_MIN_SIZE</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.CHOOSE_MAX_SIZE">CHOOSE_MAX_SIZE</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.CHOOSE_MAX_REGRET_ON_MIN">CHOOSE_MAX_REGRET_ON_MIN</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.CHOOSE_PATH">CHOOSE_PATH</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.INT_VALUE_DEFAULT">INT_VALUE_DEFAULT</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.INT_VALUE_SIMPLE">INT_VALUE_SIMPLE</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.ASSIGN_MIN_VALUE">ASSIGN_MIN_VALUE</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.ASSIGN_MAX_VALUE">ASSIGN_MAX_VALUE</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.ASSIGN_RANDOM_VALUE">ASSIGN_RANDOM_VALUE</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.ASSIGN_CENTER_VALUE">ASSIGN_CENTER_VALUE</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.SPLIT_LOWER_HALF">SPLIT_LOWER_HALF</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.SPLIT_UPPER_HALF">SPLIT_UPPER_HALF</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.SEQUENCE_DEFAULT">SEQUENCE_DEFAULT</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.SEQUENCE_SIMPLE">SEQUENCE_SIMPLE</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.CHOOSE_MIN_SLACK_RANK_FORWARD">CHOOSE_MIN_SLACK_RANK_FORWARD</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.CHOOSE_RANDOM_RANK_FORWARD">CHOOSE_RANDOM_RANK_FORWARD</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.INTERVAL_DEFAULT">INTERVAL_DEFAULT</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.INTERVAL_SIMPLE">INTERVAL_SIMPLE</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.INTERVAL_SET_TIMES_FORWARD">INTERVAL_SET_TIMES_FORWARD</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.INTERVAL_SET_TIMES_BACKWARD">INTERVAL_SET_TIMES_BACKWARD</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.TWOOPT">TWOOPT</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.OROPT">OROPT</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.RELOCATE">RELOCATE</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.EXCHANGE">EXCHANGE</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.CROSS">CROSS</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.MAKEACTIVE">MAKEACTIVE</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.MAKEINACTIVE">MAKEINACTIVE</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.MAKECHAININACTIVE">MAKECHAININACTIVE</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.SWAPACTIVE">SWAPACTIVE</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.EXTENDEDSWAPACTIVE">EXTENDEDSWAPACTIVE</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.PATHLNS">PATHLNS</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.FULLPATHLNS">FULLPATHLNS</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.UNACTIVELNS">UNACTIVELNS</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.INCREMENT">INCREMENT</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.DECREMENT">DECREMENT</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.SIMPLELNS">SIMPLELNS</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.GE">GE</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.LE">LE</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.EQ">EQ</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.DELAYED_PRIORITY">DELAYED_PRIORITY</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.VAR_PRIORITY">VAR_PRIORITY</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.NORMAL_PRIORITY">NORMAL_PRIORITY</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Parameters">Parameters</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.DefaultSolverParameters">DefaultSolverParameters</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.AddConstraint">AddConstraint</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Solve">Solve</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.NewSearch">NewSearch</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.NextSolution">NextSolution</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.RestartSearch">RestartSearch</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.EndSearch">EndSearch</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.SolveAndCommit">SolveAndCommit</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.CheckAssignment">CheckAssignment</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.CheckConstraint">CheckConstraint</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Fail">Fail</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.MemoryUsage">MemoryUsage</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.WallTime">WallTime</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Branches">Branches</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Solutions">Solutions</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Failures">Failures</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.AcceptedNeighbors">AcceptedNeighbors</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Stamp">Stamp</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.FailStamp">FailStamp</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.IntVar">IntVar</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.BoolVar">BoolVar</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.IntConst">IntConst</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Sum">Sum</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.ScalProd">ScalProd</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.MonotonicElement">MonotonicElement</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Element">Element</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.IndexExpression">IndexExpression</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Min">Min</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Max">Max</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.ConvexPiecewiseExpr">ConvexPiecewiseExpr</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.SemiContinuousExpr">SemiContinuousExpr</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.ConditionalExpression">ConditionalExpression</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.TrueConstraint">TrueConstraint</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.FalseConstraint">FalseConstraint</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.IsEqualCstCt">IsEqualCstCt</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.IsEqualCstVar">IsEqualCstVar</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.IsEqualCt">IsEqualCt</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.IsEqualVar">IsEqualVar</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.IsDifferentCstCt">IsDifferentCstCt</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.IsDifferentCstVar">IsDifferentCstVar</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.IsDifferentVar">IsDifferentVar</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.IsDifferentCt">IsDifferentCt</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.IsLessOrEqualCstCt">IsLessOrEqualCstCt</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.IsLessOrEqualCstVar">IsLessOrEqualCstVar</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.IsLessOrEqualVar">IsLessOrEqualVar</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.IsLessOrEqualCt">IsLessOrEqualCt</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.IsGreaterOrEqualCstCt">IsGreaterOrEqualCstCt</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.IsGreaterOrEqualCstVar">IsGreaterOrEqualCstVar</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.IsGreaterOrEqualVar">IsGreaterOrEqualVar</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.IsGreaterOrEqualCt">IsGreaterOrEqualCt</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.IsGreaterCstCt">IsGreaterCstCt</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.IsGreaterCstVar">IsGreaterCstVar</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.IsGreaterVar">IsGreaterVar</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.IsGreaterCt">IsGreaterCt</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.IsLessCstCt">IsLessCstCt</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.IsLessCstVar">IsLessCstVar</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.IsLessVar">IsLessVar</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.IsLessCt">IsLessCt</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.SumLessOrEqual">SumLessOrEqual</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.SumGreaterOrEqual">SumGreaterOrEqual</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.SumEquality">SumEquality</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.ScalProdEquality">ScalProdEquality</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.ScalProdGreaterOrEqual">ScalProdGreaterOrEqual</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.ScalProdLessOrEqual">ScalProdLessOrEqual</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.MinEquality">MinEquality</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.MaxEquality">MaxEquality</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.ElementEquality">ElementEquality</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.AbsEquality">AbsEquality</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.IndexOfConstraint">IndexOfConstraint</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.ConstraintInitialPropagateCallback">ConstraintInitialPropagateCallback</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.DelayedConstraintInitialPropagateCallback">DelayedConstraintInitialPropagateCallback</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.ClosureDemon">ClosureDemon</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.BetweenCt">BetweenCt</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.IsBetweenCt">IsBetweenCt</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.IsBetweenVar">IsBetweenVar</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.MemberCt">MemberCt</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.NotMemberCt">NotMemberCt</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.IsMemberCt">IsMemberCt</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.IsMemberVar">IsMemberVar</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Count">Count</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Distribute">Distribute</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Deviation">Deviation</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.AllDifferent">AllDifferent</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.AllDifferentExcept">AllDifferentExcept</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.SortingConstraint">SortingConstraint</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.LexicalLess">LexicalLess</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.LexicalLessOrEqual">LexicalLessOrEqual</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.InversePermutationConstraint">InversePermutationConstraint</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.NullIntersect">NullIntersect</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.NullIntersectExcept">NullIntersectExcept</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Circuit">Circuit</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.SubCircuit">SubCircuit</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.DelayedPathCumul">DelayedPathCumul</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.PathCumul">PathCumul</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.AllowedAssignments">AllowedAssignments</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.TransitionConstraint">TransitionConstraint</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.NonOverlappingBoxesConstraint">NonOverlappingBoxesConstraint</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Pack">Pack</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.FixedDurationIntervalVar">FixedDurationIntervalVar</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.FixedInterval">FixedInterval</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.IntervalVar">IntervalVar</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.MirrorInterval">MirrorInterval</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.FixedDurationStartSyncedOnStartIntervalVar">FixedDurationStartSyncedOnStartIntervalVar</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.FixedDurationStartSyncedOnEndIntervalVar">FixedDurationStartSyncedOnEndIntervalVar</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.FixedDurationEndSyncedOnStartIntervalVar">FixedDurationEndSyncedOnStartIntervalVar</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.FixedDurationEndSyncedOnEndIntervalVar">FixedDurationEndSyncedOnEndIntervalVar</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.IntervalRelaxedMin">IntervalRelaxedMin</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.IntervalRelaxedMax">IntervalRelaxedMax</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.TemporalDisjunction">TemporalDisjunction</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.DisjunctiveConstraint">DisjunctiveConstraint</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Cumulative">Cumulative</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Cover">Cover</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Assignment">Assignment</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.FirstSolutionCollector">FirstSolutionCollector</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.LastSolutionCollector">LastSolutionCollector</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.BestValueSolutionCollector">BestValueSolutionCollector</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.AllSolutionCollector">AllSolutionCollector</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Minimize">Minimize</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Maximize">Maximize</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Optimize">Optimize</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.WeightedMinimize">WeightedMinimize</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.WeightedMaximize">WeightedMaximize</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.WeightedOptimize">WeightedOptimize</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.TabuSearch">TabuSearch</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.SimulatedAnnealing">SimulatedAnnealing</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.LubyRestart">LubyRestart</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.ConstantRestart">ConstantRestart</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.TimeLimit">TimeLimit</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.BranchesLimit">BranchesLimit</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.FailuresLimit">FailuresLimit</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.SolutionsLimit">SolutionsLimit</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Limit">Limit</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.CustomLimit">CustomLimit</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.SearchLog">SearchLog</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.SearchTrace">SearchTrace</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.PrintModelVisitor">PrintModelVisitor</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.StatisticsModelVisitor">StatisticsModelVisitor</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.AssignVariableValue">AssignVariableValue</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.VariableLessOrEqualValue">VariableLessOrEqualValue</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.VariableGreaterOrEqualValue">VariableGreaterOrEqualValue</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.SplitVariableDomain">SplitVariableDomain</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.AssignVariableValueOrFail">AssignVariableValueOrFail</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.AssignVariablesValues">AssignVariablesValues</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.FailDecision">FailDecision</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Decision">Decision</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Compose">Compose</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Try">Try</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.DefaultPhase">DefaultPhase</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.ScheduleOrPostpone">ScheduleOrPostpone</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.ScheduleOrExpedite">ScheduleOrExpedite</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.RankFirstInterval">RankFirstInterval</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.RankLastInterval">RankLastInterval</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Phase">Phase</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.DecisionBuilderFromAssignment">DecisionBuilderFromAssignment</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.ConstraintAdder">ConstraintAdder</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.SolveOnce">SolveOnce</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.NestedOptimize">NestedOptimize</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.RestoreAssignment">RestoreAssignment</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.StoreAssignment">StoreAssignment</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Operator">Operator</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.RandomLnsOperator">RandomLnsOperator</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.MoveTowardTargetOperator">MoveTowardTargetOperator</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.ConcatenateOperators">ConcatenateOperators</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.RandomConcatenateOperators">RandomConcatenateOperators</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.NeighborhoodLimit">NeighborhoodLimit</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.LocalSearchPhase">LocalSearchPhase</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.LocalSearchPhaseParameters">LocalSearchPhaseParameters</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.SearchDepth">SearchDepth</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.SearchLeftDepth">SearchLeftDepth</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.SolveDepth">SolveDepth</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Rand64">Rand64</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Rand32">Rand32</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.ReSeed">ReSeed</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.LocalSearchProfile">LocalSearchProfile</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Constraints">Constraints</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Accept">Accept</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.FinishCurrentSearch">FinishCurrentSearch</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.RestartCurrentSearch">RestartCurrentSearch</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.ShouldFail">ShouldFail</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Add">Add</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.TreeNoCycle">TreeNoCycle</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.SearchLogWithCallback">SearchLogWithCallback</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.ElementFunction">ElementFunction</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.VarEvalValStrPhase">VarEvalValStrPhase</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.VarStrValEvalPhase">VarStrValEvalPhase</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.VarEvalValEvalPhase">VarEvalValEvalPhase</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.VarStrValEvalTieBreakPhase">VarStrValEvalTieBreakPhase</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.VarEvalValEvalTieBreakPhase">VarEvalValEvalTieBreakPhase</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.EvalEvalStrPhase">EvalEvalStrPhase</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.EvalEvalStrTieBreakPhase">EvalEvalStrTieBreakPhase</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.GuidedLocalSearch">GuidedLocalSearch</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.SumObjectiveFilter">SumObjectiveFilter</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="function" href="#Solver_DefaultSolverParameters">Solver_DefaultSolverParameters</a>
            </li>
            <li>
                    <a class="function" href="#Solver_MemoryUsage">Solver_MemoryUsage</a>
            </li>
            <li>
                    <a class="class" href="#BaseObject">BaseObject</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#BaseObject.__init__">BaseObject</a>
                        </li>
                        <li>
                                <a class="variable" href="#BaseObject.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#BaseObject.DebugString">DebugString</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#PropagationBaseObject">PropagationBaseObject</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#PropagationBaseObject.__init__">PropagationBaseObject</a>
                        </li>
                        <li>
                                <a class="variable" href="#PropagationBaseObject.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#PropagationBaseObject.DebugString">DebugString</a>
                        </li>
                        <li>
                                <a class="function" href="#PropagationBaseObject.solver">solver</a>
                        </li>
                        <li>
                                <a class="function" href="#PropagationBaseObject.Name">Name</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#Decision">Decision</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#Decision.__init__">Decision</a>
                        </li>
                        <li>
                                <a class="variable" href="#Decision.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#Decision.ApplyWrapper">ApplyWrapper</a>
                        </li>
                        <li>
                                <a class="function" href="#Decision.RefuteWrapper">RefuteWrapper</a>
                        </li>
                        <li>
                                <a class="function" href="#Decision.DebugString">DebugString</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#DecisionBuilder">DecisionBuilder</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#DecisionBuilder.__init__">DecisionBuilder</a>
                        </li>
                        <li>
                                <a class="variable" href="#DecisionBuilder.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#DecisionBuilder.NextWrapper">NextWrapper</a>
                        </li>
                        <li>
                                <a class="function" href="#DecisionBuilder.DebugString">DebugString</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#Demon">Demon</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#Demon.__init__">Demon</a>
                        </li>
                        <li>
                                <a class="variable" href="#Demon.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#Demon.RunWrapper">RunWrapper</a>
                        </li>
                        <li>
                                <a class="function" href="#Demon.Priority">Priority</a>
                        </li>
                        <li>
                                <a class="function" href="#Demon.DebugString">DebugString</a>
                        </li>
                        <li>
                                <a class="function" href="#Demon.Inhibit">Inhibit</a>
                        </li>
                        <li>
                                <a class="function" href="#Demon.Desinhibit">Desinhibit</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#Constraint">Constraint</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#Constraint.__init__">Constraint</a>
                        </li>
                        <li>
                                <a class="variable" href="#Constraint.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#Constraint.Post">Post</a>
                        </li>
                        <li>
                                <a class="function" href="#Constraint.InitialPropagateWrapper">InitialPropagateWrapper</a>
                        </li>
                        <li>
                                <a class="function" href="#Constraint.DebugString">DebugString</a>
                        </li>
                        <li>
                                <a class="function" href="#Constraint.Var">Var</a>
                        </li>
                        <li>
                                <a class="function" href="#Constraint.Square">Square</a>
                        </li>
                        <li>
                                <a class="function" href="#Constraint.MapTo">MapTo</a>
                        </li>
                        <li>
                                <a class="function" href="#Constraint.IndexOf">IndexOf</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#SearchMonitor">SearchMonitor</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#SearchMonitor.__init__">SearchMonitor</a>
                        </li>
                        <li>
                                <a class="variable" href="#SearchMonitor.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#SearchMonitor.EnterSearch">EnterSearch</a>
                        </li>
                        <li>
                                <a class="function" href="#SearchMonitor.RestartSearch">RestartSearch</a>
                        </li>
                        <li>
                                <a class="function" href="#SearchMonitor.ExitSearch">ExitSearch</a>
                        </li>
                        <li>
                                <a class="function" href="#SearchMonitor.BeginNextDecision">BeginNextDecision</a>
                        </li>
                        <li>
                                <a class="function" href="#SearchMonitor.EndNextDecision">EndNextDecision</a>
                        </li>
                        <li>
                                <a class="function" href="#SearchMonitor.ApplyDecision">ApplyDecision</a>
                        </li>
                        <li>
                                <a class="function" href="#SearchMonitor.RefuteDecision">RefuteDecision</a>
                        </li>
                        <li>
                                <a class="function" href="#SearchMonitor.AfterDecision">AfterDecision</a>
                        </li>
                        <li>
                                <a class="function" href="#SearchMonitor.BeginFail">BeginFail</a>
                        </li>
                        <li>
                                <a class="function" href="#SearchMonitor.EndFail">EndFail</a>
                        </li>
                        <li>
                                <a class="function" href="#SearchMonitor.BeginInitialPropagation">BeginInitialPropagation</a>
                        </li>
                        <li>
                                <a class="function" href="#SearchMonitor.EndInitialPropagation">EndInitialPropagation</a>
                        </li>
                        <li>
                                <a class="function" href="#SearchMonitor.AcceptSolution">AcceptSolution</a>
                        </li>
                        <li>
                                <a class="function" href="#SearchMonitor.AtSolution">AtSolution</a>
                        </li>
                        <li>
                                <a class="function" href="#SearchMonitor.NoMoreSolutions">NoMoreSolutions</a>
                        </li>
                        <li>
                                <a class="function" href="#SearchMonitor.LocalOptimum">LocalOptimum</a>
                        </li>
                        <li>
                                <a class="function" href="#SearchMonitor.AcceptDelta">AcceptDelta</a>
                        </li>
                        <li>
                                <a class="function" href="#SearchMonitor.AcceptNeighbor">AcceptNeighbor</a>
                        </li>
                        <li>
                                <a class="function" href="#SearchMonitor.solver">solver</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#IntExpr">IntExpr</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#IntExpr.__init__">IntExpr</a>
                        </li>
                        <li>
                                <a class="variable" href="#IntExpr.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#IntExpr.Min">Min</a>
                        </li>
                        <li>
                                <a class="function" href="#IntExpr.SetMin">SetMin</a>
                        </li>
                        <li>
                                <a class="function" href="#IntExpr.Max">Max</a>
                        </li>
                        <li>
                                <a class="function" href="#IntExpr.SetMax">SetMax</a>
                        </li>
                        <li>
                                <a class="function" href="#IntExpr.SetRange">SetRange</a>
                        </li>
                        <li>
                                <a class="function" href="#IntExpr.SetValue">SetValue</a>
                        </li>
                        <li>
                                <a class="function" href="#IntExpr.Bound">Bound</a>
                        </li>
                        <li>
                                <a class="function" href="#IntExpr.IsVar">IsVar</a>
                        </li>
                        <li>
                                <a class="function" href="#IntExpr.Var">Var</a>
                        </li>
                        <li>
                                <a class="function" href="#IntExpr.VarWithName">VarWithName</a>
                        </li>
                        <li>
                                <a class="function" href="#IntExpr.WhenRange">WhenRange</a>
                        </li>
                        <li>
                                <a class="function" href="#IntExpr.Square">Square</a>
                        </li>
                        <li>
                                <a class="function" href="#IntExpr.MapTo">MapTo</a>
                        </li>
                        <li>
                                <a class="function" href="#IntExpr.IndexOf">IndexOf</a>
                        </li>
                        <li>
                                <a class="function" href="#IntExpr.IsMember">IsMember</a>
                        </li>
                        <li>
                                <a class="function" href="#IntExpr.Member">Member</a>
                        </li>
                        <li>
                                <a class="function" href="#IntExpr.NotMember">NotMember</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#IntVarIterator">IntVarIterator</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#IntVarIterator.__init__">IntVarIterator</a>
                        </li>
                        <li>
                                <a class="variable" href="#IntVarIterator.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVarIterator.Init">Init</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVarIterator.Ok">Ok</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVarIterator.Value">Value</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVarIterator.Next">Next</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVarIterator.DebugString">DebugString</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVarIterator.next">next</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#IntVar">IntVar</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#IntVar.__init__">IntVar</a>
                        </li>
                        <li>
                                <a class="variable" href="#IntVar.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVar.IsVar">IsVar</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVar.Var">Var</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVar.Value">Value</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVar.RemoveValue">RemoveValue</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVar.RemoveInterval">RemoveInterval</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVar.RemoveValues">RemoveValues</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVar.SetValues">SetValues</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVar.WhenBound">WhenBound</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVar.WhenDomain">WhenDomain</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVar.Size">Size</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVar.Contains">Contains</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVar.HoleIteratorAux">HoleIteratorAux</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVar.DomainIteratorAux">DomainIteratorAux</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVar.OldMin">OldMin</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVar.OldMax">OldMax</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVar.DomainIterator">DomainIterator</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVar.HoleIterator">HoleIterator</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#SolutionCollector">SolutionCollector</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#SolutionCollector.__init__">SolutionCollector</a>
                        </li>
                        <li>
                                <a class="variable" href="#SolutionCollector.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#SolutionCollector.DebugString">DebugString</a>
                        </li>
                        <li>
                                <a class="function" href="#SolutionCollector.Add">Add</a>
                        </li>
                        <li>
                                <a class="function" href="#SolutionCollector.AddObjective">AddObjective</a>
                        </li>
                        <li>
                                <a class="function" href="#SolutionCollector.EnterSearch">EnterSearch</a>
                        </li>
                        <li>
                                <a class="function" href="#SolutionCollector.SolutionCount">SolutionCount</a>
                        </li>
                        <li>
                                <a class="function" href="#SolutionCollector.Solution">Solution</a>
                        </li>
                        <li>
                                <a class="function" href="#SolutionCollector.WallTime">WallTime</a>
                        </li>
                        <li>
                                <a class="function" href="#SolutionCollector.Branches">Branches</a>
                        </li>
                        <li>
                                <a class="function" href="#SolutionCollector.Failures">Failures</a>
                        </li>
                        <li>
                                <a class="function" href="#SolutionCollector.ObjectiveValue">ObjectiveValue</a>
                        </li>
                        <li>
                                <a class="function" href="#SolutionCollector.Value">Value</a>
                        </li>
                        <li>
                                <a class="function" href="#SolutionCollector.StartValue">StartValue</a>
                        </li>
                        <li>
                                <a class="function" href="#SolutionCollector.EndValue">EndValue</a>
                        </li>
                        <li>
                                <a class="function" href="#SolutionCollector.DurationValue">DurationValue</a>
                        </li>
                        <li>
                                <a class="function" href="#SolutionCollector.PerformedValue">PerformedValue</a>
                        </li>
                        <li>
                                <a class="function" href="#SolutionCollector.ForwardSequence">ForwardSequence</a>
                        </li>
                        <li>
                                <a class="function" href="#SolutionCollector.BackwardSequence">BackwardSequence</a>
                        </li>
                        <li>
                                <a class="function" href="#SolutionCollector.Unperformed">Unperformed</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#OptimizeVar">OptimizeVar</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#OptimizeVar.__init__">OptimizeVar</a>
                        </li>
                        <li>
                                <a class="variable" href="#OptimizeVar.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#OptimizeVar.Best">Best</a>
                        </li>
                        <li>
                                <a class="function" href="#OptimizeVar.Var">Var</a>
                        </li>
                        <li>
                                <a class="function" href="#OptimizeVar.AcceptDelta">AcceptDelta</a>
                        </li>
                        <li>
                                <a class="function" href="#OptimizeVar.EnterSearch">EnterSearch</a>
                        </li>
                        <li>
                                <a class="function" href="#OptimizeVar.BeginNextDecision">BeginNextDecision</a>
                        </li>
                        <li>
                                <a class="function" href="#OptimizeVar.RefuteDecision">RefuteDecision</a>
                        </li>
                        <li>
                                <a class="function" href="#OptimizeVar.AtSolution">AtSolution</a>
                        </li>
                        <li>
                                <a class="function" href="#OptimizeVar.AcceptSolution">AcceptSolution</a>
                        </li>
                        <li>
                                <a class="function" href="#OptimizeVar.DebugString">DebugString</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#SearchLimit">SearchLimit</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#SearchLimit.__init__">SearchLimit</a>
                        </li>
                        <li>
                                <a class="variable" href="#SearchLimit.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#SearchLimit.Crossed">Crossed</a>
                        </li>
                        <li>
                                <a class="function" href="#SearchLimit.Check">Check</a>
                        </li>
                        <li>
                                <a class="function" href="#SearchLimit.Init">Init</a>
                        </li>
                        <li>
                                <a class="function" href="#SearchLimit.EnterSearch">EnterSearch</a>
                        </li>
                        <li>
                                <a class="function" href="#SearchLimit.BeginNextDecision">BeginNextDecision</a>
                        </li>
                        <li>
                                <a class="function" href="#SearchLimit.RefuteDecision">RefuteDecision</a>
                        </li>
                        <li>
                                <a class="function" href="#SearchLimit.DebugString">DebugString</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#IntervalVar">IntervalVar</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#IntervalVar.__init__">IntervalVar</a>
                        </li>
                        <li>
                                <a class="variable" href="#IntervalVar.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.StartMin">StartMin</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.StartMax">StartMax</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.SetStartMin">SetStartMin</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.SetStartMax">SetStartMax</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.SetStartRange">SetStartRange</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.OldStartMin">OldStartMin</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.OldStartMax">OldStartMax</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.WhenStartRange">WhenStartRange</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.WhenStartBound">WhenStartBound</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.DurationMin">DurationMin</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.DurationMax">DurationMax</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.SetDurationMin">SetDurationMin</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.SetDurationMax">SetDurationMax</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.SetDurationRange">SetDurationRange</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.OldDurationMin">OldDurationMin</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.OldDurationMax">OldDurationMax</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.WhenDurationRange">WhenDurationRange</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.WhenDurationBound">WhenDurationBound</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.EndMin">EndMin</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.EndMax">EndMax</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.SetEndMin">SetEndMin</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.SetEndMax">SetEndMax</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.SetEndRange">SetEndRange</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.OldEndMin">OldEndMin</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.OldEndMax">OldEndMax</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.WhenEndRange">WhenEndRange</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.WhenEndBound">WhenEndBound</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.MustBePerformed">MustBePerformed</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.MayBePerformed">MayBePerformed</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.CannotBePerformed">CannotBePerformed</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.IsPerformedBound">IsPerformedBound</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.SetPerformed">SetPerformed</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.WasPerformedBound">WasPerformedBound</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.WhenPerformedBound">WhenPerformedBound</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.WhenAnything">WhenAnything</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.StartExpr">StartExpr</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.DurationExpr">DurationExpr</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.EndExpr">EndExpr</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.PerformedExpr">PerformedExpr</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.SafeStartExpr">SafeStartExpr</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.SafeDurationExpr">SafeDurationExpr</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.SafeEndExpr">SafeEndExpr</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.EndsAfterEnd">EndsAfterEnd</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.EndsAfterEndWithDelay">EndsAfterEndWithDelay</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.EndsAfterStart">EndsAfterStart</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.EndsAfterStartWithDelay">EndsAfterStartWithDelay</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.EndsAtEnd">EndsAtEnd</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.EndsAtEndWithDelay">EndsAtEndWithDelay</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.EndsAtStart">EndsAtStart</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.EndsAtStartWithDelay">EndsAtStartWithDelay</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.StartsAfterEnd">StartsAfterEnd</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.StartsAfterEndWithDelay">StartsAfterEndWithDelay</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.StartsAfterStart">StartsAfterStart</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.StartsAfterStartWithDelay">StartsAfterStartWithDelay</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.StartsAtEnd">StartsAtEnd</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.StartsAtEndWithDelay">StartsAtEndWithDelay</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.StartsAtStart">StartsAtStart</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.StartsAtStartWithDelay">StartsAtStartWithDelay</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.StaysInSync">StaysInSync</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.StaysInSyncWithDelay">StaysInSyncWithDelay</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.EndsAfter">EndsAfter</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.EndsAt">EndsAt</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.EndsBefore">EndsBefore</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.StartsAfter">StartsAfter</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.StartsAt">StartsAt</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.StartsBefore">StartsBefore</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.CrossesDate">CrossesDate</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVar.AvoidsDate">AvoidsDate</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#SequenceVar">SequenceVar</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#SequenceVar.__init__">SequenceVar</a>
                        </li>
                        <li>
                                <a class="variable" href="#SequenceVar.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#SequenceVar.DebugString">DebugString</a>
                        </li>
                        <li>
                                <a class="function" href="#SequenceVar.RankFirst">RankFirst</a>
                        </li>
                        <li>
                                <a class="function" href="#SequenceVar.RankNotFirst">RankNotFirst</a>
                        </li>
                        <li>
                                <a class="function" href="#SequenceVar.RankLast">RankLast</a>
                        </li>
                        <li>
                                <a class="function" href="#SequenceVar.RankNotLast">RankNotLast</a>
                        </li>
                        <li>
                                <a class="function" href="#SequenceVar.Interval">Interval</a>
                        </li>
                        <li>
                                <a class="function" href="#SequenceVar.Next">Next</a>
                        </li>
                        <li>
                                <a class="function" href="#SequenceVar.Size">Size</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#AssignmentElement">AssignmentElement</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#AssignmentElement.__init__">AssignmentElement</a>
                        </li>
                        <li>
                                <a class="variable" href="#AssignmentElement.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#AssignmentElement.Activate">Activate</a>
                        </li>
                        <li>
                                <a class="function" href="#AssignmentElement.Deactivate">Deactivate</a>
                        </li>
                        <li>
                                <a class="function" href="#AssignmentElement.Activated">Activated</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#IntVarElement">IntVarElement</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#IntVarElement.__init__">IntVarElement</a>
                        </li>
                        <li>
                                <a class="variable" href="#IntVarElement.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVarElement.Var">Var</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVarElement.Min">Min</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVarElement.SetMin">SetMin</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVarElement.Max">Max</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVarElement.SetMax">SetMax</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVarElement.Value">Value</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVarElement.Bound">Bound</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVarElement.SetRange">SetRange</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVarElement.SetValue">SetValue</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#IntervalVarElement">IntervalVarElement</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#IntervalVarElement.__init__">IntervalVarElement</a>
                        </li>
                        <li>
                                <a class="variable" href="#IntervalVarElement.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVarElement.Var">Var</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVarElement.StartMin">StartMin</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVarElement.StartMax">StartMax</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVarElement.StartValue">StartValue</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVarElement.DurationMin">DurationMin</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVarElement.DurationMax">DurationMax</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVarElement.DurationValue">DurationValue</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVarElement.EndMin">EndMin</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVarElement.EndMax">EndMax</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVarElement.EndValue">EndValue</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVarElement.PerformedMin">PerformedMin</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVarElement.PerformedMax">PerformedMax</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVarElement.PerformedValue">PerformedValue</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVarElement.SetStartMin">SetStartMin</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVarElement.SetStartMax">SetStartMax</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVarElement.SetStartRange">SetStartRange</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVarElement.SetStartValue">SetStartValue</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVarElement.SetDurationMin">SetDurationMin</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVarElement.SetDurationMax">SetDurationMax</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVarElement.SetDurationRange">SetDurationRange</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVarElement.SetDurationValue">SetDurationValue</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVarElement.SetEndMin">SetEndMin</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVarElement.SetEndMax">SetEndMax</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVarElement.SetEndRange">SetEndRange</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVarElement.SetEndValue">SetEndValue</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVarElement.SetPerformedMin">SetPerformedMin</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVarElement.SetPerformedMax">SetPerformedMax</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVarElement.SetPerformedRange">SetPerformedRange</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVarElement.SetPerformedValue">SetPerformedValue</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#SequenceVarElement">SequenceVarElement</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#SequenceVarElement.__init__">SequenceVarElement</a>
                        </li>
                        <li>
                                <a class="variable" href="#SequenceVarElement.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#SequenceVarElement.Var">Var</a>
                        </li>
                        <li>
                                <a class="function" href="#SequenceVarElement.ForwardSequence">ForwardSequence</a>
                        </li>
                        <li>
                                <a class="function" href="#SequenceVarElement.BackwardSequence">BackwardSequence</a>
                        </li>
                        <li>
                                <a class="function" href="#SequenceVarElement.Unperformed">Unperformed</a>
                        </li>
                        <li>
                                <a class="function" href="#SequenceVarElement.SetSequence">SetSequence</a>
                        </li>
                        <li>
                                <a class="function" href="#SequenceVarElement.SetForwardSequence">SetForwardSequence</a>
                        </li>
                        <li>
                                <a class="function" href="#SequenceVarElement.SetBackwardSequence">SetBackwardSequence</a>
                        </li>
                        <li>
                                <a class="function" href="#SequenceVarElement.SetUnperformed">SetUnperformed</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#Assignment">Assignment</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#Assignment.__init__">Assignment</a>
                        </li>
                        <li>
                                <a class="variable" href="#Assignment.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.Clear">Clear</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.Empty">Empty</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.Size">Size</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.NumIntVars">NumIntVars</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.NumIntervalVars">NumIntervalVars</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.NumSequenceVars">NumSequenceVars</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.Store">Store</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.Restore">Restore</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.Load">Load</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.Save">Save</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.AddObjective">AddObjective</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.Objective">Objective</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.HasObjective">HasObjective</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.ObjectiveMin">ObjectiveMin</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.ObjectiveMax">ObjectiveMax</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.ObjectiveValue">ObjectiveValue</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.ObjectiveBound">ObjectiveBound</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.SetObjectiveMin">SetObjectiveMin</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.SetObjectiveMax">SetObjectiveMax</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.SetObjectiveValue">SetObjectiveValue</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.SetObjectiveRange">SetObjectiveRange</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.Min">Min</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.Max">Max</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.Value">Value</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.Bound">Bound</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.SetMin">SetMin</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.SetMax">SetMax</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.SetRange">SetRange</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.SetValue">SetValue</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.StartMin">StartMin</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.StartMax">StartMax</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.StartValue">StartValue</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.DurationMin">DurationMin</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.DurationMax">DurationMax</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.DurationValue">DurationValue</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.EndMin">EndMin</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.EndMax">EndMax</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.EndValue">EndValue</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.PerformedMin">PerformedMin</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.PerformedMax">PerformedMax</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.PerformedValue">PerformedValue</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.SetStartMin">SetStartMin</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.SetStartMax">SetStartMax</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.SetStartRange">SetStartRange</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.SetStartValue">SetStartValue</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.SetDurationMin">SetDurationMin</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.SetDurationMax">SetDurationMax</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.SetDurationRange">SetDurationRange</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.SetDurationValue">SetDurationValue</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.SetEndMin">SetEndMin</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.SetEndMax">SetEndMax</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.SetEndRange">SetEndRange</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.SetEndValue">SetEndValue</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.SetPerformedMin">SetPerformedMin</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.SetPerformedMax">SetPerformedMax</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.SetPerformedRange">SetPerformedRange</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.SetPerformedValue">SetPerformedValue</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.Add">Add</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.ForwardSequence">ForwardSequence</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.BackwardSequence">BackwardSequence</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.Unperformed">Unperformed</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.SetSequence">SetSequence</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.SetForwardSequence">SetForwardSequence</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.SetBackwardSequence">SetBackwardSequence</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.SetUnperformed">SetUnperformed</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.Activate">Activate</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.Deactivate">Deactivate</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.Activated">Activated</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.DebugString">DebugString</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.IntVarContainer">IntVarContainer</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.MutableIntVarContainer">MutableIntVarContainer</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.IntervalVarContainer">IntervalVarContainer</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.MutableIntervalVarContainer">MutableIntervalVarContainer</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.SequenceVarContainer">SequenceVarContainer</a>
                        </li>
                        <li>
                                <a class="function" href="#Assignment.MutableSequenceVarContainer">MutableSequenceVarContainer</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#Pack">Pack</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#Pack.__init__">Pack</a>
                        </li>
                        <li>
                                <a class="variable" href="#Pack.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#Pack.AddWeightedSumLessOrEqualConstantDimension">AddWeightedSumLessOrEqualConstantDimension</a>
                        </li>
                        <li>
                                <a class="function" href="#Pack.AddWeightedSumEqualVarDimension">AddWeightedSumEqualVarDimension</a>
                        </li>
                        <li>
                                <a class="function" href="#Pack.AddSumVariableWeightsLessOrEqualConstantDimension">AddSumVariableWeightsLessOrEqualConstantDimension</a>
                        </li>
                        <li>
                                <a class="function" href="#Pack.AddWeightedSumOfAssignedDimension">AddWeightedSumOfAssignedDimension</a>
                        </li>
                        <li>
                                <a class="function" href="#Pack.AddCountUsedBinDimension">AddCountUsedBinDimension</a>
                        </li>
                        <li>
                                <a class="function" href="#Pack.AddCountAssignedItemsDimension">AddCountAssignedItemsDimension</a>
                        </li>
                        <li>
                                <a class="function" href="#Pack.Post">Post</a>
                        </li>
                        <li>
                                <a class="function" href="#Pack.InitialPropagateWrapper">InitialPropagateWrapper</a>
                        </li>
                        <li>
                                <a class="function" href="#Pack.DebugString">DebugString</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#DisjunctiveConstraint">DisjunctiveConstraint</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#DisjunctiveConstraint.__init__">DisjunctiveConstraint</a>
                        </li>
                        <li>
                                <a class="variable" href="#DisjunctiveConstraint.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#DisjunctiveConstraint.SequenceVar">SequenceVar</a>
                        </li>
                        <li>
                                <a class="function" href="#DisjunctiveConstraint.SetTransitionTime">SetTransitionTime</a>
                        </li>
                        <li>
                                <a class="function" href="#DisjunctiveConstraint.TransitionTime">TransitionTime</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#RevInteger">RevInteger</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#RevInteger.__init__">RevInteger</a>
                        </li>
                        <li>
                                <a class="variable" href="#RevInteger.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#RevInteger.Value">Value</a>
                        </li>
                        <li>
                                <a class="function" href="#RevInteger.SetValue">SetValue</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#NumericalRevInteger">NumericalRevInteger</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#NumericalRevInteger.__init__">NumericalRevInteger</a>
                        </li>
                        <li>
                                <a class="variable" href="#NumericalRevInteger.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#NumericalRevInteger.Add">Add</a>
                        </li>
                        <li>
                                <a class="function" href="#NumericalRevInteger.Incr">Incr</a>
                        </li>
                        <li>
                                <a class="function" href="#NumericalRevInteger.Decr">Decr</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#RevBool">RevBool</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#RevBool.__init__">RevBool</a>
                        </li>
                        <li>
                                <a class="variable" href="#RevBool.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#RevBool.Value">Value</a>
                        </li>
                        <li>
                                <a class="function" href="#RevBool.SetValue">SetValue</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#IntVarContainer">IntVarContainer</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#IntVarContainer.__init__">IntVarContainer</a>
                        </li>
                        <li>
                                <a class="variable" href="#IntVarContainer.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVarContainer.Contains">Contains</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVarContainer.Element">Element</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVarContainer.Size">Size</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVarContainer.Store">Store</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVarContainer.Restore">Restore</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#IntervalVarContainer">IntervalVarContainer</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#IntervalVarContainer.__init__">IntervalVarContainer</a>
                        </li>
                        <li>
                                <a class="variable" href="#IntervalVarContainer.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVarContainer.Contains">Contains</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVarContainer.Element">Element</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVarContainer.Size">Size</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVarContainer.Store">Store</a>
                        </li>
                        <li>
                                <a class="function" href="#IntervalVarContainer.Restore">Restore</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#SequenceVarContainer">SequenceVarContainer</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#SequenceVarContainer.__init__">SequenceVarContainer</a>
                        </li>
                        <li>
                                <a class="variable" href="#SequenceVarContainer.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#SequenceVarContainer.Contains">Contains</a>
                        </li>
                        <li>
                                <a class="function" href="#SequenceVarContainer.Element">Element</a>
                        </li>
                        <li>
                                <a class="function" href="#SequenceVarContainer.Size">Size</a>
                        </li>
                        <li>
                                <a class="function" href="#SequenceVarContainer.Store">Store</a>
                        </li>
                        <li>
                                <a class="function" href="#SequenceVarContainer.Restore">Restore</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#LocalSearchOperator">LocalSearchOperator</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#LocalSearchOperator.__init__">LocalSearchOperator</a>
                        </li>
                        <li>
                                <a class="variable" href="#LocalSearchOperator.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#LocalSearchOperator.NextNeighbor">NextNeighbor</a>
                        </li>
                        <li>
                                <a class="function" href="#LocalSearchOperator.Start">Start</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#IntVarLocalSearchOperatorTemplate">IntVarLocalSearchOperatorTemplate</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#IntVarLocalSearchOperatorTemplate.__init__">IntVarLocalSearchOperatorTemplate</a>
                        </li>
                        <li>
                                <a class="variable" href="#IntVarLocalSearchOperatorTemplate.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVarLocalSearchOperatorTemplate.Start">Start</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVarLocalSearchOperatorTemplate.IsIncremental">IsIncremental</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVarLocalSearchOperatorTemplate.Size">Size</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVarLocalSearchOperatorTemplate.Value">Value</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVarLocalSearchOperatorTemplate.OldValue">OldValue</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVarLocalSearchOperatorTemplate.SetValue">SetValue</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVarLocalSearchOperatorTemplate.OnStart">OnStart</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#IntVarLocalSearchOperator">IntVarLocalSearchOperator</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#IntVarLocalSearchOperator.__init__">IntVarLocalSearchOperator</a>
                        </li>
                        <li>
                                <a class="variable" href="#IntVarLocalSearchOperator.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVarLocalSearchOperator.NextNeighbor">NextNeighbor</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVarLocalSearchOperator.OneNeighbor">OneNeighbor</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#SequenceVarLocalSearchOperatorTemplate">SequenceVarLocalSearchOperatorTemplate</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#SequenceVarLocalSearchOperatorTemplate.__init__">SequenceVarLocalSearchOperatorTemplate</a>
                        </li>
                        <li>
                                <a class="variable" href="#SequenceVarLocalSearchOperatorTemplate.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#SequenceVarLocalSearchOperatorTemplate.Start">Start</a>
                        </li>
                        <li>
                                <a class="function" href="#SequenceVarLocalSearchOperatorTemplate.IsIncremental">IsIncremental</a>
                        </li>
                        <li>
                                <a class="function" href="#SequenceVarLocalSearchOperatorTemplate.Size">Size</a>
                        </li>
                        <li>
                                <a class="function" href="#SequenceVarLocalSearchOperatorTemplate.Value">Value</a>
                        </li>
                        <li>
                                <a class="function" href="#SequenceVarLocalSearchOperatorTemplate.OldValue">OldValue</a>
                        </li>
                        <li>
                                <a class="function" href="#SequenceVarLocalSearchOperatorTemplate.SetValue">SetValue</a>
                        </li>
                        <li>
                                <a class="function" href="#SequenceVarLocalSearchOperatorTemplate.OnStart">OnStart</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#SequenceVarLocalSearchOperator">SequenceVarLocalSearchOperator</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#SequenceVarLocalSearchOperator.__init__">SequenceVarLocalSearchOperator</a>
                        </li>
                        <li>
                                <a class="variable" href="#SequenceVarLocalSearchOperator.thisown">thisown</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#BaseLns">BaseLns</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#BaseLns.__init__">BaseLns</a>
                        </li>
                        <li>
                                <a class="variable" href="#BaseLns.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#BaseLns.InitFragments">InitFragments</a>
                        </li>
                        <li>
                                <a class="function" href="#BaseLns.NextFragment">NextFragment</a>
                        </li>
                        <li>
                                <a class="function" href="#BaseLns.AppendToFragment">AppendToFragment</a>
                        </li>
                        <li>
                                <a class="function" href="#BaseLns.FragmentSize">FragmentSize</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#ChangeValue">ChangeValue</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#ChangeValue.__init__">ChangeValue</a>
                        </li>
                        <li>
                                <a class="variable" href="#ChangeValue.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#ChangeValue.ModifyValue">ModifyValue</a>
                        </li>
                        <li>
                                <a class="function" href="#ChangeValue.OneNeighbor">OneNeighbor</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#PathOperator">PathOperator</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#PathOperator.__init__">PathOperator</a>
                        </li>
                        <li>
                                <a class="variable" href="#PathOperator.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#PathOperator.Neighbor">Neighbor</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#LocalSearchFilter">LocalSearchFilter</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#LocalSearchFilter.__init__">LocalSearchFilter</a>
                        </li>
                        <li>
                                <a class="variable" href="#LocalSearchFilter.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#LocalSearchFilter.Accept">Accept</a>
                        </li>
                        <li>
                                <a class="function" href="#LocalSearchFilter.IsIncremental">IsIncremental</a>
                        </li>
                        <li>
                                <a class="function" href="#LocalSearchFilter.Synchronize">Synchronize</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#LocalSearchFilterManager">LocalSearchFilterManager</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#LocalSearchFilterManager.__init__">LocalSearchFilterManager</a>
                        </li>
                        <li>
                                <a class="variable" href="#LocalSearchFilterManager.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#LocalSearchFilterManager.DebugString">DebugString</a>
                        </li>
                        <li>
                                <a class="function" href="#LocalSearchFilterManager.Accept">Accept</a>
                        </li>
                        <li>
                                <a class="function" href="#LocalSearchFilterManager.Synchronize">Synchronize</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#IntVarLocalSearchFilter">IntVarLocalSearchFilter</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#IntVarLocalSearchFilter.__init__">IntVarLocalSearchFilter</a>
                        </li>
                        <li>
                                <a class="variable" href="#IntVarLocalSearchFilter.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVarLocalSearchFilter.Synchronize">Synchronize</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVarLocalSearchFilter.Size">Size</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVarLocalSearchFilter.Value">Value</a>
                        </li>
                        <li>
                                <a class="function" href="#IntVarLocalSearchFilter.IndexFromVar">IndexFromVar</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#BooleanVar">BooleanVar</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#BooleanVar.__init__">BooleanVar</a>
                        </li>
                        <li>
                                <a class="variable" href="#BooleanVar.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#BooleanVar.Min">Min</a>
                        </li>
                        <li>
                                <a class="function" href="#BooleanVar.SetMin">SetMin</a>
                        </li>
                        <li>
                                <a class="function" href="#BooleanVar.Max">Max</a>
                        </li>
                        <li>
                                <a class="function" href="#BooleanVar.SetMax">SetMax</a>
                        </li>
                        <li>
                                <a class="function" href="#BooleanVar.SetRange">SetRange</a>
                        </li>
                        <li>
                                <a class="function" href="#BooleanVar.Bound">Bound</a>
                        </li>
                        <li>
                                <a class="function" href="#BooleanVar.Value">Value</a>
                        </li>
                        <li>
                                <a class="function" href="#BooleanVar.RemoveValue">RemoveValue</a>
                        </li>
                        <li>
                                <a class="function" href="#BooleanVar.RemoveInterval">RemoveInterval</a>
                        </li>
                        <li>
                                <a class="function" href="#BooleanVar.WhenBound">WhenBound</a>
                        </li>
                        <li>
                                <a class="function" href="#BooleanVar.WhenRange">WhenRange</a>
                        </li>
                        <li>
                                <a class="function" href="#BooleanVar.WhenDomain">WhenDomain</a>
                        </li>
                        <li>
                                <a class="function" href="#BooleanVar.Size">Size</a>
                        </li>
                        <li>
                                <a class="function" href="#BooleanVar.Contains">Contains</a>
                        </li>
                        <li>
                                <a class="function" href="#BooleanVar.HoleIteratorAux">HoleIteratorAux</a>
                        </li>
                        <li>
                                <a class="function" href="#BooleanVar.DomainIteratorAux">DomainIteratorAux</a>
                        </li>
                        <li>
                                <a class="function" href="#BooleanVar.DebugString">DebugString</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#PyDecision">PyDecision</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#PyDecision.__init__">PyDecision</a>
                        </li>
                        <li>
                                <a class="function" href="#PyDecision.ApplyWrapper">ApplyWrapper</a>
                        </li>
                        <li>
                                <a class="function" href="#PyDecision.RefuteWrapper">RefuteWrapper</a>
                        </li>
                        <li>
                                <a class="function" href="#PyDecision.DebugString">DebugString</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#PyDecisionBuilder">PyDecisionBuilder</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#PyDecisionBuilder.__init__">PyDecisionBuilder</a>
                        </li>
                        <li>
                                <a class="function" href="#PyDecisionBuilder.NextWrapper">NextWrapper</a>
                        </li>
                        <li>
                                <a class="function" href="#PyDecisionBuilder.DebugString">DebugString</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#PyDemon">PyDemon</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#PyDemon.RunWrapper">RunWrapper</a>
                        </li>
                        <li>
                                <a class="function" href="#PyDemon.DebugString">DebugString</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#PyConstraintDemon">PyConstraintDemon</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#PyConstraintDemon.__init__">PyConstraintDemon</a>
                        </li>
                        <li>
                                <a class="function" href="#PyConstraintDemon.Run">Run</a>
                        </li>
                        <li>
                                <a class="function" href="#PyConstraintDemon.Priority">Priority</a>
                        </li>
                        <li>
                                <a class="function" href="#PyConstraintDemon.DebugString">DebugString</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#PyConstraint">PyConstraint</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#PyConstraint.__init__">PyConstraint</a>
                        </li>
                        <li>
                                <a class="function" href="#PyConstraint.Demon">Demon</a>
                        </li>
                        <li>
                                <a class="function" href="#PyConstraint.DelayedDemon">DelayedDemon</a>
                        </li>
                        <li>
                                <a class="function" href="#PyConstraint.InitialPropagateDemon">InitialPropagateDemon</a>
                        </li>
                        <li>
                                <a class="function" href="#PyConstraint.DelayedInitialPropagateDemon">DelayedInitialPropagateDemon</a>
                        </li>
                        <li>
                                <a class="function" href="#PyConstraint.InitialPropagateWrapper">InitialPropagateWrapper</a>
                        </li>
                        <li>
                                <a class="function" href="#PyConstraint.DebugString">DebugString</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#RoutingIndexManager">RoutingIndexManager</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#RoutingIndexManager.__init__">RoutingIndexManager</a>
                        </li>
                        <li>
                                <a class="variable" href="#RoutingIndexManager.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingIndexManager.GetNumberOfNodes">GetNumberOfNodes</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingIndexManager.GetNumberOfVehicles">GetNumberOfVehicles</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingIndexManager.GetNumberOfIndices">GetNumberOfIndices</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingIndexManager.GetStartIndex">GetStartIndex</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingIndexManager.GetEndIndex">GetEndIndex</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingIndexManager.NodeToIndex">NodeToIndex</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingIndexManager.IndexToNode">IndexToNode</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="function" href="#DefaultRoutingModelParameters">DefaultRoutingModelParameters</a>
            </li>
            <li>
                    <a class="function" href="#DefaultRoutingSearchParameters">DefaultRoutingSearchParameters</a>
            </li>
            <li>
                    <a class="function" href="#FindErrorInRoutingSearchParameters">FindErrorInRoutingSearchParameters</a>
            </li>
            <li>
                    <a class="class" href="#RoutingModel">RoutingModel</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#RoutingModel.__init__">RoutingModel</a>
                        </li>
                        <li>
                                <a class="variable" href="#RoutingModel.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="variable" href="#RoutingModel.ROUTING_NOT_SOLVED">ROUTING_NOT_SOLVED</a>
                        </li>
                        <li>
                                <a class="variable" href="#RoutingModel.ROUTING_SUCCESS">ROUTING_SUCCESS</a>
                        </li>
                        <li>
                                <a class="variable" href="#RoutingModel.ROUTING_FAIL">ROUTING_FAIL</a>
                        </li>
                        <li>
                                <a class="variable" href="#RoutingModel.ROUTING_FAIL_TIMEOUT">ROUTING_FAIL_TIMEOUT</a>
                        </li>
                        <li>
                                <a class="variable" href="#RoutingModel.ROUTING_INVALID">ROUTING_INVALID</a>
                        </li>
                        <li>
                                <a class="variable" href="#RoutingModel.PICKUP_AND_DELIVERY_NO_ORDER">PICKUP_AND_DELIVERY_NO_ORDER</a>
                        </li>
                        <li>
                                <a class="variable" href="#RoutingModel.PICKUP_AND_DELIVERY_LIFO">PICKUP_AND_DELIVERY_LIFO</a>
                        </li>
                        <li>
                                <a class="variable" href="#RoutingModel.PICKUP_AND_DELIVERY_FIFO">PICKUP_AND_DELIVERY_FIFO</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.RegisterUnaryTransitVector">RegisterUnaryTransitVector</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.RegisterUnaryTransitCallback">RegisterUnaryTransitCallback</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.RegisterPositiveUnaryTransitCallback">RegisterPositiveUnaryTransitCallback</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.RegisterTransitMatrix">RegisterTransitMatrix</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.RegisterTransitCallback">RegisterTransitCallback</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.RegisterPositiveTransitCallback">RegisterPositiveTransitCallback</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.TransitCallback">TransitCallback</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.UnaryTransitCallbackOrNull">UnaryTransitCallbackOrNull</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.AddDimension">AddDimension</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.AddDimensionWithVehicleTransits">AddDimensionWithVehicleTransits</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.AddDimensionWithVehicleCapacity">AddDimensionWithVehicleCapacity</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.AddDimensionWithVehicleTransitAndCapacity">AddDimensionWithVehicleTransitAndCapacity</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.AddConstantDimensionWithSlack">AddConstantDimensionWithSlack</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.AddConstantDimension">AddConstantDimension</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.AddVectorDimension">AddVectorDimension</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.AddMatrixDimension">AddMatrixDimension</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.MakePathSpansAndTotalSlacks">MakePathSpansAndTotalSlacks</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetAllDimensionNames">GetAllDimensionNames</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetDimensions">GetDimensions</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetDimensionsWithSoftOrSpanCosts">GetDimensionsWithSoftOrSpanCosts</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetGlobalDimensionCumulOptimizers">GetGlobalDimensionCumulOptimizers</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetGlobalDimensionCumulMPOptimizers">GetGlobalDimensionCumulMPOptimizers</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetLocalDimensionCumulOptimizers">GetLocalDimensionCumulOptimizers</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetLocalDimensionCumulMPOptimizers">GetLocalDimensionCumulMPOptimizers</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetMutableGlobalCumulOptimizer">GetMutableGlobalCumulOptimizer</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetMutableGlobalCumulMPOptimizer">GetMutableGlobalCumulMPOptimizer</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetMutableLocalCumulOptimizer">GetMutableLocalCumulOptimizer</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetMutableLocalCumulMPOptimizer">GetMutableLocalCumulMPOptimizer</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.HasDimension">HasDimension</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetDimensionOrDie">GetDimensionOrDie</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetMutableDimension">GetMutableDimension</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.SetPrimaryConstrainedDimension">SetPrimaryConstrainedDimension</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetPrimaryConstrainedDimension">GetPrimaryConstrainedDimension</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetDimensionResourceGroupIndices">GetDimensionResourceGroupIndices</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.AddDisjunction">AddDisjunction</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetDisjunctionIndices">GetDisjunctionIndices</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetDisjunctionPenalty">GetDisjunctionPenalty</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetDisjunctionMaxCardinality">GetDisjunctionMaxCardinality</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetNumberOfDisjunctions">GetNumberOfDisjunctions</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetPerfectBinaryDisjunctions">GetPerfectBinaryDisjunctions</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.IgnoreDisjunctionsAlreadyForcedToZero">IgnoreDisjunctionsAlreadyForcedToZero</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.AddSoftSameVehicleConstraint">AddSoftSameVehicleConstraint</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.SetAllowedVehiclesForIndex">SetAllowedVehiclesForIndex</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.IsVehicleAllowedForIndex">IsVehicleAllowedForIndex</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.AddPickupAndDelivery">AddPickupAndDelivery</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.AddPickupAndDeliverySets">AddPickupAndDeliverySets</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetPickupIndexPairs">GetPickupIndexPairs</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetDeliveryIndexPairs">GetDeliveryIndexPairs</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.SetPickupAndDeliveryPolicyOfAllVehicles">SetPickupAndDeliveryPolicyOfAllVehicles</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.SetPickupAndDeliveryPolicyOfVehicle">SetPickupAndDeliveryPolicyOfVehicle</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetPickupAndDeliveryPolicyOfVehicle">GetPickupAndDeliveryPolicyOfVehicle</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetNumOfSingletonNodes">GetNumOfSingletonNodes</a>
                        </li>
                        <li>
                                <a class="variable" href="#RoutingModel.TYPE_ADDED_TO_VEHICLE">TYPE_ADDED_TO_VEHICLE</a>
                        </li>
                        <li>
                                <a class="variable" href="#RoutingModel.ADDED_TYPE_REMOVED_FROM_VEHICLE">ADDED_TYPE_REMOVED_FROM_VEHICLE</a>
                        </li>
                        <li>
                                <a class="variable" href="#RoutingModel.TYPE_ON_VEHICLE_UP_TO_VISIT">TYPE_ON_VEHICLE_UP_TO_VISIT</a>
                        </li>
                        <li>
                                <a class="variable" href="#RoutingModel.TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED">TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.SetVisitType">SetVisitType</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetVisitType">GetVisitType</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetSingleNodesOfType">GetSingleNodesOfType</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetPairIndicesOfType">GetPairIndicesOfType</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetVisitTypePolicy">GetVisitTypePolicy</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.CloseVisitTypes">CloseVisitTypes</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetNumberOfVisitTypes">GetNumberOfVisitTypes</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.AddHardTypeIncompatibility">AddHardTypeIncompatibility</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.AddTemporalTypeIncompatibility">AddTemporalTypeIncompatibility</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetHardTypeIncompatibilitiesOfType">GetHardTypeIncompatibilitiesOfType</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetTemporalTypeIncompatibilitiesOfType">GetTemporalTypeIncompatibilitiesOfType</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.HasHardTypeIncompatibilities">HasHardTypeIncompatibilities</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.HasTemporalTypeIncompatibilities">HasTemporalTypeIncompatibilities</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.AddSameVehicleRequiredTypeAlternatives">AddSameVehicleRequiredTypeAlternatives</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.AddRequiredTypeAlternativesWhenAddingType">AddRequiredTypeAlternativesWhenAddingType</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.AddRequiredTypeAlternativesWhenRemovingType">AddRequiredTypeAlternativesWhenRemovingType</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetSameVehicleRequiredTypeAlternativesOfType">GetSameVehicleRequiredTypeAlternativesOfType</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetRequiredTypeAlternativesWhenAddingType">GetRequiredTypeAlternativesWhenAddingType</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetRequiredTypeAlternativesWhenRemovingType">GetRequiredTypeAlternativesWhenRemovingType</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.HasSameVehicleTypeRequirements">HasSameVehicleTypeRequirements</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.HasTemporalTypeRequirements">HasTemporalTypeRequirements</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.HasTypeRegulations">HasTypeRegulations</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.UnperformedPenalty">UnperformedPenalty</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.UnperformedPenaltyOrValue">UnperformedPenaltyOrValue</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetDepot">GetDepot</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.SetMaximumNumberOfActiveVehicles">SetMaximumNumberOfActiveVehicles</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetMaximumNumberOfActiveVehicles">GetMaximumNumberOfActiveVehicles</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.SetArcCostEvaluatorOfAllVehicles">SetArcCostEvaluatorOfAllVehicles</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.SetArcCostEvaluatorOfVehicle">SetArcCostEvaluatorOfVehicle</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.SetFixedCostOfAllVehicles">SetFixedCostOfAllVehicles</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.SetFixedCostOfVehicle">SetFixedCostOfVehicle</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetFixedCostOfVehicle">GetFixedCostOfVehicle</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.SetAmortizedCostFactorsOfAllVehicles">SetAmortizedCostFactorsOfAllVehicles</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.SetAmortizedCostFactorsOfVehicle">SetAmortizedCostFactorsOfVehicle</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetAmortizedLinearCostFactorOfVehicles">GetAmortizedLinearCostFactorOfVehicles</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetAmortizedQuadraticCostFactorOfVehicles">GetAmortizedQuadraticCostFactorOfVehicles</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.ConsiderEmptyRouteCostsForVehicle">ConsiderEmptyRouteCostsForVehicle</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.AreEmptyRouteCostsConsideredForVehicle">AreEmptyRouteCostsConsideredForVehicle</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.SetFirstSolutionEvaluator">SetFirstSolutionEvaluator</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.AddLocalSearchOperator">AddLocalSearchOperator</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.AddSearchMonitor">AddSearchMonitor</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.AddAtSolutionCallback">AddAtSolutionCallback</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.AddVariableMinimizedByFinalizer">AddVariableMinimizedByFinalizer</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.AddVariableMaximizedByFinalizer">AddVariableMaximizedByFinalizer</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.AddWeightedVariableMinimizedByFinalizer">AddWeightedVariableMinimizedByFinalizer</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.AddVariableTargetToFinalizer">AddVariableTargetToFinalizer</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.CloseModel">CloseModel</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.CloseModelWithParameters">CloseModelWithParameters</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.Solve">Solve</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.SolveWithParameters">SolveWithParameters</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.SolveFromAssignmentWithParameters">SolveFromAssignmentWithParameters</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.SolveFromAssignmentsWithParameters">SolveFromAssignmentsWithParameters</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.SetAssignmentFromOtherModelAssignment">SetAssignmentFromOtherModelAssignment</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.ComputeLowerBound">ComputeLowerBound</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.status">status</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.ApplyLocks">ApplyLocks</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.ApplyLocksToAllVehicles">ApplyLocksToAllVehicles</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.PreAssignment">PreAssignment</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.MutablePreAssignment">MutablePreAssignment</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.WriteAssignment">WriteAssignment</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.ReadAssignment">ReadAssignment</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.RestoreAssignment">RestoreAssignment</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.ReadAssignmentFromRoutes">ReadAssignmentFromRoutes</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.RoutesToAssignment">RoutesToAssignment</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.AssignmentToRoutes">AssignmentToRoutes</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.CompactAssignment">CompactAssignment</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.CompactAndCheckAssignment">CompactAndCheckAssignment</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.AddToAssignment">AddToAssignment</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.AddIntervalToAssignment">AddIntervalToAssignment</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.PackCumulsOfOptimizerDimensionsFromAssignment">PackCumulsOfOptimizerDimensionsFromAssignment</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.AddLocalSearchFilter">AddLocalSearchFilter</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.Start">Start</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.End">End</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.IsStart">IsStart</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.IsEnd">IsEnd</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.VehicleIndex">VehicleIndex</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.Next">Next</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.IsVehicleUsed">IsVehicleUsed</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.NextVar">NextVar</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.ActiveVar">ActiveVar</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.ActiveVehicleVar">ActiveVehicleVar</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.VehicleCostsConsideredVar">VehicleCostsConsideredVar</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.VehicleVar">VehicleVar</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.CostVar">CostVar</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetArcCostForVehicle">GetArcCostForVehicle</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.CostsAreHomogeneousAcrossVehicles">CostsAreHomogeneousAcrossVehicles</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetHomogeneousCost">GetHomogeneousCost</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetArcCostForFirstSolution">GetArcCostForFirstSolution</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetArcCostForClass">GetArcCostForClass</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetCostClassIndexOfVehicle">GetCostClassIndexOfVehicle</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.HasVehicleWithCostClassIndex">HasVehicleWithCostClassIndex</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetCostClassesCount">GetCostClassesCount</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetNonZeroCostClassesCount">GetNonZeroCostClassesCount</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetVehicleClassIndexOfVehicle">GetVehicleClassIndexOfVehicle</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetVehicleOfClass">GetVehicleOfClass</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetVehicleClassesCount">GetVehicleClassesCount</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetSameVehicleIndicesOfIndex">GetSameVehicleIndicesOfIndex</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetVehicleTypeContainer">GetVehicleTypeContainer</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.ArcIsMoreConstrainedThanArc">ArcIsMoreConstrainedThanArc</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.DebugOutputAssignment">DebugOutputAssignment</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.solver">solver</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.CheckLimit">CheckLimit</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.RemainingTime">RemainingTime</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.nodes">nodes</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.vehicles">vehicles</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.Size">Size</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetNumberOfDecisionsInFirstSolution">GetNumberOfDecisionsInFirstSolution</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetNumberOfRejectsInFirstSolution">GetNumberOfRejectsInFirstSolution</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.GetAutomaticFirstSolutionStrategy">GetAutomaticFirstSolutionStrategy</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.IsMatchingModel">IsMatchingModel</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.MakeGuidedSlackFinalizer">MakeGuidedSlackFinalizer</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingModel.MakeSelfDependentDimensionFinalizer">MakeSelfDependentDimensionFinalizer</a>
                        </li>
                        <li>
                                <a class="variable" href="#RoutingModel.kNoPenalty">kNoPenalty</a>
                        </li>
                        <li>
                                <a class="variable" href="#RoutingModel.kNoDisjunction">kNoDisjunction</a>
                        </li>
                        <li>
                                <a class="variable" href="#RoutingModel.kNoDimension">kNoDimension</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#RoutingModelVisitor">RoutingModelVisitor</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#RoutingModelVisitor.__init__">RoutingModelVisitor</a>
                        </li>
                        <li>
                                <a class="variable" href="#RoutingModelVisitor.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="variable" href="#RoutingModelVisitor.kLightElement">kLightElement</a>
                        </li>
                        <li>
                                <a class="variable" href="#RoutingModelVisitor.kLightElement2">kLightElement2</a>
                        </li>
                        <li>
                                <a class="variable" href="#RoutingModelVisitor.kRemoveValues">kRemoveValues</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#GlobalVehicleBreaksConstraint">GlobalVehicleBreaksConstraint</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#GlobalVehicleBreaksConstraint.__init__">GlobalVehicleBreaksConstraint</a>
                        </li>
                        <li>
                                <a class="variable" href="#GlobalVehicleBreaksConstraint.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#GlobalVehicleBreaksConstraint.DebugString">DebugString</a>
                        </li>
                        <li>
                                <a class="function" href="#GlobalVehicleBreaksConstraint.Post">Post</a>
                        </li>
                        <li>
                                <a class="function" href="#GlobalVehicleBreaksConstraint.InitialPropagateWrapper">InitialPropagateWrapper</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#TypeRegulationsChecker">TypeRegulationsChecker</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#TypeRegulationsChecker.__init__">TypeRegulationsChecker</a>
                        </li>
                        <li>
                                <a class="variable" href="#TypeRegulationsChecker.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#TypeRegulationsChecker.CheckVehicle">CheckVehicle</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#TypeIncompatibilityChecker">TypeIncompatibilityChecker</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#TypeIncompatibilityChecker.__init__">TypeIncompatibilityChecker</a>
                        </li>
                        <li>
                                <a class="variable" href="#TypeIncompatibilityChecker.thisown">thisown</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#TypeRequirementChecker">TypeRequirementChecker</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#TypeRequirementChecker.__init__">TypeRequirementChecker</a>
                        </li>
                        <li>
                                <a class="variable" href="#TypeRequirementChecker.thisown">thisown</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#TypeRegulationsConstraint">TypeRegulationsConstraint</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#TypeRegulationsConstraint.__init__">TypeRegulationsConstraint</a>
                        </li>
                        <li>
                                <a class="variable" href="#TypeRegulationsConstraint.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#TypeRegulationsConstraint.Post">Post</a>
                        </li>
                        <li>
                                <a class="function" href="#TypeRegulationsConstraint.InitialPropagateWrapper">InitialPropagateWrapper</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#RoutingDimension">RoutingDimension</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#RoutingDimension.__init__">RoutingDimension</a>
                        </li>
                        <li>
                                <a class="variable" href="#RoutingDimension.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingDimension.model">model</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingDimension.GetTransitValue">GetTransitValue</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingDimension.GetTransitValueFromClass">GetTransitValueFromClass</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingDimension.CumulVar">CumulVar</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingDimension.TransitVar">TransitVar</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingDimension.FixedTransitVar">FixedTransitVar</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingDimension.SlackVar">SlackVar</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingDimension.SetSpanUpperBoundForVehicle">SetSpanUpperBoundForVehicle</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingDimension.SetSpanCostCoefficientForVehicle">SetSpanCostCoefficientForVehicle</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingDimension.SetSpanCostCoefficientForAllVehicles">SetSpanCostCoefficientForAllVehicles</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingDimension.SetGlobalSpanCostCoefficient">SetGlobalSpanCostCoefficient</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingDimension.SetCumulVarSoftUpperBound">SetCumulVarSoftUpperBound</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingDimension.HasCumulVarSoftUpperBound">HasCumulVarSoftUpperBound</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingDimension.GetCumulVarSoftUpperBound">GetCumulVarSoftUpperBound</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingDimension.GetCumulVarSoftUpperBoundCoefficient">GetCumulVarSoftUpperBoundCoefficient</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingDimension.SetCumulVarSoftLowerBound">SetCumulVarSoftLowerBound</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingDimension.HasCumulVarSoftLowerBound">HasCumulVarSoftLowerBound</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingDimension.GetCumulVarSoftLowerBound">GetCumulVarSoftLowerBound</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingDimension.GetCumulVarSoftLowerBoundCoefficient">GetCumulVarSoftLowerBoundCoefficient</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingDimension.SetBreakIntervalsOfVehicle">SetBreakIntervalsOfVehicle</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingDimension.SetBreakDistanceDurationOfVehicle">SetBreakDistanceDurationOfVehicle</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingDimension.InitializeBreaks">InitializeBreaks</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingDimension.HasBreakConstraints">HasBreakConstraints</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingDimension.GetPreTravelEvaluatorOfVehicle">GetPreTravelEvaluatorOfVehicle</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingDimension.GetPostTravelEvaluatorOfVehicle">GetPostTravelEvaluatorOfVehicle</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingDimension.base_dimension">base_dimension</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingDimension.ShortestTransitionSlack">ShortestTransitionSlack</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingDimension.name">name</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingDimension.SetPickupToDeliveryLimitFunctionForPair">SetPickupToDeliveryLimitFunctionForPair</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingDimension.HasPickupToDeliveryLimits">HasPickupToDeliveryLimits</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingDimension.AddNodePrecedence">AddNodePrecedence</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingDimension.GetSpanUpperBoundForVehicle">GetSpanUpperBoundForVehicle</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingDimension.GetSpanCostCoefficientForVehicle">GetSpanCostCoefficientForVehicle</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingDimension.global_span_cost_coefficient">global_span_cost_coefficient</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingDimension.GetGlobalOptimizerOffset">GetGlobalOptimizerOffset</a>
                        </li>
                        <li>
                                <a class="function" href="#RoutingDimension.GetLocalOptimizerOffsetForVehicle">GetLocalOptimizerOffsetForVehicle</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="function" href="#MakeSetValuesFromTargets">MakeSetValuesFromTargets</a>
            </li>
            <li>
                    <a class="function" href="#SolveModelWithSat">SolveModelWithSat</a>
            </li>
    </ul>


                    <footer>OR-Tools 9.1</footer>

                    <a class="attribution" title="pdoc: Python API documentation generator" href="https://pdoc.dev">
                        built with <span class="visually-hidden">pdoc</span><img
                            alt="pdoc logo"
                            src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20role%3D%22img%22%20aria-label%3D%22pdoc%20logo%22%20width%3D%22300%22%20height%3D%22150%22%20viewBox%3D%22-1%200%2060%2030%22%3E%3Ctitle%3Epdoc%3C/title%3E%3Cpath%20d%3D%22M29.621%2021.293c-.011-.273-.214-.475-.511-.481a.5.5%200%200%200-.489.503l-.044%201.393c-.097.551-.695%201.215-1.566%201.704-.577.428-1.306.486-2.193.182-1.426-.617-2.467-1.654-3.304-2.487l-.173-.172a3.43%203.43%200%200%200-.365-.306.49.49%200%200%200-.286-.196c-1.718-1.06-4.931-1.47-7.353.191l-.219.15c-1.707%201.187-3.413%202.131-4.328%201.03-.02-.027-.49-.685-.141-1.763.233-.721.546-2.408.772-4.076.042-.09.067-.187.046-.288.166-1.347.277-2.625.241-3.351%201.378-1.008%202.271-2.586%202.271-4.362%200-.976-.272-1.935-.788-2.774-.057-.094-.122-.18-.184-.268.033-.167.052-.339.052-.516%200-1.477-1.202-2.679-2.679-2.679-.791%200-1.496.352-1.987.9a6.3%206.3%200%200%200-1.001.029c-.492-.564-1.207-.929-2.012-.929-1.477%200-2.679%201.202-2.679%202.679A2.65%202.65%200%200%200%20.97%206.554c-.383.747-.595%201.572-.595%202.41%200%202.311%201.507%204.29%203.635%205.107-.037.699-.147%202.27-.423%203.294l-.137.461c-.622%202.042-2.515%208.257%201.727%2010.643%201.614.908%203.06%201.248%204.317%201.248%202.665%200%204.492-1.524%205.322-2.401%201.476-1.559%202.886-1.854%206.491.82%201.877%201.393%203.514%201.753%204.861%201.068%202.223-1.713%202.811-3.867%203.399-6.374.077-.846.056-1.469.054-1.537zm-4.835%204.313c-.054.305-.156.586-.242.629-.034-.007-.131-.022-.307-.157-.145-.111-.314-.478-.456-.908.221.121.432.25.675.355.115.039.219.051.33.081zm-2.251-1.238c-.05.33-.158.648-.252.694-.022.001-.125-.018-.307-.157-.217-.166-.488-.906-.639-1.573.358.344.754.693%201.198%201.036zm-3.887-2.337c-.006-.116-.018-.231-.041-.342.635.145%201.189.368%201.599.625.097.231.166.481.174.642-.03.049-.055.101-.067.158-.046.013-.128.026-.298.004-.278-.037-.901-.57-1.367-1.087zm-1.127-.497c.116.306.176.625.12.71-.019.014-.117.045-.345.016-.206-.027-.604-.332-.986-.695.41-.051.816-.056%201.211-.031zm-4.535%201.535c.209.22.379.47.358.598-.006.041-.088.138-.351.234-.144.055-.539-.063-.979-.259a11.66%2011.66%200%200%200%20.972-.573zm.983-.664c.359-.237.738-.418%201.126-.554.25.237.479.548.457.694-.006.042-.087.138-.351.235-.174.064-.694-.105-1.232-.375zm-3.381%201.794c-.022.145-.061.29-.149.401-.133.166-.358.248-.69.251h-.002c-.133%200-.306-.26-.45-.621.417.091.854.07%201.291-.031zm-2.066-8.077a4.78%204.78%200%200%201-.775-.584c.172-.115.505-.254.88-.378l-.105.962zm-.331%202.302a10.32%2010.32%200%200%201-.828-.502c.202-.143.576-.328.984-.49l-.156.992zm-.45%202.157l-.701-.403c.214-.115.536-.249.891-.376a11.57%2011.57%200%200%201-.19.779zm-.181%201.716c.064.398.194.702.298.893-.194-.051-.435-.162-.736-.398.061-.119.224-.3.438-.495zM8.87%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zm-.735-.389a1.15%201.15%200%200%200-.314.783%201.16%201.16%200%200%200%201.162%201.162c.457%200%20.842-.27%201.032-.653.026.117.042.238.042.362a1.68%201.68%200%200%201-1.679%201.679%201.68%201.68%200%200%201-1.679-1.679c0-.843.626-1.535%201.436-1.654zM5.059%205.406A1.68%201.68%200%200%201%203.38%207.085a1.68%201.68%200%200%201-1.679-1.679c0-.037.009-.072.011-.109.21.3.541.508.935.508a1.16%201.16%200%200%200%201.162-1.162%201.14%201.14%200%200%200-.474-.912c.015%200%20.03-.005.045-.005.926.001%201.679.754%201.679%201.68zM3.198%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zM1.375%208.964c0-.52.103-1.035.288-1.52.466.394%201.06.64%201.717.64%201.144%200%202.116-.725%202.499-1.738.383%201.012%201.355%201.738%202.499%201.738.867%200%201.631-.421%202.121-1.062.307.605.478%201.267.478%201.942%200%202.486-2.153%204.51-4.801%204.51s-4.801-2.023-4.801-4.51zm24.342%2019.349c-.985.498-2.267.168-3.813-.979-3.073-2.281-5.453-3.199-7.813-.705-1.315%201.391-4.163%203.365-8.423.97-3.174-1.786-2.239-6.266-1.261-9.479l.146-.492c.276-1.02.395-2.457.444-3.268a6.11%206.11%200%200%200%201.18.115%206.01%206.01%200%200%200%202.536-.562l-.006.175c-.802.215-1.848.612-2.021%201.25-.079.295.021.601.274.837.219.203.415.364.598.501-.667.304-1.243.698-1.311%201.179-.02.144-.022.507.393.787.213.144.395.26.564.365-1.285.521-1.361.96-1.381%201.126-.018.142-.011.496.427.746l.854.489c-.473.389-.971.914-.999%201.429-.018.278.095.532.316.713.675.556%201.231.721%201.653.721.059%200%20.104-.014.158-.02.207.707.641%201.64%201.513%201.64h.013c.8-.008%201.236-.345%201.462-.626.173-.216.268-.457.325-.692.424.195.93.374%201.372.374.151%200%20.294-.021.423-.068.732-.27.944-.704.993-1.021.009-.061.003-.119.002-.179.266.086.538.147.789.147.15%200%20.294-.021.423-.069.542-.2.797-.489.914-.754.237.147.478.258.704.288.106.014.205.021.296.021.356%200%20.595-.101.767-.229.438.435%201.094.992%201.656%201.067.106.014.205.021.296.021a1.56%201.56%200%200%200%20.323-.035c.17.575.453%201.289.866%201.605.358.273.665.362.914.362a.99.99%200%200%200%20.421-.093%201.03%201.03%200%200%200%20.245-.164c.168.428.39.846.68%201.068.358.273.665.362.913.362a.99.99%200%200%200%20.421-.093c.317-.148.512-.448.639-.762.251.157.495.257.726.257.127%200%20.25-.024.37-.071.427-.17.706-.617.841-1.314.022-.015.047-.022.068-.038.067-.051.133-.104.196-.159-.443%201.486-1.107%202.761-2.086%203.257zM8.66%209.925a.5.5%200%201%200-1%200c0%20.653-.818%201.205-1.787%201.205s-1.787-.552-1.787-1.205a.5.5%200%201%200-1%200c0%201.216%201.25%202.205%202.787%202.205s2.787-.989%202.787-2.205zm4.4%2015.965l-.208.097c-2.661%201.258-4.708%201.436-6.086.527-1.542-1.017-1.88-3.19-1.844-4.198a.4.4%200%200%200-.385-.414c-.242-.029-.406.164-.414.385-.046%201.249.367%203.686%202.202%204.896.708.467%201.547.7%202.51.7%201.248%200%202.706-.392%204.362-1.174l.185-.086a.4.4%200%200%200%20.205-.527c-.089-.204-.326-.291-.527-.206zM9.547%202.292c.093.077.205.114.317.114a.5.5%200%200%200%20.318-.886L8.817.397a.5.5%200%200%200-.703.068.5.5%200%200%200%20.069.703l1.364%201.124zm-7.661-.065c.086%200%20.173-.022.253-.068l1.523-.893a.5.5%200%200%200-.506-.863l-1.523.892a.5.5%200%200%200-.179.685c.094.158.261.247.432.247z%22%20transform%3D%22matrix%28-1%200%200%201%2058%200%29%22%20fill%3D%22%233bb300%22/%3E%3Cpath%20d%3D%22M.3%2021.86V10.18q0-.46.02-.68.04-.22.18-.5.28-.54%201.34-.54%201.06%200%201.42.28.38.26.44.78.76-1.04%202.38-1.04%201.64%200%203.1%201.54%201.46%201.54%201.46%203.58%200%202.04-1.46%203.58-1.44%201.54-3.08%201.54-1.64%200-2.38-.92v4.04q0%20.46-.04.68-.02.22-.18.5-.14.3-.5.42-.36.12-.98.12-.62%200-1-.12-.36-.12-.52-.4-.14-.28-.18-.5-.02-.22-.02-.68zm3.96-9.42q-.46.54-.46%201.18%200%20.64.46%201.18.48.52%201.2.52.74%200%201.24-.52.52-.52.52-1.18%200-.66-.48-1.18-.48-.54-1.26-.54-.76%200-1.22.54zm14.741-8.36q.16-.3.54-.42.38-.12%201-.12.64%200%201.02.12.38.12.52.42.16.3.18.54.04.22.04.68v11.94q0%20.46-.04.7-.02.22-.18.5-.3.54-1.7.54-1.38%200-1.54-.98-.84.96-2.34.96-1.8%200-3.28-1.56-1.48-1.58-1.48-3.66%200-2.1%201.48-3.68%201.5-1.58%203.28-1.58%201.48%200%202.3%201v-4.2q0-.46.02-.68.04-.24.18-.52zm-3.24%2010.86q.52.54%201.26.54.74%200%201.22-.54.5-.54.5-1.18%200-.66-.48-1.22-.46-.56-1.26-.56-.8%200-1.28.56-.48.54-.48%201.2%200%20.66.52%201.2zm7.833-1.2q0-2.4%201.68-3.96%201.68-1.56%203.84-1.56%202.16%200%203.82%201.56%201.66%201.54%201.66%203.94%200%201.66-.86%202.96-.86%201.28-2.1%201.9-1.22.6-2.54.6-1.32%200-2.56-.64-1.24-.66-2.1-1.92-.84-1.28-.84-2.88zm4.18%201.44q.64.48%201.3.48.66%200%201.32-.5.66-.5.66-1.48%200-.98-.62-1.46-.62-.48-1.34-.48-.72%200-1.34.5-.62.5-.62%201.48%200%20.96.64%201.46zm11.412-1.44q0%20.84.56%201.32.56.46%201.18.46.64%200%201.18-.36.56-.38.9-.38.6%200%201.46%201.06.46.58.46%201.04%200%20.76-1.1%201.42-1.14.8-2.8.8-1.86%200-3.58-1.34-.82-.64-1.34-1.7-.52-1.08-.52-2.36%200-1.3.52-2.34.52-1.06%201.34-1.7%201.66-1.32%203.54-1.32.76%200%201.48.22.72.2%201.06.4l.32.2q.36.24.56.38.52.4.52.92%200%20.5-.42%201.14-.72%201.1-1.38%201.1-.38%200-1.08-.44-.36-.34-1.04-.34-.66%200-1.24.48-.58.48-.58%201.34z%22%20fill%3D%22green%22/%3E%3C/svg%3E"/>
                    </a>
            </div>
        </nav>
    <main class="pdoc">
            <section>
                    <h1 class="modulename">
pywrapcp    </h1>

                
                        <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="c1"># This file was automatically generated by SWIG (http://www.swig.org).</span>
<span class="c1"># Version 4.0.2</span>
<span class="c1">#</span>
<span class="c1"># Do not make changes to this file unless you know what you are doing--modify</span>
<span class="c1"># the SWIG interface file instead.</span>

<span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="n">version_info</span> <span class="k">as</span> <span class="n">_swig_python_version_info</span>
<span class="k">if</span> <span class="n">_swig_python_version_info</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Python 2.7 or later required&quot;</span><span class="p">)</span>

<span class="c1"># Import the low-level C/C++ module</span>
<span class="k">if</span> <span class="n">__package__</span> <span class="ow">or</span> <span class="s2">&quot;.&quot;</span> <span class="ow">in</span> <span class="vm">__name__</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_pywrapcp</span>
<span class="k">else</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">_pywrapcp</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">builtins</span> <span class="k">as</span> <span class="nn">__builtin__</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">__builtin__</span>

<span class="k">def</span> <span class="nf">_swig_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">strthis</span> <span class="o">=</span> <span class="s2">&quot;proxy of &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
    <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
        <span class="n">strthis</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">; </span><span class="si">%s</span><span class="s2"> &gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">strthis</span><span class="p">,)</span>


<span class="k">def</span> <span class="nf">_swig_setattr_nondynamic_instance_variable</span><span class="p">(</span><span class="nb">set</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">set_instance_attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;thisown&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;this&quot;</span><span class="p">:</span>
            <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">name</span><span class="p">),</span> <span class="nb">property</span><span class="p">):</span>
            <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;You cannot add instance attributes to </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">set_instance_attr</span>


<span class="k">def</span> <span class="nf">_swig_setattr_nondynamic_class_variable</span><span class="p">(</span><span class="nb">set</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">set_class_attr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">),</span> <span class="nb">property</span><span class="p">):</span>
            <span class="nb">set</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;You cannot add class attributes to </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">cls</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">set_class_attr</span>


<span class="k">def</span> <span class="nf">_swig_add_metaclass</span><span class="p">(</span><span class="n">metaclass</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">metaclass</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">wrapper</span>


<span class="k">class</span> <span class="nc">_SwigNonDynamicMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Meta class to enforce nondynamic attributes (no new attributes) for a class&quot;&quot;&quot;</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="n">_swig_setattr_nondynamic_class_variable</span><span class="p">(</span><span class="nb">type</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">)</span>


<span class="kn">import</span> <span class="nn">weakref</span>

<span class="k">class</span> <span class="nc">DefaultPhaseParameters</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This struct holds all parameters for the default search.</span>
<span class="sd">    DefaultPhaseParameters is only used by Solver::MakeDefaultPhase methods.</span>
<span class="sd">    Note this is for advanced users only.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>
    <span class="n">CHOOSE_MAX_SUM_IMPACT</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_CHOOSE_MAX_SUM_IMPACT</span>
    <span class="n">CHOOSE_MAX_AVERAGE_IMPACT</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_CHOOSE_MAX_AVERAGE_IMPACT</span>
    <span class="n">CHOOSE_MAX_VALUE_IMPACT</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_CHOOSE_MAX_VALUE_IMPACT</span>
    <span class="n">SELECT_MIN_IMPACT</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_SELECT_MIN_IMPACT</span>
    <span class="n">SELECT_MAX_IMPACT</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_SELECT_MAX_IMPACT</span>
    <span class="n">NONE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_NONE</span>
    <span class="n">NORMAL</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_NORMAL</span>
    <span class="n">VERBOSE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_VERBOSE</span>
    <span class="n">var_selection_schema</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_var_selection_schema_get</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_var_selection_schema_set</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    This parameter describes how the next variable to instantiate</span>
<span class="s2">    will be chosen.</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">value_selection_schema</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_value_selection_schema_get</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_value_selection_schema_set</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot; This parameter describes which value to select for a given var.&quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">initialization_splits</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_initialization_splits_get</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_initialization_splits_set</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    Maximum number of intervals that the initialization of impacts will scan</span>
<span class="s2">    per variable.</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">run_all_heuristics</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_run_all_heuristics_get</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_run_all_heuristics_set</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    The default phase will run heuristics periodically. This parameter</span>
<span class="s2">    indicates if we should run all heuristics, or a randomly selected</span>
<span class="s2">    one.</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">heuristic_period</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_heuristic_period_get</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_heuristic_period_set</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    The distance in nodes between each run of the heuristics. A</span>
<span class="s2">    negative or null value will mean that we will not run heuristics</span>
<span class="s2">    at all.</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">heuristic_num_failures_limit</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_heuristic_num_failures_limit_get</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_heuristic_num_failures_limit_set</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot; The failure limit for each heuristic that we run.&quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">persistent_impact</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_persistent_impact_get</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_persistent_impact_set</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    Whether to keep the impact from the first search for other searches,</span>
<span class="s2">    or to recompute the impact for each new search.</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">random_seed</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_random_seed_get</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_random_seed_set</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot; Seed used to initialize the random part in some heuristics.&quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">display_level</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_display_level_get</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_display_level_set</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    This represents the amount of information displayed by the default search.</span>
<span class="s2">    NONE means no display, VERBOSE means extra information.</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">decision_builder</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_decision_builder_get</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_decision_builder_set</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot; When defined, this overrides the default impact based decision builder.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_DefaultPhaseParameters</span><span class="p">())</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_DefaultPhaseParameters</span>

<span class="c1"># Register DefaultPhaseParameters in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_swigregister</span><span class="p">(</span><span class="n">DefaultPhaseParameters</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Solver</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solver Class</span>

<span class="sd">    A solver represents the main computation engine. It implements the entire</span>
<span class="sd">    range of Constraint Programming protocols:</span>
<span class="sd">      - Reversibility</span>
<span class="sd">      - Propagation</span>
<span class="sd">      - Search</span>

<span class="sd">    Usually, Constraint Programming code consists of</span>
<span class="sd">      - the creation of the Solver,</span>
<span class="sd">      - the creation of the decision variables of the model,</span>
<span class="sd">      - the creation of the constraints of the model and their addition to the</span>
<span class="sd">        solver() through the AddConstraint() method,</span>
<span class="sd">      - the creation of the main DecisionBuilder class,</span>
<span class="sd">      - the launch of the solve() method with the decision builder.</span>

<span class="sd">    For the time being, Solver is neither MT_SAFE nor MT_HOT.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>
    <span class="n">INT_VAR_DEFAULT</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_INT_VAR_DEFAULT</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; The default behavior is CHOOSE_FIRST_UNBOUND.&quot;&quot;&quot;</span>
    <span class="n">INT_VAR_SIMPLE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_INT_VAR_SIMPLE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; The simple selection is CHOOSE_FIRST_UNBOUND.&quot;&quot;&quot;</span>
    <span class="n">CHOOSE_FIRST_UNBOUND</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_CHOOSE_FIRST_UNBOUND</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Select the first unbound variable.</span>
<span class="sd">    Variables are considered in the order of the vector of IntVars used</span>
<span class="sd">    to create the selector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CHOOSE_RANDOM</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_CHOOSE_RANDOM</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Randomly select one of the remaining unbound variables.&quot;&quot;&quot;</span>
    <span class="n">CHOOSE_MIN_SIZE_LOWEST_MIN</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_CHOOSE_MIN_SIZE_LOWEST_MIN</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Among unbound variables, select the variable with the smallest size,</span>
<span class="sd">    i.e., the smallest number of possible values.</span>
<span class="sd">    In case of a tie, the selected variables is the one with the lowest min</span>
<span class="sd">    value.</span>
<span class="sd">    In case of a tie, the first one is selected, first being defined by the</span>
<span class="sd">    order in the vector of IntVars used to create the selector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CHOOSE_MIN_SIZE_HIGHEST_MIN</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_CHOOSE_MIN_SIZE_HIGHEST_MIN</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Among unbound variables, select the variable with the smallest size,</span>
<span class="sd">    i.e., the smallest number of possible values.</span>
<span class="sd">    In case of a tie, the selected variable is the one with the highest min</span>
<span class="sd">    value.</span>
<span class="sd">    In case of a tie, the first one is selected, first being defined by the</span>
<span class="sd">    order in the vector of IntVars used to create the selector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CHOOSE_MIN_SIZE_LOWEST_MAX</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_CHOOSE_MIN_SIZE_LOWEST_MAX</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Among unbound variables, select the variable with the smallest size,</span>
<span class="sd">    i.e., the smallest number of possible values.</span>
<span class="sd">    In case of a tie, the selected variables is the one with the lowest max</span>
<span class="sd">    value.</span>
<span class="sd">    In case of a tie, the first one is selected, first being defined by the</span>
<span class="sd">    order in the vector of IntVars used to create the selector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CHOOSE_MIN_SIZE_HIGHEST_MAX</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_CHOOSE_MIN_SIZE_HIGHEST_MAX</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Among unbound variables, select the variable with the smallest size,</span>
<span class="sd">    i.e., the smallest number of possible values.</span>
<span class="sd">    In case of a tie, the selected variable is the one with the highest max</span>
<span class="sd">    value.</span>
<span class="sd">    In case of a tie, the first one is selected, first being defined by the</span>
<span class="sd">    order in the vector of IntVars used to create the selector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CHOOSE_LOWEST_MIN</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_CHOOSE_LOWEST_MIN</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Among unbound variables, select the variable with the smallest minimal</span>
<span class="sd">    value.</span>
<span class="sd">    In case of a tie, the first one is selected, &quot;first&quot; defined by the</span>
<span class="sd">    order in the vector of IntVars used to create the selector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CHOOSE_HIGHEST_MAX</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_CHOOSE_HIGHEST_MAX</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Among unbound variables, select the variable with the highest maximal</span>
<span class="sd">    value.</span>
<span class="sd">    In case of a tie, the first one is selected, first being defined by the</span>
<span class="sd">    order in the vector of IntVars used to create the selector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CHOOSE_MIN_SIZE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_CHOOSE_MIN_SIZE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Among unbound variables, select the variable with the smallest size.</span>
<span class="sd">    In case of a tie, the first one is selected, first being defined by the</span>
<span class="sd">    order in the vector of IntVars used to create the selector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CHOOSE_MAX_SIZE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_CHOOSE_MAX_SIZE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Among unbound variables, select the variable with the highest size.</span>
<span class="sd">    In case of a tie, the first one is selected, first being defined by the</span>
<span class="sd">    order in the vector of IntVars used to create the selector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CHOOSE_MAX_REGRET_ON_MIN</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_CHOOSE_MAX_REGRET_ON_MIN</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Among unbound variables, select the variable with the largest</span>
<span class="sd">    gap between the first and the second values of the domain.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CHOOSE_PATH</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_CHOOSE_PATH</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Selects the next unbound variable on a path, the path being defined by</span>
<span class="sd">    the variables: var[i] corresponds to the index of the next of i.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">INT_VALUE_DEFAULT</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_INT_VALUE_DEFAULT</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; The default behavior is ASSIGN_MIN_VALUE.&quot;&quot;&quot;</span>
    <span class="n">INT_VALUE_SIMPLE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_INT_VALUE_SIMPLE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; The simple selection is ASSIGN_MIN_VALUE.&quot;&quot;&quot;</span>
    <span class="n">ASSIGN_MIN_VALUE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ASSIGN_MIN_VALUE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Selects the min value of the selected variable.&quot;&quot;&quot;</span>
    <span class="n">ASSIGN_MAX_VALUE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ASSIGN_MAX_VALUE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Selects the max value of the selected variable.&quot;&quot;&quot;</span>
    <span class="n">ASSIGN_RANDOM_VALUE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ASSIGN_RANDOM_VALUE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Selects randomly one of the possible values of the selected variable.&quot;&quot;&quot;</span>
    <span class="n">ASSIGN_CENTER_VALUE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ASSIGN_CENTER_VALUE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Selects the first possible value which is the closest to the center</span>
<span class="sd">    of the domain of the selected variable.</span>
<span class="sd">    The center is defined as (min + max) / 2.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">SPLIT_LOWER_HALF</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SPLIT_LOWER_HALF</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Split the domain in two around the center, and choose the lower</span>
<span class="sd">    part first.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">SPLIT_UPPER_HALF</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SPLIT_UPPER_HALF</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Split the domain in two around the center, and choose the lower</span>
<span class="sd">    part first.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">SEQUENCE_DEFAULT</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SEQUENCE_DEFAULT</span>
    <span class="n">SEQUENCE_SIMPLE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SEQUENCE_SIMPLE</span>
    <span class="n">CHOOSE_MIN_SLACK_RANK_FORWARD</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_CHOOSE_MIN_SLACK_RANK_FORWARD</span>
    <span class="n">CHOOSE_RANDOM_RANK_FORWARD</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_CHOOSE_RANDOM_RANK_FORWARD</span>
    <span class="n">INTERVAL_DEFAULT</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_INTERVAL_DEFAULT</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; The default is INTERVAL_SET_TIMES_FORWARD.&quot;&quot;&quot;</span>
    <span class="n">INTERVAL_SIMPLE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_INTERVAL_SIMPLE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; The simple is INTERVAL_SET_TIMES_FORWARD.&quot;&quot;&quot;</span>
    <span class="n">INTERVAL_SET_TIMES_FORWARD</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_INTERVAL_SET_TIMES_FORWARD</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Selects the variable with the lowest starting time of all variables,</span>
<span class="sd">    and fixes its starting time to this lowest value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">INTERVAL_SET_TIMES_BACKWARD</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_INTERVAL_SET_TIMES_BACKWARD</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Selects the variable with the highest ending time of all variables,</span>
<span class="sd">    and fixes the ending time to this highest values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">TWOOPT</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_TWOOPT</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Operator which reverses a sub-chain of a path. It is called TwoOpt</span>
<span class="sd">    because it breaks two arcs on the path; resulting paths are called</span>
<span class="sd">    two-optimal.</span>
<span class="sd">    Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</span>
<span class="sd">    (where (1, 5) are first and last nodes of the path and can therefore not</span>
<span class="sd">    be moved):</span>
<span class="sd">      1 -&gt; [3 -&gt; 2] -&gt; 4  -&gt; 5</span>
<span class="sd">      1 -&gt; [4 -&gt; 3  -&gt; 2] -&gt; 5</span>
<span class="sd">      1 -&gt;  2 -&gt; [4 -&gt; 3] -&gt; 5</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">OROPT</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_OROPT</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Relocate: OROPT and RELOCATE.</span>
<span class="sd">    Operator which moves a sub-chain of a path to another position; the</span>
<span class="sd">    specified chain length is the fixed length of the chains being moved.</span>
<span class="sd">    When this length is 1, the operator simply moves a node to another</span>
<span class="sd">    position.</span>
<span class="sd">    Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5, for a chain</span>
<span class="sd">    length of 2 (where (1, 5) are first and last nodes of the path and can</span>
<span class="sd">    therefore not be moved):</span>
<span class="sd">      1 -&gt;  4 -&gt; [2 -&gt; 3] -&gt; 5</span>
<span class="sd">      1 -&gt; [3 -&gt; 4] -&gt; 2  -&gt; 5</span>

<span class="sd">    Using Relocate with chain lengths of 1, 2 and 3 together is equivalent</span>
<span class="sd">    to the OrOpt operator on a path. The OrOpt operator is a limited</span>
<span class="sd">     version of 3Opt (breaks 3 arcs on a path).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">RELOCATE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_RELOCATE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Relocate neighborhood with length of 1 (see OROPT comment).&quot;&quot;&quot;</span>
    <span class="n">EXCHANGE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_EXCHANGE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Operator which exchanges the positions of two nodes.</span>
<span class="sd">    Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</span>
<span class="sd">    (where (1, 5) are first and last nodes of the path and can therefore not</span>
<span class="sd">    be moved):</span>
<span class="sd">      1 -&gt; [3] -&gt; [2] -&gt;  4  -&gt; 5</span>
<span class="sd">      1 -&gt; [4] -&gt;  3  -&gt; [2] -&gt; 5</span>
<span class="sd">      1 -&gt;  2  -&gt; [4] -&gt; [3] -&gt; 5</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CROSS</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_CROSS</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Operator which cross exchanges the starting chains of 2 paths, including</span>
<span class="sd">    exchanging the whole paths.</span>
<span class="sd">    First and last nodes are not moved.</span>
<span class="sd">    Possible neighbors for the paths 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 and 6 -&gt; 7 -&gt; 8</span>
<span class="sd">    (where (1, 5) and (6, 8) are first and last nodes of the paths and can</span>
<span class="sd">    therefore not be moved):</span>
<span class="sd">      1 -&gt; [7] -&gt; 3 -&gt; 4 -&gt; 5  6 -&gt; [2] -&gt; 8</span>
<span class="sd">      1 -&gt; [7] -&gt; 4 -&gt; 5       6 -&gt; [2 -&gt; 3] -&gt; 8</span>
<span class="sd">      1 -&gt; [7] -&gt; 5            6 -&gt; [2 -&gt; 3 -&gt; 4] -&gt; 8</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">MAKEACTIVE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_MAKEACTIVE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Operator which inserts an inactive node into a path.</span>
<span class="sd">    Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive</span>
<span class="sd">    (where 1 and 4 are first and last nodes of the path) are:</span>
<span class="sd">      1 -&gt; [5] -&gt;  2  -&gt;  3  -&gt; 4</span>
<span class="sd">      1 -&gt;  2  -&gt; [5] -&gt;  3  -&gt; 4</span>
<span class="sd">      1 -&gt;  2  -&gt;  3  -&gt; [5] -&gt; 4</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">MAKEINACTIVE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_MAKEINACTIVE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Operator which makes path nodes inactive.</span>
<span class="sd">    Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 (where 1 and 4 are</span>
<span class="sd">    first and last nodes of the path) are:</span>
<span class="sd">      1 -&gt; 3 -&gt; 4 with 2 inactive</span>
<span class="sd">      1 -&gt; 2 -&gt; 4 with 3 inactive</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">MAKECHAININACTIVE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_MAKECHAININACTIVE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Operator which makes a &quot;chain&quot; of path nodes inactive.</span>
<span class="sd">    Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 (where 1 and 4 are</span>
<span class="sd">    first and last nodes of the path) are:</span>
<span class="sd">      1 -&gt; 3 -&gt; 4 with 2 inactive</span>
<span class="sd">      1 -&gt; 2 -&gt; 4 with 3 inactive</span>
<span class="sd">      1 -&gt; 4 with 2 and 3 inactive</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">SWAPACTIVE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SWAPACTIVE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Operator which replaces an active node by an inactive one.</span>
<span class="sd">    Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive</span>
<span class="sd">    (where 1 and 4 are first and last nodes of the path) are:</span>
<span class="sd">      1 -&gt; [5] -&gt;  3  -&gt; 4 with 2 inactive</span>
<span class="sd">      1 -&gt;  2  -&gt; [5] -&gt; 4 with 3 inactive</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">EXTENDEDSWAPACTIVE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_EXTENDEDSWAPACTIVE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Operator which makes an inactive node active and an active one inactive.</span>
<span class="sd">    It is similar to SwapActiveOperator except that it tries to insert the</span>
<span class="sd">    inactive node in all possible positions instead of just the position of</span>
<span class="sd">    the node made inactive.</span>
<span class="sd">    Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive</span>
<span class="sd">    (where 1 and 4 are first and last nodes of the path) are:</span>
<span class="sd">      1 -&gt; [5] -&gt;  3  -&gt; 4 with 2 inactive</span>
<span class="sd">      1 -&gt;  3  -&gt; [5] -&gt; 4 with 2 inactive</span>
<span class="sd">      1 -&gt; [5] -&gt;  2  -&gt; 4 with 3 inactive</span>
<span class="sd">      1 -&gt;  2  -&gt; [5] -&gt; 4 with 3 inactive</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">PATHLNS</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_PATHLNS</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Operator which relaxes two sub-chains of three consecutive arcs each.</span>
<span class="sd">    Each sub-chain is defined by a start node and the next three arcs. Those</span>
<span class="sd">    six arcs are relaxed to build a new neighbor.</span>
<span class="sd">    PATHLNS explores all possible pairs of starting nodes and so defines</span>
<span class="sd">    n^2 neighbors, n being the number of nodes.</span>
<span class="sd">    Note that the two sub-chains can be part of the same path; they even may</span>
<span class="sd">    overlap.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">FULLPATHLNS</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_FULLPATHLNS</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Operator which relaxes one entire path and all inactive nodes, thus</span>
<span class="sd">    defining num_paths neighbors.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">UNACTIVELNS</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_UNACTIVELNS</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Operator which relaxes all inactive nodes and one sub-chain of six</span>
<span class="sd">    consecutive arcs. That way the path can be improved by inserting</span>
<span class="sd">    inactive nodes or swapping arcs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">INCREMENT</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_INCREMENT</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Operator which defines one neighbor per variable. Each neighbor tries to</span>
<span class="sd">    increment by one the value of the corresponding variable. When a new</span>
<span class="sd">    solution is found the neighborhood is rebuilt from scratch, i.e., tries</span>
<span class="sd">    to increment values in the variable order.</span>
<span class="sd">    Consider for instance variables x and y. x is incremented one by one to</span>
<span class="sd">    its max, and when it is not possible to increment x anymore, y is</span>
<span class="sd">    incremented once. If this is a solution, then next neighbor tries to</span>
<span class="sd">    increment x.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">DECREMENT</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_DECREMENT</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Operator which defines a neighborhood to decrement values.</span>
<span class="sd">    The behavior is the same as INCREMENT, except values are decremented</span>
<span class="sd">    instead of incremented.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">SIMPLELNS</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SIMPLELNS</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Operator which defines one neighbor per variable. Each neighbor relaxes</span>
<span class="sd">    one variable.</span>
<span class="sd">    When a new solution is found the neighborhood is rebuilt from scratch.</span>
<span class="sd">    Consider for instance variables x and y. First x is relaxed and the</span>
<span class="sd">    solver is looking for the best possible solution (with only x relaxed).</span>
<span class="sd">    Then y is relaxed, and the solver is looking for a new solution.</span>
<span class="sd">    If a new solution is found, then the next variable to be relaxed is x.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">GE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_GE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Move is accepted when the current objective value &gt;= objective.Min.&quot;&quot;&quot;</span>
    <span class="n">LE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_LE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Move is accepted when the current objective value &lt;= objective.Max.&quot;&quot;&quot;</span>
    <span class="n">EQ</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_EQ</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Move is accepted when the current objective value is in the interval</span>
<span class="sd">    objective.Min .. objective.Max.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">DELAYED_PRIORITY</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_DELAYED_PRIORITY</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    DELAYED_PRIORITY is the lowest priority: Demons will be processed after</span>
<span class="sd">    VAR_PRIORITY and NORMAL_PRIORITY demons.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">VAR_PRIORITY</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_VAR_PRIORITY</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; VAR_PRIORITY is between DELAYED_PRIORITY and NORMAL_PRIORITY.&quot;&quot;&quot;</span>
    <span class="n">NORMAL_PRIORITY</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_NORMAL_PRIORITY</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; NORMAL_PRIORITY is the highest priority: Demons will be processed first.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_Solver</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__python_constraints</span> <span class="o">=</span> <span class="p">[]</span>



    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_Solver</span>

    <span class="k">def</span> <span class="nf">Parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::ConstraintSolverParameters&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Stored Parameters.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">DefaultSolverParameters</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::ConstraintSolverParameters&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Create a ConstraintSolverParameters proto with all the default values.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_DefaultSolverParameters</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">AddConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="s2">&quot;Constraint&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds the constraint &#39;c&#39; to the model.</span>

<span class="sd">        After calling this method, and until there is a backtrack that undoes the</span>
<span class="sd">        addition, any assignment of variables to values must satisfy the given</span>
<span class="sd">        constraint in order to be considered feasible. There are two fairly</span>
<span class="sd">        different use cases:</span>

<span class="sd">        - the most common use case is modeling: the given constraint is really</span>
<span class="sd">        part of the problem that the user is trying to solve. In this use case,</span>
<span class="sd">        AddConstraint is called outside of search (i.e., with state() ==</span>
<span class="sd">        OUTSIDE_SEARCH). Most users should only use AddConstraint in this</span>
<span class="sd">        way. In this case, the constraint will belong to the model forever: it</span>
<span class="sd">        cannot not be removed by backtracking.</span>

<span class="sd">        - a rarer use case is that &#39;c&#39; is not a real constraint of the model. It</span>
<span class="sd">        may be a constraint generated by a branching decision (a constraint whose</span>
<span class="sd">        goal is to restrict the search space), a symmetry breaking constraint (a</span>
<span class="sd">        constraint that does restrict the search space, but in a way that cannot</span>
<span class="sd">        have an impact on the quality of the solutions in the subtree), or an</span>
<span class="sd">        inferred constraint that, while having no semantic value to the model (it</span>
<span class="sd">        does not restrict the set of solutions), is worth having because we</span>
<span class="sd">        believe it may strengthen the propagation. In these cases, it happens</span>
<span class="sd">        that the constraint is added during the search (i.e., with state() ==</span>
<span class="sd">        IN_SEARCH or state() == IN_ROOT_NODE). When a constraint is</span>
<span class="sd">        added during a search, it applies only to the subtree of the search tree</span>
<span class="sd">        rooted at the current node, and will be automatically removed by</span>
<span class="sd">        backtracking.</span>

<span class="sd">        This method does not take ownership of the constraint. If the constraint</span>
<span class="sd">        has been created by any factory method (Solver::MakeXXX), it will</span>
<span class="sd">        automatically be deleted. However, power users who implement their own</span>
<span class="sd">        constraints should do: solver.AddConstraint(solver.RevAlloc(new</span>
<span class="sd">        MyConstraint(...));</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_AddConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NewSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_NewSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NextSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_NextSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RestartSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_RestartSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_EndSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SolveAndCommit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SolveAndCommit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">CheckAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solution</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Checks whether the given assignment satisfies all relevant constraints.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_CheckAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solution</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">CheckConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ct</span><span class="p">:</span> <span class="s2">&quot;Constraint&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether adding this constraint will lead to an immediate</span>
<span class="sd">        failure. It will return false if the model is already inconsistent, or if</span>
<span class="sd">        adding the constraint makes it inconsistent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_CheckConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ct</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Fail</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Abandon the current branch in the search tree. A backtrack will follow.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Fail</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">MemoryUsage</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Current memory usage in bytes&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_MemoryUsage</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">WallTime</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        DEPRECATED: Use Now() instead.</span>
<span class="sd">        Time elapsed, in ms since the creation of the solver.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_WallTime</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Branches</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; The number of branches explored since the creation of the solver.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Branches</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Solutions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; The number of solutions found since the start of the search.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Solutions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Failures</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; The number of failures encountered since the creation of the solver.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Failures</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AcceptedNeighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; The number of accepted neighbors.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_AcceptedNeighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Stamp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;uint64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The stamp indicates how many moves in the search tree we have performed.</span>
<span class="sd">        It is useful to detect if we need to update same lazy structures.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Stamp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">FailStamp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;uint64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; The fail_stamp() is incremented after each backtrack.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_FailStamp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IntVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        MakeIntVar will create the best range based int var for the bounds given.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        MakeIntVar will create a variable with the given sparse domain.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 3:*</span>
<span class="sd">        MakeIntVar will create a variable with the given sparse domain.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 4:*</span>
<span class="sd">        MakeIntVar will create the best range based int var for the bounds given.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 5:*</span>
<span class="sd">        MakeIntVar will create a variable with the given sparse domain.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 6:*</span>
<span class="sd">        MakeIntVar will create a variable with the given sparse domain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IntVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">BoolVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        MakeBoolVar will create a variable with a {0, 1} domain.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        MakeBoolVar will create a variable with a {0, 1} domain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_BoolVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IntConst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        IntConst will create a constant expression.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        IntConst will create a constant expression.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IntConst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; sum of all vars.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ScalProd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        scalar product</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        scalar product</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ScalProd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">MonotonicElement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IndexEvaluator1&quot;</span><span class="p">,</span> <span class="n">increasing</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function based element. The constraint takes ownership of the</span>
<span class="sd">        callback.  The callback must be monotonic. It must be able to</span>
<span class="sd">        cope with any possible value in the domain of &#39;index&#39;</span>
<span class="sd">        (potentially negative ones too). Furtermore, monotonicity is not</span>
<span class="sd">        checked. Thus giving a non-monotonic function, or specifying an</span>
<span class="sd">        incorrect increasing parameter will result in undefined behavior.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_MonotonicElement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">increasing</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        values[index]</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        values[index]</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 3:*</span>
<span class="sd">        Function-based element. The constraint takes ownership of the</span>
<span class="sd">        callback. The callback must be able to cope with any possible</span>
<span class="sd">        value in the domain of &#39;index&#39; (potentially negative ones too).</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 4:*</span>
<span class="sd">        2D version of function-based element expression, values(expr1, expr2).</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 5:*</span>
<span class="sd">        vars[expr]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IndexExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the expression expr such that vars[expr] == value.</span>
<span class="sd">        It assumes that vars are all different.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IndexExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        std::min(vars)</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        std::min (left, right)</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 3:*</span>
<span class="sd">        std::min(expr, value)</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 4:*</span>
<span class="sd">        std::min(expr, value)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        std::max(vars)</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        std::max(left, right)</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 3:*</span>
<span class="sd">        std::max(expr, value)</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 4:*</span>
<span class="sd">        std::max(expr, value)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ConvexPiecewiseExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">early_cost</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">early_date</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">late_date</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">late_cost</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Convex piecewise function.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ConvexPiecewiseExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">early_cost</span><span class="p">,</span> <span class="n">early_date</span><span class="p">,</span> <span class="n">late_date</span><span class="p">,</span> <span class="n">late_cost</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SemiContinuousExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">fixed_charge</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">step</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Semi continuous Expression (x &lt;= 0 -&gt; f(x) = 0; x &gt; 0 -&gt; f(x) = ax + b)</span>
<span class="sd">        a &gt;= 0 and b &gt;= 0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SemiContinuousExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">fixed_charge</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ConditionalExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">unperformed_value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Conditional Expr condition ? expr : unperformed_value&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ConditionalExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">unperformed_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">TrueConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This constraint always succeeds.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_TrueConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">FalseConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_FalseConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsEqualCstCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">boolvar</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; boolvar == (var == value)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsEqualCstCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">boolvar</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsEqualCstVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; status var of (var == value)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsEqualCstVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsEqualCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v1</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">v2</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; b == (v1 == v2)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsEqualCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsEqualVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v1</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">v2</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; status var of (v1 == v2)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsEqualVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsDifferentCstCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">boolvar</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; boolvar == (var != value)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsDifferentCstCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">boolvar</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsDifferentCstVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; status var of (var != value)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsDifferentCstVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsDifferentVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v1</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">v2</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; status var of (v1 != v2)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsDifferentVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsDifferentCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v1</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">v2</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; b == (v1 != v2)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsDifferentCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsLessOrEqualCstCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">boolvar</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; boolvar == (var &lt;= value)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsLessOrEqualCstCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">boolvar</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsLessOrEqualCstVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; status var of (var &lt;= value)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsLessOrEqualCstVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsLessOrEqualVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; status var of (left &lt;= right)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsLessOrEqualVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsLessOrEqualCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; b == (left &lt;= right)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsLessOrEqualCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsGreaterOrEqualCstCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">boolvar</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; boolvar == (var &gt;= value)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsGreaterOrEqualCstCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">boolvar</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsGreaterOrEqualCstVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; status var of (var &gt;= value)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsGreaterOrEqualCstVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsGreaterOrEqualVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; status var of (left &gt;= right)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsGreaterOrEqualVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsGreaterOrEqualCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; b == (left &gt;= right)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsGreaterOrEqualCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsGreaterCstCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; b == (v &gt; c)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsGreaterCstCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsGreaterCstVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; status var of (var &gt; value)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsGreaterCstVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsGreaterVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; status var of (left &gt; right)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsGreaterVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsGreaterCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; b == (left &gt; right)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsGreaterCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsLessCstCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; b == (v &lt; c)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsLessCstCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsLessCstVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; status var of (var &lt; value)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsLessCstVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsLessVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; status var of (left &lt; right)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsLessVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsLessCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; b == (left &lt; right)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsLessCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SumLessOrEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">cst</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Variation on arrays.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SumLessOrEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">cst</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SumGreaterOrEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">cst</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SumGreaterOrEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">cst</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SumEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SumEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ScalProdEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ScalProdEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ScalProdGreaterOrEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ScalProdGreaterOrEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ScalProdLessOrEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ScalProdLessOrEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">MinEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">min_var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_MinEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">min_var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">MaxEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">max_var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_MaxEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">max_var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ElementEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ElementEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AbsEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">abs_var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Creates the constraint abs(var) == abs_var.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_AbsEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">abs_var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IndexOfConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This constraint is a special case of the element constraint with</span>
<span class="sd">        an array of integer variables, where the variables are all</span>
<span class="sd">        different and the index variable is constrained such that</span>
<span class="sd">        vars[index] == target.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IndexOfConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ConstraintInitialPropagateCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ct</span><span class="p">:</span> <span class="s2">&quot;Constraint&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Demon *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is a specialized case of the MakeConstraintDemon</span>
<span class="sd">        method to call the InitiatePropagate of the constraint &#39;ct&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ConstraintInitialPropagateCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ct</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DelayedConstraintInitialPropagateCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ct</span><span class="p">:</span> <span class="s2">&quot;Constraint&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Demon *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is a specialized case of the MakeConstraintDemon</span>
<span class="sd">        method to call the InitiatePropagate of the constraint &#39;ct&#39; with</span>
<span class="sd">        low priority.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_DelayedConstraintInitialPropagateCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ct</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ClosureDemon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">closure</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::Closure&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Demon *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Creates a demon from a closure.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ClosureDemon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">closure</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">BetweenCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; (l &lt;= expr &lt;= u)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_BetweenCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsBetweenCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; b == (l &lt;= expr &lt;= u)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsBetweenCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsBetweenVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsBetweenVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">MemberCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_MemberCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NotMemberCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        expr not in set.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        expr should not be in the list of forbidden intervals [start[i]..end[i]].</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 3:*</span>
<span class="sd">        expr should not be in the list of forbidden intervals [start[i]..end[i]].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_NotMemberCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsMemberCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsMemberCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsMemberVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsMemberVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        |{i | vars[i] == value}| == max_count</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        |{i | vars[i] == value}| == max_count</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Distribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Aggregated version of count:  |{i | v[i] == values[j]}| == cards[j]</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Aggregated version of count:  |{i | v[i] == values[j]}| == cards[j]</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 3:*</span>
<span class="sd">        Aggregated version of count:  |{i | v[i] == j}| == cards[j]</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 4:*</span>
<span class="sd">        Aggregated version of count with bounded cardinalities:</span>
<span class="sd">        forall j in 0 .. card_size - 1: card_min &lt;= |{i | v[i] == j}| &lt;= card_max</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 5:*</span>
<span class="sd">        Aggregated version of count with bounded cardinalities:</span>
<span class="sd">        forall j in 0 .. card_size - 1:</span>
<span class="sd">           card_min[j] &lt;= |{i | v[i] == j}| &lt;= card_max[j]</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 6:*</span>
<span class="sd">        Aggregated version of count with bounded cardinalities:</span>
<span class="sd">        forall j in 0 .. card_size - 1:</span>
<span class="sd">           card_min[j] &lt;= |{i | v[i] == j}| &lt;= card_max[j]</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 7:*</span>
<span class="sd">        Aggregated version of count with bounded cardinalities:</span>
<span class="sd">        forall j in 0 .. card_size - 1:</span>
<span class="sd">           card_min[j] &lt;= |{i | v[i] == values[j]}| &lt;= card_max[j]</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 8:*</span>
<span class="sd">        Aggregated version of count with bounded cardinalities:</span>
<span class="sd">        forall j in 0 .. card_size - 1:</span>
<span class="sd">           card_min[j] &lt;= |{i | v[i] == values[j]}| &lt;= card_max[j]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Distribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Deviation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">deviation_var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">total_sum</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deviation constraint:</span>
<span class="sd">        sum_i |n * vars[i] - total_sum| &lt;= deviation_var and</span>
<span class="sd">        sum_i vars[i] == total_sum</span>
<span class="sd">        n = #vars</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Deviation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">deviation_var</span><span class="p">,</span> <span class="n">total_sum</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AllDifferent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        All variables are pairwise different. This corresponds to the</span>
<span class="sd">        stronger version of the propagation algorithm.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        All variables are pairwise different.  If &#39;stronger_propagation&#39;</span>
<span class="sd">        is true, stronger, and potentially slower propagation will</span>
<span class="sd">        occur. This API will be deprecated in the future.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_AllDifferent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AllDifferentExcept</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">escape_value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        All variables are pairwise different, unless they are assigned to</span>
<span class="sd">        the escape value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_AllDifferentExcept</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">escape_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SortingConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a constraint binding the arrays of variables &quot;vars&quot; and</span>
<span class="sd">        &quot;sorted_vars&quot;: sorted_vars[0] must be equal to the minimum of all</span>
<span class="sd">        variables in vars, and so on: the value of sorted_vars[i] must be</span>
<span class="sd">        equal to the i-th value of variables invars.</span>

<span class="sd">        This constraint propagates in both directions: from &quot;vars&quot; to</span>
<span class="sd">        &quot;sorted_vars&quot; and vice-versa.</span>

<span class="sd">        Behind the scenes, this constraint maintains that:</span>
<span class="sd">          - sorted is always increasing.</span>
<span class="sd">          - whatever the values of vars, there exists a permutation that</span>
<span class="sd">            injects its values into the sorted variables.</span>

<span class="sd">        For more info, please have a look at:</span>
<span class="sd">          https://mpi-inf.mpg.de/~mehlhorn/ftp/Mehlhorn-Thiel.pdf</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SortingConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">LexicalLess</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a constraint that enforces that left is lexicographically less</span>
<span class="sd">        than right.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_LexicalLess</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">LexicalLessOrEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a constraint that enforces that left is lexicographically less</span>
<span class="sd">        than or equal to right.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_LexicalLessOrEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">InversePermutationConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a constraint that enforces that &#39;left&#39; and &#39;right&#39; both</span>
<span class="sd">        represent permutations of [0..left.size()-1], and that &#39;right&#39; is</span>
<span class="sd">        the inverse permutation of &#39;left&#39;, i.e. for all i in</span>
<span class="sd">        [0..left.size()-1], right[left[i]] = i.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_InversePermutationConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NullIntersect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">second_vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a constraint that states that all variables in the first</span>
<span class="sd">        vector are different from all variables in the second</span>
<span class="sd">        group. Thus the set of values in the first vector does not</span>
<span class="sd">        intersect with the set of values in the second vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_NullIntersect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_vars</span><span class="p">,</span> <span class="n">second_vars</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NullIntersectExcept</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">second_vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">escape_value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a constraint that states that all variables in the first</span>
<span class="sd">        vector are different from all variables from the second group,</span>
<span class="sd">        unless they are assigned to the escape value. Thus the set of</span>
<span class="sd">        values in the first vector minus the escape value does not</span>
<span class="sd">        intersect with the set of values in the second vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_NullIntersectExcept</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_vars</span><span class="p">,</span> <span class="n">second_vars</span><span class="p">,</span> <span class="n">escape_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Circuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nexts</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Force the &quot;nexts&quot; variable to create a complete Hamiltonian path.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Circuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nexts</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SubCircuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nexts</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Force the &quot;nexts&quot; variable to create a complete Hamiltonian path</span>
<span class="sd">        for those that do not loop upon themselves.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SubCircuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nexts</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DelayedPathCumul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nexts</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">active</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">cumuls</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">transits</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delayed version of the same constraint: propagation on the nexts variables</span>
<span class="sd">        is delayed until all constraints have propagated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_DelayedPathCumul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nexts</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">cumuls</span><span class="p">,</span> <span class="n">transits</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">PathCumul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Creates a constraint which accumulates values along a path such that:</span>
<span class="sd">        cumuls[next[i]] = cumuls[i] + transits[i].</span>
<span class="sd">        Active variables indicate if the corresponding next variable is active;</span>
<span class="sd">        this could be useful to model unperformed nodes in a routing problem.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Creates a constraint which accumulates values along a path such that:</span>
<span class="sd">        cumuls[next[i]] = cumuls[i] + transit_evaluator(i, next[i]).</span>
<span class="sd">        Active variables indicate if the corresponding next variable is active;</span>
<span class="sd">        this could be useful to model unperformed nodes in a routing problem.</span>
<span class="sd">        Ownership of transit_evaluator is taken and it must be a repeatable</span>
<span class="sd">        callback.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 3:*</span>
<span class="sd">        Creates a constraint which accumulates values along a path such that:</span>
<span class="sd">        cumuls[next[i]] = cumuls[i] + transit_evaluator(i, next[i]) + slacks[i].</span>
<span class="sd">        Active variables indicate if the corresponding next variable is active;</span>
<span class="sd">        this could be useful to model unperformed nodes in a routing problem.</span>
<span class="sd">        Ownership of transit_evaluator is taken and it must be a repeatable</span>
<span class="sd">        callback.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_PathCumul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AllowedAssignments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        This method creates a constraint where the graph of the relation</span>
<span class="sd">        between the variables is given in extension. There are &#39;arity&#39;</span>
<span class="sd">        variables involved in the relation and the graph is given by a</span>
<span class="sd">        integer tuple set.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Compatibility layer for Python API.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_AllowedAssignments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">TransitionConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_TransitionConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NonOverlappingBoxesConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_NonOverlappingBoxesConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Pack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">number_of_bins</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Pack *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This constraint packs all variables onto &#39;number_of_bins&#39;</span>
<span class="sd">        variables.  For any given variable, a value of &#39;number_of_bins&#39;</span>
<span class="sd">        indicates that the variable is not assigned to any bin.</span>
<span class="sd">        Dimensions, i.e., cumulative constraints on this packing, can be</span>
<span class="sd">        added directly from the pack class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Pack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">number_of_bins</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">FixedDurationIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntervalVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Creates an interval var with a fixed duration. The duration must</span>
<span class="sd">        be greater than 0. If optional is true, then the interval can be</span>
<span class="sd">        performed or unperformed. If optional is false, then the interval</span>
<span class="sd">        is always performed.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Creates a performed interval var with a fixed duration. The duration must</span>
<span class="sd">        be greater than 0.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 3:*</span>
<span class="sd">        Creates an interval var with a fixed duration, and performed_variable.</span>
<span class="sd">        The duration must be greater than 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_FixedDurationIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">FixedInterval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">duration</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntervalVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Creates a fixed and performed interval.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_FixedInterval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_min</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">start_max</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">duration_min</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">duration_max</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">end_min</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">end_max</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">optional</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntervalVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates an interval var by specifying the bounds on start,</span>
<span class="sd">        duration, and end.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_min</span><span class="p">,</span> <span class="n">start_max</span><span class="p">,</span> <span class="n">duration_min</span><span class="p">,</span> <span class="n">duration_max</span><span class="p">,</span> <span class="n">end_min</span><span class="p">,</span> <span class="n">end_max</span><span class="p">,</span> <span class="n">optional</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">MirrorInterval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntervalVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates an interval var that is the mirror image of the given one, that</span>
<span class="sd">        is, the interval var obtained by reversing the axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_MirrorInterval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">FixedDurationStartSyncedOnStartIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">duration</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntervalVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates an interval var with a fixed duration whose start is</span>
<span class="sd">        synchronized with the start of another interval, with a given</span>
<span class="sd">        offset. The performed status is also in sync with the performed</span>
<span class="sd">        status of the given interval variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_FixedDurationStartSyncedOnStartIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">FixedDurationStartSyncedOnEndIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">duration</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntervalVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates an interval var with a fixed duration whose start is</span>
<span class="sd">        synchronized with the end of another interval, with a given</span>
<span class="sd">        offset. The performed status is also in sync with the performed</span>
<span class="sd">        status of the given interval variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_FixedDurationStartSyncedOnEndIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">FixedDurationEndSyncedOnStartIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">duration</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntervalVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates an interval var with a fixed duration whose end is</span>
<span class="sd">        synchronized with the start of another interval, with a given</span>
<span class="sd">        offset. The performed status is also in sync with the performed</span>
<span class="sd">        status of the given interval variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_FixedDurationEndSyncedOnStartIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">FixedDurationEndSyncedOnEndIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">duration</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntervalVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates an interval var with a fixed duration whose end is</span>
<span class="sd">        synchronized with the end of another interval, with a given</span>
<span class="sd">        offset. The performed status is also in sync with the performed</span>
<span class="sd">        status of the given interval variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_FixedDurationEndSyncedOnEndIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IntervalRelaxedMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntervalVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         Creates and returns an interval variable that wraps around the given one,</span>
<span class="sd">         relaxing the min start and end. Relaxing means making unbounded when</span>
<span class="sd">         optional. If the variable is non-optional, this method returns</span>
<span class="sd">         interval_var.</span>

<span class="sd">         More precisely, such an interval variable behaves as follows:</span>
<span class="sd">        When the underlying must be performed, the returned interval variable</span>
<span class="sd">             behaves exactly as the underlying;</span>
<span class="sd">        When the underlying may or may not be performed, the returned interval</span>
<span class="sd">             variable behaves like the underlying, except that it is unbounded on</span>
<span class="sd">             the min side;</span>
<span class="sd">        When the underlying cannot be performed, the returned interval variable</span>
<span class="sd">             is of duration 0 and must be performed in an interval unbounded on</span>
<span class="sd">             both sides.</span>

<span class="sd">         This is very useful to implement propagators that may only modify</span>
<span class="sd">         the start max or end max.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IntervalRelaxedMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IntervalRelaxedMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntervalVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         Creates and returns an interval variable that wraps around the given one,</span>
<span class="sd">         relaxing the max start and end. Relaxing means making unbounded when</span>
<span class="sd">         optional. If the variable is non optional, this method returns</span>
<span class="sd">         interval_var.</span>

<span class="sd">         More precisely, such an interval variable behaves as follows:</span>
<span class="sd">        When the underlying must be performed, the returned interval variable</span>
<span class="sd">             behaves exactly as the underlying;</span>
<span class="sd">        When the underlying may or may not be performed, the returned interval</span>
<span class="sd">             variable behaves like the underlying, except that it is unbounded on</span>
<span class="sd">             the max side;</span>
<span class="sd">        When the underlying cannot be performed, the returned interval variable</span>
<span class="sd">             is of duration 0 and must be performed in an interval unbounded on</span>
<span class="sd">             both sides.</span>

<span class="sd">         This is very useful for implementing propagators that may only modify</span>
<span class="sd">         the start min or end min.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IntervalRelaxedMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">TemporalDisjunction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        This constraint implements a temporal disjunction between two</span>
<span class="sd">        interval vars t1 and t2. &#39;alt&#39; indicates which alternative was</span>
<span class="sd">        chosen (alt == 0 is equivalent to t1 before t2).</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        This constraint implements a temporal disjunction between two</span>
<span class="sd">        interval vars.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_TemporalDisjunction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DisjunctiveConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intervals</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntervalVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DisjunctiveConstraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This constraint forces all interval vars into an non-overlapping</span>
<span class="sd">        sequence. Intervals with zero duration can be scheduled anywhere.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_DisjunctiveConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intervals</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Cumulative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        This constraint forces that, for any integer t, the sum of the demands</span>
<span class="sd">        corresponding to an interval containing t does not exceed the given</span>
<span class="sd">        capacity.</span>

<span class="sd">        Intervals and demands should be vectors of equal size.</span>

<span class="sd">        Demands should only contain non-negative values. Zero values are</span>
<span class="sd">        supported, and the corresponding intervals are filtered out, as they</span>
<span class="sd">        neither impact nor are impacted by this constraint.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        This constraint forces that, for any integer t, the sum of the demands</span>
<span class="sd">        corresponding to an interval containing t does not exceed the given</span>
<span class="sd">        capacity.</span>

<span class="sd">        Intervals and demands should be vectors of equal size.</span>

<span class="sd">        Demands should only contain non-negative values. Zero values are</span>
<span class="sd">        supported, and the corresponding intervals are filtered out, as they</span>
<span class="sd">        neither impact nor are impacted by this constraint.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 3:*</span>
<span class="sd">        This constraint forces that, for any integer t, the sum of the demands</span>
<span class="sd">        corresponding to an interval containing t does not exceed the given</span>
<span class="sd">        capacity.</span>

<span class="sd">        Intervals and demands should be vectors of equal size.</span>

<span class="sd">        Demands should only contain non-negative values. Zero values are</span>
<span class="sd">        supported, and the corresponding intervals are filtered out, as they</span>
<span class="sd">        neither impact nor are impacted by this constraint.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 4:*</span>
<span class="sd">        This constraint enforces that, for any integer t, the sum of the demands</span>
<span class="sd">        corresponding to an interval containing t does not exceed the given</span>
<span class="sd">        capacity.</span>

<span class="sd">        Intervals and demands should be vectors of equal size.</span>

<span class="sd">        Demands should only contain non-negative values. Zero values are</span>
<span class="sd">        supported, and the corresponding intervals are filtered out, as they</span>
<span class="sd">        neither impact nor are impacted by this constraint.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 5:*</span>
<span class="sd">        This constraint enforces that, for any integer t, the sum of demands</span>
<span class="sd">        corresponding to an interval containing t does not exceed the given</span>
<span class="sd">        capacity.</span>

<span class="sd">        Intervals and demands should be vectors of equal size.</span>

<span class="sd">        Demands should be positive.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 6:*</span>
<span class="sd">        This constraint enforces that, for any integer t, the sum of demands</span>
<span class="sd">        corresponding to an interval containing t does not exceed the given</span>
<span class="sd">        capacity.</span>

<span class="sd">        Intervals and demands should be vectors of equal size.</span>

<span class="sd">        Demands should be positive.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Cumulative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Cover</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntervalVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">target_var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This constraint states that the target_var is the convex hull of</span>
<span class="sd">        the intervals. If none of the interval variables is performed,</span>
<span class="sd">        then the target var is unperformed too. Also, if the target</span>
<span class="sd">        variable is unperformed, then all the intervals variables are</span>
<span class="sd">        unperformed too.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Cover</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">target_var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Assignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        This method creates an empty assignment.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        This method creates an assignment which is a copy of &#39;a&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Assignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">FirstSolutionCollector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SolutionCollector *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Collect the first solution of the search.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Collect the first solution of the search. The variables will need to</span>
<span class="sd">        be added later.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_FirstSolutionCollector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">LastSolutionCollector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SolutionCollector *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Collect the last solution of the search.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Collect the last solution of the search. The variables will need to</span>
<span class="sd">        be added later.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_LastSolutionCollector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">BestValueSolutionCollector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SolutionCollector *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Collect the solution corresponding to the optimal value of the objective</span>
<span class="sd">        of &#39;assignment&#39;; if &#39;assignment&#39; does not have an objective no solution is</span>
<span class="sd">        collected. This collector only collects one solution corresponding to the</span>
<span class="sd">        best objective value (the first one found).</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Collect the solution corresponding to the optimal value of the</span>
<span class="sd">        objective of &#39;assignment&#39;; if &#39;assignment&#39; does not have an objective no</span>
<span class="sd">        solution is collected. This collector only collects one solution</span>
<span class="sd">        corresponding to the best objective value (the first one</span>
<span class="sd">        found). The variables will need to be added later.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_BestValueSolutionCollector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AllSolutionCollector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SolutionCollector *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Collect all solutions of the search.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Collect all solutions of the search. The variables will need to</span>
<span class="sd">        be added later.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_AllSolutionCollector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Minimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">step</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::OptimizeVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Creates a minimization objective.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Minimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Maximize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">step</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::OptimizeVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Creates a maximization objective.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Maximize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maximize</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">step</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::OptimizeVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Creates a objective with a given sense (true = maximization).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maximize</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WeightedMinimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::OptimizeVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Creates a minimization weighted objective. The actual objective is</span>
<span class="sd">        scalar_prod(sub_objectives, weights).</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Creates a minimization weighted objective. The actual objective is</span>
<span class="sd">        scalar_prod(sub_objectives, weights).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_WeightedMinimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WeightedMaximize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::OptimizeVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Creates a maximization weigthed objective.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Creates a maximization weigthed objective.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_WeightedMaximize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WeightedOptimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::OptimizeVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Creates a weighted objective with a given sense (true = maximization).</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Creates a weighted objective with a given sense (true = maximization).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_WeightedOptimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">TabuSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maximize</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">step</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">keep_tenure</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">forbid_tenure</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">tabu_factor</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SearchMonitor *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        MetaHeuristics which try to get the search out of local optima.</span>
<span class="sd">        Creates a Tabu Search monitor.</span>
<span class="sd">        In the context of local search the behavior is similar to MakeOptimize(),</span>
<span class="sd">        creating an objective in a given sense. The behavior differs once a local</span>
<span class="sd">        optimum is reached: thereafter solutions which degrade the value of the</span>
<span class="sd">        objective are allowed if they are not &quot;tabu&quot;. A solution is &quot;tabu&quot; if it</span>
<span class="sd">        doesn&#39;t respect the following rules:</span>
<span class="sd">        - improving the best solution found so far</span>
<span class="sd">        - variables in the &quot;keep&quot; list must keep their value, variables in the</span>
<span class="sd">        &quot;forbid&quot; list must not take the value they have in the list.</span>
<span class="sd">        Variables with new values enter the tabu lists after each new solution</span>
<span class="sd">        found and leave the lists after a given number of iterations (called</span>
<span class="sd">        tenure). Only the variables passed to the method can enter the lists.</span>
<span class="sd">        The tabu criterion is softened by the tabu factor which gives the number</span>
<span class="sd">        of &quot;tabu&quot; violations which is tolerated; a factor of 1 means no violations</span>
<span class="sd">        allowed; a factor of 0 means all violations are allowed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_TabuSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maximize</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">keep_tenure</span><span class="p">,</span> <span class="n">forbid_tenure</span><span class="p">,</span> <span class="n">tabu_factor</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SimulatedAnnealing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maximize</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">step</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">initial_temperature</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SearchMonitor *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Creates a Simulated Annealing monitor.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SimulatedAnnealing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maximize</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">initial_temperature</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">LubyRestart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale_factor</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SearchMonitor *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This search monitor will restart the search periodically.</span>
<span class="sd">        At the iteration n, it will restart after scale_factor * Luby(n) failures</span>
<span class="sd">        where Luby is the Luby Strategy (i.e. 1 1 2 1 1 2 4 1 1 2 1 1 2 4 8...).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_LubyRestart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale_factor</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ConstantRestart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frequency</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SearchMonitor *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This search monitor will restart the search periodically after &#39;frequency&#39;</span>
<span class="sd">        failures.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ConstantRestart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frequency</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">TimeLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RegularLimit *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_TimeLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">BranchesLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">branches</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RegularLimit *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a search limit that constrains the number of branches</span>
<span class="sd">        explored in the search tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_BranchesLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">branches</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">FailuresLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">failures</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RegularLimit *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a search limit that constrains the number of failures</span>
<span class="sd">        that can happen when exploring the search tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_FailuresLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">failures</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SolutionsLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solutions</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RegularLimit *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a search limit that constrains the number of solutions found</span>
<span class="sd">        during the search.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SolutionsLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solutions</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SearchLimit *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Limits the search with the &#39;time&#39;, &#39;branches&#39;, &#39;failures&#39; and</span>
<span class="sd">        &#39;solutions&#39; limits. &#39;smart_time_check&#39; reduces the calls to the wall</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Creates a search limit from its protobuf description</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 3:*</span>
<span class="sd">        Creates a search limit that is reached when either of the underlying limit</span>
<span class="sd">        is reached. That is, the returned limit is more stringent than both</span>
<span class="sd">        argument limits.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">CustomLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limiter</span><span class="p">:</span> <span class="s2">&quot;std::function&lt; bool () &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SearchLimit *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Callback-based search limit. Search stops when limiter returns true; if</span>
<span class="sd">        this happens at a leaf the corresponding solution will be rejected.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_CustomLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limiter</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SearchLog</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SearchMonitor *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SearchLog</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SearchTrace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SearchMonitor *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a search monitor that will trace precisely the behavior of the</span>
<span class="sd">        search. Use this only for low level debugging.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SearchTrace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">PrintModelVisitor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::ModelVisitor *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Prints the model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_PrintModelVisitor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StatisticsModelVisitor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::ModelVisitor *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Displays some nice statistics on the model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_StatisticsModelVisitor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AssignVariableValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Decision *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Decisions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_AssignVariableValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">VariableLessOrEqualValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Decision *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_VariableLessOrEqualValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">VariableGreaterOrEqualValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Decision *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_VariableGreaterOrEqualValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SplitVariableDomain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">start_with_lower_half</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Decision *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SplitVariableDomain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">start_with_lower_half</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AssignVariableValueOrFail</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Decision *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_AssignVariableValueOrFail</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AssignVariablesValues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Decision *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_AssignVariablesValues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">FailDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Decision *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_FailDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Decision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">apply</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::Action&quot;</span><span class="p">,</span> <span class="n">refute</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::Action&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Decision *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Decision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">apply</span><span class="p">,</span> <span class="n">refute</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Compose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dbs</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::DecisionBuilder * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Compose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dbs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Try</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dbs</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::DecisionBuilder * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Try</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dbs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DefaultPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_DefaultPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ScheduleOrPostpone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">est</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="p">:</span> <span class="s2">&quot;int64_t *const&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Decision *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a decision that tries to schedule a task at a given time.</span>
<span class="sd">        On the Apply branch, it will set that interval var as performed and set</span>
<span class="sd">        its start to &#39;est&#39;. On the Refute branch, it will just update the</span>
<span class="sd">        &#39;marker&#39; to &#39;est&#39; + 1. This decision is used in the</span>
<span class="sd">        INTERVAL_SET_TIMES_FORWARD strategy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ScheduleOrPostpone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">est</span><span class="p">,</span> <span class="n">marker</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ScheduleOrExpedite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">est</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="p">:</span> <span class="s2">&quot;int64_t *const&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Decision *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a decision that tries to schedule a task at a given time.</span>
<span class="sd">        On the Apply branch, it will set that interval var as performed and set</span>
<span class="sd">        its end to &#39;est&#39;. On the Refute branch, it will just update the</span>
<span class="sd">        &#39;marker&#39; to &#39;est&#39; - 1. This decision is used in the</span>
<span class="sd">        INTERVAL_SET_TIMES_BACKWARD strategy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ScheduleOrExpedite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">est</span><span class="p">,</span> <span class="n">marker</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RankFirstInterval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequence</span><span class="p">:</span> <span class="s2">&quot;SequenceVar&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Decision *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a decision that tries to rank first the ith interval var</span>
<span class="sd">        in the sequence variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_RankFirstInterval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequence</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RankLastInterval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequence</span><span class="p">:</span> <span class="s2">&quot;SequenceVar&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Decision *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a decision that tries to rank last the ith interval var</span>
<span class="sd">        in the sequence variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_RankLastInterval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequence</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Phase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Phase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DecisionBuilderFromAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">db</span><span class="p">:</span> <span class="s2">&quot;DecisionBuilder&quot;</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a decision builder for which the left-most leaf corresponds</span>
<span class="sd">        to assignment, the rest of the tree being explored using &#39;db&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_DecisionBuilderFromAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">,</span> <span class="n">db</span><span class="p">,</span> <span class="nb">vars</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ConstraintAdder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ct</span><span class="p">:</span> <span class="s2">&quot;Constraint&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a decision builder that will add the given constraint to</span>
<span class="sd">        the model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ConstraintAdder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ct</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SolveOnce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">db</span><span class="p">:</span> <span class="s2">&quot;DecisionBuilder&quot;</span><span class="p">,</span> <span class="n">monitors</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::SearchMonitor * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SolveOnce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">db</span><span class="p">,</span> <span class="n">monitors</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NestedOptimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_NestedOptimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RestoreAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a DecisionBuilder which restores an Assignment</span>
<span class="sd">        (calls void Assignment::Restore())</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_RestoreAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StoreAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a DecisionBuilder which stores an Assignment</span>
<span class="sd">        (calls void Assignment::Store())</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_StoreAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::LocalSearchOperator *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RandomLnsOperator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::LocalSearchOperator *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_RandomLnsOperator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">MoveTowardTargetOperator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::LocalSearchOperator *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Creates a local search operator that tries to move the assignment of some</span>
<span class="sd">        variables toward a target. The target is given as an Assignment. This</span>
<span class="sd">        operator generates neighbors in which the only difference compared to the</span>
<span class="sd">        current state is that one variable that belongs to the target assignment</span>
<span class="sd">        is set to its target value.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Creates a local search operator that tries to move the assignment of some</span>
<span class="sd">        variables toward a target. The target is given either as two vectors: a</span>
<span class="sd">        vector of variables and a vector of associated target values. The two</span>
<span class="sd">        vectors should be of the same length. This operator generates neighbors in</span>
<span class="sd">        which the only difference compared to the current state is that one</span>
<span class="sd">        variable that belongs to the given vector is set to its target value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_MoveTowardTargetOperator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ConcatenateOperators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::LocalSearchOperator *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ConcatenateOperators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RandomConcatenateOperators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::LocalSearchOperator *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Randomized version of local search concatenator; calls a random operator</span>
<span class="sd">        at each call to MakeNextNeighbor().</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Randomized version of local search concatenator; calls a random operator</span>
<span class="sd">        at each call to MakeNextNeighbor(). The provided seed is used to</span>
<span class="sd">        initialize the random number generator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_RandomConcatenateOperators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NeighborhoodLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">:</span> <span class="s2">&quot;LocalSearchOperator&quot;</span><span class="p">,</span> <span class="n">limit</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::LocalSearchOperator *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a local search operator that wraps another local search</span>
<span class="sd">        operator and limits the number of neighbors explored (i.e., calls</span>
<span class="sd">        to MakeNextNeighbor from the current solution (between two calls</span>
<span class="sd">        to Start()). When this limit is reached, MakeNextNeighbor()</span>
<span class="sd">        returns false. The counter is cleared when Start() is called.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_NeighborhoodLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">LocalSearchPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_LocalSearchPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">LocalSearchPhaseParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::LocalSearchPhaseParameters *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_LocalSearchPhaseParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SearchDepth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the search depth of the current active search. Returns -1 if</span>
<span class="sd">        there is no active search opened.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SearchDepth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SearchLeftDepth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the search left depth of the current active search. Returns -1 if</span>
<span class="sd">        there is no active search opened.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SearchLeftDepth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SolveDepth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the number of nested searches. It returns 0 outside search,</span>
<span class="sd">        1 during the top level search, 2 or more in case of nested searches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SolveDepth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Rand64</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns a random value between 0 and &#39;size&#39; - 1;&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Rand64</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Rand32</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="s2">&quot;int32_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int32_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns a random value between 0 and &#39;size&#39; - 1;&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Rand32</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ReSeed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">:</span> <span class="s2">&quot;int32_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Reseed the solver random generator.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ReSeed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">LocalSearchProfile</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns local search profiling information in a human readable format.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_LocalSearchProfile</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Counts the number of constraints that have been added</span>
<span class="sd">        to the solver before the search.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Accept</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">visitor</span><span class="p">:</span> <span class="s2">&quot;operations_research::ModelVisitor *const&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Accepts the given model visitor.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Accept</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">visitor</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">FinishCurrentSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Tells the solver to kill or restart the current search.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_FinishCurrentSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RestartCurrentSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_RestartCurrentSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ShouldFail</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        These methods are only useful for the SWIG wrappers, which need a way</span>
<span class="sd">        to externally cause the Solver to fail.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ShouldFail</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver___str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ct</span><span class="p">):</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">PyConstraint</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__python_constraints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">AddConstraint</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">TreeNoCycle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nexts</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">active</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IndexFilter1&quot;</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_TreeNoCycle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nexts</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SearchLogWithCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">period</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="s2">&quot;std::function&lt; std::string () &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SearchMonitor *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SearchLogWithCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ElementFunction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="s2">&quot;std::function&lt; int64_t (int64_t) &gt;&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ElementFunction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">VarEvalValStrPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">var_evaluator</span><span class="p">:</span> <span class="s2">&quot;std::function&lt; int64_t (int64_t) &gt;&quot;</span><span class="p">,</span> <span class="n">val_str</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IntValueStrategy&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_VarEvalValStrPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">var_evaluator</span><span class="p">,</span> <span class="n">val_str</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">VarStrValEvalPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">var_str</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IntVarStrategy&quot;</span><span class="p">,</span> <span class="n">val_eval</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IndexEvaluator2&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_VarStrValEvalPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">var_str</span><span class="p">,</span> <span class="n">val_eval</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">VarEvalValEvalPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">var_eval</span><span class="p">:</span> <span class="s2">&quot;std::function&lt; int64_t (int64_t) &gt;&quot;</span><span class="p">,</span> <span class="n">val_eval</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IndexEvaluator2&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_VarEvalValEvalPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">var_eval</span><span class="p">,</span> <span class="n">val_eval</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">VarStrValEvalTieBreakPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">var_str</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IntVarStrategy&quot;</span><span class="p">,</span> <span class="n">val_eval</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IndexEvaluator2&quot;</span><span class="p">,</span> <span class="n">tie_breaker</span><span class="p">:</span> <span class="s2">&quot;std::function&lt; int64_t (int64_t) &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_VarStrValEvalTieBreakPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">var_str</span><span class="p">,</span> <span class="n">val_eval</span><span class="p">,</span> <span class="n">tie_breaker</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">VarEvalValEvalTieBreakPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">var_eval</span><span class="p">:</span> <span class="s2">&quot;std::function&lt; int64_t (int64_t) &gt;&quot;</span><span class="p">,</span> <span class="n">val_eval</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IndexEvaluator2&quot;</span><span class="p">,</span> <span class="n">tie_breaker</span><span class="p">:</span> <span class="s2">&quot;std::function&lt; int64_t (int64_t) &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_VarEvalValEvalTieBreakPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">var_eval</span><span class="p">,</span> <span class="n">val_eval</span><span class="p">,</span> <span class="n">tie_breaker</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EvalEvalStrPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">evaluator</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IndexEvaluator2&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::EvaluatorStrategy&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_EvalEvalStrPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">evaluator</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EvalEvalStrTieBreakPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">evaluator</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IndexEvaluator2&quot;</span><span class="p">,</span> <span class="n">tie_breaker</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IndexEvaluator1&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::EvaluatorStrategy&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_EvalEvalStrTieBreakPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">evaluator</span><span class="p">,</span> <span class="n">tie_breaker</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GuidedLocalSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SearchMonitor *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_GuidedLocalSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SumObjectiveFilter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IndexEvaluator2&quot;</span><span class="p">,</span> <span class="n">filter_enum</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::LocalSearchFilterBound&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::LocalSearchFilter *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SumObjectiveFilter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">filter_enum</span><span class="p">)</span>

<span class="c1"># Register Solver in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_swigregister</span><span class="p">(</span><span class="n">Solver</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Solver_DefaultSolverParameters</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::ConstraintSolverParameters&quot;</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Create a ConstraintSolverParameters proto with all the default values.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_DefaultSolverParameters</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">Solver_MemoryUsage</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Current memory usage in bytes&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_MemoryUsage</span><span class="p">()</span>

<span class="k">class</span> <span class="nc">BaseObject</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A BaseObject is the root of all reversibly allocated objects.</span>
<span class="sd">    A DebugString method and the associated &lt;&lt; operator are implemented</span>
<span class="sd">    as a convenience.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">BaseObject</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BaseObject_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_BaseObject</span><span class="p">(</span><span class="n">_self</span><span class="p">,</span> <span class="p">))</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_BaseObject</span>

    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BaseObject_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BaseObject___str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BaseObject___repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__disown__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">disown</span><span class="p">()</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">disown_BaseObject</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<span class="c1"># Register BaseObject in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BaseObject_swigregister</span><span class="p">(</span><span class="n">BaseObject</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">PropagationBaseObject</span><span class="p">(</span><span class="n">BaseObject</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    NOLINT</span>
<span class="sd">    The PropagationBaseObject is a subclass of BaseObject that is also</span>
<span class="sd">    friend to the Solver class. It allows accessing methods useful when</span>
<span class="sd">    writing new constraints or new expressions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">PropagationBaseObject</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">PropagationBaseObject_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_PropagationBaseObject</span><span class="p">(</span><span class="n">_self</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_PropagationBaseObject</span>

    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">PropagationBaseObject_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Solver *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">PropagationBaseObject_solver</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Object naming.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">PropagationBaseObject_Name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__disown__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">disown</span><span class="p">()</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">disown_PropagationBaseObject</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<span class="c1"># Register PropagationBaseObject in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">PropagationBaseObject_swigregister</span><span class="p">(</span><span class="n">PropagationBaseObject</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Decision</span><span class="p">(</span><span class="n">BaseObject</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Decision represents a choice point in the search tree. The two main</span>
<span class="sd">    methods are Apply() to go left, or Refute() to go right.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">Decision</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Decision_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_Decision</span><span class="p">(</span><span class="n">_self</span><span class="p">,</span> <span class="p">))</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_Decision</span>

    <span class="k">def</span> <span class="nf">ApplyWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Apply will be called first when the decision is executed.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Decision_ApplyWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RefuteWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Refute will be called after a backtrack.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Decision_RefuteWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Decision_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Decision___repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Decision___str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__disown__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">disown</span><span class="p">()</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">disown_Decision</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<span class="c1"># Register Decision in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Decision_swigregister</span><span class="p">(</span><span class="n">Decision</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">DecisionBuilder</span><span class="p">(</span><span class="n">BaseObject</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A DecisionBuilder is responsible for creating the search tree. The</span>
<span class="sd">    important method is Next(), which returns the next decision to execute.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">DecisionBuilder</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DecisionBuilder_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_DecisionBuilder</span><span class="p">(</span><span class="n">_self</span><span class="p">,</span> <span class="p">))</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_DecisionBuilder</span>

    <span class="k">def</span> <span class="nf">NextWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Decision *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is the main method of the decision builder class. It must</span>
<span class="sd">        return a decision (an instance of the class Decision). If it</span>
<span class="sd">        returns nullptr, this means that the decision builder has finished</span>
<span class="sd">        its work.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DecisionBuilder_NextWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DecisionBuilder_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DecisionBuilder___repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DecisionBuilder___str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__disown__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">disown</span><span class="p">()</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">disown_DecisionBuilder</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<span class="c1"># Register DecisionBuilder in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DecisionBuilder_swigregister</span><span class="p">(</span><span class="n">DecisionBuilder</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Demon</span><span class="p">(</span><span class="n">BaseObject</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Demon is the base element of a propagation queue. It is the main</span>
<span class="sd">      object responsible for implementing the actual propagation</span>
<span class="sd">      of the constraint and pruning the inconsistent values in the domains</span>
<span class="sd">      of the variables. The main concept is that demons are listeners that are</span>
<span class="sd">      attached to the variables and listen to their modifications.</span>
<span class="sd">    There are two methods:</span>
<span class="sd">     - Run() is the actual method called when the demon is processed.</span>
<span class="sd">     - priority() returns its priority. Standard priorities are slow, normal</span>
<span class="sd">       or fast. &quot;immediate&quot; is reserved for variables and is treated separately.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This indicates the priority of a demon. Immediate demons are treated</span>
<span class="sd">        separately and corresponds to variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">Demon</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Demon_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_Demon</span><span class="p">(</span><span class="n">_self</span><span class="p">,</span> <span class="p">))</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_Demon</span>

    <span class="k">def</span> <span class="nf">RunWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This is the main callback of the demon.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Demon_RunWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Priority</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Solver::DemonPriority&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns the priority of the demon. Usually a demon is</span>
<span class="sd">        fast, slow or normal. Immediate demons are reserved for internal</span>
<span class="sd">        use to maintain variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Demon_Priority</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Demon_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Inhibit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method inhibits the demon in the search tree below the</span>
<span class="sd">        current position.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Demon_Inhibit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Desinhibit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This method un-inhibits the demon that was previously inhibited.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Demon_Desinhibit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__disown__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">disown</span><span class="p">()</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">disown_Demon</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<span class="c1"># Register Demon in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Demon_swigregister</span><span class="p">(</span><span class="n">Demon</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Constraint</span><span class="p">(</span><span class="n">PropagationBaseObject</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A constraint is the main modeling object. It provides two methods:</span>
<span class="sd">      - Post() is responsible for creating the demons and attaching them to</span>
<span class="sd">        immediate demons().</span>
<span class="sd">      - InitialPropagate() is called once just after Post and performs</span>
<span class="sd">        the initial propagation. The subsequent propagations will be performed</span>
<span class="sd">        by the demons Posted during the post() method.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">Constraint</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_Constraint</span><span class="p">(</span><span class="n">_self</span><span class="p">,</span> <span class="n">solver</span><span class="p">))</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_Constraint</span>

    <span class="k">def</span> <span class="nf">Post</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called when the constraint is processed by the</span>
<span class="sd">        solver. Its main usage is to attach demons to variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint_Post</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">InitialPropagateWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method performs the initial propagation of the</span>
<span class="sd">        constraint. It is called just after the post.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint_InitialPropagateWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a Boolean variable representing the status of the constraint</span>
<span class="sd">        (false = constraint is violated, true = constraint is satisfied). It</span>
<span class="sd">        returns nullptr if the constraint does not support this API.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint_Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint___repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint___str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint___add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint___radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint___sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint___rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint___mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint___rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__floordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint___floordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint___neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint___abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Square</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint_Square</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint___eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint___ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint___ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint___gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint___le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint___lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">MapTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint_MapTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IndexOf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint_IndexOf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__disown__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">disown</span><span class="p">()</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">disown_Constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<span class="c1"># Register Constraint in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint_swigregister</span><span class="p">(</span><span class="n">Constraint</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">SearchMonitor</span><span class="p">(</span><span class="n">BaseObject</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; A search monitor is a simple set of callbacks to monitor all search events&quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">SearchMonitor</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_SearchMonitor</span><span class="p">(</span><span class="n">_self</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_SearchMonitor</span>

    <span class="k">def</span> <span class="nf">EnterSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Beginning of the search.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_EnterSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RestartSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Restart the search.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_RestartSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ExitSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; End of the search.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_ExitSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">BeginNextDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="s2">&quot;DecisionBuilder&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Before calling DecisionBuilder::Next.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_BeginNextDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndNextDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="s2">&quot;DecisionBuilder&quot;</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="s2">&quot;Decision&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; After calling DecisionBuilder::Next, along with the returned decision.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_EndNextDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ApplyDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="s2">&quot;Decision&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Before applying the decision.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_ApplyDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RefuteDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="s2">&quot;Decision&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Before refuting the decision.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_RefuteDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AfterDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="s2">&quot;Decision&quot;</span><span class="p">,</span> <span class="n">apply</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Just after refuting or applying the decision, apply is true after Apply.</span>
<span class="sd">        This is called only if the Apply() or Refute() methods have not failed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_AfterDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">apply</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">BeginFail</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Just when the failure occurs.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_BeginFail</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndFail</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; After completing the backtrack.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_EndFail</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">BeginInitialPropagation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Before the initial propagation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_BeginInitialPropagation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndInitialPropagation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; After the initial propagation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_EndInitialPropagation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AcceptSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called when a solution is found. It asserts whether the</span>
<span class="sd">        solution is valid. A value of false indicates that the solution</span>
<span class="sd">        should be discarded.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_AcceptSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AtSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called when a valid solution is found. If the</span>
<span class="sd">        return value is true, then search will resume after. If the result</span>
<span class="sd">        is false, then search will stop there.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_AtSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NoMoreSolutions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; When the search tree is finished.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_NoMoreSolutions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">LocalOptimum</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        When a local optimum is reached. If &#39;true&#39; is returned, the last solution</span>
<span class="sd">        is discarded and the search proceeds with the next one.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_LocalOptimum</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AcceptDelta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_AcceptDelta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AcceptNeighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; After accepting a neighbor during local search.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_AcceptNeighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Solver *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_solver</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor___repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor___str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__disown__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">disown</span><span class="p">()</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">disown_SearchMonitor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<span class="c1"># Register SearchMonitor in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_swigregister</span><span class="p">(</span><span class="n">SearchMonitor</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">IntExpr</span><span class="p">(</span><span class="n">PropagationBaseObject</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The class IntExpr is the base of all integer expressions in</span>
<span class="sd">    constraint programming.</span>
<span class="sd">    It contains the basic protocol for an expression:</span>
<span class="sd">      - setting and modifying its bound</span>
<span class="sd">      - querying if it is bound</span>
<span class="sd">      - listening to events modifying its bounds</span>
<span class="sd">      - casting it into a variable (instance of IntVar)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Min</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_Min</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_SetMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Max</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_Max</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_SetMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This method sets both the min and the max of the expression.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_SetRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This method sets the value of the expression.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Bound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns true if the min and the max of the expression are equal.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_Bound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsVar</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns true if the expression is indeed a variable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_IsVar</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Creates a variable from the expression.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">VarWithName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a variable from the expression and set the name of the</span>
<span class="sd">        resulting var. If the expression is already a variable, then it</span>
<span class="sd">        will set the name of the expression, possibly overwriting it.</span>
<span class="sd">        This is just a shortcut to Var() followed by set_name().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_VarWithName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WhenRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Attach a demon that will watch the min or the max of the expression.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Attach a demon that will watch the min or the max of the expression.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_WhenRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr___repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr___str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr___add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr___radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr___sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr___rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr___mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr___rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__floordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr___floordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr___mod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr___neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr___abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Square</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_Square</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr___eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr___ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr___ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr___gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr___le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr___lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">MapTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_MapTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IndexOf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_IndexOf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsMember</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_IsMember</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Member</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_Member</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NotMember</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">starts</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">ends</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_NotMember</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">starts</span><span class="p">,</span> <span class="n">ends</span><span class="p">)</span>

<span class="c1"># Register IntExpr in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_swigregister</span><span class="p">(</span><span class="n">IntExpr</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">IntVarIterator</span><span class="p">(</span><span class="n">BaseObject</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     The class Iterator has two direct subclasses. HoleIterators</span>
<span class="sd">     iterates over all holes, that is value removed between the</span>
<span class="sd">     current min and max of the variable since the last time the</span>
<span class="sd">     variable was processed in the queue. DomainIterators iterates</span>
<span class="sd">     over all elements of the variable domain. Both iterators are not</span>
<span class="sd">     robust to domain changes. Hole iterators can also report values outside</span>
<span class="sd">     the current min and max of the variable.</span>
<span class="sd">     HoleIterators should only be called from a demon attached to the</span>
<span class="sd">     variable that has created this iterator.</span>
<span class="sd">     IntVar* current_var;</span>
<span class="sd">     std::unique_ptr&lt;IntVarIterator&gt; it(current_var-&gt;MakeHoleIterator(false));</span>
<span class="sd">     for (const int64_t hole : InitAndGetValues(it)) {</span>
<span class="sd">    use the hole</span>
<span class="sd">     }</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">Init</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This method must be called before each loop.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarIterator_Init</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Ok</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This method indicates if we can call Value() or not.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarIterator_Ok</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This method returns the current value of the iterator.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarIterator_Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Next</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This method moves the iterator to the next value.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarIterator_Next</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Pretty Print.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarIterator_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">Init</span><span class="p">()</span>
      <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ok</span><span class="p">():</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Value</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">StopIteration</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>


<span class="c1"># Register IntVarIterator in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarIterator_swigregister</span><span class="p">(</span><span class="n">IntVarIterator</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">IntVar</span><span class="p">(</span><span class="n">IntExpr</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The class IntVar is a subset of IntExpr. In addition to the</span>
<span class="sd">    IntExpr protocol, it offers persistence, removing values from the domains,</span>
<span class="sd">    and a finer model for events.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsVar</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_IsVar</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns the value of the variable. This method checks</span>
<span class="sd">        before that the variable is bound.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RemoveValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This method removes the value &#39;v&#39; from the domain of the variable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_RemoveValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RemoveInterval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method removes the interval &#39;l&#39; .. &#39;u&#39; from the domain of</span>
<span class="sd">        the variable. It assumes that &#39;l&#39; &lt;= &#39;u&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_RemoveInterval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RemoveValues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This method remove the values from the domain of the variable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_RemoveValues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetValues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This method intersects the current domain with the values in the array.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_SetValues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WhenBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        This method attaches a demon that will be awakened when the</span>
<span class="sd">        variable is bound.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        This method attaches a closure that will be awakened when the</span>
<span class="sd">        variable is bound.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_WhenBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WhenDomain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        This method attaches a demon that will watch any domain</span>
<span class="sd">        modification of the domain of the variable.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        This method attaches a closure that will watch any domain</span>
<span class="sd">        modification of the domain of the variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_WhenDomain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;uint64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This method returns the number of values in the domain of the variable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns whether the value &#39;v&#39; is in the domain of the</span>
<span class="sd">        variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_Contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">HoleIteratorAux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reversible</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVarIterator *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a hole iterator. When &#39;reversible&#39; is false, the returned</span>
<span class="sd">        object is created on the normal C++ heap and the solver does NOT</span>
<span class="sd">        take ownership of the object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_HoleIteratorAux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reversible</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DomainIteratorAux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reversible</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVarIterator *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a domain iterator. When &#39;reversible&#39; is false, the</span>
<span class="sd">        returned object is created on the normal C++ heap and the solver</span>
<span class="sd">        does NOT take ownership of the object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_DomainIteratorAux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reversible</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">OldMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the previous min.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_OldMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">OldMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the previous max.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_OldMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar___repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar___str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DomainIterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DomainIteratorAux</span><span class="p">(</span><span class="kc">False</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">HoleIterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">HoleIteratorAux</span><span class="p">(</span><span class="kc">False</span><span class="p">))</span>


<span class="c1"># Register IntVar in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_swigregister</span><span class="p">(</span><span class="n">IntVar</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">SolutionCollector</span><span class="p">(</span><span class="n">SearchMonitor</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class is the root class of all solution collectors.</span>
<span class="sd">    It implements a basic query API to be used independently</span>
<span class="sd">    of the collector used.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddObjective</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">objective</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_AddObjective</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">objective</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EnterSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Beginning of the search.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_EnterSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SolutionCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns how many solutions were stored during the search.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_SolutionCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Solution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the nth solution.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_Solution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WallTime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the wall time in ms for the nth solution.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_WallTime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Branches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the number of branches when the nth solution was found.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_Branches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Failures</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of failures encountered at the time of the nth</span>
<span class="sd">        solution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_Failures</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ObjectiveValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the objective value of the nth solution.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_ObjectiveValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This is a shortcut to get the Value of &#39;var&#39; in the nth solution.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_Value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This is a shortcut to get the StartValue of &#39;var&#39; in the nth solution.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_StartValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This is a shortcut to get the EndValue of &#39;var&#39; in the nth solution.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_EndValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DurationValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This is a shortcut to get the DurationValue of &#39;var&#39; in the nth solution.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_DurationValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">PerformedValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This is a shortcut to get the PerformedValue of &#39;var&#39; in the nth solution.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_PerformedValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ForwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;SequenceVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a shortcut to get the ForwardSequence of &#39;var&#39; in the</span>
<span class="sd">        nth solution. The forward sequence is the list of ranked interval</span>
<span class="sd">        variables starting from the start of the sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_ForwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">BackwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;SequenceVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a shortcut to get the BackwardSequence of &#39;var&#39; in the</span>
<span class="sd">        nth solution. The backward sequence is the list of ranked interval</span>
<span class="sd">        variables starting from the end of the sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_BackwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Unperformed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;SequenceVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a shortcut to get the list of unperformed of &#39;var&#39; in the</span>
<span class="sd">        nth solution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_Unperformed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

<span class="c1"># Register SolutionCollector in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_swigregister</span><span class="p">(</span><span class="n">SolutionCollector</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">OptimizeVar</span><span class="p">(</span><span class="n">SearchMonitor</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class encapsulates an objective. It requires the direction</span>
<span class="sd">    (minimize or maximize), the variable to optimize, and the</span>
<span class="sd">    improvement step.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">Best</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the best value found during search.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">OptimizeVar_Best</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the variable that is optimized.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">OptimizeVar_Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AcceptDelta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Internal methods.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">OptimizeVar_AcceptDelta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EnterSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">OptimizeVar_EnterSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">BeginNextDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">db</span><span class="p">:</span> <span class="s2">&quot;DecisionBuilder&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">OptimizeVar_BeginNextDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">db</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RefuteDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="s2">&quot;Decision&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">OptimizeVar_RefuteDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AtSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">OptimizeVar_AtSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AcceptSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">OptimizeVar_AcceptSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">OptimizeVar_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<span class="c1"># Register OptimizeVar in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">OptimizeVar_swigregister</span><span class="p">(</span><span class="n">OptimizeVar</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">SearchLimit</span><span class="p">(</span><span class="n">SearchMonitor</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Base class of all search limits.&quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_SearchLimit</span>

    <span class="k">def</span> <span class="nf">Crossed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns true if the limit has been crossed.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchLimit_Crossed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Check</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called to check the status of the limit. A return</span>
<span class="sd">        value of true indicates that we have indeed crossed the limit. In</span>
<span class="sd">        that case, this method will not be called again and the remaining</span>
<span class="sd">        search will be discarded.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchLimit_Check</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Init</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This method is called when the search limit is initialized.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchLimit_Init</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EnterSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Internal methods.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchLimit_EnterSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">BeginNextDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="s2">&quot;DecisionBuilder&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchLimit_BeginNextDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RefuteDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="s2">&quot;Decision&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchLimit_RefuteDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchLimit_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<span class="c1"># Register SearchLimit in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchLimit_swigregister</span><span class="p">(</span><span class="n">SearchLimit</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">IntervalVar</span><span class="p">(</span><span class="n">PropagationBaseObject</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interval variables are often used in scheduling. The main characteristics</span>
<span class="sd">    of an IntervalVar are the start position, duration, and end</span>
<span class="sd">    date. All these characteristics can be queried and set, and demons can</span>
<span class="sd">    be posted on their modifications.</span>

<span class="sd">    An important aspect is optionality: an IntervalVar can be performed or not.</span>
<span class="sd">    If unperformed, then it simply does not exist, and its characteristics</span>
<span class="sd">    cannot be accessed any more. An interval var is automatically marked</span>
<span class="sd">    as unperformed when it is not consistent anymore (start greater</span>
<span class="sd">    than end, duration &lt; 0...)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        These methods query, set, and watch the start position of the</span>
<span class="sd">        interval var.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetStartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_SetStartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetStartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_SetStartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetStartRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">ma</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_SetStartRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">ma</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">OldStartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_OldStartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">OldStartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_OldStartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WhenStartRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_WhenStartRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WhenStartBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_WhenStartBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; These methods query, set, and watch the duration of the interval var.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_DurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_DurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetDurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_SetDurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetDurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_SetDurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetDurationRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">ma</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_SetDurationRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">ma</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">OldDurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_OldDurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">OldDurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_OldDurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WhenDurationRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_WhenDurationRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WhenDurationBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_WhenDurationBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; These methods query, set, and watch the end position of the interval var.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetEndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_SetEndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetEndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_SetEndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetEndRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">ma</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_SetEndRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">ma</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">OldEndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_OldEndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">OldEndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_OldEndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WhenEndRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_WhenEndRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WhenEndBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_WhenEndBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">MustBePerformed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        These methods query, set, and watch the performed status of the</span>
<span class="sd">        interval var.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_MustBePerformed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">MayBePerformed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_MayBePerformed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">CannotBePerformed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_CannotBePerformed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsPerformedBound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_IsPerformedBound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetPerformed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_SetPerformed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WasPerformedBound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_WasPerformedBound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WhenPerformedBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_WhenPerformedBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WhenAnything</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Attaches a demon awakened when anything about this interval changes.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Attaches a closure awakened when anything about this interval changes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_WhenAnything</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        These methods create expressions encapsulating the start, end</span>
<span class="sd">        and duration of the interval var. Please note that these must not</span>
<span class="sd">        be used if the interval var is unperformed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DurationExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_DurationExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">PerformedExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_PerformedExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SafeStartExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unperformed_value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        These methods create expressions encapsulating the start, end</span>
<span class="sd">        and duration of the interval var. If the interval var is</span>
<span class="sd">        unperformed, they will return the unperformed_value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_SafeStartExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unperformed_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SafeDurationExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unperformed_value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_SafeDurationExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unperformed_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SafeEndExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unperformed_value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_SafeEndExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unperformed_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndsAfterEnd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndsAfterEnd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndsAfterEndWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndsAfterEndWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">delay</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndsAfterStart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndsAfterStart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndsAfterStartWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndsAfterStartWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">delay</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndsAtEnd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndsAtEnd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndsAtEndWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndsAtEndWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">delay</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndsAtStart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndsAtStart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndsAtStartWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndsAtStartWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">delay</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartsAfterEnd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartsAfterEnd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartsAfterEndWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartsAfterEndWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">delay</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartsAfterStart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartsAfterStart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartsAfterStartWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartsAfterStartWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">delay</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartsAtEnd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartsAtEnd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartsAtEndWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartsAtEndWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">delay</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartsAtStart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartsAtStart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartsAtStartWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartsAtStartWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">delay</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StaysInSync</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StaysInSync</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StaysInSyncWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StaysInSyncWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">delay</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndsAfter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndsAfter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndsAt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndsAt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndsBefore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndsBefore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartsAfter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartsAfter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartsAt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartsAt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartsBefore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartsBefore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">CrossesDate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_CrossesDate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AvoidsDate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_AvoidsDate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar___repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar___str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<span class="c1"># Register IntervalVar in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_swigregister</span><span class="p">(</span><span class="n">IntervalVar</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">SequenceVar</span><span class="p">(</span><span class="n">PropagationBaseObject</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A sequence variable is a variable whose domain is a set of possible</span>
<span class="sd">    orderings of the interval variables. It allows ordering of tasks. It</span>
<span class="sd">    has two sets of methods: ComputePossibleFirstsAndLasts(), which</span>
<span class="sd">    returns the list of interval variables that can be ranked first or</span>
<span class="sd">    last; and RankFirst/RankNotFirst/RankLast/RankNotLast, which can be</span>
<span class="sd">    used to create the search decision.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVar_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RankFirst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ranks the index_th interval var first of all unranked interval</span>
<span class="sd">        vars. After that, it will no longer be considered ranked.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVar_RankFirst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RankNotFirst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Indicates that the index_th interval var will not be ranked first</span>
<span class="sd">        of all currently unranked interval vars.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVar_RankNotFirst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RankLast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ranks the index_th interval var first of all unranked interval</span>
<span class="sd">        vars. After that, it will no longer be considered ranked.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVar_RankLast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RankNotLast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Indicates that the index_th interval var will not be ranked first</span>
<span class="sd">        of all currently unranked interval vars.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVar_RankNotLast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Interval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntervalVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the index_th interval of the sequence.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVar_Interval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Next</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the next of the index_th interval of the sequence.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVar_Next</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the number of interval vars in the sequence.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVar_Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVar___repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVar___str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<span class="c1"># Register SequenceVar in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVar_swigregister</span><span class="p">(</span><span class="n">SequenceVar</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">AssignmentElement</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">Activate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">AssignmentElement_Activate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Deactivate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">AssignmentElement_Deactivate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Activated</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">AssignmentElement_Activated</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_AssignmentElement</span>

<span class="c1"># Register AssignmentElement in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">AssignmentElement_swigregister</span><span class="p">(</span><span class="n">AssignmentElement</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">IntVarElement</span><span class="p">(</span><span class="n">AssignmentElement</span><span class="p">):</span>
    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarElement_Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Min</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarElement_Min</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarElement_SetMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Max</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarElement_Max</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarElement_SetMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarElement_Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Bound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarElement_Bound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarElement_SetRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarElement_SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">:</span> <span class="s2">&quot;IntVarElement&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarElement___eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">:</span> <span class="s2">&quot;IntVarElement&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarElement___ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_IntVarElement</span>

<span class="c1"># Register IntVarElement in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarElement_swigregister</span><span class="p">(</span><span class="n">IntVarElement</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">IntervalVarElement</span><span class="p">(</span><span class="n">AssignmentElement</span><span class="p">):</span>
    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntervalVar *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_StartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_StartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_StartValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_DurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_DurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DurationValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_DurationValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_EndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_EndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_EndValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">PerformedMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_PerformedMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">PerformedMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_PerformedMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">PerformedValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_PerformedValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetStartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetStartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetStartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetStartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetStartRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">ma</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetStartRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">ma</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetStartValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetStartValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetDurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetDurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetDurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetDurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetDurationRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">ma</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetDurationRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">ma</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetDurationValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetDurationValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetEndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetEndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetEndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetEndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetEndRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">ma</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetEndRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">ma</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetEndValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetEndValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetPerformedMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetPerformedMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetPerformedMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetPerformedMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetPerformedRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">ma</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetPerformedRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">ma</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetPerformedValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetPerformedValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">:</span> <span class="s2">&quot;IntervalVarElement&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement___eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">:</span> <span class="s2">&quot;IntervalVarElement&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement___ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_IntervalVarElement</span>

<span class="c1"># Register IntervalVarElement in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_swigregister</span><span class="p">(</span><span class="n">IntervalVarElement</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">SequenceVarElement</span><span class="p">(</span><span class="n">AssignmentElement</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The SequenceVarElement stores a partial representation of ranked</span>
<span class="sd">    interval variables in the underlying sequence variable.</span>
<span class="sd">    This representation consists of three vectors:</span>
<span class="sd">      - the forward sequence. That is the list of interval variables</span>
<span class="sd">        ranked first in the sequence.  The first element of the backward</span>
<span class="sd">        sequence is the first interval in the sequence variable.</span>
<span class="sd">      - the backward sequence. That is the list of interval variables</span>
<span class="sd">        ranked last in the sequence. The first element of the backward</span>
<span class="sd">        sequence is the last interval in the sequence variable.</span>
<span class="sd">      - The list of unperformed interval variables.</span>
<span class="sd">     Furthermore, if all performed variables are ranked, then by</span>
<span class="sd">     convention, the forward_sequence will contain all such variables</span>
<span class="sd">     and the backward_sequence will be empty.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SequenceVar *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarElement_Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ForwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarElement_ForwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">BackwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarElement_BackwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Unperformed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarElement_Unperformed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forward_sequence</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">backward_sequence</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">unperformed</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarElement_SetSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forward_sequence</span><span class="p">,</span> <span class="n">backward_sequence</span><span class="p">,</span> <span class="n">unperformed</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetForwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forward_sequence</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarElement_SetForwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forward_sequence</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetBackwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">backward_sequence</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarElement_SetBackwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">backward_sequence</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetUnperformed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unperformed</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarElement_SetUnperformed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unperformed</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">:</span> <span class="s2">&quot;SequenceVarElement&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarElement___eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">:</span> <span class="s2">&quot;SequenceVarElement&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarElement___ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_SequenceVarElement</span>

<span class="c1"># Register SequenceVarElement in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarElement_swigregister</span><span class="p">(</span><span class="n">SequenceVarElement</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Assignment</span><span class="p">(</span><span class="n">PropagationBaseObject</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An Assignment is a variable -&gt; domains mapping, used</span>
<span class="sd">    to report solutions to the user.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">Clear</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Clear</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Empty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Empty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NumIntVars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_NumIntVars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NumIntervalVars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_NumIntervalVars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NumSequenceVars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_NumSequenceVars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Store</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Store</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Restore</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Restore</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddObjective</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_AddObjective</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Objective</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Objective</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">HasObjective</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_HasObjective</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ObjectiveMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_ObjectiveMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ObjectiveMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_ObjectiveMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ObjectiveValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_ObjectiveValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ObjectiveBound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_ObjectiveBound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetObjectiveMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetObjectiveMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetObjectiveMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetObjectiveMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetObjectiveValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetObjectiveValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetObjectiveRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetObjectiveRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Bound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Bound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_StartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_StartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_StartValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_DurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_DurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DurationValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_DurationValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_EndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_EndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_EndValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">PerformedMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_PerformedMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">PerformedMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_PerformedMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">PerformedValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_PerformedValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetStartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetStartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetStartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetStartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetStartRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">mi</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">ma</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetStartRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">ma</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetStartValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetStartValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetDurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetDurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetDurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetDurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetDurationRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">mi</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">ma</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetDurationRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">ma</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetDurationValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetDurationValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetEndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetEndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetEndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetEndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetEndRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">mi</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">ma</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetEndRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">ma</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetEndValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetEndValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetPerformedMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetPerformedMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetPerformedMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetPerformedMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetPerformedRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">mi</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">ma</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetPerformedRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">ma</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetPerformedValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetPerformedValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ForwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;SequenceVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_ForwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">BackwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;SequenceVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_BackwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Unperformed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;SequenceVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Unperformed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;SequenceVar&quot;</span><span class="p">,</span> <span class="n">forward_sequence</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">backward_sequence</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">unperformed</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">forward_sequence</span><span class="p">,</span> <span class="n">backward_sequence</span><span class="p">,</span> <span class="n">unperformed</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetForwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;SequenceVar&quot;</span><span class="p">,</span> <span class="n">forward_sequence</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetForwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">forward_sequence</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetBackwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;SequenceVar&quot;</span><span class="p">,</span> <span class="n">backward_sequence</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetBackwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">backward_sequence</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetUnperformed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;SequenceVar&quot;</span><span class="p">,</span> <span class="n">unperformed</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetUnperformed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">unperformed</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Activate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Activate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Deactivate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Deactivate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Activated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Activated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IntVarContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment::IntContainer const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_IntVarContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">MutableIntVarContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment::IntContainer *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_MutableIntVarContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IntervalVarContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment::IntervalContainer const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_IntervalVarContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">MutableIntervalVarContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment::IntervalContainer *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_MutableIntervalVarContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SequenceVarContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment::SequenceContainer const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SequenceVarContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">MutableSequenceVarContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment::SequenceContainer *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_MutableSequenceVarContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment___eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment___ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">)</span>

<span class="c1"># Register Assignment in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_swigregister</span><span class="p">(</span><span class="n">Assignment</span><span class="p">)</span>


<span class="k">def</span> <span class="fm">__lshift__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::ostream &amp;&quot;</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="fm">__lshift__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Pack</span><span class="p">(</span><span class="n">Constraint</span><span class="p">):</span>
    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">AddWeightedSumLessOrEqualConstantDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Dimensions are additional constraints than can restrict what is</span>
<span class="sd">        possible with the pack constraint. It can be used to set capacity</span>
<span class="sd">        limits, to count objects per bin, to compute unassigned</span>
<span class="sd">        penalties...</span>
<span class="sd">        This dimension imposes that for all bins b, the weighted sum</span>
<span class="sd">        (weights[i]) of all objects i assigned to &#39;b&#39; is less or equal</span>
<span class="sd">        &#39;bounds[b]&#39;.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        This dimension imposes that for all bins b, the weighted sum</span>
<span class="sd">        (weights-&gt;Run(i)) of all objects i assigned to &#39;b&#39; is less or</span>
<span class="sd">        equal to &#39;bounds[b]&#39;. Ownership of the callback is transferred to</span>
<span class="sd">        the pack constraint.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 3:*</span>
<span class="sd">        This dimension imposes that for all bins b, the weighted sum</span>
<span class="sd">        (weights-&gt;Run(i, b) of all objects i assigned to &#39;b&#39; is less or</span>
<span class="sd">        equal to &#39;bounds[b]&#39;. Ownership of the callback is transferred to</span>
<span class="sd">        the pack constraint.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Pack_AddWeightedSumLessOrEqualConstantDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddWeightedSumEqualVarDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        This dimension imposes that for all bins b, the weighted sum</span>
<span class="sd">        (weights[i]) of all objects i assigned to &#39;b&#39; is equal to loads[b].</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        This dimension imposes that for all bins b, the weighted sum</span>
<span class="sd">        (weights-&gt;Run(i, b)) of all objects i assigned to &#39;b&#39; is equal to</span>
<span class="sd">        loads[b].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Pack_AddWeightedSumEqualVarDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddSumVariableWeightsLessOrEqualConstantDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">usage</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This dimension imposes:</span>
<span class="sd">        forall b in bins,</span>
<span class="sd">           sum (i in items: usage[i] * is_assigned(i, b)) &lt;= capacity[b]</span>
<span class="sd">        where is_assigned(i, b) is true if and only if item i is assigned</span>
<span class="sd">        to the bin b.</span>

<span class="sd">        This can be used to model shapes of items by linking variables of</span>
<span class="sd">        the same item on parallel dimensions with an allowed assignment</span>
<span class="sd">        constraint.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Pack_AddSumVariableWeightsLessOrEqualConstantDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">usage</span><span class="p">,</span> <span class="n">capacity</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddWeightedSumOfAssignedDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weights</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">cost_var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This dimension enforces that cost_var == sum of weights[i] for</span>
<span class="sd">        all objects &#39;i&#39; assigned to a bin.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Pack_AddWeightedSumOfAssignedDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">cost_var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddCountUsedBinDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count_var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This dimension links &#39;count_var&#39; to the actual number of bins used in the</span>
<span class="sd">        pack.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Pack_AddCountUsedBinDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count_var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddCountAssignedItemsDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count_var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This dimension links &#39;count_var&#39; to the actual number of items</span>
<span class="sd">        assigned to a bin in the pack.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Pack_AddCountAssignedItemsDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count_var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Post</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Pack_Post</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">InitialPropagateWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Pack_InitialPropagateWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Pack_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<span class="c1"># Register Pack in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Pack_swigregister</span><span class="p">(</span><span class="n">Pack</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">DisjunctiveConstraint</span><span class="p">(</span><span class="n">Constraint</span><span class="p">):</span>
    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">SequenceVar</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SequenceVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Creates a sequence variable from the constraint.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DisjunctiveConstraint_SequenceVar</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetTransitionTime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transition_time</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IndexEvaluator2&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a transition time between intervals.  It forces the distance between</span>
<span class="sd">        the end of interval a and start of interval b that follows it to be at</span>
<span class="sd">        least transition_time(a, b). This function must always return</span>
<span class="sd">        a positive or null value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DisjunctiveConstraint_SetTransitionTime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transition_time</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">TransitionTime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">before_index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">after_index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DisjunctiveConstraint_TransitionTime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">before_index</span><span class="p">,</span> <span class="n">after_index</span><span class="p">)</span>

<span class="c1"># Register DisjunctiveConstraint in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DisjunctiveConstraint_swigregister</span><span class="p">(</span><span class="n">DisjunctiveConstraint</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">RevInteger</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class adds reversibility to a POD type.</span>
<span class="sd">    It contains the stamp optimization. i.e. the SaveValue call is done</span>
<span class="sd">    only once per node of the search tree.  Please note that actual</span>
<span class="sd">    stamps always starts at 1, thus an initial value of 0 will always</span>
<span class="sd">    trigger the first SaveValue.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="s2">&quot;long const &amp;&quot;</span><span class="p">):</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RevInteger_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_RevInteger</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;long const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RevInteger_Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="s2">&quot;long const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RevInteger_SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_RevInteger</span>

<span class="c1"># Register RevInteger in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RevInteger_swigregister</span><span class="p">(</span><span class="n">RevInteger</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">NumericalRevInteger</span><span class="p">(</span><span class="n">RevInteger</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Subclass of Rev&lt;T&gt; which adds numerical operations.&quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="s2">&quot;long const &amp;&quot;</span><span class="p">):</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">NumericalRevInteger_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_NumericalRevInteger</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">,</span> <span class="n">to_add</span><span class="p">:</span> <span class="s2">&quot;long const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">NumericalRevInteger_Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">to_add</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Incr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">NumericalRevInteger_Incr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Decr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">NumericalRevInteger_Decr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_NumericalRevInteger</span>

<span class="c1"># Register NumericalRevInteger in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">NumericalRevInteger_swigregister</span><span class="p">(</span><span class="n">NumericalRevInteger</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">RevBool</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class adds reversibility to a POD type.</span>
<span class="sd">    It contains the stamp optimization. i.e. the SaveValue call is done</span>
<span class="sd">    only once per node of the search tree.  Please note that actual</span>
<span class="sd">    stamps always starts at 1, thus an initial value of 0 will always</span>
<span class="sd">    trigger the first SaveValue.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="s2">&quot;bool const &amp;&quot;</span><span class="p">):</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RevBool_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_RevBool</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RevBool_Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="s2">&quot;bool const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RevBool_SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_RevBool</span>

<span class="c1"># Register RevBool in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RevBool_swigregister</span><span class="p">(</span><span class="n">RevBool</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">IntVarContainer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">Contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarContainer_Contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVarElement *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarContainer_Element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarContainer_Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Store</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarContainer_Store</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Restore</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarContainer_Restore</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">container</span><span class="p">:</span> <span class="s2">&quot;IntVarContainer&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns true if this and &#39;container&#39; both represent the same V* -&gt; E map.</span>
<span class="sd">        Runs in linear time; requires that the == operator on the type E is well</span>
<span class="sd">        defined.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarContainer___eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">container</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">container</span><span class="p">:</span> <span class="s2">&quot;IntVarContainer&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarContainer___ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">container</span><span class="p">)</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_IntVarContainer</span>

<span class="c1"># Register IntVarContainer in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarContainer_swigregister</span><span class="p">(</span><span class="n">IntVarContainer</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">IntervalVarContainer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">Contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarContainer_Contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntervalVarElement *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarContainer_Element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarContainer_Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Store</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarContainer_Store</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Restore</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarContainer_Restore</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">container</span><span class="p">:</span> <span class="s2">&quot;IntervalVarContainer&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns true if this and &#39;container&#39; both represent the same V* -&gt; E map.</span>
<span class="sd">        Runs in linear time; requires that the == operator on the type E is well</span>
<span class="sd">        defined.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarContainer___eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">container</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">container</span><span class="p">:</span> <span class="s2">&quot;IntervalVarContainer&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarContainer___ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">container</span><span class="p">)</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_IntervalVarContainer</span>

<span class="c1"># Register IntervalVarContainer in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarContainer_swigregister</span><span class="p">(</span><span class="n">IntervalVarContainer</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">SequenceVarContainer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">Contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;SequenceVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarContainer_Contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SequenceVarElement *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarContainer_Element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarContainer_Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Store</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarContainer_Store</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Restore</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarContainer_Restore</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">container</span><span class="p">:</span> <span class="s2">&quot;SequenceVarContainer&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns true if this and &#39;container&#39; both represent the same V* -&gt; E map.</span>
<span class="sd">        Runs in linear time; requires that the == operator on the type E is well</span>
<span class="sd">        defined.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarContainer___eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">container</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">container</span><span class="p">:</span> <span class="s2">&quot;SequenceVarContainer&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarContainer___ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">container</span><span class="p">)</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_SequenceVarContainer</span>

<span class="c1"># Register SequenceVarContainer in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarContainer_swigregister</span><span class="p">(</span><span class="n">SequenceVarContainer</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">LocalSearchOperator</span><span class="p">(</span><span class="n">BaseObject</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class represent a reversible FIFO structure.</span>
<span class="sd">    The main difference w.r.t a standard FIFO structure is that a Solver is</span>
<span class="sd">    given as parameter to the modifiers such that the solver can store the</span>
<span class="sd">    backtrack information</span>
<span class="sd">    Iterator&#39;s traversing order should not be changed, as some algorithm</span>
<span class="sd">    depend on it to be consistent.</span>
<span class="sd">    It&#39;s main use is to store a list of demons in the various classes of</span>
<span class="sd">    variables.</span>
<span class="sd">    The base class for all local search operators.</span>

<span class="sd">    A local search operator is an object that defines the neighborhood of a</span>
<span class="sd">    solution. In other words, a neighborhood is the set of solutions which can</span>
<span class="sd">    be reached from a given solution using an operator.</span>

<span class="sd">    The behavior of the LocalSearchOperator class is similar to iterators.</span>
<span class="sd">    The operator is synchronized with an assignment (gives the</span>
<span class="sd">    current values of the variables); this is done in the Start() method.</span>

<span class="sd">    Then one can iterate over the neighbors using the MakeNextNeighbor method.</span>
<span class="sd">    This method returns an assignment which represents the incremental changes</span>
<span class="sd">    to the current solution. It also returns a second assignment representing</span>
<span class="sd">    the changes to the last solution defined by the neighborhood operator; this</span>
<span class="sd">    assignment is empty if the neighborhood operator cannot track this</span>
<span class="sd">    information.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">NextNeighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">LocalSearchOperator_NextNeighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">LocalSearchOperator_Start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__disown__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">disown</span><span class="p">()</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">disown_LocalSearchOperator</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<span class="c1"># Register LocalSearchOperator in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">LocalSearchOperator_swigregister</span><span class="p">(</span><span class="n">LocalSearchOperator</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">IntVarLocalSearchOperatorTemplate</span><span class="p">(</span><span class="n">LocalSearchOperator</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Base operator class for operators manipulating variables.&quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">Start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method should not be overridden. Override OnStart() instead which is</span>
<span class="sd">        called before exiting this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchOperatorTemplate_Start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsIncremental</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchOperatorTemplate_IsIncremental</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchOperatorTemplate_Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;long const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the value in the current assignment of the variable of given</span>
<span class="sd">        index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchOperatorTemplate_Value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">OldValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;long const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchOperatorTemplate_OldValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;long const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchOperatorTemplate_SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">OnStart</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called by Start() after synchronizing the operator with the current</span>
<span class="sd">        assignment. Should be overridden instead of Start() to avoid calling</span>
<span class="sd">        VarLocalSearchOperator::Start explicitly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchOperatorTemplate_OnStart</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<span class="c1"># Register IntVarLocalSearchOperatorTemplate in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchOperatorTemplate_swigregister</span><span class="p">(</span><span class="n">IntVarLocalSearchOperatorTemplate</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">IntVarLocalSearchOperator</span><span class="p">(</span><span class="n">IntVarLocalSearchOperatorTemplate</span><span class="p">):</span>
    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">IntVarLocalSearchOperator</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchOperator_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_IntVarLocalSearchOperator</span><span class="p">(</span><span class="n">_self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">))</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_IntVarLocalSearchOperator</span>

    <span class="k">def</span> <span class="nf">NextNeighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Redefines MakeNextNeighbor to export a simpler interface. The calls to</span>
<span class="sd">        ApplyChanges() and RevertChanges() are factored in this method, hiding</span>
<span class="sd">        both delta and deltadelta from subclasses which only need to override</span>
<span class="sd">        MakeOneNeighbor().</span>
<span class="sd">        Therefore this method should not be overridden. Override MakeOneNeighbor()</span>
<span class="sd">        instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchOperator_NextNeighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">OneNeighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new neighbor. It returns false when the neighborhood is</span>
<span class="sd">        completely explored.</span>
<span class="sd">        MakeNextNeighbor() in a subclass of IntVarLocalSearchOperator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchOperator_OneNeighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__disown__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">disown</span><span class="p">()</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">disown_IntVarLocalSearchOperator</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<span class="c1"># Register IntVarLocalSearchOperator in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchOperator_swigregister</span><span class="p">(</span><span class="n">IntVarLocalSearchOperator</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">SequenceVarLocalSearchOperatorTemplate</span><span class="p">(</span><span class="n">LocalSearchOperator</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Base operator class for operators manipulating variables.&quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">Start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method should not be overridden. Override OnStart() instead which is</span>
<span class="sd">        called before exiting this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarLocalSearchOperatorTemplate_Start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsIncremental</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarLocalSearchOperatorTemplate_IsIncremental</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarLocalSearchOperatorTemplate_Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the value in the current assignment of the variable of given</span>
<span class="sd">        index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarLocalSearchOperatorTemplate_Value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">OldValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarLocalSearchOperatorTemplate_OldValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarLocalSearchOperatorTemplate_SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">OnStart</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called by Start() after synchronizing the operator with the current</span>
<span class="sd">        assignment. Should be overridden instead of Start() to avoid calling</span>
<span class="sd">        VarLocalSearchOperator::Start explicitly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarLocalSearchOperatorTemplate_OnStart</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<span class="c1"># Register SequenceVarLocalSearchOperatorTemplate in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarLocalSearchOperatorTemplate_swigregister</span><span class="p">(</span><span class="n">SequenceVarLocalSearchOperatorTemplate</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">SequenceVarLocalSearchOperator</span><span class="p">(</span><span class="n">SequenceVarLocalSearchOperatorTemplate</span><span class="p">):</span>
    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

<span class="c1"># Register SequenceVarLocalSearchOperator in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarLocalSearchOperator_swigregister</span><span class="p">(</span><span class="n">SequenceVarLocalSearchOperator</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">BaseLns</span><span class="p">(</span><span class="n">IntVarLocalSearchOperator</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is the base class for building an Lns operator. An Lns fragment is a</span>
<span class="sd">    collection of variables which will be relaxed. Fragments are built with</span>
<span class="sd">    NextFragment(), which returns false if there are no more fragments to build.</span>
<span class="sd">    Optionally one can override InitFragments, which is called from</span>
<span class="sd">    LocalSearchOperator::Start to initialize fragment data.</span>

<span class="sd">    Here&#39;s a sample relaxing one variable at a time:</span>

<span class="sd">    class OneVarLns : public BaseLns {</span>
<span class="sd">     public:</span>
<span class="sd">      OneVarLns(const std::vector&lt;IntVar*&gt;&amp; vars) : BaseLns(vars), index_(0) {}</span>
<span class="sd">      virtual ~OneVarLns() {}</span>
<span class="sd">      virtual void InitFragments() { index_ = 0; }</span>
<span class="sd">      virtual bool NextFragment() {</span>
<span class="sd">        const int size = Size();</span>
<span class="sd">        if (index_ &lt; size) {</span>
<span class="sd">          AppendToFragment(index_);</span>
<span class="sd">          ++index_;</span>
<span class="sd">          return true;</span>
<span class="sd">        } else {</span>
<span class="sd">          return false;</span>
<span class="sd">        }</span>
<span class="sd">      }</span>

<span class="sd">     private:</span>
<span class="sd">      int index_;</span>
<span class="sd">    };</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">BaseLns</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BaseLns_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_BaseLns</span><span class="p">(</span><span class="n">_self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">))</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_BaseLns</span>

    <span class="k">def</span> <span class="nf">InitFragments</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BaseLns_InitFragments</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NextFragment</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BaseLns_NextFragment</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AppendToFragment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BaseLns_AppendToFragment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">FragmentSize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BaseLns_FragmentSize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BaseLns___getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BaseLns___len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__disown__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">disown</span><span class="p">()</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">disown_BaseLns</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<span class="c1"># Register BaseLns in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BaseLns_swigregister</span><span class="p">(</span><span class="n">BaseLns</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">ChangeValue</span><span class="p">(</span><span class="n">IntVarLocalSearchOperator</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines operators which change the value of variables;</span>
<span class="sd">    each neighbor corresponds to *one* modified variable.</span>
<span class="sd">    Sub-classes have to define ModifyValue which determines what the new</span>
<span class="sd">    variable value is going to be (given the current value and the variable).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">ChangeValue</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">ChangeValue_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_ChangeValue</span><span class="p">(</span><span class="n">_self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">))</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_ChangeValue</span>

    <span class="k">def</span> <span class="nf">ModifyValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">ChangeValue_ModifyValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">OneNeighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This method should not be overridden. Override ModifyValue() instead.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">ChangeValue_OneNeighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__disown__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">disown</span><span class="p">()</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">disown_ChangeValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<span class="c1"># Register ChangeValue in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">ChangeValue_swigregister</span><span class="p">(</span><span class="n">ChangeValue</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">PathOperator</span><span class="p">(</span><span class="n">IntVarLocalSearchOperator</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class of the local search operators dedicated to path modifications</span>
<span class="sd">    (a path is a set of nodes linked together by arcs).</span>
<span class="sd">    This family of neighborhoods supposes they are handling next variables</span>
<span class="sd">    representing the arcs (var[i] represents the node immediately after i on</span>
<span class="sd">    a path).</span>
<span class="sd">    Several services are provided:</span>
<span class="sd">    - arc manipulators (SetNext(), ReverseChain(), MoveChain())</span>
<span class="sd">    - path inspectors (Next(), Prev(), IsPathEnd())</span>
<span class="sd">    - path iterators: operators need a given number of nodes to define a</span>
<span class="sd">      neighbor; this class provides the iteration on a given number of (base)</span>
<span class="sd">      nodes which can be used to define a neighbor (through the BaseNode method)</span>
<span class="sd">    Subclasses only need to override MakeNeighbor to create neighbors using</span>
<span class="sd">    the services above (no direct manipulation of assignments).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">Neighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">PathOperator_Neighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<span class="c1"># Register PathOperator in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">PathOperator_swigregister</span><span class="p">(</span><span class="n">PathOperator</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">LocalSearchFilter</span><span class="p">(</span><span class="n">BaseObject</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Classes to which this template function can be applied to as of 04/2014.</span>
<span class="sd">    Usage: LocalSearchOperator* op = MakeLocalSearchOperator&lt;Relocate&gt;(...);</span>
<span class="sd">    class TwoOpt;</span>
<span class="sd">    class Relocate;</span>
<span class="sd">    class Exchange;</span>
<span class="sd">    class Cross;</span>
<span class="sd">    class MakeActiveOperator;</span>
<span class="sd">    class MakeInactiveOperator;</span>
<span class="sd">    class MakeChainInactiveOperator;</span>
<span class="sd">    class SwapActiveOperator;</span>
<span class="sd">    class ExtendedSwapActiveOperator;</span>
<span class="sd">    class MakeActiveAndRelocate;</span>
<span class="sd">    class RelocateAndMakeActiveOperator;</span>
<span class="sd">    class RelocateAndMakeInactiveOperator;</span>
<span class="sd">    Local Search Filters are used for fast neighbor pruning.</span>
<span class="sd">    Filtering a move is done in several phases:</span>
<span class="sd">    - in the Relax phase, filters determine which parts of their internals</span>
<span class="sd">      will be changed by the candidate, and modify intermediary State</span>
<span class="sd">    - in the Accept phase, filters check that the candidate is feasible,</span>
<span class="sd">    - if the Accept phase succeeds, the solver may decide to trigger a</span>
<span class="sd">      Synchronize phase that makes filters change their internal representation</span>
<span class="sd">      to the last candidate,</span>
<span class="sd">    - otherwise (Accept fails or the solver does not want to synchronize),</span>
<span class="sd">      a Revert phase makes filters erase any intermediary State generated by the</span>
<span class="sd">      Relax and Accept phases.</span>
<span class="sd">    A given filter has phases called with the following pattern:</span>
<span class="sd">    (Relax.Accept.Synchronize | Relax.Accept.Revert | Relax.Revert)*.</span>
<span class="sd">    Filters&#39;s Revert() is always called in the reverse order their Accept() was</span>
<span class="sd">    called, to allow late filters to use state done/undone by early filters&#39;</span>
<span class="sd">    Accept()/Revert().</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">Accept</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">objective_min</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">objective_max</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Accepts a &quot;delta&quot; given the assignment with which the filter has been</span>
<span class="sd">        synchronized; the delta holds the variables which have been modified and</span>
<span class="sd">        their new value.</span>
<span class="sd">        If the filter represents a part of the global objective, its contribution</span>
<span class="sd">        must be between objective_min and objective_max.</span>
<span class="sd">        Sample: supposing one wants to maintain a[0,1] + b[0,1] &lt;= 1,</span>
<span class="sd">        for the assignment (a,1), (b,0), the delta (b,1) will be rejected</span>
<span class="sd">        but the delta (a,0) will be accepted.</span>
<span class="sd">        TODO(user): Remove arguments when there are no more need for those.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">LocalSearchFilter_Accept</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">,</span> <span class="n">objective_min</span><span class="p">,</span> <span class="n">objective_max</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsIncremental</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">LocalSearchFilter_IsIncremental</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Synchronize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Synchronizes the filter with the current solution, delta being the</span>
<span class="sd">        difference with the solution passed to the previous call to Synchronize()</span>
<span class="sd">        or IncrementalSynchronize(). &#39;delta&#39; can be used to incrementally</span>
<span class="sd">        synchronizing the filter with the new solution by only considering the</span>
<span class="sd">        changes in delta.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">LocalSearchFilter_Synchronize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_LocalSearchFilter</span>

<span class="c1"># Register LocalSearchFilter in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">LocalSearchFilter_swigregister</span><span class="p">(</span><span class="n">LocalSearchFilter</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">LocalSearchFilterManager</span><span class="p">(</span><span class="n">BaseObject</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filter manager: when a move is made, filters are executed to decide whether</span>
<span class="sd">    the solution is feasible and compute parts of the new cost. This class</span>
<span class="sd">    schedules filter execution and composes costs as a sum.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">LocalSearchFilterManager_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">LocalSearchFilterManager_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_LocalSearchFilterManager</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">Accept</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">monitor</span><span class="p">:</span> <span class="s2">&quot;operations_research::LocalSearchMonitor *const&quot;</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">objective_min</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">objective_max</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns true iff all filters return true, and the sum of their accepted</span>
<span class="sd">        objectives is between objective_min and objective_max.</span>
<span class="sd">        The monitor has its Begin/EndFiltering events triggered.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">LocalSearchFilterManager_Accept</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">monitor</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">,</span> <span class="n">objective_min</span><span class="p">,</span> <span class="n">objective_max</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Synchronize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Synchronizes all filters to assignment.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">LocalSearchFilterManager_Synchronize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_LocalSearchFilterManager</span>

<span class="c1"># Register LocalSearchFilterManager in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">LocalSearchFilterManager_swigregister</span><span class="p">(</span><span class="n">LocalSearchFilterManager</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">IntVarLocalSearchFilter</span><span class="p">(</span><span class="n">LocalSearchFilter</span><span class="p">):</span>
    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">IntVarLocalSearchFilter</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchFilter_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_IntVarLocalSearchFilter</span><span class="p">(</span><span class="n">_self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">))</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_IntVarLocalSearchFilter</span>

    <span class="k">def</span> <span class="nf">Synchronize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method should not be overridden. Override OnSynchronize() instead</span>
<span class="sd">        which is called before exiting this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchFilter_Synchronize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchFilter_Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchFilter_Value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IndexFromVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchFilter_IndexFromVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__disown__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">disown</span><span class="p">()</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">disown_IntVarLocalSearchFilter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<span class="c1"># Register IntVarLocalSearchFilter in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchFilter_swigregister</span><span class="p">(</span><span class="n">IntVarLocalSearchFilter</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">BooleanVar</span><span class="p">(</span><span class="n">IntVar</span><span class="p">):</span>
    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">Min</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_Min</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_SetMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Max</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_Max</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_SetMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">ma</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_SetRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">ma</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Bound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_Bound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RemoveValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_RemoveValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RemoveInterval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_RemoveInterval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WhenBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="s2">&quot;Demon&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_WhenBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WhenRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="s2">&quot;Demon&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_WhenRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WhenDomain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="s2">&quot;Demon&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_WhenDomain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;uint64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_Contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">HoleIteratorAux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reversible</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVarIterator *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_HoleIteratorAux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reversible</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DomainIteratorAux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reversible</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVarIterator *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_DomainIteratorAux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reversible</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<span class="c1"># Register BooleanVar in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_swigregister</span><span class="p">(</span><span class="n">BooleanVar</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">PyDecision</span><span class="p">(</span><span class="n">Decision</span><span class="p">):</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">Decision</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">ApplyWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">Apply</span><span class="p">(</span><span class="n">solver</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
      <span class="k">if</span> <span class="s1">&#39;CP Solver fail&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">ShouldFail</span><span class="p">()</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span>

  <span class="k">def</span> <span class="nf">RefuteWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">Refute</span><span class="p">(</span><span class="n">solver</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
      <span class="k">if</span> <span class="s1">&#39;CP Solver fail&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">ShouldFail</span><span class="p">()</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span>

  <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="s2">&quot;PyDecision&quot;</span>


<span class="k">class</span> <span class="nc">PyDecisionBuilder</span><span class="p">(</span><span class="n">DecisionBuilder</span><span class="p">):</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">DecisionBuilder</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">NextWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Next</span><span class="p">(</span><span class="n">solver</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
      <span class="k">if</span> <span class="s1">&#39;CP Solver fail&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">solver</span><span class="o">.</span><span class="n">FailDecision</span><span class="p">()</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span>

  <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="s2">&quot;PyDecisionBuilder&quot;</span>


<span class="k">class</span> <span class="nc">PyDemon</span><span class="p">(</span><span class="n">Demon</span><span class="p">):</span>

  <span class="k">def</span> <span class="nf">RunWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">Run</span><span class="p">(</span><span class="n">solver</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
      <span class="k">if</span> <span class="s1">&#39;CP Solver fail&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">ShouldFail</span><span class="p">()</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span>

  <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="s2">&quot;PyDemon&quot;</span>


<span class="k">class</span> <span class="nc">PyConstraintDemon</span><span class="p">(</span><span class="n">PyDemon</span><span class="p">):</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ct</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">delayed</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="n">PyDemon</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__constraint</span> <span class="o">=</span> <span class="n">ct</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__method</span> <span class="o">=</span> <span class="n">method</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__delayed</span> <span class="o">=</span> <span class="n">delayed</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__args</span> <span class="o">=</span> <span class="n">args</span>

  <span class="k">def</span> <span class="nf">Run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__method</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__constraint</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">__args</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">Priority</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Solver</span><span class="o">.</span><span class="n">DELAYED_PRIORITY</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__delayed</span> <span class="k">else</span> <span class="n">Solver</span><span class="o">.</span><span class="n">NORMAL_PRIORITY</span>

  <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="s1">&#39;PyConstraintDemon&#39;</span>


<span class="k">class</span> <span class="nc">PyConstraint</span><span class="p">(</span><span class="n">Constraint</span><span class="p">):</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver</span><span class="p">):</span>
    <span class="n">Constraint</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__demons</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="k">def</span> <span class="nf">Demon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="n">demon</span> <span class="o">=</span> <span class="n">PyConstraintDemon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__demons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">demon</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">demon</span>

  <span class="k">def</span> <span class="nf">DelayedDemon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="n">demon</span> <span class="o">=</span> <span class="n">PyConstraintDemon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__demons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">demon</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">demon</span>

  <span class="k">def</span> <span class="nf">InitialPropagateDemon</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">()</span><span class="o">.</span><span class="n">ConstraintInitialPropagateCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">DelayedInitialPropagateDemon</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">()</span><span class="o">.</span><span class="n">DelayedConstraintInitialPropagateCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">InitialPropagateWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">InitialPropagate</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
      <span class="k">if</span> <span class="s1">&#39;CP Solver fail&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">()</span><span class="o">.</span><span class="n">ShouldFail</span><span class="p">()</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span>

  <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="s2">&quot;PyConstraint&quot;</span>



<span class="k">class</span> <span class="nc">RoutingIndexManager</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Manager for any NodeIndex &lt;-&gt; variable index conversion. The routing solver</span>
<span class="sd">    uses variable indices internally and through its API. These variable indices</span>
<span class="sd">    are tricky to manage directly because one Node can correspond to a multitude</span>
<span class="sd">    of variables, depending on the number of times they appear in the model, and</span>
<span class="sd">    if they&#39;re used as start and/or end points. This class aims to simplify</span>
<span class="sd">    variable index usage, allowing users to use NodeIndex instead.</span>

<span class="sd">    Usage:</span>

<span class="sd">      .. code-block:: c++</span>

<span class="sd">          auto starts_ends = ...;  /// These are NodeIndex.</span>
<span class="sd">          RoutingIndexManager manager(10, 4, starts_ends);  // 10 nodes, 4 vehicles.</span>
<span class="sd">          RoutingModel model(manager);</span>

<span class="sd">    Then, use &#39;manager.NodeToIndex(node)&#39; whenever model requires a variable</span>
<span class="sd">    index.</span>

<span class="sd">    Note: the mapping between node indices and variables indices is subject to</span>
<span class="sd">    change so no assumption should be made on it. The only guarantee is that</span>
<span class="sd">    indices range between 0 and n-1, where n = number of vehicles * 2 (for start</span>
<span class="sd">    and end nodes) + number of non-start or end nodes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingIndexManager_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_RoutingIndexManager</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_RoutingIndexManager</span>

    <span class="k">def</span> <span class="nf">GetNumberOfNodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingIndexManager_GetNumberOfNodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetNumberOfVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingIndexManager_GetNumberOfVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetNumberOfIndices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingIndexManager_GetNumberOfIndices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetStartIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingIndexManager_GetStartIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetEndIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingIndexManager_GetEndIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NodeToIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingIndexManager::NodeIndex&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingIndexManager_NodeToIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IndexToNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingIndexManager::NodeIndex&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingIndexManager_IndexToNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

<span class="c1"># Register RoutingIndexManager in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingIndexManager_swigregister</span><span class="p">(</span><span class="n">RoutingIndexManager</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">DefaultRoutingModelParameters</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingModelParameters&quot;</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultRoutingModelParameters</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">DefaultRoutingSearchParameters</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingSearchParameters&quot;</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultRoutingSearchParameters</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">FindErrorInRoutingSearchParameters</span><span class="p">(</span><span class="n">search_parameters</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingSearchParameters const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns an empty std::string if the routing search parameters are valid, and</span>
<span class="sd">    a non-empty, human readable error description if they&#39;re not.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">FindErrorInRoutingSearchParameters</span><span class="p">(</span><span class="n">search_parameters</span><span class="p">)</span>
<span class="n">BOOL_UNSPECIFIED</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BOOL_UNSPECIFIED</span>
<span class="n">BOOL_FALSE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BOOL_FALSE</span>
<span class="n">BOOL_TRUE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BOOL_TRUE</span>
<span class="k">class</span> <span class="nc">RoutingModel</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>
    <span class="n">ROUTING_NOT_SOLVED</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_ROUTING_NOT_SOLVED</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Problem not solved yet (before calling RoutingModel::Solve()).&quot;&quot;&quot;</span>
    <span class="n">ROUTING_SUCCESS</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_ROUTING_SUCCESS</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Problem solved successfully after calling RoutingModel::Solve().&quot;&quot;&quot;</span>
    <span class="n">ROUTING_FAIL</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_ROUTING_FAIL</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; No solution found to the problem after calling RoutingModel::Solve().&quot;&quot;&quot;</span>
    <span class="n">ROUTING_FAIL_TIMEOUT</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_ROUTING_FAIL_TIMEOUT</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Time limit reached before finding a solution with RoutingModel::Solve().&quot;&quot;&quot;</span>
    <span class="n">ROUTING_INVALID</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_ROUTING_INVALID</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Model, model parameters or flags are not valid.&quot;&quot;&quot;</span>
    <span class="n">PICKUP_AND_DELIVERY_NO_ORDER</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_PICKUP_AND_DELIVERY_NO_ORDER</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Any precedence is accepted.&quot;&quot;&quot;</span>
    <span class="n">PICKUP_AND_DELIVERY_LIFO</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_PICKUP_AND_DELIVERY_LIFO</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Deliveries must be performed in reverse order of pickups.&quot;&quot;&quot;</span>
    <span class="n">PICKUP_AND_DELIVERY_FIFO</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_PICKUP_AND_DELIVERY_FIFO</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Deliveries must be performed in the same order as pickups.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_RoutingModel</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_RoutingModel</span>

    <span class="k">def</span> <span class="nf">RegisterUnaryTransitVector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Registers &#39;callback&#39; and returns its index.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_RegisterUnaryTransitVector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RegisterUnaryTransitCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingModel::TransitCallback1&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_RegisterUnaryTransitCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RegisterPositiveUnaryTransitCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingModel::TransitCallback1&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_RegisterPositiveUnaryTransitCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RegisterTransitMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; std::vector&lt; int64_t &gt; &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_RegisterTransitMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RegisterTransitCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingModel::TransitCallback2&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_RegisterTransitCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RegisterPositiveTransitCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingModel::TransitCallback2&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_RegisterPositiveTransitCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">TransitCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback_index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingModel::TransitCallback2 const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_TransitCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback_index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">UnaryTransitCallbackOrNull</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback_index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingModel::TransitCallback1 const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_UnaryTransitCallbackOrNull</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback_index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator_index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">slack_max</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Model creation</span>
<span class="sd">        Methods to add dimensions to routes; dimensions represent quantities</span>
<span class="sd">        accumulated at nodes along the routes. They represent quantities such as</span>
<span class="sd">        weights or volumes carried along the route, or distance or times.</span>
<span class="sd">        Quantities at a node are represented by &quot;cumul&quot; variables and the increase</span>
<span class="sd">        or decrease of quantities between nodes are represented by &quot;transit&quot;</span>
<span class="sd">        variables. These variables are linked as follows:</span>
<span class="sd">        if j == next(i), cumul(j) = cumul(i) + transit(i) + slack(i)</span>
<span class="sd">        where slack is a positive slack variable (can represent waiting times for</span>
<span class="sd">        a time dimension).</span>
<span class="sd">        Setting the value of fix_start_cumul_to_zero to true will force the</span>
<span class="sd">        &quot;cumul&quot; variable of the start node of all vehicles to be equal to 0.</span>
<span class="sd">        Creates a dimension where the transit variable is constrained to be</span>
<span class="sd">        equal to evaluator(i, next(i)); &#39;slack_max&#39; is the upper bound of the</span>
<span class="sd">        slack variable and &#39;capacity&#39; is the upper bound of the cumul variables.</span>
<span class="sd">        &#39;name&#39; is the name used to reference the dimension; this name is used to</span>
<span class="sd">        get cumul and transit variables from the routing model.</span>
<span class="sd">        Returns false if a dimension with the same name has already been created</span>
<span class="sd">        (and doesn&#39;t create the new dimension).</span>
<span class="sd">        Takes ownership of the callback &#39;evaluator&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator_index</span><span class="p">,</span> <span class="n">slack_max</span><span class="p">,</span> <span class="n">capacity</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddDimensionWithVehicleTransits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator_indices</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">slack_max</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddDimensionWithVehicleTransits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator_indices</span><span class="p">,</span> <span class="n">slack_max</span><span class="p">,</span> <span class="n">capacity</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddDimensionWithVehicleCapacity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator_index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">slack_max</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">vehicle_capacities</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt;&quot;</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddDimensionWithVehicleCapacity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator_index</span><span class="p">,</span> <span class="n">slack_max</span><span class="p">,</span> <span class="n">vehicle_capacities</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddDimensionWithVehicleTransitAndCapacity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator_indices</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">slack_max</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">vehicle_capacities</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt;&quot;</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddDimensionWithVehicleTransitAndCapacity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator_indices</span><span class="p">,</span> <span class="n">slack_max</span><span class="p">,</span> <span class="n">vehicle_capacities</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddConstantDimensionWithSlack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">slack_max</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::pair&lt; int,bool &gt;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a dimension where the transit variable is constrained to be</span>
<span class="sd">        equal to &#39;value&#39;; &#39;capacity&#39; is the upper bound of the cumul variables.</span>
<span class="sd">        &#39;name&#39; is the name used to reference the dimension; this name is used to</span>
<span class="sd">        get cumul and transit variables from the routing model.</span>
<span class="sd">        Returns a pair consisting of an index to the registered unary transit</span>
<span class="sd">        callback and a bool denoting whether the dimension has been created.</span>
<span class="sd">        It is false if a dimension with the same name has already been created</span>
<span class="sd">        (and doesn&#39;t create the new dimension but still register a new callback).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddConstantDimensionWithSlack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">capacity</span><span class="p">,</span> <span class="n">slack_max</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddConstantDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::pair&lt; int,bool &gt;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddConstantDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">capacity</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddVectorDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt;&quot;</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::pair&lt; int,bool &gt;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a dimension where the transit variable is constrained to be</span>
<span class="sd">        equal to &#39;values[i]&#39; for node i; &#39;capacity&#39; is the upper bound of</span>
<span class="sd">        the cumul variables. &#39;name&#39; is the name used to reference the dimension;</span>
<span class="sd">        this name is used to get cumul and transit variables from the routing</span>
<span class="sd">        model.</span>
<span class="sd">        Returns a pair consisting of an index to the registered unary transit</span>
<span class="sd">        callback and a bool denoting whether the dimension has been created.</span>
<span class="sd">        It is false if a dimension with the same name has already been created</span>
<span class="sd">        (and doesn&#39;t create the new dimension but still register a new callback).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddVectorDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">capacity</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddMatrixDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; std::vector&lt; int64_t &gt; &gt;&quot;</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::pair&lt; int,bool &gt;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a dimension where the transit variable is constrained to be</span>
<span class="sd">        equal to &#39;values[i][next(i)]&#39; for node i; &#39;capacity&#39; is the upper bound of</span>
<span class="sd">        the cumul variables. &#39;name&#39; is the name used to reference the dimension;</span>
<span class="sd">        this name is used to get cumul and transit variables from the routing</span>
<span class="sd">        model.</span>
<span class="sd">        Returns a pair consisting of an index to the registered transit callback</span>
<span class="sd">        and a bool denoting whether the dimension has been created.</span>
<span class="sd">        It is false if a dimension with the same name has already been created</span>
<span class="sd">        (and doesn&#39;t create the new dimension but still register a new callback).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddMatrixDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">capacity</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">MakePathSpansAndTotalSlacks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="s2">&quot;RoutingDimension&quot;</span><span class="p">,</span> <span class="n">spans</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt;&quot;</span><span class="p">,</span> <span class="n">total_slacks</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For every vehicle of the routing model:</span>
<span class="sd">        - if total_slacks[vehicle] is not nullptr, constrains it to be the sum of</span>
<span class="sd">          slacks on that vehicle, that is,</span>
<span class="sd">          dimension-&gt;CumulVar(end) - dimension-&gt;CumulVar(start) -</span>
<span class="sd">          sum_{node in path of vehicle} dimension-&gt;FixedTransitVar(node).</span>
<span class="sd">        - if spans[vehicle] is not nullptr, constrains it to be</span>
<span class="sd">          dimension-&gt;CumulVar(end) - dimension-&gt;CumulVar(start)</span>
<span class="sd">        This does stronger propagation than a decomposition, and takes breaks into</span>
<span class="sd">        account.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_MakePathSpansAndTotalSlacks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">spans</span><span class="p">,</span> <span class="n">total_slacks</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetAllDimensionNames</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; std::string &gt;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Outputs the names of all dimensions added to the routing engine.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetAllDimensionNames</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetDimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; operations_research::RoutingDimension * &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns all dimensions of the model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetDimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetDimensionsWithSoftOrSpanCosts</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; operations_research::RoutingDimension * &gt;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns dimensions with soft or vehicle span costs.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetDimensionsWithSoftOrSpanCosts</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetGlobalDimensionCumulOptimizers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; std::unique_ptr&lt; operations_research::GlobalDimensionCumulOptimizer &gt; &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns [global|local]_dimension_optimizers_, which are empty if the model</span>
<span class="sd">        has not been closed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetGlobalDimensionCumulOptimizers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetGlobalDimensionCumulMPOptimizers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; std::unique_ptr&lt; operations_research::GlobalDimensionCumulOptimizer &gt; &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetGlobalDimensionCumulMPOptimizers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetLocalDimensionCumulOptimizers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; std::unique_ptr&lt; operations_research::LocalDimensionCumulOptimizer &gt; &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetLocalDimensionCumulOptimizers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetLocalDimensionCumulMPOptimizers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; std::unique_ptr&lt; operations_research::LocalDimensionCumulOptimizer &gt; &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetLocalDimensionCumulMPOptimizers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetMutableGlobalCumulOptimizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="s2">&quot;RoutingDimension&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::GlobalDimensionCumulOptimizer *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the global/local dimension cumul optimizer for a given dimension,</span>
<span class="sd">        or nullptr if there is none.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetMutableGlobalCumulOptimizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetMutableGlobalCumulMPOptimizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="s2">&quot;RoutingDimension&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::GlobalDimensionCumulOptimizer *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetMutableGlobalCumulMPOptimizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetMutableLocalCumulOptimizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="s2">&quot;RoutingDimension&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::LocalDimensionCumulOptimizer *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetMutableLocalCumulOptimizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetMutableLocalCumulMPOptimizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="s2">&quot;RoutingDimension&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::LocalDimensionCumulOptimizer *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetMutableLocalCumulMPOptimizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">HasDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension_name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns true if a dimension exists for a given dimension name.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_HasDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetDimensionOrDie</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension_name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingDimension const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns a dimension from its name. Dies if the dimension does not exist.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetDimensionOrDie</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetMutableDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension_name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingDimension *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dimension from its name. Returns nullptr if the dimension does</span>
<span class="sd">        not exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetMutableDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetPrimaryConstrainedDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension_name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the given dimension as &quot;primary constrained&quot;. As of August 2013, this</span>
<span class="sd">        is only used by ArcIsMoreConstrainedThanArc().</span>
<span class="sd">        &quot;dimension&quot; must be the name of an existing dimension, or be empty, in</span>
<span class="sd">        which case there will not be a primary dimension after this call.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetPrimaryConstrainedDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetPrimaryConstrainedDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Get the primary constrained dimension, or an empty string if it is unset.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetPrimaryConstrainedDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetDimensionResourceGroupIndices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="s2">&quot;RoutingDimension&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the indices of resource groups for this dimension. This method can</span>
<span class="sd">        only be called after the model has been closed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetDimensionResourceGroupIndices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddDisjunction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingModel::DisjunctionIndex&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a disjunction constraint on the indices: exactly &#39;max_cardinality&#39; of</span>
<span class="sd">        the indices are active. Start and end indices of any vehicle cannot be</span>
<span class="sd">        part of a disjunction.</span>

<span class="sd">        If a penalty is given, at most &#39;max_cardinality&#39; of the indices can be</span>
<span class="sd">        active, and if less are active, &#39;penalty&#39; is payed per inactive index.</span>
<span class="sd">        This is equivalent to adding the constraint:</span>
<span class="sd">            p + Sum(i)active[i] == max_cardinality</span>
<span class="sd">        where p is an integer variable, and the following cost to the cost</span>
<span class="sd">        function:</span>
<span class="sd">            p * penalty.</span>
<span class="sd">        &#39;penalty&#39; must be positive to make the disjunction optional; a negative</span>
<span class="sd">        penalty will force &#39;max_cardinality&#39; indices of the disjunction to be</span>
<span class="sd">        performed, and therefore p == 0.</span>
<span class="sd">        Note: passing a vector with a single index will model an optional index</span>
<span class="sd">        with a penalty cost if it is not visited.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddDisjunction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetDisjunctionIndices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; operations_research::RoutingModel::DisjunctionIndex &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the indices of the disjunctions to which an index belongs.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetDisjunctionIndices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetDisjunctionPenalty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingModel::DisjunctionIndex&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the penalty of the node disjunction of index &#39;index&#39;.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetDisjunctionPenalty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetDisjunctionMaxCardinality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingModel::DisjunctionIndex&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the maximum number of possible active nodes of the node</span>
<span class="sd">        disjunction of index &#39;index&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetDisjunctionMaxCardinality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetNumberOfDisjunctions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the number of node disjunctions in the model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetNumberOfDisjunctions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetPerfectBinaryDisjunctions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; std::pair&lt; int64_t,int64_t &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the list of all perfect binary disjunctions, as pairs of variable</span>
<span class="sd">        indices: a disjunction is &quot;perfect&quot; when its variables do not appear in</span>
<span class="sd">        any other disjunction. Each pair is sorted (lowest variable index first),</span>
<span class="sd">        and the output vector is also sorted (lowest pairs first).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetPerfectBinaryDisjunctions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IgnoreDisjunctionsAlreadyForcedToZero</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        SPECIAL: Makes the solver ignore all the disjunctions whose active</span>
<span class="sd">        variables are all trivially zero (i.e. Max() == 0), by setting their</span>
<span class="sd">        max_cardinality to 0.</span>
<span class="sd">        This can be useful when using the BaseBinaryDisjunctionNeighborhood</span>
<span class="sd">        operators, in the context of arc-based routing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_IgnoreDisjunctionsAlreadyForcedToZero</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddSoftSameVehicleConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">cost</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a soft constraint to force a set of variable indices to be on the</span>
<span class="sd">        same vehicle. If all nodes are not on the same vehicle, each extra vehicle</span>
<span class="sd">        used adds &#39;cost&#39; to the cost function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddSoftSameVehicleConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">cost</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetAllowedVehiclesForIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicles</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the vehicles which can visit a given node. If the node is in a</span>
<span class="sd">        disjunction, this will not prevent it from being unperformed.</span>
<span class="sd">        Specifying an empty vector of vehicles has no effect (all vehicles</span>
<span class="sd">        will be allowed to visit the node).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetAllowedVehiclesForIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicles</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsVehicleAllowedForIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns true if a vehicle is allowed to visit a given node.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_IsVehicleAllowedForIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddPickupAndDelivery</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pickup</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">delivery</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Notifies that index1 and index2 form a pair of nodes which should belong</span>
<span class="sd">        to the same route. This methods helps the search find better solutions,</span>
<span class="sd">        especially in the local search phase.</span>
<span class="sd">        It should be called each time you have an equality constraint linking</span>
<span class="sd">        the vehicle variables of two node (including for instance pickup and</span>
<span class="sd">        delivery problems):</span>
<span class="sd">            Solver* const solver = routing.solver();</span>
<span class="sd">            int64_t index1 = manager.NodeToIndex(node1);</span>
<span class="sd">            int64_t index2 = manager.NodeToIndex(node2);</span>
<span class="sd">            solver-&gt;AddConstraint(solver-&gt;MakeEquality(</span>
<span class="sd">                routing.VehicleVar(index1),</span>
<span class="sd">                routing.VehicleVar(index2)));</span>
<span class="sd">            routing.AddPickupAndDelivery(index1, index2);</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddPickupAndDelivery</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pickup</span><span class="p">,</span> <span class="n">delivery</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddPickupAndDeliverySets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pickup_disjunction</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingModel::DisjunctionIndex&quot;</span><span class="p">,</span> <span class="n">delivery_disjunction</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingModel::DisjunctionIndex&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as AddPickupAndDelivery but notifying that the performed node from</span>
<span class="sd">        the disjunction of index &#39;pickup_disjunction&#39; is on the same route as the</span>
<span class="sd">        performed node from the disjunction of index &#39;delivery_disjunction&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddPickupAndDeliverySets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pickup_disjunction</span><span class="p">,</span> <span class="n">delivery_disjunction</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetPickupIndexPairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; std::pair&lt; int,int &gt; &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns pairs for which the node is a pickup; the first element of each</span>
<span class="sd">        pair is the index in the pickup and delivery pairs list in which the</span>
<span class="sd">        pickup appears, the second element is its index in the pickups list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetPickupIndexPairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetDeliveryIndexPairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; std::pair&lt; int,int &gt; &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Same as above for deliveries.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetDeliveryIndexPairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetPickupAndDeliveryPolicyOfAllVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">policy</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingModel::PickupAndDeliveryPolicy&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the Pickup and delivery policy of all vehicles. It is equivalent to</span>
<span class="sd">        calling SetPickupAndDeliveryPolicyOfVehicle on all vehicles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetPickupAndDeliveryPolicyOfAllVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">policy</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetPickupAndDeliveryPolicyOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">policy</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingModel::PickupAndDeliveryPolicy&quot;</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetPickupAndDeliveryPolicyOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">policy</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetPickupAndDeliveryPolicyOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingModel::PickupAndDeliveryPolicy&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetPickupAndDeliveryPolicyOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetNumOfSingletonNodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of non-start/end nodes which do not appear in a</span>
<span class="sd">        pickup/delivery pair.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetNumOfSingletonNodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">TYPE_ADDED_TO_VEHICLE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_TYPE_ADDED_TO_VEHICLE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; When visited, the number of types &#39;T&#39; on the vehicle increases by one.&quot;&quot;&quot;</span>
    <span class="n">ADDED_TYPE_REMOVED_FROM_VEHICLE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_ADDED_TYPE_REMOVED_FROM_VEHICLE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    When visited, one instance of type &#39;T&#39; previously added to the route</span>
<span class="sd">    (TYPE_ADDED_TO_VEHICLE), if any, is removed from the vehicle.</span>
<span class="sd">    If the type was not previously added to the route or all added instances</span>
<span class="sd">    have already been removed, this visit has no effect on the types.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">TYPE_ON_VEHICLE_UP_TO_VISIT</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_TYPE_ON_VEHICLE_UP_TO_VISIT</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    With the following policy, the visit enforces that type &#39;T&#39; is</span>
<span class="sd">    considered on the route from its start until this node is visited.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The visit doesn&#39;t have an impact on the number of types &#39;T&#39; on the</span>
<span class="sd">    route, as it&#39;s (virtually) added and removed directly.</span>
<span class="sd">    This policy can be used for visits which are part of an incompatibility</span>
<span class="sd">    or requirement set without affecting the type count on the route.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">SetVisitType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">type_policy</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingModel::VisitTypePolicy&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetVisitType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">type_policy</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetVisitType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetVisitType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetSingleNodesOfType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetSingleNodesOfType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetPairIndicesOfType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetPairIndicesOfType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetVisitTypePolicy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingModel::VisitTypePolicy&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetVisitTypePolicy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">CloseVisitTypes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function should be called once all node visit types have been set and</span>
<span class="sd">        prior to adding any incompatibilities/requirements.</span>
<span class="sd">        &quot;close&quot; types.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_CloseVisitTypes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetNumberOfVisitTypes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetNumberOfVisitTypes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddHardTypeIncompatibility</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type1</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">type2</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Incompatibilities:</span>
<span class="sd">        Two nodes with &quot;hard&quot; incompatible types cannot share the same route at</span>
<span class="sd">        all, while with a &quot;temporal&quot; incompatibility they can&#39;t be on the same</span>
<span class="sd">        route at the same time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddHardTypeIncompatibility</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type1</span><span class="p">,</span> <span class="n">type2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddTemporalTypeIncompatibility</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type1</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">type2</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddTemporalTypeIncompatibility</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type1</span><span class="p">,</span> <span class="n">type2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetHardTypeIncompatibilitiesOfType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;absl::flat_hash_set&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns visit types incompatible with a given type.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetHardTypeIncompatibilitiesOfType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetTemporalTypeIncompatibilitiesOfType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;absl::flat_hash_set&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetTemporalTypeIncompatibilitiesOfType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">HasHardTypeIncompatibilities</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns true iff any hard (resp. temporal) type incompatibilities have</span>
<span class="sd">        been added to the model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_HasHardTypeIncompatibilities</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">HasTemporalTypeIncompatibilities</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_HasTemporalTypeIncompatibilities</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddSameVehicleRequiredTypeAlternatives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dependent_type</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">required_type_alternatives</span><span class="p">:</span> <span class="s2">&quot;absl::flat_hash_set&lt; int &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Requirements:</span>
<span class="sd">        NOTE: As of 2019-04, cycles in the requirement graph are not supported,</span>
<span class="sd">        and lead to the dependent nodes being skipped if possible (otherwise</span>
<span class="sd">        the model is considered infeasible).</span>
<span class="sd">        The following functions specify that &quot;dependent_type&quot; requires at least</span>
<span class="sd">        one of the types in &quot;required_type_alternatives&quot;.</span>

<span class="sd">        For same-vehicle requirements, a node of dependent type type_D requires at</span>
<span class="sd">        least one node of type type_R among the required alternatives on the same</span>
<span class="sd">        route.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddSameVehicleRequiredTypeAlternatives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dependent_type</span><span class="p">,</span> <span class="n">required_type_alternatives</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddRequiredTypeAlternativesWhenAddingType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dependent_type</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">required_type_alternatives</span><span class="p">:</span> <span class="s2">&quot;absl::flat_hash_set&lt; int &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If type_D depends on type_R when adding type_D, any node_D of type_D and</span>
<span class="sd">        VisitTypePolicy TYPE_ADDED_TO_VEHICLE or</span>
<span class="sd">        TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED requires at least one type_R on its</span>
<span class="sd">        vehicle at the time node_D is visited.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddRequiredTypeAlternativesWhenAddingType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dependent_type</span><span class="p">,</span> <span class="n">required_type_alternatives</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddRequiredTypeAlternativesWhenRemovingType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dependent_type</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">required_type_alternatives</span><span class="p">:</span> <span class="s2">&quot;absl::flat_hash_set&lt; int &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The following requirements apply when visiting dependent nodes that remove</span>
<span class="sd">        their type from the route, i.e. type_R must be on the vehicle when type_D</span>
<span class="sd">        of VisitTypePolicy ADDED_TYPE_REMOVED_FROM_VEHICLE,</span>
<span class="sd">        TYPE_ON_VEHICLE_UP_TO_VISIT or TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED is</span>
<span class="sd">        visited.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddRequiredTypeAlternativesWhenRemovingType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dependent_type</span><span class="p">,</span> <span class="n">required_type_alternatives</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetSameVehicleRequiredTypeAlternativesOfType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; absl::flat_hash_set&lt; int &gt; &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the set of same-vehicle requirement alternatives for the given</span>
<span class="sd">        type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetSameVehicleRequiredTypeAlternativesOfType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetRequiredTypeAlternativesWhenAddingType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; absl::flat_hash_set&lt; int &gt; &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the set of requirement alternatives when adding the given type.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetRequiredTypeAlternativesWhenAddingType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetRequiredTypeAlternativesWhenRemovingType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; absl::flat_hash_set&lt; int &gt; &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the set of requirement alternatives when removing the given type.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetRequiredTypeAlternativesWhenRemovingType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">HasSameVehicleTypeRequirements</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns true iff any same-route (resp. temporal) type requirements have</span>
<span class="sd">        been added to the model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_HasSameVehicleTypeRequirements</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">HasTemporalTypeRequirements</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_HasTemporalTypeRequirements</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">HasTypeRegulations</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns true iff the model has any incompatibilities or requirements set</span>
<span class="sd">        on node types.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_HasTypeRegulations</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">UnperformedPenalty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the &quot;unperformed&quot; penalty of a node. This is only well defined if the</span>
<span class="sd">        node is only part of a single Disjunction, and that disjunction has a</span>
<span class="sd">        penalty. For forced active nodes returns max int64_t. In all other cases,</span>
<span class="sd">        this returns 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_UnperformedPenalty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">UnperformedPenaltyOrValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">default_value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">var_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as above except that it returns default_value instead of 0 when</span>
<span class="sd">        penalty is not well defined (default value is passed as first argument to</span>
<span class="sd">        simplify the usage of the method in a callback).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_UnperformedPenaltyOrValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">default_value</span><span class="p">,</span> <span class="n">var_index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetDepot</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the variable index of the first starting or ending node of all</span>
<span class="sd">        routes. If all routes start  and end at the same node (single depot), this</span>
<span class="sd">        is the node returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetDepot</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetMaximumNumberOfActiveVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_active_vehicles</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constrains the maximum number of active vehicles, aka the number of</span>
<span class="sd">        vehicles which do not have an empty route. For instance, this can be used</span>
<span class="sd">        to limit the number of routes in the case where there are fewer drivers</span>
<span class="sd">        than vehicles and that the fleet of vehicle is heterogeneous.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetMaximumNumberOfActiveVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_active_vehicles</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetMaximumNumberOfActiveVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the maximum number of active vehicles.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetMaximumNumberOfActiveVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetArcCostEvaluatorOfAllVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator_index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the cost function of the model such that the cost of a segment of a</span>
<span class="sd">        route between node &#39;from&#39; and &#39;to&#39; is evaluator(from, to), whatever the</span>
<span class="sd">        route or vehicle performing the route.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetArcCostEvaluatorOfAllVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator_index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetArcCostEvaluatorOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator_index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Sets the cost function for a given vehicle route.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetArcCostEvaluatorOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator_index</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetFixedCostOfAllVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cost</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the fixed cost of all vehicle routes. It is equivalent to calling</span>
<span class="sd">        SetFixedCostOfVehicle on all vehicle routes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetFixedCostOfAllVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cost</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetFixedCostOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cost</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Sets the fixed cost of one vehicle route.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetFixedCostOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cost</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetFixedCostOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the route fixed cost taken into account if the route of the</span>
<span class="sd">        vehicle is not empty, aka there&#39;s at least one node on the route other</span>
<span class="sd">        than the first and last nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetFixedCostOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetAmortizedCostFactorsOfAllVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linear_cost_factor</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">quadratic_cost_factor</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The following methods set the linear and quadratic cost factors of</span>
<span class="sd">        vehicles (must be positive values). The default value of these parameters</span>
<span class="sd">        is zero for all vehicles.</span>

<span class="sd">        When set, the cost_ of the model will contain terms aiming at reducing the</span>
<span class="sd">        number of vehicles used in the model, by adding the following to the</span>
<span class="sd">        objective for every vehicle v:</span>
<span class="sd">        INDICATOR(v used in the model) *</span>
<span class="sd">          [linear_cost_factor_of_vehicle_[v]</span>
<span class="sd">           - quadratic_cost_factor_of_vehicle_[v]*(square of length of route v)]</span>
<span class="sd">        i.e. for every used vehicle, we add the linear factor as fixed cost, and</span>
<span class="sd">        subtract the square of the route length multiplied by the quadratic</span>
<span class="sd">        factor. This second term aims at making the routes as dense as possible.</span>

<span class="sd">        Sets the linear and quadratic cost factor of all vehicles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetAmortizedCostFactorsOfAllVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linear_cost_factor</span><span class="p">,</span> <span class="n">quadratic_cost_factor</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetAmortizedCostFactorsOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linear_cost_factor</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">quadratic_cost_factor</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Sets the linear and quadratic cost factor of the given vehicle.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetAmortizedCostFactorsOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linear_cost_factor</span><span class="p">,</span> <span class="n">quadratic_cost_factor</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetAmortizedLinearCostFactorOfVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int64_t &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetAmortizedLinearCostFactorOfVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetAmortizedQuadraticCostFactorOfVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int64_t &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetAmortizedQuadraticCostFactorOfVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ConsiderEmptyRouteCostsForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">consider_costs</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_ConsiderEmptyRouteCostsForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">consider_costs</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AreEmptyRouteCostsConsideredForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AreEmptyRouteCostsConsideredForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetFirstSolutionEvaluator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IndexEvaluator2&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets/sets the evaluator used during the search. Only relevant when</span>
<span class="sd">        RoutingSearchParameters.first_solution_strategy = EVALUATOR_STRATEGY.</span>
<span class="sd">        Takes ownership of evaluator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetFirstSolutionEvaluator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddLocalSearchOperator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ls_operator</span><span class="p">:</span> <span class="s2">&quot;LocalSearchOperator&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a local search operator to the set of operators used to solve the</span>
<span class="sd">        vehicle routing problem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddLocalSearchOperator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ls_operator</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddSearchMonitor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">monitor</span><span class="p">:</span> <span class="s2">&quot;SearchMonitor&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Adds a search monitor to the search used to solve the routing model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddSearchMonitor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">monitor</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddAtSolutionCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="s2">&quot;std::function&lt; void () &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a callback called each time a solution is found during the search.</span>
<span class="sd">        This is a shortcut to creating a monitor to call the callback on</span>
<span class="sd">        AtSolution() and adding it with AddSearchMonitor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddAtSolutionCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddVariableMinimizedByFinalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a variable to minimize in the solution finalizer. The solution</span>
<span class="sd">        finalizer is called each time a solution is found during the search and</span>
<span class="sd">        allows to instantiate secondary variables (such as dimension cumul</span>
<span class="sd">        variables).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddVariableMinimizedByFinalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddVariableMaximizedByFinalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a variable to maximize in the solution finalizer (see above for</span>
<span class="sd">        information on the solution finalizer).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddVariableMaximizedByFinalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddWeightedVariableMinimizedByFinalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">cost</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a variable to minimize in the solution finalizer, with a weighted</span>
<span class="sd">        priority: the higher the more priority it has.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddWeightedVariableMinimizedByFinalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">cost</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddVariableTargetToFinalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a variable to set the closest possible to the target value in the</span>
<span class="sd">        solution finalizer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddVariableTargetToFinalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">CloseModel</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Closes the current routing model; after this method is called, no</span>
<span class="sd">        modification to the model can be done, but RoutesToAssignment becomes</span>
<span class="sd">        available. Note that CloseModel() is automatically called by Solve() and</span>
<span class="sd">        other methods that produce solution.</span>
<span class="sd">        This is equivalent to calling</span>
<span class="sd">        CloseModelWithParameters(DefaultRoutingSearchParameters()).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_CloseModel</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">CloseModelWithParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">search_parameters</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingSearchParameters const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as above taking search parameters (as of 10/2015 some the parameters</span>
<span class="sd">        have to be set when closing the model).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_CloseModelWithParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">search_parameters</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment const *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solves the current routing model; closes the current model.</span>
<span class="sd">        This is equivalent to calling</span>
<span class="sd">        SolveWithParameters(DefaultRoutingSearchParameters())</span>
<span class="sd">        or</span>
<span class="sd">        SolveFromAssignmentWithParameters(assignment,</span>
<span class="sd">                                          DefaultRoutingSearchParameters()).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_Solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SolveWithParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">search_parameters</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingSearchParameters const &amp;&quot;</span><span class="p">,</span> <span class="n">solutions</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::Assignment const * &gt; *&quot;</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment const *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solves the current routing model with the given parameters. If &#39;solutions&#39;</span>
<span class="sd">        is specified, it will contain the k best solutions found during the search</span>
<span class="sd">        (from worst to best, including the one returned by this method), where k</span>
<span class="sd">        corresponds to the &#39;number_of_solutions_to_collect&#39; in</span>
<span class="sd">        &#39;search_parameters&#39;. Note that the Assignment returned by the method and</span>
<span class="sd">        the ones in solutions are owned by the underlying solver and should not be</span>
<span class="sd">        deleted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SolveWithParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">search_parameters</span><span class="p">,</span> <span class="n">solutions</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SolveFromAssignmentWithParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">search_parameters</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingSearchParameters const &amp;&quot;</span><span class="p">,</span> <span class="n">solutions</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::Assignment const * &gt; *&quot;</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment const *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as above, except that if assignment is not null, it will be used as</span>
<span class="sd">        the initial solution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SolveFromAssignmentWithParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">,</span> <span class="n">search_parameters</span><span class="p">,</span> <span class="n">solutions</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SolveFromAssignmentsWithParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignments</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::Assignment const * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">search_parameters</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingSearchParameters const &amp;&quot;</span><span class="p">,</span> <span class="n">solutions</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::Assignment const * &gt; *&quot;</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment const *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as above but will try all assignments in order as first solutions</span>
<span class="sd">        until one succeeds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SolveFromAssignmentsWithParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignments</span><span class="p">,</span> <span class="n">search_parameters</span><span class="p">,</span> <span class="n">solutions</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetAssignmentFromOtherModelAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">source_model</span><span class="p">:</span> <span class="s2">&quot;RoutingModel&quot;</span><span class="p">,</span> <span class="n">source_assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a &quot;source_model&quot; and its &quot;source_assignment&quot;, resets</span>
<span class="sd">        &quot;target_assignment&quot; with the IntVar variables (nexts_, and vehicle_vars_</span>
<span class="sd">        if costs aren&#39;t homogeneous across vehicles) of &quot;this&quot; model, with the</span>
<span class="sd">        values set according to those in &quot;other_assignment&quot;.</span>
<span class="sd">        The objective_element of target_assignment is set to this-&gt;cost_.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetAssignmentFromOtherModelAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_assignment</span><span class="p">,</span> <span class="n">source_model</span><span class="p">,</span> <span class="n">source_assignment</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ComputeLowerBound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes a lower bound to the routing problem solving a linear assignment</span>
<span class="sd">        problem. The routing model must be closed before calling this method.</span>
<span class="sd">        Note that problems with node disjunction constraints (including optional</span>
<span class="sd">        nodes) and non-homogenous costs are not supported (the method returns 0 in</span>
<span class="sd">        these cases).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_ComputeLowerBound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">status</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingModel::Status&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the current status of the routing model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_status</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ApplyLocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locks</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies a lock chain to the next search. &#39;locks&#39; represents an ordered</span>
<span class="sd">        vector of nodes representing a partial route which will be fixed during</span>
<span class="sd">        the next search; it will constrain next variables such that:</span>
<span class="sd">        next[locks[i]] == locks[i+1].</span>

<span class="sd">        Returns the next variable at the end of the locked chain; this variable is</span>
<span class="sd">        not locked. An assignment containing the locks can be obtained by calling</span>
<span class="sd">        PreAssignment().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_ApplyLocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locks</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ApplyLocksToAllVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locks</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; std::vector&lt; int64_t &gt; &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">close_routes</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies lock chains to all vehicles to the next search, such that locks[p]</span>
<span class="sd">        is the lock chain for route p. Returns false if the locks do not contain</span>
<span class="sd">        valid routes; expects that the routes do not contain the depots,</span>
<span class="sd">        i.e. there are empty vectors in place of empty routes.</span>
<span class="sd">        If close_routes is set to true, adds the end nodes to the route of each</span>
<span class="sd">        vehicle and deactivates other nodes.</span>
<span class="sd">        An assignment containing the locks can be obtained by calling</span>
<span class="sd">        PreAssignment().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_ApplyLocksToAllVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locks</span><span class="p">,</span> <span class="n">close_routes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">PreAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment const *const&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an assignment used to fix some of the variables of the problem.</span>
<span class="sd">        In practice, this assignment locks partial routes of the problem. This</span>
<span class="sd">        can be used in the context of locking the parts of the routes which have</span>
<span class="sd">        already been driven in online routing problems.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_PreAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">MutablePreAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_MutablePreAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WriteAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes the current solution to a file containing an AssignmentProto.</span>
<span class="sd">        Returns false if the file cannot be opened or if there is no current</span>
<span class="sd">        solution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_WriteAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ReadAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads an assignment from a file and returns the current solution.</span>
<span class="sd">        Returns nullptr if the file cannot be opened or if the assignment is not</span>
<span class="sd">        valid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_ReadAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RestoreAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solution</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Restores an assignment as a solution in the routing model and returns the</span>
<span class="sd">        new solution. Returns nullptr if the assignment is not valid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_RestoreAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solution</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ReadAssignmentFromRoutes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">routes</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; std::vector&lt; int64_t &gt; &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">ignore_inactive_indices</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Restores the routes as the current solution. Returns nullptr if the</span>
<span class="sd">        solution cannot be restored (routes do not contain a valid solution). Note</span>
<span class="sd">        that calling this method will run the solver to assign values to the</span>
<span class="sd">        dimension variables; this may take considerable amount of time, especially</span>
<span class="sd">        when using dimensions with slack.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_ReadAssignmentFromRoutes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">routes</span><span class="p">,</span> <span class="n">ignore_inactive_indices</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RoutesToAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">routes</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; std::vector&lt; int64_t &gt; &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">ignore_inactive_indices</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">close_routes</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fills an assignment from a specification of the routes of the</span>
<span class="sd">        vehicles. The routes are specified as lists of variable indices that</span>
<span class="sd">        appear on the routes of the vehicles. The indices of the outer vector in</span>
<span class="sd">        &#39;routes&#39; correspond to vehicles IDs, the inner vector contains the</span>
<span class="sd">        variable indices on the routes for the given vehicle. The inner vectors</span>
<span class="sd">        must not contain the start and end indices, as these are determined by the</span>
<span class="sd">        routing model.  Sets the value of NextVars in the assignment, adding the</span>
<span class="sd">        variables to the assignment if necessary. The method does not touch other</span>
<span class="sd">        variables in the assignment. The method can only be called after the model</span>
<span class="sd">        is closed.  With ignore_inactive_indices set to false, this method will</span>
<span class="sd">        fail (return nullptr) in case some of the route contain indices that are</span>
<span class="sd">        deactivated in the model; when set to true, these indices will be</span>
<span class="sd">        skipped.  Returns true if routes were successfully</span>
<span class="sd">        loaded. However, such assignment still might not be a valid</span>
<span class="sd">        solution to the routing problem due to more complex constraints;</span>
<span class="sd">        it is advisible to call solver()-&gt;CheckSolution() afterwards.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_RoutesToAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">routes</span><span class="p">,</span> <span class="n">ignore_inactive_indices</span><span class="p">,</span> <span class="n">close_routes</span><span class="p">,</span> <span class="n">assignment</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AssignmentToRoutes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">routes</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; std::vector&lt; int64_t &gt; &gt; *const&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts the solution in the given assignment to routes for all vehicles.</span>
<span class="sd">        Expects that assignment contains a valid solution (i.e. routes for all</span>
<span class="sd">        vehicles end with an end index for that vehicle).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AssignmentToRoutes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">,</span> <span class="n">routes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">CompactAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts the solution in the given assignment to routes for all vehicles.</span>
<span class="sd">        If the returned vector is route_indices, route_indices[i][j] is the index</span>
<span class="sd">        for jth location visited on route i. Note that contrary to</span>
<span class="sd">        AssignmentToRoutes, the vectors do include start and end locations.</span>
<span class="sd">        Returns a compacted version of the given assignment, in which all vehicles</span>
<span class="sd">        with id lower or equal to some N have non-empty routes, and all vehicles</span>
<span class="sd">        with id greater than N have empty routes. Does not take ownership of the</span>
<span class="sd">        returned object.</span>
<span class="sd">        If found, the cost of the compact assignment is the same as in the</span>
<span class="sd">        original assignment and it preserves the values of &#39;active&#39; variables.</span>
<span class="sd">        Returns nullptr if a compact assignment was not found.</span>
<span class="sd">        This method only works in homogenous mode, and it only swaps equivalent</span>
<span class="sd">        vehicles (vehicles with the same start and end nodes). When creating the</span>
<span class="sd">        compact assignment, the empty plan is replaced by the route assigned to</span>
<span class="sd">        the compatible vehicle with the highest id. Note that with more complex</span>
<span class="sd">        constraints on vehicle variables, this method might fail even if a compact</span>
<span class="sd">        solution exists.</span>
<span class="sd">        This method changes the vehicle and dimension variables as necessary.</span>
<span class="sd">        While compacting the solution, only basic checks on vehicle variables are</span>
<span class="sd">        performed; if one of these checks fails no attempts to repair it are made</span>
<span class="sd">        (instead, the method returns nullptr).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_CompactAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">CompactAndCheckAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as CompactAssignment() but also checks the validity of the final</span>
<span class="sd">        compact solution; if it is not valid, no attempts to repair it are made</span>
<span class="sd">        (instead, the method returns nullptr).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_CompactAndCheckAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddToAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Adds an extra variable to the vehicle routing assignment.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddToAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddIntervalToAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddIntervalToAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">PackCumulsOfOptimizerDimensionsFromAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">original_assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">duration_limit</span><span class="p">:</span> <span class="s2">&quot;absl::Duration&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment const *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For every dimension in the model with an optimizer in</span>
<span class="sd">        local/global_dimension_optimizers_, this method tries to pack the cumul</span>
<span class="sd">        values of the dimension, such that:</span>
<span class="sd">        - The cumul costs (span costs, soft lower and upper bound costs, etc) are</span>
<span class="sd">          minimized.</span>
<span class="sd">        - The cumuls of the ends of the routes are minimized for this given</span>
<span class="sd">          minimal cumul cost.</span>
<span class="sd">        - Given these minimal end cumuls, the route start cumuls are maximized.</span>
<span class="sd">        Returns the assignment resulting from allocating these packed cumuls with</span>
<span class="sd">        the solver, and nullptr if these cumuls could not be set by the solver.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_PackCumulsOfOptimizerDimensionsFromAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">original_assignment</span><span class="p">,</span> <span class="n">duration_limit</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddLocalSearchFilter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">filter</span><span class="p">:</span> <span class="s2">&quot;LocalSearchFilter&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a custom local search filter to the list of filters used to speed up</span>
<span class="sd">        local search by pruning unfeasible variable assignments.</span>
<span class="sd">        Calling this method after the routing model has been closed (CloseModel()</span>
<span class="sd">        or Solve() has been called) has no effect.</span>
<span class="sd">        The routing model does not take ownership of the filter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddLocalSearchFilter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">filter</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Model inspection.</span>
<span class="sd">        Returns the variable index of the starting node of a vehicle route.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_Start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">End</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the variable index of the ending node of a vehicle route.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_End</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsStart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns true if &#39;index&#39; represents the first node of a route.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_IsStart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsEnd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns true if &#39;index&#39; represents the last node of a route.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_IsEnd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">VehicleIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the vehicle of the given start/end index, and -1 if the given</span>
<span class="sd">        index is not a vehicle start/end.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_VehicleIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Next</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assignment inspection</span>
<span class="sd">        Returns the variable index of the node directly after the node</span>
<span class="sd">        corresponding to &#39;index&#39; in &#39;assignment&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_Next</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsVehicleUsed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns true if the route of &#39;vehicle&#39; is non empty in &#39;assignment&#39;.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_IsVehicleUsed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NextVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the next variable of the node corresponding to index. Note that</span>
<span class="sd">        NextVar(index) == index is equivalent to ActiveVar(index) == 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_NextVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ActiveVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the active variable of the node corresponding to index.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_ActiveVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ActiveVehicleVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the active variable of the vehicle. It will be equal to 1 iff the</span>
<span class="sd">        route of the vehicle is not empty, 0 otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_ActiveVehicleVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">VehicleCostsConsideredVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the variable specifying whether or not costs are considered for</span>
<span class="sd">        vehicle.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_VehicleCostsConsideredVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">VehicleVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the vehicle variable of the node corresponding to index. Note that</span>
<span class="sd">        VehicleVar(index) == -1 is equivalent to ActiveVar(index) == 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_VehicleVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">CostVar</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the global cost variable which is being minimized.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_CostVar</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetArcCostForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">to_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the cost of the transit arc between two nodes for a given vehicle.</span>
<span class="sd">        Input are variable indices of node. This returns 0 if vehicle &lt; 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetArcCostForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_index</span><span class="p">,</span> <span class="n">to_index</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">CostsAreHomogeneousAcrossVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Whether costs are homogeneous across all vehicles.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_CostsAreHomogeneousAcrossVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetHomogeneousCost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">to_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the cost of the segment between two nodes supposing all vehicle</span>
<span class="sd">        costs are the same (returns the cost for the first vehicle otherwise).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetHomogeneousCost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_index</span><span class="p">,</span> <span class="n">to_index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetArcCostForFirstSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">to_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the cost of the arc in the context of the first solution strategy.</span>
<span class="sd">        This is typically a simplification of the actual cost; see the .cc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetArcCostForFirstSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_index</span><span class="p">,</span> <span class="n">to_index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetArcCostForClass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">to_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">cost_class_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the cost of the segment between two nodes for a given cost</span>
<span class="sd">        class. Input are variable indices of nodes and the cost class.</span>
<span class="sd">        Unlike GetArcCostForVehicle(), if cost_class is kNoCost, then the</span>
<span class="sd">        returned cost won&#39;t necessarily be zero: only some of the components</span>
<span class="sd">        of the cost that depend on the cost class will be omited. See the code</span>
<span class="sd">        for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetArcCostForClass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_index</span><span class="p">,</span> <span class="n">to_index</span><span class="p">,</span> <span class="n">cost_class_index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetCostClassIndexOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingModel::CostClassIndex&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Get the cost class index of the given vehicle.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetCostClassIndexOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">HasVehicleWithCostClassIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cost_class_index</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingModel::CostClassIndex&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns true iff the model contains a vehicle with the given</span>
<span class="sd">        cost_class_index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_HasVehicleWithCostClassIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cost_class_index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetCostClassesCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the number of different cost classes in the model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetCostClassesCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetNonZeroCostClassesCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Ditto, minus the &#39;always zero&#39;, built-in cost class.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetNonZeroCostClassesCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetVehicleClassIndexOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingModel::VehicleClassIndex&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetVehicleClassIndexOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetVehicleOfClass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle_class</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingModel::VehicleClassIndex&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a vehicle of the given vehicle class, and -1 if there are no</span>
<span class="sd">        vehicles for this class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetVehicleOfClass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle_class</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetVehicleClassesCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the number of different vehicle classes in the model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetVehicleClassesCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetSameVehicleIndicesOfIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns variable indices of nodes constrained to be on the same route.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetSameVehicleIndicesOfIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetVehicleTypeContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingModel::VehicleTypeContainer const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetVehicleTypeContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ArcIsMoreConstrainedThanArc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_from</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">to1</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">to2</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns whether the arc from-&gt;to1 is more constrained than from-&gt;to2,</span>
<span class="sd">        taking into account, in order:</span>
<span class="sd">        - whether the destination node isn&#39;t an end node</span>
<span class="sd">        - whether the destination node is mandatory</span>
<span class="sd">        - whether the destination node is bound to the same vehicle as the source</span>
<span class="sd">        - the &quot;primary constrained&quot; dimension (see SetPrimaryConstrainedDimension)</span>
<span class="sd">        It then breaks ties using, in order:</span>
<span class="sd">        - the arc cost (taking unperformed penalties into account)</span>
<span class="sd">        - the size of the vehicle vars of &quot;to1&quot; and &quot;to2&quot; (lowest size wins)</span>
<span class="sd">        - the value: the lowest value of the indices to1 and to2 wins.</span>
<span class="sd">        See the .cc for details.</span>
<span class="sd">        The more constrained arc is typically preferable when building a</span>
<span class="sd">        first solution. This method is intended to be used as a callback for the</span>
<span class="sd">        BestValueByComparisonSelector value selector.</span>
<span class="sd">        Args:</span>
<span class="sd">          from: the variable index of the source node</span>
<span class="sd">          to1: the variable index of the first candidate destination node.</span>
<span class="sd">          to2: the variable index of the second candidate destination node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_ArcIsMoreConstrainedThanArc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_from</span><span class="p">,</span> <span class="n">to1</span><span class="p">,</span> <span class="n">to2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DebugOutputAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solution_assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">dimension_to_print</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print some debugging information about an assignment, including the</span>
<span class="sd">        feasible intervals of the CumulVar for dimension &quot;dimension_to_print&quot;</span>
<span class="sd">        at each step of the routes.</span>
<span class="sd">        If &quot;dimension_to_print&quot; is omitted, all dimensions will be printed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_DebugOutputAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solution_assignment</span><span class="p">,</span> <span class="n">dimension_to_print</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Solver *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a vector cumul_bounds, for which cumul_bounds[i][j] is a pair</span>
<span class="sd">        containing the minimum and maximum of the CumulVar of the jth node on</span>
<span class="sd">        route i.</span>
<span class="sd">        - cumul_bounds[i][j].first is the minimum.</span>
<span class="sd">        - cumul_bounds[i][j].second is the maximum.</span>
<span class="sd">        Returns the underlying constraint solver. Can be used to add extra</span>
<span class="sd">        constraints and/or modify search algorithms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_solver</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">CheckLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns true if the search limit has been crossed.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_CheckLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RemainingTime</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;absl::Duration&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the time left in the search limit.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_RemainingTime</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sizes and indices</span>
<span class="sd">        Returns the number of nodes in the model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">vehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the number of vehicle routes in the model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_vehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the number of next variables in the model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetNumberOfDecisionsInFirstSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">search_parameters</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingSearchParameters const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns statistics on first solution search, number of decisions sent to</span>
<span class="sd">        filters, number of decisions rejected by filters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetNumberOfDecisionsInFirstSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">search_parameters</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetNumberOfRejectsInFirstSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">search_parameters</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingSearchParameters const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetNumberOfRejectsInFirstSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">search_parameters</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetAutomaticFirstSolutionStrategy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::FirstSolutionStrategy::Value&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the automatic first solution strategy selected.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetAutomaticFirstSolutionStrategy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsMatchingModel</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns true if a vehicle/node matching problem is detected.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_IsMatchingModel</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">MakeGuidedSlackFinalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="s2">&quot;RoutingDimension&quot;</span><span class="p">,</span> <span class="n">initializer</span><span class="p">:</span> <span class="s2">&quot;std::function&lt; int64_t (int64_t) &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The next few members are in the public section only for testing purposes.</span>

<span class="sd">        MakeGuidedSlackFinalizer creates a DecisionBuilder for the slacks of a</span>
<span class="sd">        dimension using a callback to choose which values to start with.</span>
<span class="sd">        The finalizer works only when all next variables in the model have</span>
<span class="sd">        been fixed. It has the following two characteristics:</span>
<span class="sd">        1. It follows the routes defined by the nexts variables when choosing a</span>
<span class="sd">           variable to make a decision on.</span>
<span class="sd">        2. When it comes to choose a value for the slack of node i, the decision</span>
<span class="sd">           builder first calls the callback with argument i, and supposingly the</span>
<span class="sd">           returned value is x it creates decisions slack[i] = x, slack[i] = x +</span>
<span class="sd">           1, slack[i] = x - 1, slack[i] = x + 2, etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_MakeGuidedSlackFinalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">initializer</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">MakeSelfDependentDimensionFinalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="s2">&quot;RoutingDimension&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        MakeSelfDependentDimensionFinalizer is a finalizer for the slacks of a</span>
<span class="sd">        self-dependent dimension. It makes an extensive use of the caches of the</span>
<span class="sd">        state dependent transits.</span>
<span class="sd">        In detail, MakeSelfDependentDimensionFinalizer returns a composition of a</span>
<span class="sd">        local search decision builder with a greedy descent operator for the cumul</span>
<span class="sd">        of the start of each route and a guided slack finalizer. Provided there</span>
<span class="sd">        are no time windows and the maximum slacks are large enough, once the</span>
<span class="sd">        cumul of the start of route is fixed, the guided finalizer can find</span>
<span class="sd">        optimal values of the slacks for the rest of the route in time</span>
<span class="sd">        proportional to the length of the route. Therefore the composed finalizer</span>
<span class="sd">        generally works in time O(log(t)*n*m), where t is the latest possible</span>
<span class="sd">        departute time, n is the number of nodes in the network and m is the</span>
<span class="sd">        number of vehicles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_MakeSelfDependentDimensionFinalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">)</span>

<span class="c1"># Register RoutingModel in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_swigregister</span><span class="p">(</span><span class="n">RoutingModel</span><span class="p">)</span>
<span class="n">cvar</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">cvar</span>
<span class="n">RoutingModel</span><span class="o">.</span><span class="n">kNoPenalty</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">cvar</span><span class="o">.</span><span class="n">RoutingModel_kNoPenalty</span>
<span class="n">RoutingModel</span><span class="o">.</span><span class="n">kNoDisjunction</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">cvar</span><span class="o">.</span><span class="n">RoutingModel_kNoDisjunction</span>
<span class="n">RoutingModel</span><span class="o">.</span><span class="n">kNoDimension</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">cvar</span><span class="o">.</span><span class="n">RoutingModel_kNoDimension</span>

<span class="k">class</span> <span class="nc">RoutingModelVisitor</span><span class="p">(</span><span class="n">BaseObject</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Routing model visitor.&quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModelVisitor_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_RoutingModelVisitor</span><span class="p">())</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_RoutingModelVisitor</span>

<span class="c1"># Register RoutingModelVisitor in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModelVisitor_swigregister</span><span class="p">(</span><span class="n">RoutingModelVisitor</span><span class="p">)</span>
<span class="n">RoutingModelVisitor</span><span class="o">.</span><span class="n">kLightElement</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">cvar</span><span class="o">.</span><span class="n">RoutingModelVisitor_kLightElement</span>
<span class="n">RoutingModelVisitor</span><span class="o">.</span><span class="n">kLightElement2</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">cvar</span><span class="o">.</span><span class="n">RoutingModelVisitor_kLightElement2</span>
<span class="n">RoutingModelVisitor</span><span class="o">.</span><span class="n">kRemoveValues</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">cvar</span><span class="o">.</span><span class="n">RoutingModelVisitor_kRemoveValues</span>

<span class="k">class</span> <span class="nc">GlobalVehicleBreaksConstraint</span><span class="p">(</span><span class="n">Constraint</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    GlobalVehicleBreaksConstraint ensures breaks constraints are enforced on</span>
<span class="sd">    all vehicles in the dimension passed to its constructor.</span>
<span class="sd">    It is intended to be used for dimensions representing time.</span>
<span class="sd">    A break constraint ensures break intervals fit on the route of a vehicle.</span>
<span class="sd">    For a given vehicle, it forces break intervals to be disjoint from visit</span>
<span class="sd">    intervals, where visit intervals start at CumulVar(node) and last for</span>
<span class="sd">    node_visit_transit[node]. Moreover, it ensures that there is enough time</span>
<span class="sd">    between two consecutive nodes of a route to do transit and vehicle breaks,</span>
<span class="sd">    i.e. if Next(nodeA) = nodeB, CumulVar(nodeA) = tA and CumulVar(nodeB) = tB,</span>
<span class="sd">    then SlackVar(nodeA) &gt;= sum_{breaks [tA, tB)} duration(break).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="s2">&quot;RoutingDimension&quot;</span><span class="p">):</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">GlobalVehicleBreaksConstraint_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_GlobalVehicleBreaksConstraint</span><span class="p">(</span><span class="n">dimension</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">GlobalVehicleBreaksConstraint_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Post</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">GlobalVehicleBreaksConstraint_Post</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">InitialPropagateWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">GlobalVehicleBreaksConstraint_InitialPropagateWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_GlobalVehicleBreaksConstraint</span>

<span class="c1"># Register GlobalVehicleBreaksConstraint in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">GlobalVehicleBreaksConstraint_swigregister</span><span class="p">(</span><span class="n">GlobalVehicleBreaksConstraint</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">TypeRegulationsChecker</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_TypeRegulationsChecker</span>

    <span class="k">def</span> <span class="nf">CheckVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">next_accessor</span><span class="p">:</span> <span class="s2">&quot;std::function&lt; int64_t (int64_t) &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">TypeRegulationsChecker_CheckVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">,</span> <span class="n">next_accessor</span><span class="p">)</span>

<span class="c1"># Register TypeRegulationsChecker in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">TypeRegulationsChecker_swigregister</span><span class="p">(</span><span class="n">TypeRegulationsChecker</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">TypeIncompatibilityChecker</span><span class="p">(</span><span class="n">TypeRegulationsChecker</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Checker for type incompatibilities.&quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="s2">&quot;RoutingModel&quot;</span><span class="p">,</span> <span class="n">check_hard_incompatibilities</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">):</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">TypeIncompatibilityChecker_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_TypeIncompatibilityChecker</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">check_hard_incompatibilities</span><span class="p">))</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_TypeIncompatibilityChecker</span>

<span class="c1"># Register TypeIncompatibilityChecker in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">TypeIncompatibilityChecker_swigregister</span><span class="p">(</span><span class="n">TypeIncompatibilityChecker</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">TypeRequirementChecker</span><span class="p">(</span><span class="n">TypeRegulationsChecker</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Checker for type requirements.&quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="s2">&quot;RoutingModel&quot;</span><span class="p">):</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">TypeRequirementChecker_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_TypeRequirementChecker</span><span class="p">(</span><span class="n">model</span><span class="p">))</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_TypeRequirementChecker</span>

<span class="c1"># Register TypeRequirementChecker in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">TypeRequirementChecker_swigregister</span><span class="p">(</span><span class="n">TypeRequirementChecker</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">TypeRegulationsConstraint</span><span class="p">(</span><span class="n">Constraint</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The following constraint ensures that incompatibilities and requirements</span>
<span class="sd">    between types are respected.</span>

<span class="sd">    It verifies both &quot;hard&quot; and &quot;temporal&quot; incompatibilities.</span>
<span class="sd">    Two nodes with hard incompatible types cannot be served by the same vehicle</span>
<span class="sd">    at all, while with a temporal incompatibility they can&#39;t be on the same</span>
<span class="sd">    route at the same time.</span>
<span class="sd">    The VisitTypePolicy of a node determines how visiting it impacts the type</span>
<span class="sd">    count on the route.</span>

<span class="sd">    For example, for</span>
<span class="sd">    - three temporally incompatible types T1 T2 and T3</span>
<span class="sd">    - 2 pairs of nodes a1/r1 and a2/r2 of type T1 and T2 respectively, with</span>
<span class="sd">        - a1 and a2 of VisitTypePolicy TYPE_ADDED_TO_VEHICLE</span>
<span class="sd">        - r1 and r2 of policy ADDED_TYPE_REMOVED_FROM_VEHICLE</span>
<span class="sd">    - 3 nodes A, UV and AR of type T3, respectively with type policies</span>
<span class="sd">      TYPE_ADDED_TO_VEHICLE, TYPE_ON_VEHICLE_UP_TO_VISIT and</span>
<span class="sd">      TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED</span>
<span class="sd">    the configurations</span>
<span class="sd">    UV --&gt; a1 --&gt; r1 --&gt; a2 --&gt; r2,   a1 --&gt; r1 --&gt; a2 --&gt; r2 --&gt; A and</span>
<span class="sd">    a1 --&gt; r1 --&gt; AR --&gt; a2 --&gt; r2 are acceptable, whereas the configurations</span>
<span class="sd">    a1 --&gt; a2 --&gt; r1 --&gt; ..., or A --&gt; a1 --&gt; r1 --&gt; ..., or</span>
<span class="sd">    a1 --&gt; r1 --&gt; UV --&gt; ... are not feasible.</span>

<span class="sd">    It also verifies same-vehicle and temporal type requirements.</span>
<span class="sd">    A node of type T_d with a same-vehicle requirement for type T_r needs to be</span>
<span class="sd">    served by the same vehicle as a node of type T_r.</span>
<span class="sd">    Temporal requirements, on the other hand, can take effect either when the</span>
<span class="sd">    dependent type is being added to the route or when it&#39;s removed from it,</span>
<span class="sd">    which is determined by the dependent node&#39;s VisitTypePolicy.</span>
<span class="sd">    In the above example:</span>
<span class="sd">    - If T3 is required on the same vehicle as T1, A, AR or UV must be on the</span>
<span class="sd">      same vehicle as a1.</span>
<span class="sd">    - If T2 is required when adding T1, a2 must be visited *before* a1, and if</span>
<span class="sd">      r2 is also visited on the route, it must be *after* a1, i.e. T2 must be on</span>
<span class="sd">      the vehicle when a1 is visited:</span>
<span class="sd">      ... --&gt; a2 --&gt; ... --&gt; a1 --&gt; ... --&gt; r2 --&gt; ...</span>
<span class="sd">    - If T3 is required when removing T1, T3 needs to be on the vehicle when</span>
<span class="sd">      r1 is visited:</span>
<span class="sd">      ... --&gt; A --&gt; ... --&gt; r1 --&gt; ...   OR   ... --&gt; r1 --&gt; ... --&gt; UV --&gt; ...</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="s2">&quot;RoutingModel&quot;</span><span class="p">):</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">TypeRegulationsConstraint_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_TypeRegulationsConstraint</span><span class="p">(</span><span class="n">model</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">Post</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">TypeRegulationsConstraint_Post</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">InitialPropagateWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">TypeRegulationsConstraint_InitialPropagateWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_TypeRegulationsConstraint</span>

<span class="c1"># Register TypeRegulationsConstraint in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">TypeRegulationsConstraint_swigregister</span><span class="p">(</span><span class="n">TypeRegulationsConstraint</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">RoutingDimension</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dimensions represent quantities accumulated at nodes along the routes. They</span>
<span class="sd">    represent quantities such as weights or volumes carried along the route, or</span>
<span class="sd">    distance or times.</span>

<span class="sd">    Quantities at a node are represented by &quot;cumul&quot; variables and the increase</span>
<span class="sd">    or decrease of quantities between nodes are represented by &quot;transit&quot;</span>
<span class="sd">    variables. These variables are linked as follows:</span>

<span class="sd">    if j == next(i),</span>
<span class="sd">    cumuls(j) = cumuls(i) + transits(i) + slacks(i) +</span>
<span class="sd">                state_dependent_transits(i)</span>

<span class="sd">    where slack is a positive slack variable (can represent waiting times for</span>
<span class="sd">    a time dimension), and state_dependent_transits is a non-purely functional</span>
<span class="sd">    version of transits_. Favour transits over state_dependent_transits when</span>
<span class="sd">    possible, because purely functional callbacks allow more optimisations and</span>
<span class="sd">    make the model faster and easier to solve.</span>
<span class="sd">    for a given vehicle, it is passed as an external vector, it would be better</span>
<span class="sd">    to have this information here.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_RoutingDimension</span>

    <span class="k">def</span> <span class="nf">model</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingModel *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the model on which the dimension was created.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_model</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetTransitValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">to_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the transition value for a given pair of nodes (as var index);</span>
<span class="sd">        this value is the one taken by the corresponding transit variable when</span>
<span class="sd">        the &#39;next&#39; variable for &#39;from_index&#39; is bound to &#39;to_index&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_GetTransitValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_index</span><span class="p">,</span> <span class="n">to_index</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetTransitValueFromClass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">to_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">vehicle_class</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as above but taking a vehicle class of the dimension instead of a</span>
<span class="sd">        vehicle (the class of a vehicle can be obtained with vehicle_to_class()).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_GetTransitValueFromClass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_index</span><span class="p">,</span> <span class="n">to_index</span><span class="p">,</span> <span class="n">vehicle_class</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">CumulVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the cumul, transit and slack variables for the given node (given as</span>
<span class="sd">        int64_t var index).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_CumulVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">TransitVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_TransitVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">FixedTransitVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_FixedTransitVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SlackVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_SlackVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetSpanUpperBoundForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets an upper bound on the dimension span on a given vehicle. This is the</span>
<span class="sd">        preferred way to limit the &quot;length&quot; of the route of a vehicle according to</span>
<span class="sd">        a dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_SetSpanUpperBoundForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetSpanCostCoefficientForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coefficient</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets a cost proportional to the dimension span on a given vehicle,</span>
<span class="sd">        or on all vehicles at once. &quot;coefficient&quot; must be nonnegative.</span>
<span class="sd">        This is handy to model costs proportional to idle time when the dimension</span>
<span class="sd">        represents time.</span>
<span class="sd">        The cost for a vehicle is</span>
<span class="sd">          span_cost = coefficient * (dimension end value - dimension start value).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_SetSpanCostCoefficientForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coefficient</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetSpanCostCoefficientForAllVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coefficient</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_SetSpanCostCoefficientForAllVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coefficient</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetGlobalSpanCostCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coefficient</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets a cost proportional to the *global* dimension span, that is the</span>
<span class="sd">        difference between the largest value of route end cumul variables and</span>
<span class="sd">        the smallest value of route start cumul variables.</span>
<span class="sd">        In other words:</span>
<span class="sd">        global_span_cost =</span>
<span class="sd">          coefficient * (Max(dimension end value) - Min(dimension start value)).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_SetGlobalSpanCostCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coefficient</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetCumulVarSoftUpperBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">coefficient</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets a soft upper bound to the cumul variable of a given variable index.</span>
<span class="sd">        If the value of the cumul variable is greater than the bound, a cost</span>
<span class="sd">        proportional to the difference between this value and the bound is added</span>
<span class="sd">        to the cost function of the model:</span>
<span class="sd">          cumulVar &lt;= upper_bound -&gt; cost = 0</span>
<span class="sd">           cumulVar &gt; upper_bound -&gt; cost = coefficient * (cumulVar - upper_bound)</span>
<span class="sd">        This is also handy to model tardiness costs when the dimension represents</span>
<span class="sd">        time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_SetCumulVarSoftUpperBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">,</span> <span class="n">coefficient</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">HasCumulVarSoftUpperBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns true if a soft upper bound has been set for a given variable</span>
<span class="sd">        index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_HasCumulVarSoftUpperBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetCumulVarSoftUpperBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the soft upper bound of a cumul variable for a given variable</span>
<span class="sd">        index. The &quot;hard&quot; upper bound of the variable is returned if no soft upper</span>
<span class="sd">        bound has been set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_GetCumulVarSoftUpperBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetCumulVarSoftUpperBoundCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the cost coefficient of the soft upper bound of a cumul variable</span>
<span class="sd">        for a given variable index. If no soft upper bound has been set, 0 is</span>
<span class="sd">        returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_GetCumulVarSoftUpperBoundCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetCumulVarSoftLowerBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">lower_bound</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">coefficient</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets a soft lower bound to the cumul variable of a given variable index.</span>
<span class="sd">        If the value of the cumul variable is less than the bound, a cost</span>
<span class="sd">        proportional to the difference between this value and the bound is added</span>
<span class="sd">        to the cost function of the model:</span>
<span class="sd">          cumulVar &gt; lower_bound -&gt; cost = 0</span>
<span class="sd">          cumulVar &lt;= lower_bound -&gt; cost = coefficient * (lower_bound -</span>
<span class="sd">                      cumulVar).</span>
<span class="sd">        This is also handy to model earliness costs when the dimension represents</span>
<span class="sd">        time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_SetCumulVarSoftLowerBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">lower_bound</span><span class="p">,</span> <span class="n">coefficient</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">HasCumulVarSoftLowerBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns true if a soft lower bound has been set for a given variable</span>
<span class="sd">        index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_HasCumulVarSoftLowerBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetCumulVarSoftLowerBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the soft lower bound of a cumul variable for a given variable</span>
<span class="sd">        index. The &quot;hard&quot; lower bound of the variable is returned if no soft lower</span>
<span class="sd">        bound has been set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_GetCumulVarSoftLowerBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetCumulVarSoftLowerBoundCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the cost coefficient of the soft lower bound of a cumul variable</span>
<span class="sd">        for a given variable index. If no soft lower bound has been set, 0 is</span>
<span class="sd">        returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_GetCumulVarSoftLowerBoundCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetBreakIntervalsOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">breaks</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntervalVar * &gt;&quot;</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">node_visit_transits</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the breaks for a given vehicle. Breaks are represented by</span>
<span class="sd">        IntervalVars. They may interrupt transits between nodes and increase</span>
<span class="sd">        the value of corresponding slack variables.</span>
<span class="sd">        A break may take place before the start of a vehicle, after the end of</span>
<span class="sd">        a vehicle, or during a travel i -&gt; j.</span>

<span class="sd">        In that case, the interval [break.Start(), break.End()) must be a subset</span>
<span class="sd">        of [CumulVar(i) + pre_travel(i, j), CumulVar(j) - post_travel(i, j)). In</span>
<span class="sd">        other words, a break may not overlap any node n&#39;s visit, given by</span>
<span class="sd">        [CumulVar(n) - post_travel(_, n), CumulVar(n) + pre_travel(n, _)).</span>
<span class="sd">        This formula considers post_travel(_, start) and pre_travel(end, _) to be</span>
<span class="sd">        0; pre_travel will never be called on any (_, start) and post_travel will</span>
<span class="sd">        never we called on any (end, _). If pre_travel_evaluator or</span>
<span class="sd">        post_travel_evaluator is -1, it will be taken as a function that always</span>
<span class="sd">        returns 0.</span>
<span class="sd">        Deprecated, sets pre_travel(i, j) = node_visit_transit[i].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_SetBreakIntervalsOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">breaks</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">,</span> <span class="n">node_visit_transits</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetBreakDistanceDurationOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">duration</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        With breaks supposed to be consecutive, this forces the distance between</span>
<span class="sd">        breaks of size at least minimum_break_duration to be at most distance.</span>
<span class="sd">        This supposes that the time until route start and after route end are</span>
<span class="sd">        infinite breaks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_SetBreakDistanceDurationOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">InitializeBreaks</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets up vehicle_break_intervals_, vehicle_break_distance_duration_,</span>
<span class="sd">        pre_travel_evaluators and post_travel_evaluators.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_InitializeBreaks</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">HasBreakConstraints</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns true if any break interval or break distance was defined.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_HasBreakConstraints</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetPreTravelEvaluatorOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_GetPreTravelEvaluatorOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetPostTravelEvaluatorOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_GetPostTravelEvaluatorOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">base_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingDimension const *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the parent in the dependency tree if any or nullptr otherwise.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_base_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ShortestTransitionSlack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        It makes sense to use the function only for self-dependent dimension.</span>
<span class="sd">        For such dimensions the value of the slack of a node determines the</span>
<span class="sd">        transition cost of the next transit. Provided that</span>
<span class="sd">          1. cumul[node] is fixed,</span>
<span class="sd">          2. next[node] and next[next[node]] (if exists) are fixed,</span>
<span class="sd">        the value of slack[node] for which cumul[next[node]] + transit[next[node]]</span>
<span class="sd">        is minimized can be found in O(1) using this function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_ShortestTransitionSlack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the name of the dimension.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetPickupToDeliveryLimitFunctionForPair</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit_function</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingDimension::PickupToDeliveryLimitFunction&quot;</span><span class="p">,</span> <span class="n">pair_index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_SetPickupToDeliveryLimitFunctionForPair</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit_function</span><span class="p">,</span> <span class="n">pair_index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">HasPickupToDeliveryLimits</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_HasPickupToDeliveryLimits</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddNodePrecedence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_node</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">second_node</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_AddNodePrecedence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_node</span><span class="p">,</span> <span class="n">second_node</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetSpanUpperBoundForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_GetSpanUpperBoundForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetSpanCostCoefficientForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_GetSpanCostCoefficientForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">global_span_cost_coefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_global_span_cost_coefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetGlobalOptimizerOffset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_GetGlobalOptimizerOffset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetLocalOptimizerOffsetForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_GetLocalOptimizerOffsetForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

<span class="c1"># Register RoutingDimension in _pywrapcp:</span>
<span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_swigregister</span><span class="p">(</span><span class="n">RoutingDimension</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">MakeSetValuesFromTargets</span><span class="p">(</span><span class="n">solver</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">,</span> <span class="n">variables</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt;&quot;</span><span class="p">,</span> <span class="n">targets</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A decision builder which tries to assign values to variables as close as</span>
<span class="sd">    possible to target values first.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">MakeSetValuesFromTargets</span><span class="p">(</span><span class="n">solver</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">targets</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">SolveModelWithSat</span><span class="p">(</span><span class="n">model</span><span class="p">:</span> <span class="s2">&quot;RoutingModel&quot;</span><span class="p">,</span> <span class="n">search_parameters</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingSearchParameters const &amp;&quot;</span><span class="p">,</span> <span class="n">initial_solution</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">solution</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Attempts to solve the model using the cp-sat solver. As of 5/2019, will</span>
<span class="sd">    solve the TSP corresponding to the model if it has a single vehicle.</span>
<span class="sd">    Therefore the resulting solution might not actually be feasible. Will return</span>
<span class="sd">    false if a solution could not be found.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolveModelWithSat</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">search_parameters</span><span class="p">,</span> <span class="n">initial_solution</span><span class="p">,</span> <span class="n">solution</span><span class="p">)</span>
</pre></div>

        </details>

            </section>
                <section id="DefaultPhaseParameters">
                                <div class="attr class">
        <a class="headerlink" href="#DefaultPhaseParameters">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">DefaultPhaseParameters</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">DefaultPhaseParameters</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This struct holds all parameters for the default search.</span>
<span class="sd">    DefaultPhaseParameters is only used by Solver::MakeDefaultPhase methods.</span>
<span class="sd">    Note this is for advanced users only.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>
    <span class="n">CHOOSE_MAX_SUM_IMPACT</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_CHOOSE_MAX_SUM_IMPACT</span>
    <span class="n">CHOOSE_MAX_AVERAGE_IMPACT</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_CHOOSE_MAX_AVERAGE_IMPACT</span>
    <span class="n">CHOOSE_MAX_VALUE_IMPACT</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_CHOOSE_MAX_VALUE_IMPACT</span>
    <span class="n">SELECT_MIN_IMPACT</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_SELECT_MIN_IMPACT</span>
    <span class="n">SELECT_MAX_IMPACT</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_SELECT_MAX_IMPACT</span>
    <span class="n">NONE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_NONE</span>
    <span class="n">NORMAL</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_NORMAL</span>
    <span class="n">VERBOSE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_VERBOSE</span>
    <span class="n">var_selection_schema</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_var_selection_schema_get</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_var_selection_schema_set</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    This parameter describes how the next variable to instantiate</span>
<span class="s2">    will be chosen.</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">value_selection_schema</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_value_selection_schema_get</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_value_selection_schema_set</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot; This parameter describes which value to select for a given var.&quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">initialization_splits</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_initialization_splits_get</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_initialization_splits_set</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    Maximum number of intervals that the initialization of impacts will scan</span>
<span class="s2">    per variable.</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">run_all_heuristics</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_run_all_heuristics_get</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_run_all_heuristics_set</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    The default phase will run heuristics periodically. This parameter</span>
<span class="s2">    indicates if we should run all heuristics, or a randomly selected</span>
<span class="s2">    one.</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">heuristic_period</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_heuristic_period_get</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_heuristic_period_set</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    The distance in nodes between each run of the heuristics. A</span>
<span class="s2">    negative or null value will mean that we will not run heuristics</span>
<span class="s2">    at all.</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">heuristic_num_failures_limit</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_heuristic_num_failures_limit_get</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_heuristic_num_failures_limit_set</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot; The failure limit for each heuristic that we run.&quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">persistent_impact</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_persistent_impact_get</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_persistent_impact_set</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    Whether to keep the impact from the first search for other searches,</span>
<span class="s2">    or to recompute the impact for each new search.</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">random_seed</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_random_seed_get</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_random_seed_set</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot; Seed used to initialize the random part in some heuristics.&quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">display_level</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_display_level_get</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_display_level_set</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot;</span>
<span class="s2">    This represents the amount of information displayed by the default search.</span>
<span class="s2">    NONE means no display, VERBOSE means extra information.</span>
<span class="s2">    &quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">decision_builder</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_decision_builder_get</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_decision_builder_set</span><span class="p">,</span> <span class="n">doc</span><span class="o">=</span><span class="sa">r</span><span class="s2">&quot;&quot;&quot; When defined, this overrides the default impact based decision builder.&quot;&quot;&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_DefaultPhaseParameters</span><span class="p">())</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_DefaultPhaseParameters</span>
</pre></div>

        </details>

            <div class="docstring"><p>This struct holds all parameters for the default search.
DefaultPhaseParameters is only used by Solver::MakeDefaultPhase methods.
Note this is for advanced users only.</p>
</div>


                            <div id="DefaultPhaseParameters.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DefaultPhaseParameters.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">DefaultPhaseParameters</span><span class="signature">()</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultPhaseParameters_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_DefaultPhaseParameters</span><span class="p">())</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="DefaultPhaseParameters.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#DefaultPhaseParameters.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="DefaultPhaseParameters.CHOOSE_MAX_SUM_IMPACT" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#DefaultPhaseParameters.CHOOSE_MAX_SUM_IMPACT">#&nbsp;&nbsp</a>

        <span class="name">CHOOSE_MAX_SUM_IMPACT</span><span class="default_value"> = 0</span>
    </div>

    

                            </div>
                            <div id="DefaultPhaseParameters.CHOOSE_MAX_AVERAGE_IMPACT" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#DefaultPhaseParameters.CHOOSE_MAX_AVERAGE_IMPACT">#&nbsp;&nbsp</a>

        <span class="name">CHOOSE_MAX_AVERAGE_IMPACT</span><span class="default_value"> = 1</span>
    </div>

    

                            </div>
                            <div id="DefaultPhaseParameters.CHOOSE_MAX_VALUE_IMPACT" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#DefaultPhaseParameters.CHOOSE_MAX_VALUE_IMPACT">#&nbsp;&nbsp</a>

        <span class="name">CHOOSE_MAX_VALUE_IMPACT</span><span class="default_value"> = 2</span>
    </div>

    

                            </div>
                            <div id="DefaultPhaseParameters.SELECT_MIN_IMPACT" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#DefaultPhaseParameters.SELECT_MIN_IMPACT">#&nbsp;&nbsp</a>

        <span class="name">SELECT_MIN_IMPACT</span><span class="default_value"> = 0</span>
    </div>

    

                            </div>
                            <div id="DefaultPhaseParameters.SELECT_MAX_IMPACT" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#DefaultPhaseParameters.SELECT_MAX_IMPACT">#&nbsp;&nbsp</a>

        <span class="name">SELECT_MAX_IMPACT</span><span class="default_value"> = 1</span>
    </div>

    

                            </div>
                            <div id="DefaultPhaseParameters.NONE" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#DefaultPhaseParameters.NONE">#&nbsp;&nbsp</a>

        <span class="name">NONE</span><span class="default_value"> = 0</span>
    </div>

    

                            </div>
                            <div id="DefaultPhaseParameters.NORMAL" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#DefaultPhaseParameters.NORMAL">#&nbsp;&nbsp</a>

        <span class="name">NORMAL</span><span class="default_value"> = 1</span>
    </div>

    

                            </div>
                            <div id="DefaultPhaseParameters.VERBOSE" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#DefaultPhaseParameters.VERBOSE">#&nbsp;&nbsp</a>

        <span class="name">VERBOSE</span><span class="default_value"> = 2</span>
    </div>

    

                            </div>
                            <div id="DefaultPhaseParameters.var_selection_schema" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#DefaultPhaseParameters.var_selection_schema">#&nbsp;&nbsp</a>

        <span class="name">var_selection_schema</span>
    </div>

            <div class="docstring"><p>This parameter describes how the next variable to instantiate
will be chosen.</p>
</div>


                            </div>
                            <div id="DefaultPhaseParameters.value_selection_schema" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#DefaultPhaseParameters.value_selection_schema">#&nbsp;&nbsp</a>

        <span class="name">value_selection_schema</span>
    </div>

            <div class="docstring"><p>This parameter describes which value to select for a given var.</p>
</div>


                            </div>
                            <div id="DefaultPhaseParameters.initialization_splits" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#DefaultPhaseParameters.initialization_splits">#&nbsp;&nbsp</a>

        <span class="name">initialization_splits</span>
    </div>

            <div class="docstring"><p>Maximum number of intervals that the initialization of impacts will scan
per variable.</p>
</div>


                            </div>
                            <div id="DefaultPhaseParameters.run_all_heuristics" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#DefaultPhaseParameters.run_all_heuristics">#&nbsp;&nbsp</a>

        <span class="name">run_all_heuristics</span>
    </div>

            <div class="docstring"><p>The default phase will run heuristics periodically. This parameter
indicates if we should run all heuristics, or a randomly selected
one.</p>
</div>


                            </div>
                            <div id="DefaultPhaseParameters.heuristic_period" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#DefaultPhaseParameters.heuristic_period">#&nbsp;&nbsp</a>

        <span class="name">heuristic_period</span>
    </div>

            <div class="docstring"><p>The distance in nodes between each run of the heuristics. A
negative or null value will mean that we will not run heuristics
at all.</p>
</div>


                            </div>
                            <div id="DefaultPhaseParameters.heuristic_num_failures_limit" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#DefaultPhaseParameters.heuristic_num_failures_limit">#&nbsp;&nbsp</a>

        <span class="name">heuristic_num_failures_limit</span>
    </div>

            <div class="docstring"><p>The failure limit for each heuristic that we run.</p>
</div>


                            </div>
                            <div id="DefaultPhaseParameters.persistent_impact" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#DefaultPhaseParameters.persistent_impact">#&nbsp;&nbsp</a>

        <span class="name">persistent_impact</span>
    </div>

            <div class="docstring"><p>Whether to keep the impact from the first search for other searches,
or to recompute the impact for each new search.</p>
</div>


                            </div>
                            <div id="DefaultPhaseParameters.random_seed" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#DefaultPhaseParameters.random_seed">#&nbsp;&nbsp</a>

        <span class="name">random_seed</span>
    </div>

            <div class="docstring"><p>Seed used to initialize the random part in some heuristics.</p>
</div>


                            </div>
                            <div id="DefaultPhaseParameters.display_level" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#DefaultPhaseParameters.display_level">#&nbsp;&nbsp</a>

        <span class="name">display_level</span>
    </div>

            <div class="docstring"><p>This represents the amount of information displayed by the default search.
NONE means no display, VERBOSE means extra information.</p>
</div>


                            </div>
                            <div id="DefaultPhaseParameters.decision_builder" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#DefaultPhaseParameters.decision_builder">#&nbsp;&nbsp</a>

        <span class="name">decision_builder</span>
    </div>

            <div class="docstring"><p>When defined, this overrides the default impact based decision builder.</p>
</div>


                            </div>
                </section>
                <section id="Solver">
                                <div class="attr class">
        <a class="headerlink" href="#Solver">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">Solver</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Solver</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solver Class</span>

<span class="sd">    A solver represents the main computation engine. It implements the entire</span>
<span class="sd">    range of Constraint Programming protocols:</span>
<span class="sd">      - Reversibility</span>
<span class="sd">      - Propagation</span>
<span class="sd">      - Search</span>

<span class="sd">    Usually, Constraint Programming code consists of</span>
<span class="sd">      - the creation of the Solver,</span>
<span class="sd">      - the creation of the decision variables of the model,</span>
<span class="sd">      - the creation of the constraints of the model and their addition to the</span>
<span class="sd">        solver() through the AddConstraint() method,</span>
<span class="sd">      - the creation of the main DecisionBuilder class,</span>
<span class="sd">      - the launch of the solve() method with the decision builder.</span>

<span class="sd">    For the time being, Solver is neither MT_SAFE nor MT_HOT.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>
    <span class="n">INT_VAR_DEFAULT</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_INT_VAR_DEFAULT</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; The default behavior is CHOOSE_FIRST_UNBOUND.&quot;&quot;&quot;</span>
    <span class="n">INT_VAR_SIMPLE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_INT_VAR_SIMPLE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; The simple selection is CHOOSE_FIRST_UNBOUND.&quot;&quot;&quot;</span>
    <span class="n">CHOOSE_FIRST_UNBOUND</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_CHOOSE_FIRST_UNBOUND</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Select the first unbound variable.</span>
<span class="sd">    Variables are considered in the order of the vector of IntVars used</span>
<span class="sd">    to create the selector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CHOOSE_RANDOM</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_CHOOSE_RANDOM</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Randomly select one of the remaining unbound variables.&quot;&quot;&quot;</span>
    <span class="n">CHOOSE_MIN_SIZE_LOWEST_MIN</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_CHOOSE_MIN_SIZE_LOWEST_MIN</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Among unbound variables, select the variable with the smallest size,</span>
<span class="sd">    i.e., the smallest number of possible values.</span>
<span class="sd">    In case of a tie, the selected variables is the one with the lowest min</span>
<span class="sd">    value.</span>
<span class="sd">    In case of a tie, the first one is selected, first being defined by the</span>
<span class="sd">    order in the vector of IntVars used to create the selector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CHOOSE_MIN_SIZE_HIGHEST_MIN</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_CHOOSE_MIN_SIZE_HIGHEST_MIN</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Among unbound variables, select the variable with the smallest size,</span>
<span class="sd">    i.e., the smallest number of possible values.</span>
<span class="sd">    In case of a tie, the selected variable is the one with the highest min</span>
<span class="sd">    value.</span>
<span class="sd">    In case of a tie, the first one is selected, first being defined by the</span>
<span class="sd">    order in the vector of IntVars used to create the selector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CHOOSE_MIN_SIZE_LOWEST_MAX</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_CHOOSE_MIN_SIZE_LOWEST_MAX</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Among unbound variables, select the variable with the smallest size,</span>
<span class="sd">    i.e., the smallest number of possible values.</span>
<span class="sd">    In case of a tie, the selected variables is the one with the lowest max</span>
<span class="sd">    value.</span>
<span class="sd">    In case of a tie, the first one is selected, first being defined by the</span>
<span class="sd">    order in the vector of IntVars used to create the selector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CHOOSE_MIN_SIZE_HIGHEST_MAX</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_CHOOSE_MIN_SIZE_HIGHEST_MAX</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Among unbound variables, select the variable with the smallest size,</span>
<span class="sd">    i.e., the smallest number of possible values.</span>
<span class="sd">    In case of a tie, the selected variable is the one with the highest max</span>
<span class="sd">    value.</span>
<span class="sd">    In case of a tie, the first one is selected, first being defined by the</span>
<span class="sd">    order in the vector of IntVars used to create the selector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CHOOSE_LOWEST_MIN</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_CHOOSE_LOWEST_MIN</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Among unbound variables, select the variable with the smallest minimal</span>
<span class="sd">    value.</span>
<span class="sd">    In case of a tie, the first one is selected, &quot;first&quot; defined by the</span>
<span class="sd">    order in the vector of IntVars used to create the selector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CHOOSE_HIGHEST_MAX</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_CHOOSE_HIGHEST_MAX</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Among unbound variables, select the variable with the highest maximal</span>
<span class="sd">    value.</span>
<span class="sd">    In case of a tie, the first one is selected, first being defined by the</span>
<span class="sd">    order in the vector of IntVars used to create the selector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CHOOSE_MIN_SIZE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_CHOOSE_MIN_SIZE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Among unbound variables, select the variable with the smallest size.</span>
<span class="sd">    In case of a tie, the first one is selected, first being defined by the</span>
<span class="sd">    order in the vector of IntVars used to create the selector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CHOOSE_MAX_SIZE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_CHOOSE_MAX_SIZE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Among unbound variables, select the variable with the highest size.</span>
<span class="sd">    In case of a tie, the first one is selected, first being defined by the</span>
<span class="sd">    order in the vector of IntVars used to create the selector.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CHOOSE_MAX_REGRET_ON_MIN</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_CHOOSE_MAX_REGRET_ON_MIN</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Among unbound variables, select the variable with the largest</span>
<span class="sd">    gap between the first and the second values of the domain.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CHOOSE_PATH</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_CHOOSE_PATH</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Selects the next unbound variable on a path, the path being defined by</span>
<span class="sd">    the variables: var[i] corresponds to the index of the next of i.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">INT_VALUE_DEFAULT</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_INT_VALUE_DEFAULT</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; The default behavior is ASSIGN_MIN_VALUE.&quot;&quot;&quot;</span>
    <span class="n">INT_VALUE_SIMPLE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_INT_VALUE_SIMPLE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; The simple selection is ASSIGN_MIN_VALUE.&quot;&quot;&quot;</span>
    <span class="n">ASSIGN_MIN_VALUE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ASSIGN_MIN_VALUE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Selects the min value of the selected variable.&quot;&quot;&quot;</span>
    <span class="n">ASSIGN_MAX_VALUE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ASSIGN_MAX_VALUE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Selects the max value of the selected variable.&quot;&quot;&quot;</span>
    <span class="n">ASSIGN_RANDOM_VALUE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ASSIGN_RANDOM_VALUE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Selects randomly one of the possible values of the selected variable.&quot;&quot;&quot;</span>
    <span class="n">ASSIGN_CENTER_VALUE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ASSIGN_CENTER_VALUE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Selects the first possible value which is the closest to the center</span>
<span class="sd">    of the domain of the selected variable.</span>
<span class="sd">    The center is defined as (min + max) / 2.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">SPLIT_LOWER_HALF</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SPLIT_LOWER_HALF</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Split the domain in two around the center, and choose the lower</span>
<span class="sd">    part first.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">SPLIT_UPPER_HALF</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SPLIT_UPPER_HALF</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Split the domain in two around the center, and choose the lower</span>
<span class="sd">    part first.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">SEQUENCE_DEFAULT</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SEQUENCE_DEFAULT</span>
    <span class="n">SEQUENCE_SIMPLE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SEQUENCE_SIMPLE</span>
    <span class="n">CHOOSE_MIN_SLACK_RANK_FORWARD</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_CHOOSE_MIN_SLACK_RANK_FORWARD</span>
    <span class="n">CHOOSE_RANDOM_RANK_FORWARD</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_CHOOSE_RANDOM_RANK_FORWARD</span>
    <span class="n">INTERVAL_DEFAULT</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_INTERVAL_DEFAULT</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; The default is INTERVAL_SET_TIMES_FORWARD.&quot;&quot;&quot;</span>
    <span class="n">INTERVAL_SIMPLE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_INTERVAL_SIMPLE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; The simple is INTERVAL_SET_TIMES_FORWARD.&quot;&quot;&quot;</span>
    <span class="n">INTERVAL_SET_TIMES_FORWARD</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_INTERVAL_SET_TIMES_FORWARD</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Selects the variable with the lowest starting time of all variables,</span>
<span class="sd">    and fixes its starting time to this lowest value.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">INTERVAL_SET_TIMES_BACKWARD</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_INTERVAL_SET_TIMES_BACKWARD</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Selects the variable with the highest ending time of all variables,</span>
<span class="sd">    and fixes the ending time to this highest values.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">TWOOPT</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_TWOOPT</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Operator which reverses a sub-chain of a path. It is called TwoOpt</span>
<span class="sd">    because it breaks two arcs on the path; resulting paths are called</span>
<span class="sd">    two-optimal.</span>
<span class="sd">    Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</span>
<span class="sd">    (where (1, 5) are first and last nodes of the path and can therefore not</span>
<span class="sd">    be moved):</span>
<span class="sd">      1 -&gt; [3 -&gt; 2] -&gt; 4  -&gt; 5</span>
<span class="sd">      1 -&gt; [4 -&gt; 3  -&gt; 2] -&gt; 5</span>
<span class="sd">      1 -&gt;  2 -&gt; [4 -&gt; 3] -&gt; 5</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">OROPT</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_OROPT</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Relocate: OROPT and RELOCATE.</span>
<span class="sd">    Operator which moves a sub-chain of a path to another position; the</span>
<span class="sd">    specified chain length is the fixed length of the chains being moved.</span>
<span class="sd">    When this length is 1, the operator simply moves a node to another</span>
<span class="sd">    position.</span>
<span class="sd">    Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5, for a chain</span>
<span class="sd">    length of 2 (where (1, 5) are first and last nodes of the path and can</span>
<span class="sd">    therefore not be moved):</span>
<span class="sd">      1 -&gt;  4 -&gt; [2 -&gt; 3] -&gt; 5</span>
<span class="sd">      1 -&gt; [3 -&gt; 4] -&gt; 2  -&gt; 5</span>

<span class="sd">    Using Relocate with chain lengths of 1, 2 and 3 together is equivalent</span>
<span class="sd">    to the OrOpt operator on a path. The OrOpt operator is a limited</span>
<span class="sd">     version of 3Opt (breaks 3 arcs on a path).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">RELOCATE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_RELOCATE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Relocate neighborhood with length of 1 (see OROPT comment).&quot;&quot;&quot;</span>
    <span class="n">EXCHANGE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_EXCHANGE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Operator which exchanges the positions of two nodes.</span>
<span class="sd">    Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5</span>
<span class="sd">    (where (1, 5) are first and last nodes of the path and can therefore not</span>
<span class="sd">    be moved):</span>
<span class="sd">      1 -&gt; [3] -&gt; [2] -&gt;  4  -&gt; 5</span>
<span class="sd">      1 -&gt; [4] -&gt;  3  -&gt; [2] -&gt; 5</span>
<span class="sd">      1 -&gt;  2  -&gt; [4] -&gt; [3] -&gt; 5</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">CROSS</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_CROSS</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Operator which cross exchanges the starting chains of 2 paths, including</span>
<span class="sd">    exchanging the whole paths.</span>
<span class="sd">    First and last nodes are not moved.</span>
<span class="sd">    Possible neighbors for the paths 1 -&gt; 2 -&gt; 3 -&gt; 4 -&gt; 5 and 6 -&gt; 7 -&gt; 8</span>
<span class="sd">    (where (1, 5) and (6, 8) are first and last nodes of the paths and can</span>
<span class="sd">    therefore not be moved):</span>
<span class="sd">      1 -&gt; [7] -&gt; 3 -&gt; 4 -&gt; 5  6 -&gt; [2] -&gt; 8</span>
<span class="sd">      1 -&gt; [7] -&gt; 4 -&gt; 5       6 -&gt; [2 -&gt; 3] -&gt; 8</span>
<span class="sd">      1 -&gt; [7] -&gt; 5            6 -&gt; [2 -&gt; 3 -&gt; 4] -&gt; 8</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">MAKEACTIVE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_MAKEACTIVE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Operator which inserts an inactive node into a path.</span>
<span class="sd">    Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive</span>
<span class="sd">    (where 1 and 4 are first and last nodes of the path) are:</span>
<span class="sd">      1 -&gt; [5] -&gt;  2  -&gt;  3  -&gt; 4</span>
<span class="sd">      1 -&gt;  2  -&gt; [5] -&gt;  3  -&gt; 4</span>
<span class="sd">      1 -&gt;  2  -&gt;  3  -&gt; [5] -&gt; 4</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">MAKEINACTIVE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_MAKEINACTIVE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Operator which makes path nodes inactive.</span>
<span class="sd">    Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 (where 1 and 4 are</span>
<span class="sd">    first and last nodes of the path) are:</span>
<span class="sd">      1 -&gt; 3 -&gt; 4 with 2 inactive</span>
<span class="sd">      1 -&gt; 2 -&gt; 4 with 3 inactive</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">MAKECHAININACTIVE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_MAKECHAININACTIVE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Operator which makes a &quot;chain&quot; of path nodes inactive.</span>
<span class="sd">    Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 (where 1 and 4 are</span>
<span class="sd">    first and last nodes of the path) are:</span>
<span class="sd">      1 -&gt; 3 -&gt; 4 with 2 inactive</span>
<span class="sd">      1 -&gt; 2 -&gt; 4 with 3 inactive</span>
<span class="sd">      1 -&gt; 4 with 2 and 3 inactive</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">SWAPACTIVE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SWAPACTIVE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Operator which replaces an active node by an inactive one.</span>
<span class="sd">    Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive</span>
<span class="sd">    (where 1 and 4 are first and last nodes of the path) are:</span>
<span class="sd">      1 -&gt; [5] -&gt;  3  -&gt; 4 with 2 inactive</span>
<span class="sd">      1 -&gt;  2  -&gt; [5] -&gt; 4 with 3 inactive</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">EXTENDEDSWAPACTIVE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_EXTENDEDSWAPACTIVE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Operator which makes an inactive node active and an active one inactive.</span>
<span class="sd">    It is similar to SwapActiveOperator except that it tries to insert the</span>
<span class="sd">    inactive node in all possible positions instead of just the position of</span>
<span class="sd">    the node made inactive.</span>
<span class="sd">    Possible neighbors for the path 1 -&gt; 2 -&gt; 3 -&gt; 4 with 5 inactive</span>
<span class="sd">    (where 1 and 4 are first and last nodes of the path) are:</span>
<span class="sd">      1 -&gt; [5] -&gt;  3  -&gt; 4 with 2 inactive</span>
<span class="sd">      1 -&gt;  3  -&gt; [5] -&gt; 4 with 2 inactive</span>
<span class="sd">      1 -&gt; [5] -&gt;  2  -&gt; 4 with 3 inactive</span>
<span class="sd">      1 -&gt;  2  -&gt; [5] -&gt; 4 with 3 inactive</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">PATHLNS</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_PATHLNS</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Operator which relaxes two sub-chains of three consecutive arcs each.</span>
<span class="sd">    Each sub-chain is defined by a start node and the next three arcs. Those</span>
<span class="sd">    six arcs are relaxed to build a new neighbor.</span>
<span class="sd">    PATHLNS explores all possible pairs of starting nodes and so defines</span>
<span class="sd">    n^2 neighbors, n being the number of nodes.</span>
<span class="sd">    Note that the two sub-chains can be part of the same path; they even may</span>
<span class="sd">    overlap.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">FULLPATHLNS</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_FULLPATHLNS</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Operator which relaxes one entire path and all inactive nodes, thus</span>
<span class="sd">    defining num_paths neighbors.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">UNACTIVELNS</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_UNACTIVELNS</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Operator which relaxes all inactive nodes and one sub-chain of six</span>
<span class="sd">    consecutive arcs. That way the path can be improved by inserting</span>
<span class="sd">    inactive nodes or swapping arcs.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">INCREMENT</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_INCREMENT</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Operator which defines one neighbor per variable. Each neighbor tries to</span>
<span class="sd">    increment by one the value of the corresponding variable. When a new</span>
<span class="sd">    solution is found the neighborhood is rebuilt from scratch, i.e., tries</span>
<span class="sd">    to increment values in the variable order.</span>
<span class="sd">    Consider for instance variables x and y. x is incremented one by one to</span>
<span class="sd">    its max, and when it is not possible to increment x anymore, y is</span>
<span class="sd">    incremented once. If this is a solution, then next neighbor tries to</span>
<span class="sd">    increment x.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">DECREMENT</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_DECREMENT</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Operator which defines a neighborhood to decrement values.</span>
<span class="sd">    The behavior is the same as INCREMENT, except values are decremented</span>
<span class="sd">    instead of incremented.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">SIMPLELNS</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SIMPLELNS</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Operator which defines one neighbor per variable. Each neighbor relaxes</span>
<span class="sd">    one variable.</span>
<span class="sd">    When a new solution is found the neighborhood is rebuilt from scratch.</span>
<span class="sd">    Consider for instance variables x and y. First x is relaxed and the</span>
<span class="sd">    solver is looking for the best possible solution (with only x relaxed).</span>
<span class="sd">    Then y is relaxed, and the solver is looking for a new solution.</span>
<span class="sd">    If a new solution is found, then the next variable to be relaxed is x.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">GE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_GE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Move is accepted when the current objective value &gt;= objective.Min.&quot;&quot;&quot;</span>
    <span class="n">LE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_LE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Move is accepted when the current objective value &lt;= objective.Max.&quot;&quot;&quot;</span>
    <span class="n">EQ</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_EQ</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Move is accepted when the current objective value is in the interval</span>
<span class="sd">    objective.Min .. objective.Max.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">DELAYED_PRIORITY</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_DELAYED_PRIORITY</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    DELAYED_PRIORITY is the lowest priority: Demons will be processed after</span>
<span class="sd">    VAR_PRIORITY and NORMAL_PRIORITY demons.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">VAR_PRIORITY</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_VAR_PRIORITY</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; VAR_PRIORITY is between DELAYED_PRIORITY and NORMAL_PRIORITY.&quot;&quot;&quot;</span>
    <span class="n">NORMAL_PRIORITY</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_NORMAL_PRIORITY</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; NORMAL_PRIORITY is the highest priority: Demons will be processed first.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_Solver</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__python_constraints</span> <span class="o">=</span> <span class="p">[]</span>



    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_Solver</span>

    <span class="k">def</span> <span class="nf">Parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::ConstraintSolverParameters&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Stored Parameters.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">DefaultSolverParameters</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::ConstraintSolverParameters&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Create a ConstraintSolverParameters proto with all the default values.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_DefaultSolverParameters</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">AddConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="s2">&quot;Constraint&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds the constraint &#39;c&#39; to the model.</span>

<span class="sd">        After calling this method, and until there is a backtrack that undoes the</span>
<span class="sd">        addition, any assignment of variables to values must satisfy the given</span>
<span class="sd">        constraint in order to be considered feasible. There are two fairly</span>
<span class="sd">        different use cases:</span>

<span class="sd">        - the most common use case is modeling: the given constraint is really</span>
<span class="sd">        part of the problem that the user is trying to solve. In this use case,</span>
<span class="sd">        AddConstraint is called outside of search (i.e., with state() ==</span>
<span class="sd">        OUTSIDE_SEARCH). Most users should only use AddConstraint in this</span>
<span class="sd">        way. In this case, the constraint will belong to the model forever: it</span>
<span class="sd">        cannot not be removed by backtracking.</span>

<span class="sd">        - a rarer use case is that &#39;c&#39; is not a real constraint of the model. It</span>
<span class="sd">        may be a constraint generated by a branching decision (a constraint whose</span>
<span class="sd">        goal is to restrict the search space), a symmetry breaking constraint (a</span>
<span class="sd">        constraint that does restrict the search space, but in a way that cannot</span>
<span class="sd">        have an impact on the quality of the solutions in the subtree), or an</span>
<span class="sd">        inferred constraint that, while having no semantic value to the model (it</span>
<span class="sd">        does not restrict the set of solutions), is worth having because we</span>
<span class="sd">        believe it may strengthen the propagation. In these cases, it happens</span>
<span class="sd">        that the constraint is added during the search (i.e., with state() ==</span>
<span class="sd">        IN_SEARCH or state() == IN_ROOT_NODE). When a constraint is</span>
<span class="sd">        added during a search, it applies only to the subtree of the search tree</span>
<span class="sd">        rooted at the current node, and will be automatically removed by</span>
<span class="sd">        backtracking.</span>

<span class="sd">        This method does not take ownership of the constraint. If the constraint</span>
<span class="sd">        has been created by any factory method (Solver::MakeXXX), it will</span>
<span class="sd">        automatically be deleted. However, power users who implement their own</span>
<span class="sd">        constraints should do: solver.AddConstraint(solver.RevAlloc(new</span>
<span class="sd">        MyConstraint(...));</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_AddConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NewSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_NewSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NextSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_NextSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RestartSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_RestartSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_EndSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SolveAndCommit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SolveAndCommit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">CheckAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solution</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Checks whether the given assignment satisfies all relevant constraints.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_CheckAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solution</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">CheckConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ct</span><span class="p">:</span> <span class="s2">&quot;Constraint&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether adding this constraint will lead to an immediate</span>
<span class="sd">        failure. It will return false if the model is already inconsistent, or if</span>
<span class="sd">        adding the constraint makes it inconsistent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_CheckConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ct</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Fail</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Abandon the current branch in the search tree. A backtrack will follow.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Fail</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">MemoryUsage</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Current memory usage in bytes&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_MemoryUsage</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">WallTime</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        DEPRECATED: Use Now() instead.</span>
<span class="sd">        Time elapsed, in ms since the creation of the solver.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_WallTime</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Branches</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; The number of branches explored since the creation of the solver.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Branches</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Solutions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; The number of solutions found since the start of the search.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Solutions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Failures</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; The number of failures encountered since the creation of the solver.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Failures</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AcceptedNeighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; The number of accepted neighbors.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_AcceptedNeighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Stamp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;uint64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The stamp indicates how many moves in the search tree we have performed.</span>
<span class="sd">        It is useful to detect if we need to update same lazy structures.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Stamp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">FailStamp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;uint64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; The fail_stamp() is incremented after each backtrack.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_FailStamp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IntVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        MakeIntVar will create the best range based int var for the bounds given.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        MakeIntVar will create a variable with the given sparse domain.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 3:*</span>
<span class="sd">        MakeIntVar will create a variable with the given sparse domain.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 4:*</span>
<span class="sd">        MakeIntVar will create the best range based int var for the bounds given.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 5:*</span>
<span class="sd">        MakeIntVar will create a variable with the given sparse domain.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 6:*</span>
<span class="sd">        MakeIntVar will create a variable with the given sparse domain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IntVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">BoolVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        MakeBoolVar will create a variable with a {0, 1} domain.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        MakeBoolVar will create a variable with a {0, 1} domain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_BoolVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IntConst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        IntConst will create a constant expression.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        IntConst will create a constant expression.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IntConst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; sum of all vars.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ScalProd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        scalar product</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        scalar product</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ScalProd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">MonotonicElement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IndexEvaluator1&quot;</span><span class="p">,</span> <span class="n">increasing</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function based element. The constraint takes ownership of the</span>
<span class="sd">        callback.  The callback must be monotonic. It must be able to</span>
<span class="sd">        cope with any possible value in the domain of &#39;index&#39;</span>
<span class="sd">        (potentially negative ones too). Furtermore, monotonicity is not</span>
<span class="sd">        checked. Thus giving a non-monotonic function, or specifying an</span>
<span class="sd">        incorrect increasing parameter will result in undefined behavior.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_MonotonicElement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">increasing</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        values[index]</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        values[index]</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 3:*</span>
<span class="sd">        Function-based element. The constraint takes ownership of the</span>
<span class="sd">        callback. The callback must be able to cope with any possible</span>
<span class="sd">        value in the domain of &#39;index&#39; (potentially negative ones too).</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 4:*</span>
<span class="sd">        2D version of function-based element expression, values(expr1, expr2).</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 5:*</span>
<span class="sd">        vars[expr]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IndexExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the expression expr such that vars[expr] == value.</span>
<span class="sd">        It assumes that vars are all different.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IndexExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        std::min(vars)</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        std::min (left, right)</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 3:*</span>
<span class="sd">        std::min(expr, value)</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 4:*</span>
<span class="sd">        std::min(expr, value)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        std::max(vars)</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        std::max(left, right)</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 3:*</span>
<span class="sd">        std::max(expr, value)</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 4:*</span>
<span class="sd">        std::max(expr, value)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ConvexPiecewiseExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">early_cost</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">early_date</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">late_date</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">late_cost</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Convex piecewise function.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ConvexPiecewiseExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">early_cost</span><span class="p">,</span> <span class="n">early_date</span><span class="p">,</span> <span class="n">late_date</span><span class="p">,</span> <span class="n">late_cost</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SemiContinuousExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">fixed_charge</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">step</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Semi continuous Expression (x &lt;= 0 -&gt; f(x) = 0; x &gt; 0 -&gt; f(x) = ax + b)</span>
<span class="sd">        a &gt;= 0 and b &gt;= 0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SemiContinuousExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">fixed_charge</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ConditionalExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">unperformed_value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Conditional Expr condition ? expr : unperformed_value&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ConditionalExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">unperformed_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">TrueConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This constraint always succeeds.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_TrueConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">FalseConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_FalseConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsEqualCstCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">boolvar</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; boolvar == (var == value)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsEqualCstCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">boolvar</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsEqualCstVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; status var of (var == value)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsEqualCstVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsEqualCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v1</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">v2</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; b == (v1 == v2)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsEqualCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsEqualVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v1</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">v2</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; status var of (v1 == v2)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsEqualVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsDifferentCstCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">boolvar</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; boolvar == (var != value)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsDifferentCstCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">boolvar</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsDifferentCstVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; status var of (var != value)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsDifferentCstVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsDifferentVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v1</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">v2</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; status var of (v1 != v2)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsDifferentVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsDifferentCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v1</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">v2</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; b == (v1 != v2)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsDifferentCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsLessOrEqualCstCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">boolvar</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; boolvar == (var &lt;= value)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsLessOrEqualCstCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">boolvar</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsLessOrEqualCstVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; status var of (var &lt;= value)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsLessOrEqualCstVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsLessOrEqualVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; status var of (left &lt;= right)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsLessOrEqualVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsLessOrEqualCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; b == (left &lt;= right)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsLessOrEqualCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsGreaterOrEqualCstCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">boolvar</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; boolvar == (var &gt;= value)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsGreaterOrEqualCstCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">boolvar</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsGreaterOrEqualCstVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; status var of (var &gt;= value)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsGreaterOrEqualCstVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsGreaterOrEqualVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; status var of (left &gt;= right)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsGreaterOrEqualVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsGreaterOrEqualCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; b == (left &gt;= right)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsGreaterOrEqualCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsGreaterCstCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; b == (v &gt; c)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsGreaterCstCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsGreaterCstVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; status var of (var &gt; value)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsGreaterCstVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsGreaterVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; status var of (left &gt; right)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsGreaterVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsGreaterCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; b == (left &gt; right)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsGreaterCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsLessCstCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; b == (v &lt; c)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsLessCstCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsLessCstVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; status var of (var &lt; value)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsLessCstVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsLessVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; status var of (left &lt; right)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsLessVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsLessCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; b == (left &lt; right)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsLessCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SumLessOrEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">cst</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Variation on arrays.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SumLessOrEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">cst</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SumGreaterOrEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">cst</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SumGreaterOrEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">cst</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SumEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SumEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ScalProdEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ScalProdEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ScalProdGreaterOrEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ScalProdGreaterOrEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ScalProdLessOrEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ScalProdLessOrEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">MinEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">min_var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_MinEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">min_var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">MaxEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">max_var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_MaxEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">max_var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ElementEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ElementEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AbsEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">abs_var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Creates the constraint abs(var) == abs_var.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_AbsEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">abs_var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IndexOfConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This constraint is a special case of the element constraint with</span>
<span class="sd">        an array of integer variables, where the variables are all</span>
<span class="sd">        different and the index variable is constrained such that</span>
<span class="sd">        vars[index] == target.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IndexOfConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ConstraintInitialPropagateCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ct</span><span class="p">:</span> <span class="s2">&quot;Constraint&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Demon *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is a specialized case of the MakeConstraintDemon</span>
<span class="sd">        method to call the InitiatePropagate of the constraint &#39;ct&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ConstraintInitialPropagateCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ct</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DelayedConstraintInitialPropagateCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ct</span><span class="p">:</span> <span class="s2">&quot;Constraint&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Demon *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is a specialized case of the MakeConstraintDemon</span>
<span class="sd">        method to call the InitiatePropagate of the constraint &#39;ct&#39; with</span>
<span class="sd">        low priority.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_DelayedConstraintInitialPropagateCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ct</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ClosureDemon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">closure</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::Closure&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Demon *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Creates a demon from a closure.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ClosureDemon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">closure</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">BetweenCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; (l &lt;= expr &lt;= u)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_BetweenCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsBetweenCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; b == (l &lt;= expr &lt;= u)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsBetweenCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsBetweenVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsBetweenVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">MemberCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_MemberCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NotMemberCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        expr not in set.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        expr should not be in the list of forbidden intervals [start[i]..end[i]].</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 3:*</span>
<span class="sd">        expr should not be in the list of forbidden intervals [start[i]..end[i]].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_NotMemberCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsMemberCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsMemberCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsMemberVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsMemberVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        |{i | vars[i] == value}| == max_count</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        |{i | vars[i] == value}| == max_count</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Distribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Aggregated version of count:  |{i | v[i] == values[j]}| == cards[j]</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Aggregated version of count:  |{i | v[i] == values[j]}| == cards[j]</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 3:*</span>
<span class="sd">        Aggregated version of count:  |{i | v[i] == j}| == cards[j]</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 4:*</span>
<span class="sd">        Aggregated version of count with bounded cardinalities:</span>
<span class="sd">        forall j in 0 .. card_size - 1: card_min &lt;= |{i | v[i] == j}| &lt;= card_max</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 5:*</span>
<span class="sd">        Aggregated version of count with bounded cardinalities:</span>
<span class="sd">        forall j in 0 .. card_size - 1:</span>
<span class="sd">           card_min[j] &lt;= |{i | v[i] == j}| &lt;= card_max[j]</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 6:*</span>
<span class="sd">        Aggregated version of count with bounded cardinalities:</span>
<span class="sd">        forall j in 0 .. card_size - 1:</span>
<span class="sd">           card_min[j] &lt;= |{i | v[i] == j}| &lt;= card_max[j]</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 7:*</span>
<span class="sd">        Aggregated version of count with bounded cardinalities:</span>
<span class="sd">        forall j in 0 .. card_size - 1:</span>
<span class="sd">           card_min[j] &lt;= |{i | v[i] == values[j]}| &lt;= card_max[j]</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 8:*</span>
<span class="sd">        Aggregated version of count with bounded cardinalities:</span>
<span class="sd">        forall j in 0 .. card_size - 1:</span>
<span class="sd">           card_min[j] &lt;= |{i | v[i] == values[j]}| &lt;= card_max[j]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Distribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Deviation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">deviation_var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">total_sum</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deviation constraint:</span>
<span class="sd">        sum_i |n * vars[i] - total_sum| &lt;= deviation_var and</span>
<span class="sd">        sum_i vars[i] == total_sum</span>
<span class="sd">        n = #vars</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Deviation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">deviation_var</span><span class="p">,</span> <span class="n">total_sum</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AllDifferent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        All variables are pairwise different. This corresponds to the</span>
<span class="sd">        stronger version of the propagation algorithm.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        All variables are pairwise different.  If &#39;stronger_propagation&#39;</span>
<span class="sd">        is true, stronger, and potentially slower propagation will</span>
<span class="sd">        occur. This API will be deprecated in the future.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_AllDifferent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AllDifferentExcept</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">escape_value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        All variables are pairwise different, unless they are assigned to</span>
<span class="sd">        the escape value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_AllDifferentExcept</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">escape_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SortingConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a constraint binding the arrays of variables &quot;vars&quot; and</span>
<span class="sd">        &quot;sorted_vars&quot;: sorted_vars[0] must be equal to the minimum of all</span>
<span class="sd">        variables in vars, and so on: the value of sorted_vars[i] must be</span>
<span class="sd">        equal to the i-th value of variables invars.</span>

<span class="sd">        This constraint propagates in both directions: from &quot;vars&quot; to</span>
<span class="sd">        &quot;sorted_vars&quot; and vice-versa.</span>

<span class="sd">        Behind the scenes, this constraint maintains that:</span>
<span class="sd">          - sorted is always increasing.</span>
<span class="sd">          - whatever the values of vars, there exists a permutation that</span>
<span class="sd">            injects its values into the sorted variables.</span>

<span class="sd">        For more info, please have a look at:</span>
<span class="sd">          https://mpi-inf.mpg.de/~mehlhorn/ftp/Mehlhorn-Thiel.pdf</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SortingConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">LexicalLess</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a constraint that enforces that left is lexicographically less</span>
<span class="sd">        than right.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_LexicalLess</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">LexicalLessOrEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a constraint that enforces that left is lexicographically less</span>
<span class="sd">        than or equal to right.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_LexicalLessOrEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">InversePermutationConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a constraint that enforces that &#39;left&#39; and &#39;right&#39; both</span>
<span class="sd">        represent permutations of [0..left.size()-1], and that &#39;right&#39; is</span>
<span class="sd">        the inverse permutation of &#39;left&#39;, i.e. for all i in</span>
<span class="sd">        [0..left.size()-1], right[left[i]] = i.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_InversePermutationConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NullIntersect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">second_vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a constraint that states that all variables in the first</span>
<span class="sd">        vector are different from all variables in the second</span>
<span class="sd">        group. Thus the set of values in the first vector does not</span>
<span class="sd">        intersect with the set of values in the second vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_NullIntersect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_vars</span><span class="p">,</span> <span class="n">second_vars</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NullIntersectExcept</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">second_vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">escape_value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a constraint that states that all variables in the first</span>
<span class="sd">        vector are different from all variables from the second group,</span>
<span class="sd">        unless they are assigned to the escape value. Thus the set of</span>
<span class="sd">        values in the first vector minus the escape value does not</span>
<span class="sd">        intersect with the set of values in the second vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_NullIntersectExcept</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_vars</span><span class="p">,</span> <span class="n">second_vars</span><span class="p">,</span> <span class="n">escape_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Circuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nexts</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Force the &quot;nexts&quot; variable to create a complete Hamiltonian path.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Circuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nexts</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SubCircuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nexts</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Force the &quot;nexts&quot; variable to create a complete Hamiltonian path</span>
<span class="sd">        for those that do not loop upon themselves.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SubCircuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nexts</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DelayedPathCumul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nexts</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">active</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">cumuls</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">transits</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delayed version of the same constraint: propagation on the nexts variables</span>
<span class="sd">        is delayed until all constraints have propagated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_DelayedPathCumul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nexts</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">cumuls</span><span class="p">,</span> <span class="n">transits</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">PathCumul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Creates a constraint which accumulates values along a path such that:</span>
<span class="sd">        cumuls[next[i]] = cumuls[i] + transits[i].</span>
<span class="sd">        Active variables indicate if the corresponding next variable is active;</span>
<span class="sd">        this could be useful to model unperformed nodes in a routing problem.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Creates a constraint which accumulates values along a path such that:</span>
<span class="sd">        cumuls[next[i]] = cumuls[i] + transit_evaluator(i, next[i]).</span>
<span class="sd">        Active variables indicate if the corresponding next variable is active;</span>
<span class="sd">        this could be useful to model unperformed nodes in a routing problem.</span>
<span class="sd">        Ownership of transit_evaluator is taken and it must be a repeatable</span>
<span class="sd">        callback.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 3:*</span>
<span class="sd">        Creates a constraint which accumulates values along a path such that:</span>
<span class="sd">        cumuls[next[i]] = cumuls[i] + transit_evaluator(i, next[i]) + slacks[i].</span>
<span class="sd">        Active variables indicate if the corresponding next variable is active;</span>
<span class="sd">        this could be useful to model unperformed nodes in a routing problem.</span>
<span class="sd">        Ownership of transit_evaluator is taken and it must be a repeatable</span>
<span class="sd">        callback.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_PathCumul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AllowedAssignments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        This method creates a constraint where the graph of the relation</span>
<span class="sd">        between the variables is given in extension. There are &#39;arity&#39;</span>
<span class="sd">        variables involved in the relation and the graph is given by a</span>
<span class="sd">        integer tuple set.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Compatibility layer for Python API.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_AllowedAssignments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">TransitionConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_TransitionConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NonOverlappingBoxesConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_NonOverlappingBoxesConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Pack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">number_of_bins</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Pack *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This constraint packs all variables onto &#39;number_of_bins&#39;</span>
<span class="sd">        variables.  For any given variable, a value of &#39;number_of_bins&#39;</span>
<span class="sd">        indicates that the variable is not assigned to any bin.</span>
<span class="sd">        Dimensions, i.e., cumulative constraints on this packing, can be</span>
<span class="sd">        added directly from the pack class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Pack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">number_of_bins</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">FixedDurationIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntervalVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Creates an interval var with a fixed duration. The duration must</span>
<span class="sd">        be greater than 0. If optional is true, then the interval can be</span>
<span class="sd">        performed or unperformed. If optional is false, then the interval</span>
<span class="sd">        is always performed.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Creates a performed interval var with a fixed duration. The duration must</span>
<span class="sd">        be greater than 0.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 3:*</span>
<span class="sd">        Creates an interval var with a fixed duration, and performed_variable.</span>
<span class="sd">        The duration must be greater than 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_FixedDurationIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">FixedInterval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">duration</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntervalVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Creates a fixed and performed interval.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_FixedInterval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_min</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">start_max</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">duration_min</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">duration_max</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">end_min</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">end_max</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">optional</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntervalVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates an interval var by specifying the bounds on start,</span>
<span class="sd">        duration, and end.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_min</span><span class="p">,</span> <span class="n">start_max</span><span class="p">,</span> <span class="n">duration_min</span><span class="p">,</span> <span class="n">duration_max</span><span class="p">,</span> <span class="n">end_min</span><span class="p">,</span> <span class="n">end_max</span><span class="p">,</span> <span class="n">optional</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">MirrorInterval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntervalVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates an interval var that is the mirror image of the given one, that</span>
<span class="sd">        is, the interval var obtained by reversing the axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_MirrorInterval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">FixedDurationStartSyncedOnStartIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">duration</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntervalVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates an interval var with a fixed duration whose start is</span>
<span class="sd">        synchronized with the start of another interval, with a given</span>
<span class="sd">        offset. The performed status is also in sync with the performed</span>
<span class="sd">        status of the given interval variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_FixedDurationStartSyncedOnStartIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">FixedDurationStartSyncedOnEndIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">duration</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntervalVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates an interval var with a fixed duration whose start is</span>
<span class="sd">        synchronized with the end of another interval, with a given</span>
<span class="sd">        offset. The performed status is also in sync with the performed</span>
<span class="sd">        status of the given interval variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_FixedDurationStartSyncedOnEndIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">FixedDurationEndSyncedOnStartIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">duration</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntervalVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates an interval var with a fixed duration whose end is</span>
<span class="sd">        synchronized with the start of another interval, with a given</span>
<span class="sd">        offset. The performed status is also in sync with the performed</span>
<span class="sd">        status of the given interval variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_FixedDurationEndSyncedOnStartIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">FixedDurationEndSyncedOnEndIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">duration</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntervalVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates an interval var with a fixed duration whose end is</span>
<span class="sd">        synchronized with the end of another interval, with a given</span>
<span class="sd">        offset. The performed status is also in sync with the performed</span>
<span class="sd">        status of the given interval variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_FixedDurationEndSyncedOnEndIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IntervalRelaxedMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntervalVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         Creates and returns an interval variable that wraps around the given one,</span>
<span class="sd">         relaxing the min start and end. Relaxing means making unbounded when</span>
<span class="sd">         optional. If the variable is non-optional, this method returns</span>
<span class="sd">         interval_var.</span>

<span class="sd">         More precisely, such an interval variable behaves as follows:</span>
<span class="sd">        When the underlying must be performed, the returned interval variable</span>
<span class="sd">             behaves exactly as the underlying;</span>
<span class="sd">        When the underlying may or may not be performed, the returned interval</span>
<span class="sd">             variable behaves like the underlying, except that it is unbounded on</span>
<span class="sd">             the min side;</span>
<span class="sd">        When the underlying cannot be performed, the returned interval variable</span>
<span class="sd">             is of duration 0 and must be performed in an interval unbounded on</span>
<span class="sd">             both sides.</span>

<span class="sd">         This is very useful to implement propagators that may only modify</span>
<span class="sd">         the start max or end max.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IntervalRelaxedMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IntervalRelaxedMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntervalVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         Creates and returns an interval variable that wraps around the given one,</span>
<span class="sd">         relaxing the max start and end. Relaxing means making unbounded when</span>
<span class="sd">         optional. If the variable is non optional, this method returns</span>
<span class="sd">         interval_var.</span>

<span class="sd">         More precisely, such an interval variable behaves as follows:</span>
<span class="sd">        When the underlying must be performed, the returned interval variable</span>
<span class="sd">             behaves exactly as the underlying;</span>
<span class="sd">        When the underlying may or may not be performed, the returned interval</span>
<span class="sd">             variable behaves like the underlying, except that it is unbounded on</span>
<span class="sd">             the max side;</span>
<span class="sd">        When the underlying cannot be performed, the returned interval variable</span>
<span class="sd">             is of duration 0 and must be performed in an interval unbounded on</span>
<span class="sd">             both sides.</span>

<span class="sd">         This is very useful for implementing propagators that may only modify</span>
<span class="sd">         the start min or end min.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IntervalRelaxedMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">TemporalDisjunction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        This constraint implements a temporal disjunction between two</span>
<span class="sd">        interval vars t1 and t2. &#39;alt&#39; indicates which alternative was</span>
<span class="sd">        chosen (alt == 0 is equivalent to t1 before t2).</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        This constraint implements a temporal disjunction between two</span>
<span class="sd">        interval vars.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_TemporalDisjunction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DisjunctiveConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intervals</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntervalVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DisjunctiveConstraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This constraint forces all interval vars into an non-overlapping</span>
<span class="sd">        sequence. Intervals with zero duration can be scheduled anywhere.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_DisjunctiveConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intervals</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Cumulative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        This constraint forces that, for any integer t, the sum of the demands</span>
<span class="sd">        corresponding to an interval containing t does not exceed the given</span>
<span class="sd">        capacity.</span>

<span class="sd">        Intervals and demands should be vectors of equal size.</span>

<span class="sd">        Demands should only contain non-negative values. Zero values are</span>
<span class="sd">        supported, and the corresponding intervals are filtered out, as they</span>
<span class="sd">        neither impact nor are impacted by this constraint.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        This constraint forces that, for any integer t, the sum of the demands</span>
<span class="sd">        corresponding to an interval containing t does not exceed the given</span>
<span class="sd">        capacity.</span>

<span class="sd">        Intervals and demands should be vectors of equal size.</span>

<span class="sd">        Demands should only contain non-negative values. Zero values are</span>
<span class="sd">        supported, and the corresponding intervals are filtered out, as they</span>
<span class="sd">        neither impact nor are impacted by this constraint.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 3:*</span>
<span class="sd">        This constraint forces that, for any integer t, the sum of the demands</span>
<span class="sd">        corresponding to an interval containing t does not exceed the given</span>
<span class="sd">        capacity.</span>

<span class="sd">        Intervals and demands should be vectors of equal size.</span>

<span class="sd">        Demands should only contain non-negative values. Zero values are</span>
<span class="sd">        supported, and the corresponding intervals are filtered out, as they</span>
<span class="sd">        neither impact nor are impacted by this constraint.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 4:*</span>
<span class="sd">        This constraint enforces that, for any integer t, the sum of the demands</span>
<span class="sd">        corresponding to an interval containing t does not exceed the given</span>
<span class="sd">        capacity.</span>

<span class="sd">        Intervals and demands should be vectors of equal size.</span>

<span class="sd">        Demands should only contain non-negative values. Zero values are</span>
<span class="sd">        supported, and the corresponding intervals are filtered out, as they</span>
<span class="sd">        neither impact nor are impacted by this constraint.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 5:*</span>
<span class="sd">        This constraint enforces that, for any integer t, the sum of demands</span>
<span class="sd">        corresponding to an interval containing t does not exceed the given</span>
<span class="sd">        capacity.</span>

<span class="sd">        Intervals and demands should be vectors of equal size.</span>

<span class="sd">        Demands should be positive.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 6:*</span>
<span class="sd">        This constraint enforces that, for any integer t, the sum of demands</span>
<span class="sd">        corresponding to an interval containing t does not exceed the given</span>
<span class="sd">        capacity.</span>

<span class="sd">        Intervals and demands should be vectors of equal size.</span>

<span class="sd">        Demands should be positive.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Cumulative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Cover</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntervalVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">target_var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This constraint states that the target_var is the convex hull of</span>
<span class="sd">        the intervals. If none of the interval variables is performed,</span>
<span class="sd">        then the target var is unperformed too. Also, if the target</span>
<span class="sd">        variable is unperformed, then all the intervals variables are</span>
<span class="sd">        unperformed too.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Cover</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">target_var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Assignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        This method creates an empty assignment.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        This method creates an assignment which is a copy of &#39;a&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Assignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">FirstSolutionCollector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SolutionCollector *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Collect the first solution of the search.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Collect the first solution of the search. The variables will need to</span>
<span class="sd">        be added later.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_FirstSolutionCollector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">LastSolutionCollector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SolutionCollector *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Collect the last solution of the search.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Collect the last solution of the search. The variables will need to</span>
<span class="sd">        be added later.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_LastSolutionCollector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">BestValueSolutionCollector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SolutionCollector *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Collect the solution corresponding to the optimal value of the objective</span>
<span class="sd">        of &#39;assignment&#39;; if &#39;assignment&#39; does not have an objective no solution is</span>
<span class="sd">        collected. This collector only collects one solution corresponding to the</span>
<span class="sd">        best objective value (the first one found).</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Collect the solution corresponding to the optimal value of the</span>
<span class="sd">        objective of &#39;assignment&#39;; if &#39;assignment&#39; does not have an objective no</span>
<span class="sd">        solution is collected. This collector only collects one solution</span>
<span class="sd">        corresponding to the best objective value (the first one</span>
<span class="sd">        found). The variables will need to be added later.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_BestValueSolutionCollector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AllSolutionCollector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SolutionCollector *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Collect all solutions of the search.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Collect all solutions of the search. The variables will need to</span>
<span class="sd">        be added later.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_AllSolutionCollector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Minimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">step</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::OptimizeVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Creates a minimization objective.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Minimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Maximize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">step</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::OptimizeVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Creates a maximization objective.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Maximize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maximize</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">step</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::OptimizeVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Creates a objective with a given sense (true = maximization).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maximize</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WeightedMinimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::OptimizeVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Creates a minimization weighted objective. The actual objective is</span>
<span class="sd">        scalar_prod(sub_objectives, weights).</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Creates a minimization weighted objective. The actual objective is</span>
<span class="sd">        scalar_prod(sub_objectives, weights).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_WeightedMinimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WeightedMaximize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::OptimizeVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Creates a maximization weigthed objective.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Creates a maximization weigthed objective.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_WeightedMaximize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WeightedOptimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::OptimizeVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Creates a weighted objective with a given sense (true = maximization).</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Creates a weighted objective with a given sense (true = maximization).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_WeightedOptimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">TabuSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maximize</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">step</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">keep_tenure</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">forbid_tenure</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">tabu_factor</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SearchMonitor *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        MetaHeuristics which try to get the search out of local optima.</span>
<span class="sd">        Creates a Tabu Search monitor.</span>
<span class="sd">        In the context of local search the behavior is similar to MakeOptimize(),</span>
<span class="sd">        creating an objective in a given sense. The behavior differs once a local</span>
<span class="sd">        optimum is reached: thereafter solutions which degrade the value of the</span>
<span class="sd">        objective are allowed if they are not &quot;tabu&quot;. A solution is &quot;tabu&quot; if it</span>
<span class="sd">        doesn&#39;t respect the following rules:</span>
<span class="sd">        - improving the best solution found so far</span>
<span class="sd">        - variables in the &quot;keep&quot; list must keep their value, variables in the</span>
<span class="sd">        &quot;forbid&quot; list must not take the value they have in the list.</span>
<span class="sd">        Variables with new values enter the tabu lists after each new solution</span>
<span class="sd">        found and leave the lists after a given number of iterations (called</span>
<span class="sd">        tenure). Only the variables passed to the method can enter the lists.</span>
<span class="sd">        The tabu criterion is softened by the tabu factor which gives the number</span>
<span class="sd">        of &quot;tabu&quot; violations which is tolerated; a factor of 1 means no violations</span>
<span class="sd">        allowed; a factor of 0 means all violations are allowed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_TabuSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maximize</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">keep_tenure</span><span class="p">,</span> <span class="n">forbid_tenure</span><span class="p">,</span> <span class="n">tabu_factor</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SimulatedAnnealing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maximize</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">step</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">initial_temperature</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SearchMonitor *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Creates a Simulated Annealing monitor.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SimulatedAnnealing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maximize</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">initial_temperature</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">LubyRestart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale_factor</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SearchMonitor *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This search monitor will restart the search periodically.</span>
<span class="sd">        At the iteration n, it will restart after scale_factor * Luby(n) failures</span>
<span class="sd">        where Luby is the Luby Strategy (i.e. 1 1 2 1 1 2 4 1 1 2 1 1 2 4 8...).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_LubyRestart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale_factor</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ConstantRestart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frequency</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SearchMonitor *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This search monitor will restart the search periodically after &#39;frequency&#39;</span>
<span class="sd">        failures.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ConstantRestart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frequency</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">TimeLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RegularLimit *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_TimeLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">BranchesLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">branches</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RegularLimit *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a search limit that constrains the number of branches</span>
<span class="sd">        explored in the search tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_BranchesLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">branches</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">FailuresLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">failures</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RegularLimit *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a search limit that constrains the number of failures</span>
<span class="sd">        that can happen when exploring the search tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_FailuresLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">failures</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SolutionsLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solutions</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RegularLimit *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a search limit that constrains the number of solutions found</span>
<span class="sd">        during the search.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SolutionsLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solutions</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SearchLimit *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Limits the search with the &#39;time&#39;, &#39;branches&#39;, &#39;failures&#39; and</span>
<span class="sd">        &#39;solutions&#39; limits. &#39;smart_time_check&#39; reduces the calls to the wall</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Creates a search limit from its protobuf description</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 3:*</span>
<span class="sd">        Creates a search limit that is reached when either of the underlying limit</span>
<span class="sd">        is reached. That is, the returned limit is more stringent than both</span>
<span class="sd">        argument limits.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">CustomLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limiter</span><span class="p">:</span> <span class="s2">&quot;std::function&lt; bool () &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SearchLimit *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Callback-based search limit. Search stops when limiter returns true; if</span>
<span class="sd">        this happens at a leaf the corresponding solution will be rejected.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_CustomLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limiter</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SearchLog</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SearchMonitor *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SearchLog</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SearchTrace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SearchMonitor *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a search monitor that will trace precisely the behavior of the</span>
<span class="sd">        search. Use this only for low level debugging.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SearchTrace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">PrintModelVisitor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::ModelVisitor *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Prints the model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_PrintModelVisitor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StatisticsModelVisitor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::ModelVisitor *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Displays some nice statistics on the model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_StatisticsModelVisitor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AssignVariableValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Decision *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Decisions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_AssignVariableValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">VariableLessOrEqualValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Decision *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_VariableLessOrEqualValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">VariableGreaterOrEqualValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Decision *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_VariableGreaterOrEqualValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SplitVariableDomain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">start_with_lower_half</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Decision *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SplitVariableDomain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">start_with_lower_half</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AssignVariableValueOrFail</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Decision *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_AssignVariableValueOrFail</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AssignVariablesValues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Decision *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_AssignVariablesValues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">FailDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Decision *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_FailDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Decision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">apply</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::Action&quot;</span><span class="p">,</span> <span class="n">refute</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::Action&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Decision *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Decision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">apply</span><span class="p">,</span> <span class="n">refute</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Compose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dbs</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::DecisionBuilder * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Compose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dbs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Try</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dbs</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::DecisionBuilder * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Try</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dbs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DefaultPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_DefaultPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ScheduleOrPostpone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">est</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="p">:</span> <span class="s2">&quot;int64_t *const&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Decision *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a decision that tries to schedule a task at a given time.</span>
<span class="sd">        On the Apply branch, it will set that interval var as performed and set</span>
<span class="sd">        its start to &#39;est&#39;. On the Refute branch, it will just update the</span>
<span class="sd">        &#39;marker&#39; to &#39;est&#39; + 1. This decision is used in the</span>
<span class="sd">        INTERVAL_SET_TIMES_FORWARD strategy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ScheduleOrPostpone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">est</span><span class="p">,</span> <span class="n">marker</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ScheduleOrExpedite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">est</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="p">:</span> <span class="s2">&quot;int64_t *const&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Decision *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a decision that tries to schedule a task at a given time.</span>
<span class="sd">        On the Apply branch, it will set that interval var as performed and set</span>
<span class="sd">        its end to &#39;est&#39;. On the Refute branch, it will just update the</span>
<span class="sd">        &#39;marker&#39; to &#39;est&#39; - 1. This decision is used in the</span>
<span class="sd">        INTERVAL_SET_TIMES_BACKWARD strategy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ScheduleOrExpedite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">est</span><span class="p">,</span> <span class="n">marker</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RankFirstInterval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequence</span><span class="p">:</span> <span class="s2">&quot;SequenceVar&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Decision *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a decision that tries to rank first the ith interval var</span>
<span class="sd">        in the sequence variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_RankFirstInterval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequence</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RankLastInterval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequence</span><span class="p">:</span> <span class="s2">&quot;SequenceVar&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Decision *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a decision that tries to rank last the ith interval var</span>
<span class="sd">        in the sequence variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_RankLastInterval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequence</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Phase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Phase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DecisionBuilderFromAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">db</span><span class="p">:</span> <span class="s2">&quot;DecisionBuilder&quot;</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a decision builder for which the left-most leaf corresponds</span>
<span class="sd">        to assignment, the rest of the tree being explored using &#39;db&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_DecisionBuilderFromAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">,</span> <span class="n">db</span><span class="p">,</span> <span class="nb">vars</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ConstraintAdder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ct</span><span class="p">:</span> <span class="s2">&quot;Constraint&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a decision builder that will add the given constraint to</span>
<span class="sd">        the model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ConstraintAdder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ct</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SolveOnce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">db</span><span class="p">:</span> <span class="s2">&quot;DecisionBuilder&quot;</span><span class="p">,</span> <span class="n">monitors</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::SearchMonitor * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SolveOnce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">db</span><span class="p">,</span> <span class="n">monitors</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NestedOptimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_NestedOptimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RestoreAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a DecisionBuilder which restores an Assignment</span>
<span class="sd">        (calls void Assignment::Restore())</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_RestoreAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StoreAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a DecisionBuilder which stores an Assignment</span>
<span class="sd">        (calls void Assignment::Store())</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_StoreAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::LocalSearchOperator *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RandomLnsOperator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::LocalSearchOperator *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_RandomLnsOperator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">MoveTowardTargetOperator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::LocalSearchOperator *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Creates a local search operator that tries to move the assignment of some</span>
<span class="sd">        variables toward a target. The target is given as an Assignment. This</span>
<span class="sd">        operator generates neighbors in which the only difference compared to the</span>
<span class="sd">        current state is that one variable that belongs to the target assignment</span>
<span class="sd">        is set to its target value.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Creates a local search operator that tries to move the assignment of some</span>
<span class="sd">        variables toward a target. The target is given either as two vectors: a</span>
<span class="sd">        vector of variables and a vector of associated target values. The two</span>
<span class="sd">        vectors should be of the same length. This operator generates neighbors in</span>
<span class="sd">        which the only difference compared to the current state is that one</span>
<span class="sd">        variable that belongs to the given vector is set to its target value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_MoveTowardTargetOperator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ConcatenateOperators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::LocalSearchOperator *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ConcatenateOperators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RandomConcatenateOperators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::LocalSearchOperator *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Randomized version of local search concatenator; calls a random operator</span>
<span class="sd">        at each call to MakeNextNeighbor().</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Randomized version of local search concatenator; calls a random operator</span>
<span class="sd">        at each call to MakeNextNeighbor(). The provided seed is used to</span>
<span class="sd">        initialize the random number generator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_RandomConcatenateOperators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NeighborhoodLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">:</span> <span class="s2">&quot;LocalSearchOperator&quot;</span><span class="p">,</span> <span class="n">limit</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::LocalSearchOperator *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a local search operator that wraps another local search</span>
<span class="sd">        operator and limits the number of neighbors explored (i.e., calls</span>
<span class="sd">        to MakeNextNeighbor from the current solution (between two calls</span>
<span class="sd">        to Start()). When this limit is reached, MakeNextNeighbor()</span>
<span class="sd">        returns false. The counter is cleared when Start() is called.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_NeighborhoodLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">LocalSearchPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_LocalSearchPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">LocalSearchPhaseParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::LocalSearchPhaseParameters *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_LocalSearchPhaseParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SearchDepth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the search depth of the current active search. Returns -1 if</span>
<span class="sd">        there is no active search opened.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SearchDepth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SearchLeftDepth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the search left depth of the current active search. Returns -1 if</span>
<span class="sd">        there is no active search opened.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SearchLeftDepth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SolveDepth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the number of nested searches. It returns 0 outside search,</span>
<span class="sd">        1 during the top level search, 2 or more in case of nested searches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SolveDepth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Rand64</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns a random value between 0 and &#39;size&#39; - 1;&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Rand64</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Rand32</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="s2">&quot;int32_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int32_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns a random value between 0 and &#39;size&#39; - 1;&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Rand32</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ReSeed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">:</span> <span class="s2">&quot;int32_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Reseed the solver random generator.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ReSeed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">LocalSearchProfile</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns local search profiling information in a human readable format.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_LocalSearchProfile</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Counts the number of constraints that have been added</span>
<span class="sd">        to the solver before the search.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Accept</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">visitor</span><span class="p">:</span> <span class="s2">&quot;operations_research::ModelVisitor *const&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Accepts the given model visitor.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Accept</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">visitor</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">FinishCurrentSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Tells the solver to kill or restart the current search.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_FinishCurrentSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RestartCurrentSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_RestartCurrentSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ShouldFail</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        These methods are only useful for the SWIG wrappers, which need a way</span>
<span class="sd">        to externally cause the Solver to fail.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ShouldFail</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver___str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ct</span><span class="p">):</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">PyConstraint</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__python_constraints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">AddConstraint</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">TreeNoCycle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nexts</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">active</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IndexFilter1&quot;</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_TreeNoCycle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nexts</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SearchLogWithCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">period</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="s2">&quot;std::function&lt; std::string () &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SearchMonitor *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SearchLogWithCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ElementFunction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="s2">&quot;std::function&lt; int64_t (int64_t) &gt;&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ElementFunction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">VarEvalValStrPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">var_evaluator</span><span class="p">:</span> <span class="s2">&quot;std::function&lt; int64_t (int64_t) &gt;&quot;</span><span class="p">,</span> <span class="n">val_str</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IntValueStrategy&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_VarEvalValStrPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">var_evaluator</span><span class="p">,</span> <span class="n">val_str</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">VarStrValEvalPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">var_str</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IntVarStrategy&quot;</span><span class="p">,</span> <span class="n">val_eval</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IndexEvaluator2&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_VarStrValEvalPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">var_str</span><span class="p">,</span> <span class="n">val_eval</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">VarEvalValEvalPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">var_eval</span><span class="p">:</span> <span class="s2">&quot;std::function&lt; int64_t (int64_t) &gt;&quot;</span><span class="p">,</span> <span class="n">val_eval</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IndexEvaluator2&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_VarEvalValEvalPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">var_eval</span><span class="p">,</span> <span class="n">val_eval</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">VarStrValEvalTieBreakPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">var_str</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IntVarStrategy&quot;</span><span class="p">,</span> <span class="n">val_eval</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IndexEvaluator2&quot;</span><span class="p">,</span> <span class="n">tie_breaker</span><span class="p">:</span> <span class="s2">&quot;std::function&lt; int64_t (int64_t) &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_VarStrValEvalTieBreakPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">var_str</span><span class="p">,</span> <span class="n">val_eval</span><span class="p">,</span> <span class="n">tie_breaker</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">VarEvalValEvalTieBreakPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">var_eval</span><span class="p">:</span> <span class="s2">&quot;std::function&lt; int64_t (int64_t) &gt;&quot;</span><span class="p">,</span> <span class="n">val_eval</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IndexEvaluator2&quot;</span><span class="p">,</span> <span class="n">tie_breaker</span><span class="p">:</span> <span class="s2">&quot;std::function&lt; int64_t (int64_t) &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_VarEvalValEvalTieBreakPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">var_eval</span><span class="p">,</span> <span class="n">val_eval</span><span class="p">,</span> <span class="n">tie_breaker</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EvalEvalStrPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">evaluator</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IndexEvaluator2&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::EvaluatorStrategy&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_EvalEvalStrPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">evaluator</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EvalEvalStrTieBreakPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">evaluator</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IndexEvaluator2&quot;</span><span class="p">,</span> <span class="n">tie_breaker</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IndexEvaluator1&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::EvaluatorStrategy&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_EvalEvalStrTieBreakPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">evaluator</span><span class="p">,</span> <span class="n">tie_breaker</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GuidedLocalSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SearchMonitor *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_GuidedLocalSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SumObjectiveFilter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IndexEvaluator2&quot;</span><span class="p">,</span> <span class="n">filter_enum</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::LocalSearchFilterBound&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::LocalSearchFilter *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SumObjectiveFilter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">filter_enum</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Solver Class</p>

<p>A solver represents the main computation engine. It implements the entire
range of Constraint Programming protocols:</p>

<ul>
<li>Reversibility</li>
<li>Propagation</li>
<li>Search</li>
</ul>

<p>Usually, Constraint Programming code consists of</p>

<ul>
<li>the creation of the Solver,</li>
<li>the creation of the decision variables of the model,</li>
<li>the creation of the constraints of the model and their addition to the
solver() through the AddConstraint() method,</li>
<li>the creation of the main DecisionBuilder class,</li>
<li>the launch of the solve() method with the decision builder.</li>
</ul>

<p>For the time being, Solver is neither MT_SAFE nor MT_HOT.</p>
</div>


                            <div id="Solver.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">Solver</span><span class="signature">(*args)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_Solver</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">__python_constraints</span> <span class="o">=</span> <span class="p">[]</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="Solver.INT_VAR_DEFAULT" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.INT_VAR_DEFAULT">#&nbsp;&nbsp</a>

        <span class="name">INT_VAR_DEFAULT</span><span class="default_value"> = 0</span>
    </div>

            <div class="docstring"><p>The default behavior is CHOOSE_FIRST_UNBOUND.</p>
</div>


                            </div>
                            <div id="Solver.INT_VAR_SIMPLE" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.INT_VAR_SIMPLE">#&nbsp;&nbsp</a>

        <span class="name">INT_VAR_SIMPLE</span><span class="default_value"> = 1</span>
    </div>

            <div class="docstring"><p>The simple selection is CHOOSE_FIRST_UNBOUND.</p>
</div>


                            </div>
                            <div id="Solver.CHOOSE_FIRST_UNBOUND" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.CHOOSE_FIRST_UNBOUND">#&nbsp;&nbsp</a>

        <span class="name">CHOOSE_FIRST_UNBOUND</span><span class="default_value"> = 2</span>
    </div>

            <div class="docstring"><p>Select the first unbound variable.
Variables are considered in the order of the vector of IntVars used
to create the selector.</p>
</div>


                            </div>
                            <div id="Solver.CHOOSE_RANDOM" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.CHOOSE_RANDOM">#&nbsp;&nbsp</a>

        <span class="name">CHOOSE_RANDOM</span><span class="default_value"> = 3</span>
    </div>

            <div class="docstring"><p>Randomly select one of the remaining unbound variables.</p>
</div>


                            </div>
                            <div id="Solver.CHOOSE_MIN_SIZE_LOWEST_MIN" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.CHOOSE_MIN_SIZE_LOWEST_MIN">#&nbsp;&nbsp</a>

        <span class="name">CHOOSE_MIN_SIZE_LOWEST_MIN</span><span class="default_value"> = 4</span>
    </div>

            <div class="docstring"><p>Among unbound variables, select the variable with the smallest size,
i.e., the smallest number of possible values.
In case of a tie, the selected variables is the one with the lowest min
value.
In case of a tie, the first one is selected, first being defined by the
order in the vector of IntVars used to create the selector.</p>
</div>


                            </div>
                            <div id="Solver.CHOOSE_MIN_SIZE_HIGHEST_MIN" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.CHOOSE_MIN_SIZE_HIGHEST_MIN">#&nbsp;&nbsp</a>

        <span class="name">CHOOSE_MIN_SIZE_HIGHEST_MIN</span><span class="default_value"> = 5</span>
    </div>

            <div class="docstring"><p>Among unbound variables, select the variable with the smallest size,
i.e., the smallest number of possible values.
In case of a tie, the selected variable is the one with the highest min
value.
In case of a tie, the first one is selected, first being defined by the
order in the vector of IntVars used to create the selector.</p>
</div>


                            </div>
                            <div id="Solver.CHOOSE_MIN_SIZE_LOWEST_MAX" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.CHOOSE_MIN_SIZE_LOWEST_MAX">#&nbsp;&nbsp</a>

        <span class="name">CHOOSE_MIN_SIZE_LOWEST_MAX</span><span class="default_value"> = 6</span>
    </div>

            <div class="docstring"><p>Among unbound variables, select the variable with the smallest size,
i.e., the smallest number of possible values.
In case of a tie, the selected variables is the one with the lowest max
value.
In case of a tie, the first one is selected, first being defined by the
order in the vector of IntVars used to create the selector.</p>
</div>


                            </div>
                            <div id="Solver.CHOOSE_MIN_SIZE_HIGHEST_MAX" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.CHOOSE_MIN_SIZE_HIGHEST_MAX">#&nbsp;&nbsp</a>

        <span class="name">CHOOSE_MIN_SIZE_HIGHEST_MAX</span><span class="default_value"> = 7</span>
    </div>

            <div class="docstring"><p>Among unbound variables, select the variable with the smallest size,
i.e., the smallest number of possible values.
In case of a tie, the selected variable is the one with the highest max
value.
In case of a tie, the first one is selected, first being defined by the
order in the vector of IntVars used to create the selector.</p>
</div>


                            </div>
                            <div id="Solver.CHOOSE_LOWEST_MIN" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.CHOOSE_LOWEST_MIN">#&nbsp;&nbsp</a>

        <span class="name">CHOOSE_LOWEST_MIN</span><span class="default_value"> = 8</span>
    </div>

            <div class="docstring"><p>Among unbound variables, select the variable with the smallest minimal
value.
In case of a tie, the first one is selected, "first" defined by the
order in the vector of IntVars used to create the selector.</p>
</div>


                            </div>
                            <div id="Solver.CHOOSE_HIGHEST_MAX" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.CHOOSE_HIGHEST_MAX">#&nbsp;&nbsp</a>

        <span class="name">CHOOSE_HIGHEST_MAX</span><span class="default_value"> = 9</span>
    </div>

            <div class="docstring"><p>Among unbound variables, select the variable with the highest maximal
value.
In case of a tie, the first one is selected, first being defined by the
order in the vector of IntVars used to create the selector.</p>
</div>


                            </div>
                            <div id="Solver.CHOOSE_MIN_SIZE" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.CHOOSE_MIN_SIZE">#&nbsp;&nbsp</a>

        <span class="name">CHOOSE_MIN_SIZE</span><span class="default_value"> = 10</span>
    </div>

            <div class="docstring"><p>Among unbound variables, select the variable with the smallest size.
In case of a tie, the first one is selected, first being defined by the
order in the vector of IntVars used to create the selector.</p>
</div>


                            </div>
                            <div id="Solver.CHOOSE_MAX_SIZE" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.CHOOSE_MAX_SIZE">#&nbsp;&nbsp</a>

        <span class="name">CHOOSE_MAX_SIZE</span><span class="default_value"> = 11</span>
    </div>

            <div class="docstring"><p>Among unbound variables, select the variable with the highest size.
In case of a tie, the first one is selected, first being defined by the
order in the vector of IntVars used to create the selector.</p>
</div>


                            </div>
                            <div id="Solver.CHOOSE_MAX_REGRET_ON_MIN" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.CHOOSE_MAX_REGRET_ON_MIN">#&nbsp;&nbsp</a>

        <span class="name">CHOOSE_MAX_REGRET_ON_MIN</span><span class="default_value"> = 12</span>
    </div>

            <div class="docstring"><p>Among unbound variables, select the variable with the largest
gap between the first and the second values of the domain.</p>
</div>


                            </div>
                            <div id="Solver.CHOOSE_PATH" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.CHOOSE_PATH">#&nbsp;&nbsp</a>

        <span class="name">CHOOSE_PATH</span><span class="default_value"> = 13</span>
    </div>

            <div class="docstring"><p>Selects the next unbound variable on a path, the path being defined by
the variables: var[i] corresponds to the index of the next of i.</p>
</div>


                            </div>
                            <div id="Solver.INT_VALUE_DEFAULT" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.INT_VALUE_DEFAULT">#&nbsp;&nbsp</a>

        <span class="name">INT_VALUE_DEFAULT</span><span class="default_value"> = 0</span>
    </div>

            <div class="docstring"><p>The default behavior is ASSIGN_MIN_VALUE.</p>
</div>


                            </div>
                            <div id="Solver.INT_VALUE_SIMPLE" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.INT_VALUE_SIMPLE">#&nbsp;&nbsp</a>

        <span class="name">INT_VALUE_SIMPLE</span><span class="default_value"> = 1</span>
    </div>

            <div class="docstring"><p>The simple selection is ASSIGN_MIN_VALUE.</p>
</div>


                            </div>
                            <div id="Solver.ASSIGN_MIN_VALUE" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.ASSIGN_MIN_VALUE">#&nbsp;&nbsp</a>

        <span class="name">ASSIGN_MIN_VALUE</span><span class="default_value"> = 2</span>
    </div>

            <div class="docstring"><p>Selects the min value of the selected variable.</p>
</div>


                            </div>
                            <div id="Solver.ASSIGN_MAX_VALUE" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.ASSIGN_MAX_VALUE">#&nbsp;&nbsp</a>

        <span class="name">ASSIGN_MAX_VALUE</span><span class="default_value"> = 3</span>
    </div>

            <div class="docstring"><p>Selects the max value of the selected variable.</p>
</div>


                            </div>
                            <div id="Solver.ASSIGN_RANDOM_VALUE" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.ASSIGN_RANDOM_VALUE">#&nbsp;&nbsp</a>

        <span class="name">ASSIGN_RANDOM_VALUE</span><span class="default_value"> = 4</span>
    </div>

            <div class="docstring"><p>Selects randomly one of the possible values of the selected variable.</p>
</div>


                            </div>
                            <div id="Solver.ASSIGN_CENTER_VALUE" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.ASSIGN_CENTER_VALUE">#&nbsp;&nbsp</a>

        <span class="name">ASSIGN_CENTER_VALUE</span><span class="default_value"> = 5</span>
    </div>

            <div class="docstring"><p>Selects the first possible value which is the closest to the center
of the domain of the selected variable.
The center is defined as (min + max) / 2.</p>
</div>


                            </div>
                            <div id="Solver.SPLIT_LOWER_HALF" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.SPLIT_LOWER_HALF">#&nbsp;&nbsp</a>

        <span class="name">SPLIT_LOWER_HALF</span><span class="default_value"> = 6</span>
    </div>

            <div class="docstring"><p>Split the domain in two around the center, and choose the lower
part first.</p>
</div>


                            </div>
                            <div id="Solver.SPLIT_UPPER_HALF" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.SPLIT_UPPER_HALF">#&nbsp;&nbsp</a>

        <span class="name">SPLIT_UPPER_HALF</span><span class="default_value"> = 7</span>
    </div>

            <div class="docstring"><p>Split the domain in two around the center, and choose the lower
part first.</p>
</div>


                            </div>
                            <div id="Solver.SEQUENCE_DEFAULT" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.SEQUENCE_DEFAULT">#&nbsp;&nbsp</a>

        <span class="name">SEQUENCE_DEFAULT</span><span class="default_value"> = 0</span>
    </div>

    

                            </div>
                            <div id="Solver.SEQUENCE_SIMPLE" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.SEQUENCE_SIMPLE">#&nbsp;&nbsp</a>

        <span class="name">SEQUENCE_SIMPLE</span><span class="default_value"> = 1</span>
    </div>

    

                            </div>
                            <div id="Solver.CHOOSE_MIN_SLACK_RANK_FORWARD" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.CHOOSE_MIN_SLACK_RANK_FORWARD">#&nbsp;&nbsp</a>

        <span class="name">CHOOSE_MIN_SLACK_RANK_FORWARD</span><span class="default_value"> = 2</span>
    </div>

    

                            </div>
                            <div id="Solver.CHOOSE_RANDOM_RANK_FORWARD" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.CHOOSE_RANDOM_RANK_FORWARD">#&nbsp;&nbsp</a>

        <span class="name">CHOOSE_RANDOM_RANK_FORWARD</span><span class="default_value"> = 3</span>
    </div>

    

                            </div>
                            <div id="Solver.INTERVAL_DEFAULT" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.INTERVAL_DEFAULT">#&nbsp;&nbsp</a>

        <span class="name">INTERVAL_DEFAULT</span><span class="default_value"> = 0</span>
    </div>

            <div class="docstring"><p>The default is INTERVAL_SET_TIMES_FORWARD.</p>
</div>


                            </div>
                            <div id="Solver.INTERVAL_SIMPLE" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.INTERVAL_SIMPLE">#&nbsp;&nbsp</a>

        <span class="name">INTERVAL_SIMPLE</span><span class="default_value"> = 1</span>
    </div>

            <div class="docstring"><p>The simple is INTERVAL_SET_TIMES_FORWARD.</p>
</div>


                            </div>
                            <div id="Solver.INTERVAL_SET_TIMES_FORWARD" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.INTERVAL_SET_TIMES_FORWARD">#&nbsp;&nbsp</a>

        <span class="name">INTERVAL_SET_TIMES_FORWARD</span><span class="default_value"> = 2</span>
    </div>

            <div class="docstring"><p>Selects the variable with the lowest starting time of all variables,
and fixes its starting time to this lowest value.</p>
</div>


                            </div>
                            <div id="Solver.INTERVAL_SET_TIMES_BACKWARD" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.INTERVAL_SET_TIMES_BACKWARD">#&nbsp;&nbsp</a>

        <span class="name">INTERVAL_SET_TIMES_BACKWARD</span><span class="default_value"> = 3</span>
    </div>

            <div class="docstring"><p>Selects the variable with the highest ending time of all variables,
and fixes the ending time to this highest values.</p>
</div>


                            </div>
                            <div id="Solver.TWOOPT" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.TWOOPT">#&nbsp;&nbsp</a>

        <span class="name">TWOOPT</span><span class="default_value"> = 0</span>
    </div>

            <div class="docstring"><p>Operator which reverses a sub-chain of a path. It is called TwoOpt
because it breaks two arcs on the path; resulting paths are called
two-optimal.
Possible neighbors for the path 1 -> 2 -> 3 -> 4 -> 5
(where (1, 5) are first and last nodes of the path and can therefore not
be moved):
  1 -> [3 -> 2] -> 4  -> 5
  1 -> [4 -> 3  -> 2] -> 5
  1 ->  2 -> [4 -> 3] -> 5</p>
</div>


                            </div>
                            <div id="Solver.OROPT" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.OROPT">#&nbsp;&nbsp</a>

        <span class="name">OROPT</span><span class="default_value"> = 1</span>
    </div>

            <div class="docstring"><p>Relocate: OROPT and RELOCATE.
Operator which moves a sub-chain of a path to another position; the
specified chain length is the fixed length of the chains being moved.
When this length is 1, the operator simply moves a node to another
position.
Possible neighbors for the path 1 -> 2 -> 3 -> 4 -> 5, for a chain
length of 2 (where (1, 5) are first and last nodes of the path and can
therefore not be moved):
  1 ->  4 -> [2 -> 3] -> 5
  1 -> [3 -> 4] -> 2  -> 5</p>

<p>Using Relocate with chain lengths of 1, 2 and 3 together is equivalent
to the OrOpt operator on a path. The OrOpt operator is a limited
 version of 3Opt (breaks 3 arcs on a path).</p>
</div>


                            </div>
                            <div id="Solver.RELOCATE" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.RELOCATE">#&nbsp;&nbsp</a>

        <span class="name">RELOCATE</span><span class="default_value"> = 2</span>
    </div>

            <div class="docstring"><p>Relocate neighborhood with length of 1 (see OROPT comment).</p>
</div>


                            </div>
                            <div id="Solver.EXCHANGE" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.EXCHANGE">#&nbsp;&nbsp</a>

        <span class="name">EXCHANGE</span><span class="default_value"> = 3</span>
    </div>

            <div class="docstring"><p>Operator which exchanges the positions of two nodes.
Possible neighbors for the path 1 -> 2 -> 3 -> 4 -> 5
(where (1, 5) are first and last nodes of the path and can therefore not
be moved):
  1 -> [3] -> [2] ->  4  -> 5
  1 -> [4] ->  3  -> [2] -> 5
  1 ->  2  -> [4] -> [3] -> 5</p>
</div>


                            </div>
                            <div id="Solver.CROSS" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.CROSS">#&nbsp;&nbsp</a>

        <span class="name">CROSS</span><span class="default_value"> = 4</span>
    </div>

            <div class="docstring"><p>Operator which cross exchanges the starting chains of 2 paths, including
exchanging the whole paths.
First and last nodes are not moved.
Possible neighbors for the paths 1 -> 2 -> 3 -> 4 -> 5 and 6 -> 7 -> 8
(where (1, 5) and (6, 8) are first and last nodes of the paths and can
therefore not be moved):
  1 -> [7] -> 3 -> 4 -> 5  6 -> [2] -> 8
  1 -> [7] -> 4 -> 5       6 -> [2 -> 3] -> 8
  1 -> [7] -> 5            6 -> [2 -> 3 -> 4] -> 8</p>
</div>


                            </div>
                            <div id="Solver.MAKEACTIVE" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.MAKEACTIVE">#&nbsp;&nbsp</a>

        <span class="name">MAKEACTIVE</span><span class="default_value"> = 5</span>
    </div>

            <div class="docstring"><p>Operator which inserts an inactive node into a path.
Possible neighbors for the path 1 -> 2 -> 3 -> 4 with 5 inactive
(where 1 and 4 are first and last nodes of the path) are:
  1 -> [5] ->  2  ->  3  -> 4
  1 ->  2  -> [5] ->  3  -> 4
  1 ->  2  ->  3  -> [5] -> 4</p>
</div>


                            </div>
                            <div id="Solver.MAKEINACTIVE" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.MAKEINACTIVE">#&nbsp;&nbsp</a>

        <span class="name">MAKEINACTIVE</span><span class="default_value"> = 6</span>
    </div>

            <div class="docstring"><p>Operator which makes path nodes inactive.
Possible neighbors for the path 1 -> 2 -> 3 -> 4 (where 1 and 4 are
first and last nodes of the path) are:
  1 -> 3 -> 4 with 2 inactive
  1 -> 2 -> 4 with 3 inactive</p>
</div>


                            </div>
                            <div id="Solver.MAKECHAININACTIVE" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.MAKECHAININACTIVE">#&nbsp;&nbsp</a>

        <span class="name">MAKECHAININACTIVE</span><span class="default_value"> = 7</span>
    </div>

            <div class="docstring"><p>Operator which makes a "chain" of path nodes inactive.
Possible neighbors for the path 1 -> 2 -> 3 -> 4 (where 1 and 4 are
first and last nodes of the path) are:
  1 -> 3 -> 4 with 2 inactive
  1 -> 2 -> 4 with 3 inactive
  1 -> 4 with 2 and 3 inactive</p>
</div>


                            </div>
                            <div id="Solver.SWAPACTIVE" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.SWAPACTIVE">#&nbsp;&nbsp</a>

        <span class="name">SWAPACTIVE</span><span class="default_value"> = 8</span>
    </div>

            <div class="docstring"><p>Operator which replaces an active node by an inactive one.
Possible neighbors for the path 1 -> 2 -> 3 -> 4 with 5 inactive
(where 1 and 4 are first and last nodes of the path) are:
  1 -> [5] ->  3  -> 4 with 2 inactive
  1 ->  2  -> [5] -> 4 with 3 inactive</p>
</div>


                            </div>
                            <div id="Solver.EXTENDEDSWAPACTIVE" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.EXTENDEDSWAPACTIVE">#&nbsp;&nbsp</a>

        <span class="name">EXTENDEDSWAPACTIVE</span><span class="default_value"> = 9</span>
    </div>

            <div class="docstring"><p>Operator which makes an inactive node active and an active one inactive.
It is similar to SwapActiveOperator except that it tries to insert the
inactive node in all possible positions instead of just the position of
the node made inactive.
Possible neighbors for the path 1 -> 2 -> 3 -> 4 with 5 inactive
(where 1 and 4 are first and last nodes of the path) are:
  1 -> [5] ->  3  -> 4 with 2 inactive
  1 ->  3  -> [5] -> 4 with 2 inactive
  1 -> [5] ->  2  -> 4 with 3 inactive
  1 ->  2  -> [5] -> 4 with 3 inactive</p>
</div>


                            </div>
                            <div id="Solver.PATHLNS" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.PATHLNS">#&nbsp;&nbsp</a>

        <span class="name">PATHLNS</span><span class="default_value"> = 10</span>
    </div>

            <div class="docstring"><p>Operator which relaxes two sub-chains of three consecutive arcs each.
Each sub-chain is defined by a start node and the next three arcs. Those
six arcs are relaxed to build a new neighbor.
PATHLNS explores all possible pairs of starting nodes and so defines
n^2 neighbors, n being the number of nodes.
Note that the two sub-chains can be part of the same path; they even may
overlap.</p>
</div>


                            </div>
                            <div id="Solver.FULLPATHLNS" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.FULLPATHLNS">#&nbsp;&nbsp</a>

        <span class="name">FULLPATHLNS</span><span class="default_value"> = 11</span>
    </div>

            <div class="docstring"><p>Operator which relaxes one entire path and all inactive nodes, thus
defining num_paths neighbors.</p>
</div>


                            </div>
                            <div id="Solver.UNACTIVELNS" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.UNACTIVELNS">#&nbsp;&nbsp</a>

        <span class="name">UNACTIVELNS</span><span class="default_value"> = 12</span>
    </div>

            <div class="docstring"><p>Operator which relaxes all inactive nodes and one sub-chain of six
consecutive arcs. That way the path can be improved by inserting
inactive nodes or swapping arcs.</p>
</div>


                            </div>
                            <div id="Solver.INCREMENT" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.INCREMENT">#&nbsp;&nbsp</a>

        <span class="name">INCREMENT</span><span class="default_value"> = 13</span>
    </div>

            <div class="docstring"><p>Operator which defines one neighbor per variable. Each neighbor tries to
increment by one the value of the corresponding variable. When a new
solution is found the neighborhood is rebuilt from scratch, i.e., tries
to increment values in the variable order.
Consider for instance variables x and y. x is incremented one by one to
its max, and when it is not possible to increment x anymore, y is
incremented once. If this is a solution, then next neighbor tries to
increment x.</p>
</div>


                            </div>
                            <div id="Solver.DECREMENT" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.DECREMENT">#&nbsp;&nbsp</a>

        <span class="name">DECREMENT</span><span class="default_value"> = 14</span>
    </div>

            <div class="docstring"><p>Operator which defines a neighborhood to decrement values.
The behavior is the same as INCREMENT, except values are decremented
instead of incremented.</p>
</div>


                            </div>
                            <div id="Solver.SIMPLELNS" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.SIMPLELNS">#&nbsp;&nbsp</a>

        <span class="name">SIMPLELNS</span><span class="default_value"> = 15</span>
    </div>

            <div class="docstring"><p>Operator which defines one neighbor per variable. Each neighbor relaxes
one variable.
When a new solution is found the neighborhood is rebuilt from scratch.
Consider for instance variables x and y. First x is relaxed and the
solver is looking for the best possible solution (with only x relaxed).
Then y is relaxed, and the solver is looking for a new solution.
If a new solution is found, then the next variable to be relaxed is x.</p>
</div>


                            </div>
                            <div id="Solver.GE" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.GE">#&nbsp;&nbsp</a>

        <span class="name">GE</span><span class="default_value"> = 0</span>
    </div>

            <div class="docstring"><p>Move is accepted when the current objective value &gt;= objective.Min.</p>
</div>


                            </div>
                            <div id="Solver.LE" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.LE">#&nbsp;&nbsp</a>

        <span class="name">LE</span><span class="default_value"> = 1</span>
    </div>

            <div class="docstring"><p>Move is accepted when the current objective value &lt;= objective.Max.</p>
</div>


                            </div>
                            <div id="Solver.EQ" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.EQ">#&nbsp;&nbsp</a>

        <span class="name">EQ</span><span class="default_value"> = 2</span>
    </div>

            <div class="docstring"><p>Move is accepted when the current objective value is in the interval
objective.Min .. objective.Max.</p>
</div>


                            </div>
                            <div id="Solver.DELAYED_PRIORITY" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.DELAYED_PRIORITY">#&nbsp;&nbsp</a>

        <span class="name">DELAYED_PRIORITY</span><span class="default_value"> = 0</span>
    </div>

            <div class="docstring"><p>DELAYED_PRIORITY is the lowest priority: Demons will be processed after
VAR_PRIORITY and NORMAL_PRIORITY demons.</p>
</div>


                            </div>
                            <div id="Solver.VAR_PRIORITY" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.VAR_PRIORITY">#&nbsp;&nbsp</a>

        <span class="name">VAR_PRIORITY</span><span class="default_value"> = 1</span>
    </div>

            <div class="docstring"><p>VAR_PRIORITY is between DELAYED_PRIORITY and NORMAL_PRIORITY.</p>
</div>


                            </div>
                            <div id="Solver.NORMAL_PRIORITY" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.NORMAL_PRIORITY">#&nbsp;&nbsp</a>

        <span class="name">NORMAL_PRIORITY</span><span class="default_value"> = 2</span>
    </div>

            <div class="docstring"><p>NORMAL_PRIORITY is the highest priority: Demons will be processed first.</p>
</div>


                            </div>
                            <div id="Solver.Parameters" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Parameters">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Parameters</span><span class="signature">(self) -&gt; &#39;operations_research::ConstraintSolverParameters&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::ConstraintSolverParameters&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Stored Parameters.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Parameters</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Stored Parameters.</p>
</div>


                            </div>
                            <div id="Solver.DefaultSolverParameters" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.DefaultSolverParameters">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">DefaultSolverParameters</span><span class="signature">() -&gt; &#39;operations_research::ConstraintSolverParameters&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">DefaultSolverParameters</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::ConstraintSolverParameters&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Create a ConstraintSolverParameters proto with all the default values.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_DefaultSolverParameters</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>Create a ConstraintSolverParameters proto with all the default values.</p>
</div>


                            </div>
                            <div id="Solver.AddConstraint" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.AddConstraint">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddConstraint</span><span class="signature">(self, c: <a href="#Constraint">pywrapcp.Constraint</a>) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="s2">&quot;Constraint&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds the constraint &#39;c&#39; to the model.</span>

<span class="sd">        After calling this method, and until there is a backtrack that undoes the</span>
<span class="sd">        addition, any assignment of variables to values must satisfy the given</span>
<span class="sd">        constraint in order to be considered feasible. There are two fairly</span>
<span class="sd">        different use cases:</span>

<span class="sd">        - the most common use case is modeling: the given constraint is really</span>
<span class="sd">        part of the problem that the user is trying to solve. In this use case,</span>
<span class="sd">        AddConstraint is called outside of search (i.e., with state() ==</span>
<span class="sd">        OUTSIDE_SEARCH). Most users should only use AddConstraint in this</span>
<span class="sd">        way. In this case, the constraint will belong to the model forever: it</span>
<span class="sd">        cannot not be removed by backtracking.</span>

<span class="sd">        - a rarer use case is that &#39;c&#39; is not a real constraint of the model. It</span>
<span class="sd">        may be a constraint generated by a branching decision (a constraint whose</span>
<span class="sd">        goal is to restrict the search space), a symmetry breaking constraint (a</span>
<span class="sd">        constraint that does restrict the search space, but in a way that cannot</span>
<span class="sd">        have an impact on the quality of the solutions in the subtree), or an</span>
<span class="sd">        inferred constraint that, while having no semantic value to the model (it</span>
<span class="sd">        does not restrict the set of solutions), is worth having because we</span>
<span class="sd">        believe it may strengthen the propagation. In these cases, it happens</span>
<span class="sd">        that the constraint is added during the search (i.e., with state() ==</span>
<span class="sd">        IN_SEARCH or state() == IN_ROOT_NODE). When a constraint is</span>
<span class="sd">        added during a search, it applies only to the subtree of the search tree</span>
<span class="sd">        rooted at the current node, and will be automatically removed by</span>
<span class="sd">        backtracking.</span>

<span class="sd">        This method does not take ownership of the constraint. If the constraint</span>
<span class="sd">        has been created by any factory method (Solver::MakeXXX), it will</span>
<span class="sd">        automatically be deleted. However, power users who implement their own</span>
<span class="sd">        constraints should do: solver.AddConstraint(solver.RevAlloc(new</span>
<span class="sd">        MyConstraint(...));</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_AddConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">c</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds the constraint 'c' to the model.</p>

<p>After calling this method, and until there is a backtrack that undoes the
addition, any assignment of variables to values must satisfy the given
constraint in order to be considered feasible. There are two fairly
different use cases:</p>

<ul>
<li><p>the most common use case is modeling: the given constraint is really
part of the problem that the user is trying to solve. In this use case,
AddConstraint is called outside of search (i.e., with state() ==
OUTSIDE_SEARCH). Most users should only use AddConstraint in this
way. In this case, the constraint will belong to the model forever: it
cannot not be removed by backtracking.</p></li>
<li><p>a rarer use case is that 'c' is not a real constraint of the model. It
may be a constraint generated by a branching decision (a constraint whose
goal is to restrict the search space), a symmetry breaking constraint (a
constraint that does restrict the search space, but in a way that cannot
have an impact on the quality of the solutions in the subtree), or an
inferred constraint that, while having no semantic value to the model (it
does not restrict the set of solutions), is worth having because we
believe it may strengthen the propagation. In these cases, it happens
that the constraint is added during the search (i.e., with state() ==
IN_SEARCH or state() == IN_ROOT_NODE). When a constraint is
added during a search, it applies only to the subtree of the search tree
rooted at the current node, and will be automatically removed by
backtracking.</p></li>
</ul>

<p>This method does not take ownership of the constraint. If the constraint
has been created by any factory method (Solver::MakeXXX), it will
automatically be deleted. However, power users who implement their own
constraints should do: solver.AddConstraint(solver.RevAlloc(new
MyConstraint(...));</p>
</div>


                            </div>
                            <div id="Solver.Solve" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Solve">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Solve</span><span class="signature">(self, *args) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.NewSearch" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.NewSearch">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">NewSearch</span><span class="signature">(self, *args) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">NewSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_NewSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.NextSolution" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.NextSolution">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">NextSolution</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">NextSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_NextSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.RestartSearch" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.RestartSearch">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">RestartSearch</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">RestartSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_RestartSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.EndSearch" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.EndSearch">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">EndSearch</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">EndSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_EndSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.SolveAndCommit" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.SolveAndCommit">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SolveAndCommit</span><span class="signature">(self, *args) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SolveAndCommit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SolveAndCommit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.CheckAssignment" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.CheckAssignment">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">CheckAssignment</span><span class="signature">(self, solution: <a href="#Assignment">pywrapcp.Assignment</a>) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">CheckAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solution</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Checks whether the given assignment satisfies all relevant constraints.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_CheckAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solution</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Checks whether the given assignment satisfies all relevant constraints.</p>
</div>


                            </div>
                            <div id="Solver.CheckConstraint" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.CheckConstraint">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">CheckConstraint</span><span class="signature">(self, ct: <a href="#Constraint">pywrapcp.Constraint</a>) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">CheckConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ct</span><span class="p">:</span> <span class="s2">&quot;Constraint&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks whether adding this constraint will lead to an immediate</span>
<span class="sd">        failure. It will return false if the model is already inconsistent, or if</span>
<span class="sd">        adding the constraint makes it inconsistent.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_CheckConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ct</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Checks whether adding this constraint will lead to an immediate
failure. It will return false if the model is already inconsistent, or if
adding the constraint makes it inconsistent.</p>
</div>


                            </div>
                            <div id="Solver.Fail" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Fail">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Fail</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Fail</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Abandon the current branch in the search tree. A backtrack will follow.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Fail</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Abandon the current branch in the search tree. A backtrack will follow.</p>
</div>


                            </div>
                            <div id="Solver.MemoryUsage" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.MemoryUsage">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">MemoryUsage</span><span class="signature">() -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">MemoryUsage</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Current memory usage in bytes&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_MemoryUsage</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>Current memory usage in bytes</p>
</div>


                            </div>
                            <div id="Solver.WallTime" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.WallTime">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">WallTime</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">WallTime</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        DEPRECATED: Use Now() instead.</span>
<span class="sd">        Time elapsed, in ms since the creation of the solver.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_WallTime</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>DEPRECATED: Use Now() instead.
Time elapsed, in ms since the creation of the solver.</p>
</div>


                            </div>
                            <div id="Solver.Branches" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Branches">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Branches</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Branches</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; The number of branches explored since the creation of the solver.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Branches</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>The number of branches explored since the creation of the solver.</p>
</div>


                            </div>
                            <div id="Solver.Solutions" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Solutions">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Solutions</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Solutions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; The number of solutions found since the start of the search.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Solutions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>The number of solutions found since the start of the search.</p>
</div>


                            </div>
                            <div id="Solver.Failures" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Failures">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Failures</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Failures</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; The number of failures encountered since the creation of the solver.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Failures</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>The number of failures encountered since the creation of the solver.</p>
</div>


                            </div>
                            <div id="Solver.AcceptedNeighbors" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.AcceptedNeighbors">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AcceptedNeighbors</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AcceptedNeighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; The number of accepted neighbors.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_AcceptedNeighbors</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>The number of accepted neighbors.</p>
</div>


                            </div>
                            <div id="Solver.Stamp" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Stamp">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Stamp</span><span class="signature">(self) -&gt; &#39;uint64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Stamp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;uint64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The stamp indicates how many moves in the search tree we have performed.</span>
<span class="sd">        It is useful to detect if we need to update same lazy structures.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Stamp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>The stamp indicates how many moves in the search tree we have performed.
It is useful to detect if we need to update same lazy structures.</p>
</div>


                            </div>
                            <div id="Solver.FailStamp" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.FailStamp">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">FailStamp</span><span class="signature">(self) -&gt; &#39;uint64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">FailStamp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;uint64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; The fail_stamp() is incremented after each backtrack.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_FailStamp</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>The fail_stamp() is incremented after each backtrack.</p>
</div>


                            </div>
                            <div id="Solver.IntVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.IntVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IntVar</span><span class="signature">(self, *args) -&gt; &#39;operations_research::IntVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IntVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        MakeIntVar will create the best range based int var for the bounds given.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        MakeIntVar will create a variable with the given sparse domain.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 3:*</span>
<span class="sd">        MakeIntVar will create a variable with the given sparse domain.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 4:*</span>
<span class="sd">        MakeIntVar will create the best range based int var for the bounds given.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 5:*</span>
<span class="sd">        MakeIntVar will create a variable with the given sparse domain.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 6:*</span>
<span class="sd">        MakeIntVar will create a variable with the given sparse domain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IntVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p><em>Overload 1:</em>
MakeIntVar will create the best range based int var for the bounds given.</p>

<p>|</p>

<p><em>Overload 2:</em>
MakeIntVar will create a variable with the given sparse domain.</p>

<p>|</p>

<p><em>Overload 3:</em>
MakeIntVar will create a variable with the given sparse domain.</p>

<p>|</p>

<p><em>Overload 4:</em>
MakeIntVar will create the best range based int var for the bounds given.</p>

<p>|</p>

<p><em>Overload 5:</em>
MakeIntVar will create a variable with the given sparse domain.</p>

<p>|</p>

<p><em>Overload 6:</em>
MakeIntVar will create a variable with the given sparse domain.</p>
</div>


                            </div>
                            <div id="Solver.BoolVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.BoolVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">BoolVar</span><span class="signature">(self, *args) -&gt; &#39;operations_research::IntVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">BoolVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        MakeBoolVar will create a variable with a {0, 1} domain.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        MakeBoolVar will create a variable with a {0, 1} domain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_BoolVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p><em>Overload 1:</em>
MakeBoolVar will create a variable with a {0, 1} domain.</p>

<p>|</p>

<p><em>Overload 2:</em>
MakeBoolVar will create a variable with a {0, 1} domain.</p>
</div>


                            </div>
                            <div id="Solver.IntConst" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.IntConst">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IntConst</span><span class="signature">(self, *args) -&gt; &#39;operations_research::IntVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IntConst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        IntConst will create a constant expression.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        IntConst will create a constant expression.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IntConst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p><em>Overload 1:</em>
IntConst will create a constant expression.</p>

<p>|</p>

<p><em>Overload 2:</em>
IntConst will create a constant expression.</p>
</div>


                            </div>
                            <div id="Solver.Sum" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Sum">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Sum</span><span class="signature">(
    self,
    vars: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;
) -&gt; &#39;operations_research::IntExpr *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; sum of all vars.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>sum of all vars.</p>
</div>


                            </div>
                            <div id="Solver.ScalProd" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.ScalProd">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ScalProd</span><span class="signature">(self, *args) -&gt; &#39;operations_research::IntExpr *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ScalProd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        scalar product</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        scalar product</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ScalProd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p><em>Overload 1:</em>
scalar product</p>

<p>|</p>

<p><em>Overload 2:</em>
scalar product</p>
</div>


                            </div>
                            <div id="Solver.MonotonicElement" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.MonotonicElement">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">MonotonicElement</span><span class="signature">(
    self,
    values: &#39;operations_research::Solver::IndexEvaluator1&#39;,
    increasing: bool,
    index: <a href="#IntVar">pywrapcp.IntVar</a>
) -&gt; &#39;operations_research::IntExpr *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">MonotonicElement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IndexEvaluator1&quot;</span><span class="p">,</span> <span class="n">increasing</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Function based element. The constraint takes ownership of the</span>
<span class="sd">        callback.  The callback must be monotonic. It must be able to</span>
<span class="sd">        cope with any possible value in the domain of &#39;index&#39;</span>
<span class="sd">        (potentially negative ones too). Furtermore, monotonicity is not</span>
<span class="sd">        checked. Thus giving a non-monotonic function, or specifying an</span>
<span class="sd">        incorrect increasing parameter will result in undefined behavior.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_MonotonicElement</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">increasing</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Function based element. The constraint takes ownership of the
callback.  The callback must be monotonic. It must be able to
cope with any possible value in the domain of 'index'
(potentially negative ones too). Furtermore, monotonicity is not
checked. Thus giving a non-monotonic function, or specifying an
incorrect increasing parameter will result in undefined behavior.</p>
</div>


                            </div>
                            <div id="Solver.Element" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Element">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Element</span><span class="signature">(self, *args) -&gt; &#39;operations_research::IntExpr *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        values[index]</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        values[index]</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 3:*</span>
<span class="sd">        Function-based element. The constraint takes ownership of the</span>
<span class="sd">        callback. The callback must be able to cope with any possible</span>
<span class="sd">        value in the domain of &#39;index&#39; (potentially negative ones too).</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 4:*</span>
<span class="sd">        2D version of function-based element expression, values(expr1, expr2).</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 5:*</span>
<span class="sd">        vars[expr]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p><em>Overload 1:</em>
values[index]</p>

<p>|</p>

<p><em>Overload 2:</em>
values[index]</p>

<p>|</p>

<p><em>Overload 3:</em>
Function-based element. The constraint takes ownership of the
callback. The callback must be able to cope with any possible
value in the domain of 'index' (potentially negative ones too).</p>

<p>|</p>

<p><em>Overload 4:</em>
2D version of function-based element expression, values(expr1, expr2).</p>

<p>|</p>

<p><em>Overload 5:</em>
vars[expr]</p>
</div>


                            </div>
                            <div id="Solver.IndexExpression" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.IndexExpression">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IndexExpression</span><span class="signature">(
    self,
    vars: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;,
    value: &#39;int64_t&#39;
) -&gt; &#39;operations_research::IntExpr *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IndexExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the expression expr such that vars[expr] == value.</span>
<span class="sd">        It assumes that vars are all different.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IndexExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the expression expr such that vars[expr] == value.
It assumes that vars are all different.</p>
</div>


                            </div>
                            <div id="Solver.Min" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Min">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Min</span><span class="signature">(self, *args) -&gt; &#39;operations_research::IntExpr *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        std::min(vars)</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        std::min (left, right)</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 3:*</span>
<span class="sd">        std::min(expr, value)</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 4:*</span>
<span class="sd">        std::min(expr, value)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p><em>Overload 1:</em>
std::min(vars)</p>

<p>|</p>

<p><em>Overload 2:</em>
std::min (left, right)</p>

<p>|</p>

<p><em>Overload 3:</em>
std::min(expr, value)</p>

<p>|</p>

<p><em>Overload 4:</em>
std::min(expr, value)</p>
</div>


                            </div>
                            <div id="Solver.Max" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Max">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Max</span><span class="signature">(self, *args) -&gt; &#39;operations_research::IntExpr *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        std::max(vars)</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        std::max(left, right)</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 3:*</span>
<span class="sd">        std::max(expr, value)</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 4:*</span>
<span class="sd">        std::max(expr, value)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p><em>Overload 1:</em>
std::max(vars)</p>

<p>|</p>

<p><em>Overload 2:</em>
std::max(left, right)</p>

<p>|</p>

<p><em>Overload 3:</em>
std::max(expr, value)</p>

<p>|</p>

<p><em>Overload 4:</em>
std::max(expr, value)</p>
</div>


                            </div>
                            <div id="Solver.ConvexPiecewiseExpr" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.ConvexPiecewiseExpr">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ConvexPiecewiseExpr</span><span class="signature">(
    self,
    expr: <a href="#IntExpr">pywrapcp.IntExpr</a>,
    early_cost: &#39;int64_t&#39;,
    early_date: &#39;int64_t&#39;,
    late_date: &#39;int64_t&#39;,
    late_cost: &#39;int64_t&#39;
) -&gt; &#39;operations_research::IntExpr *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ConvexPiecewiseExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">early_cost</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">early_date</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">late_date</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">late_cost</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Convex piecewise function.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ConvexPiecewiseExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">early_cost</span><span class="p">,</span> <span class="n">early_date</span><span class="p">,</span> <span class="n">late_date</span><span class="p">,</span> <span class="n">late_cost</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Convex piecewise function.</p>
</div>


                            </div>
                            <div id="Solver.SemiContinuousExpr" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.SemiContinuousExpr">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SemiContinuousExpr</span><span class="signature">(
    self,
    expr: <a href="#IntExpr">pywrapcp.IntExpr</a>,
    fixed_charge: &#39;int64_t&#39;,
    step: &#39;int64_t&#39;
) -&gt; &#39;operations_research::IntExpr *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SemiContinuousExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">fixed_charge</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">step</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Semi continuous Expression (x &lt;= 0 -&gt; f(x) = 0; x &gt; 0 -&gt; f(x) = ax + b)</span>
<span class="sd">        a &gt;= 0 and b &gt;= 0</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SemiContinuousExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">fixed_charge</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Semi continuous Expression (x &lt;= 0 -> f(x) = 0; x &gt; 0 -> f(x) = ax + b)
a &gt;= 0 and b &gt;= 0</p>
</div>


                            </div>
                            <div id="Solver.ConditionalExpression" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.ConditionalExpression">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ConditionalExpression</span><span class="signature">(
    self,
    condition: <a href="#IntVar">pywrapcp.IntVar</a>,
    expr: <a href="#IntExpr">pywrapcp.IntExpr</a>,
    unperformed_value: &#39;int64_t&#39;
) -&gt; &#39;operations_research::IntExpr *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ConditionalExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">unperformed_value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Conditional Expr condition ? expr : unperformed_value&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ConditionalExpression</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">condition</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">unperformed_value</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Conditional Expr condition ? expr : unperformed_value</p>
</div>


                            </div>
                            <div id="Solver.TrueConstraint" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.TrueConstraint">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">TrueConstraint</span><span class="signature">(self) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">TrueConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This constraint always succeeds.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_TrueConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This constraint always succeeds.</p>
</div>


                            </div>
                            <div id="Solver.FalseConstraint" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.FalseConstraint">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">FalseConstraint</span><span class="signature">(self, *args) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">FalseConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_FalseConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.IsEqualCstCt" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.IsEqualCstCt">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsEqualCstCt</span><span class="signature">(
    self,
    var: <a href="#IntExpr">pywrapcp.IntExpr</a>,
    value: &#39;int64_t&#39;,
    boolvar: <a href="#IntVar">pywrapcp.IntVar</a>
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsEqualCstCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">boolvar</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; boolvar == (var == value)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsEqualCstCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">boolvar</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>boolvar == (var == value)</p>
</div>


                            </div>
                            <div id="Solver.IsEqualCstVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.IsEqualCstVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsEqualCstVar</span><span class="signature">(
    self,
    var: <a href="#IntExpr">pywrapcp.IntExpr</a>,
    value: &#39;int64_t&#39;
) -&gt; &#39;operations_research::IntVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsEqualCstVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; status var of (var == value)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsEqualCstVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>status var of (var == value)</p>
</div>


                            </div>
                            <div id="Solver.IsEqualCt" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.IsEqualCt">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsEqualCt</span><span class="signature">(
    self,
    v1: <a href="#IntExpr">pywrapcp.IntExpr</a>,
    v2: <a href="#IntExpr">pywrapcp.IntExpr</a>,
    b: <a href="#IntVar">pywrapcp.IntVar</a>
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsEqualCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v1</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">v2</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; b == (v1 == v2)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsEqualCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>b == (v1 == v2)</p>
</div>


                            </div>
                            <div id="Solver.IsEqualVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.IsEqualVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsEqualVar</span><span class="signature">(
    self,
    v1: <a href="#IntExpr">pywrapcp.IntExpr</a>,
    v2: <a href="#IntExpr">pywrapcp.IntExpr</a>
) -&gt; &#39;operations_research::IntVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsEqualVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v1</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">v2</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; status var of (v1 == v2)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsEqualVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>status var of (v1 == v2)</p>
</div>


                            </div>
                            <div id="Solver.IsDifferentCstCt" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.IsDifferentCstCt">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsDifferentCstCt</span><span class="signature">(
    self,
    var: <a href="#IntExpr">pywrapcp.IntExpr</a>,
    value: &#39;int64_t&#39;,
    boolvar: <a href="#IntVar">pywrapcp.IntVar</a>
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsDifferentCstCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">boolvar</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; boolvar == (var != value)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsDifferentCstCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">boolvar</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>boolvar == (var != value)</p>
</div>


                            </div>
                            <div id="Solver.IsDifferentCstVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.IsDifferentCstVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsDifferentCstVar</span><span class="signature">(
    self,
    var: <a href="#IntExpr">pywrapcp.IntExpr</a>,
    value: &#39;int64_t&#39;
) -&gt; &#39;operations_research::IntVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsDifferentCstVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; status var of (var != value)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsDifferentCstVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>status var of (var != value)</p>
</div>


                            </div>
                            <div id="Solver.IsDifferentVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.IsDifferentVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsDifferentVar</span><span class="signature">(
    self,
    v1: <a href="#IntExpr">pywrapcp.IntExpr</a>,
    v2: <a href="#IntExpr">pywrapcp.IntExpr</a>
) -&gt; &#39;operations_research::IntVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsDifferentVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v1</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">v2</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; status var of (v1 != v2)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsDifferentVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>status var of (v1 != v2)</p>
</div>


                            </div>
                            <div id="Solver.IsDifferentCt" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.IsDifferentCt">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsDifferentCt</span><span class="signature">(
    self,
    v1: <a href="#IntExpr">pywrapcp.IntExpr</a>,
    v2: <a href="#IntExpr">pywrapcp.IntExpr</a>,
    b: <a href="#IntVar">pywrapcp.IntVar</a>
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsDifferentCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v1</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">v2</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; b == (v1 != v2)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsDifferentCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>b == (v1 != v2)</p>
</div>


                            </div>
                            <div id="Solver.IsLessOrEqualCstCt" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.IsLessOrEqualCstCt">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsLessOrEqualCstCt</span><span class="signature">(
    self,
    var: <a href="#IntExpr">pywrapcp.IntExpr</a>,
    value: &#39;int64_t&#39;,
    boolvar: <a href="#IntVar">pywrapcp.IntVar</a>
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsLessOrEqualCstCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">boolvar</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; boolvar == (var &lt;= value)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsLessOrEqualCstCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">boolvar</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>boolvar == (var &lt;= value)</p>
</div>


                            </div>
                            <div id="Solver.IsLessOrEqualCstVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.IsLessOrEqualCstVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsLessOrEqualCstVar</span><span class="signature">(
    self,
    var: <a href="#IntExpr">pywrapcp.IntExpr</a>,
    value: &#39;int64_t&#39;
) -&gt; &#39;operations_research::IntVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsLessOrEqualCstVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; status var of (var &lt;= value)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsLessOrEqualCstVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>status var of (var &lt;= value)</p>
</div>


                            </div>
                            <div id="Solver.IsLessOrEqualVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.IsLessOrEqualVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsLessOrEqualVar</span><span class="signature">(
    self,
    left: <a href="#IntExpr">pywrapcp.IntExpr</a>,
    right: <a href="#IntExpr">pywrapcp.IntExpr</a>
) -&gt; &#39;operations_research::IntVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsLessOrEqualVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; status var of (left &lt;= right)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsLessOrEqualVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>status var of (left &lt;= right)</p>
</div>


                            </div>
                            <div id="Solver.IsLessOrEqualCt" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.IsLessOrEqualCt">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsLessOrEqualCt</span><span class="signature">(
    self,
    left: <a href="#IntExpr">pywrapcp.IntExpr</a>,
    right: <a href="#IntExpr">pywrapcp.IntExpr</a>,
    b: <a href="#IntVar">pywrapcp.IntVar</a>
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsLessOrEqualCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; b == (left &lt;= right)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsLessOrEqualCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>b == (left &lt;= right)</p>
</div>


                            </div>
                            <div id="Solver.IsGreaterOrEqualCstCt" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.IsGreaterOrEqualCstCt">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsGreaterOrEqualCstCt</span><span class="signature">(
    self,
    var: <a href="#IntExpr">pywrapcp.IntExpr</a>,
    value: &#39;int64_t&#39;,
    boolvar: <a href="#IntVar">pywrapcp.IntVar</a>
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsGreaterOrEqualCstCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">boolvar</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; boolvar == (var &gt;= value)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsGreaterOrEqualCstCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">boolvar</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>boolvar == (var &gt;= value)</p>
</div>


                            </div>
                            <div id="Solver.IsGreaterOrEqualCstVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.IsGreaterOrEqualCstVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsGreaterOrEqualCstVar</span><span class="signature">(
    self,
    var: <a href="#IntExpr">pywrapcp.IntExpr</a>,
    value: &#39;int64_t&#39;
) -&gt; &#39;operations_research::IntVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsGreaterOrEqualCstVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; status var of (var &gt;= value)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsGreaterOrEqualCstVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>status var of (var &gt;= value)</p>
</div>


                            </div>
                            <div id="Solver.IsGreaterOrEqualVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.IsGreaterOrEqualVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsGreaterOrEqualVar</span><span class="signature">(
    self,
    left: <a href="#IntExpr">pywrapcp.IntExpr</a>,
    right: <a href="#IntExpr">pywrapcp.IntExpr</a>
) -&gt; &#39;operations_research::IntVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsGreaterOrEqualVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; status var of (left &gt;= right)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsGreaterOrEqualVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>status var of (left &gt;= right)</p>
</div>


                            </div>
                            <div id="Solver.IsGreaterOrEqualCt" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.IsGreaterOrEqualCt">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsGreaterOrEqualCt</span><span class="signature">(
    self,
    left: <a href="#IntExpr">pywrapcp.IntExpr</a>,
    right: <a href="#IntExpr">pywrapcp.IntExpr</a>,
    b: <a href="#IntVar">pywrapcp.IntVar</a>
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsGreaterOrEqualCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; b == (left &gt;= right)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsGreaterOrEqualCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>b == (left &gt;= right)</p>
</div>


                            </div>
                            <div id="Solver.IsGreaterCstCt" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.IsGreaterCstCt">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsGreaterCstCt</span><span class="signature">(
    self,
    v: <a href="#IntExpr">pywrapcp.IntExpr</a>,
    c: &#39;int64_t&#39;,
    b: <a href="#IntVar">pywrapcp.IntVar</a>
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsGreaterCstCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; b == (v &gt; c)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsGreaterCstCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>b == (v &gt; c)</p>
</div>


                            </div>
                            <div id="Solver.IsGreaterCstVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.IsGreaterCstVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsGreaterCstVar</span><span class="signature">(
    self,
    var: <a href="#IntExpr">pywrapcp.IntExpr</a>,
    value: &#39;int64_t&#39;
) -&gt; &#39;operations_research::IntVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsGreaterCstVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; status var of (var &gt; value)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsGreaterCstVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>status var of (var &gt; value)</p>
</div>


                            </div>
                            <div id="Solver.IsGreaterVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.IsGreaterVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsGreaterVar</span><span class="signature">(
    self,
    left: <a href="#IntExpr">pywrapcp.IntExpr</a>,
    right: <a href="#IntExpr">pywrapcp.IntExpr</a>
) -&gt; &#39;operations_research::IntVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsGreaterVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; status var of (left &gt; right)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsGreaterVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>status var of (left &gt; right)</p>
</div>


                            </div>
                            <div id="Solver.IsGreaterCt" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.IsGreaterCt">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsGreaterCt</span><span class="signature">(
    self,
    left: <a href="#IntExpr">pywrapcp.IntExpr</a>,
    right: <a href="#IntExpr">pywrapcp.IntExpr</a>,
    b: <a href="#IntVar">pywrapcp.IntVar</a>
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsGreaterCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; b == (left &gt; right)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsGreaterCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>b == (left &gt; right)</p>
</div>


                            </div>
                            <div id="Solver.IsLessCstCt" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.IsLessCstCt">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsLessCstCt</span><span class="signature">(
    self,
    v: <a href="#IntExpr">pywrapcp.IntExpr</a>,
    c: &#39;int64_t&#39;,
    b: <a href="#IntVar">pywrapcp.IntVar</a>
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsLessCstCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">c</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; b == (v &lt; c)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsLessCstCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>b == (v &lt; c)</p>
</div>


                            </div>
                            <div id="Solver.IsLessCstVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.IsLessCstVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsLessCstVar</span><span class="signature">(
    self,
    var: <a href="#IntExpr">pywrapcp.IntExpr</a>,
    value: &#39;int64_t&#39;
) -&gt; &#39;operations_research::IntVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsLessCstVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; status var of (var &lt; value)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsLessCstVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>status var of (var &lt; value)</p>
</div>


                            </div>
                            <div id="Solver.IsLessVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.IsLessVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsLessVar</span><span class="signature">(
    self,
    left: <a href="#IntExpr">pywrapcp.IntExpr</a>,
    right: <a href="#IntExpr">pywrapcp.IntExpr</a>
) -&gt; &#39;operations_research::IntVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsLessVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; status var of (left &lt; right)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsLessVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>status var of (left &lt; right)</p>
</div>


                            </div>
                            <div id="Solver.IsLessCt" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.IsLessCt">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsLessCt</span><span class="signature">(
    self,
    left: <a href="#IntExpr">pywrapcp.IntExpr</a>,
    right: <a href="#IntExpr">pywrapcp.IntExpr</a>,
    b: <a href="#IntVar">pywrapcp.IntVar</a>
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsLessCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; b == (left &lt; right)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsLessCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>b == (left &lt; right)</p>
</div>


                            </div>
                            <div id="Solver.SumLessOrEqual" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.SumLessOrEqual">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SumLessOrEqual</span><span class="signature">(
    self,
    vars: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;,
    cst: &#39;int64_t&#39;
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SumLessOrEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">cst</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Variation on arrays.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SumLessOrEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">cst</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Variation on arrays.</p>
</div>


                            </div>
                            <div id="Solver.SumGreaterOrEqual" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.SumGreaterOrEqual">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SumGreaterOrEqual</span><span class="signature">(
    self,
    vars: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;,
    cst: &#39;int64_t&#39;
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SumGreaterOrEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">cst</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SumGreaterOrEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">cst</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.SumEquality" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.SumEquality">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SumEquality</span><span class="signature">(self, *args) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SumEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SumEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.ScalProdEquality" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.ScalProdEquality">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ScalProdEquality</span><span class="signature">(self, *args) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ScalProdEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ScalProdEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.ScalProdGreaterOrEqual" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.ScalProdGreaterOrEqual">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ScalProdGreaterOrEqual</span><span class="signature">(self, *args) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ScalProdGreaterOrEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ScalProdGreaterOrEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.ScalProdLessOrEqual" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.ScalProdLessOrEqual">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ScalProdLessOrEqual</span><span class="signature">(self, *args) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ScalProdLessOrEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ScalProdLessOrEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.MinEquality" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.MinEquality">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">MinEquality</span><span class="signature">(
    self,
    vars: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;,
    min_var: <a href="#IntVar">pywrapcp.IntVar</a>
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">MinEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">min_var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_MinEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">min_var</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.MaxEquality" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.MaxEquality">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">MaxEquality</span><span class="signature">(
    self,
    vars: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;,
    max_var: <a href="#IntVar">pywrapcp.IntVar</a>
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">MaxEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">max_var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_MaxEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">max_var</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.ElementEquality" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.ElementEquality">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ElementEquality</span><span class="signature">(self, *args) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ElementEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ElementEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.AbsEquality" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.AbsEquality">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AbsEquality</span><span class="signature">(
    self,
    var: <a href="#IntVar">pywrapcp.IntVar</a>,
    abs_var: <a href="#IntVar">pywrapcp.IntVar</a>
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AbsEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">abs_var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Creates the constraint abs(var) == abs_var.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_AbsEquality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">abs_var</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates the constraint abs(var) == abs_var.</p>
</div>


                            </div>
                            <div id="Solver.IndexOfConstraint" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.IndexOfConstraint">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IndexOfConstraint</span><span class="signature">(
    self,
    vars: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;,
    index: <a href="#IntVar">pywrapcp.IntVar</a>,
    target: &#39;int64_t&#39;
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IndexOfConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This constraint is a special case of the element constraint with</span>
<span class="sd">        an array of integer variables, where the variables are all</span>
<span class="sd">        different and the index variable is constrained such that</span>
<span class="sd">        vars[index] == target.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IndexOfConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This constraint is a special case of the element constraint with
an array of integer variables, where the variables are all
different and the index variable is constrained such that
vars[index] == target.</p>
</div>


                            </div>
                            <div id="Solver.ConstraintInitialPropagateCallback" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.ConstraintInitialPropagateCallback">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ConstraintInitialPropagateCallback</span><span class="signature">(self, ct: <a href="#Constraint">pywrapcp.Constraint</a>) -&gt; &#39;operations_research::Demon *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ConstraintInitialPropagateCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ct</span><span class="p">:</span> <span class="s2">&quot;Constraint&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Demon *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is a specialized case of the MakeConstraintDemon</span>
<span class="sd">        method to call the InitiatePropagate of the constraint &#39;ct&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ConstraintInitialPropagateCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ct</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method is a specialized case of the MakeConstraintDemon
method to call the InitiatePropagate of the constraint 'ct'.</p>
</div>


                            </div>
                            <div id="Solver.DelayedConstraintInitialPropagateCallback" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.DelayedConstraintInitialPropagateCallback">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DelayedConstraintInitialPropagateCallback</span><span class="signature">(self, ct: <a href="#Constraint">pywrapcp.Constraint</a>) -&gt; &#39;operations_research::Demon *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">DelayedConstraintInitialPropagateCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ct</span><span class="p">:</span> <span class="s2">&quot;Constraint&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Demon *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is a specialized case of the MakeConstraintDemon</span>
<span class="sd">        method to call the InitiatePropagate of the constraint &#39;ct&#39; with</span>
<span class="sd">        low priority.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_DelayedConstraintInitialPropagateCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ct</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method is a specialized case of the MakeConstraintDemon
method to call the InitiatePropagate of the constraint 'ct' with
low priority.</p>
</div>


                            </div>
                            <div id="Solver.ClosureDemon" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.ClosureDemon">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ClosureDemon</span><span class="signature">(
    self,
    closure: &#39;operations_research::Solver::Closure&#39;
) -&gt; &#39;operations_research::Demon *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ClosureDemon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">closure</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::Closure&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Demon *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Creates a demon from a closure.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ClosureDemon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">closure</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates a demon from a closure.</p>
</div>


                            </div>
                            <div id="Solver.BetweenCt" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.BetweenCt">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">BetweenCt</span><span class="signature">(
    self,
    expr: <a href="#IntExpr">pywrapcp.IntExpr</a>,
    l: &#39;int64_t&#39;,
    u: &#39;int64_t&#39;
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">BetweenCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; (l &lt;= expr &lt;= u)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_BetweenCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>(l &lt;= expr &lt;= u)</p>
</div>


                            </div>
                            <div id="Solver.IsBetweenCt" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.IsBetweenCt">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsBetweenCt</span><span class="signature">(
    self,
    expr: <a href="#IntExpr">pywrapcp.IntExpr</a>,
    l: &#39;int64_t&#39;,
    u: &#39;int64_t&#39;,
    b: <a href="#IntVar">pywrapcp.IntVar</a>
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsBetweenCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; b == (l &lt;= expr &lt;= u)&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsBetweenCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">u</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>b == (l &lt;= expr &lt;= u)</p>
</div>


                            </div>
                            <div id="Solver.IsBetweenVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.IsBetweenVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsBetweenVar</span><span class="signature">(
    self,
    v: <a href="#IntExpr">pywrapcp.IntExpr</a>,
    l: &#39;int64_t&#39;,
    u: &#39;int64_t&#39;
) -&gt; &#39;operations_research::IntVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsBetweenVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;IntExpr&quot;</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsBetweenVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.MemberCt" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.MemberCt">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">MemberCt</span><span class="signature">(self, *args) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">MemberCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_MemberCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.NotMemberCt" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.NotMemberCt">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">NotMemberCt</span><span class="signature">(self, *args) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">NotMemberCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        expr not in set.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        expr should not be in the list of forbidden intervals [start[i]..end[i]].</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 3:*</span>
<span class="sd">        expr should not be in the list of forbidden intervals [start[i]..end[i]].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_NotMemberCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p><em>Overload 1:</em>
expr not in set.</p>

<p>|</p>

<p><em>Overload 2:</em>
expr should not be in the list of forbidden intervals [start[i]..end[i]].</p>

<p>|</p>

<p><em>Overload 3:</em>
expr should not be in the list of forbidden intervals [start[i]..end[i]].</p>
</div>


                            </div>
                            <div id="Solver.IsMemberCt" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.IsMemberCt">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsMemberCt</span><span class="signature">(self, *args) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsMemberCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsMemberCt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.IsMemberVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.IsMemberVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsMemberVar</span><span class="signature">(self, *args) -&gt; &#39;operations_research::IntVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsMemberVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IsMemberVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.Count" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Count">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Count</span><span class="signature">(self, *args) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        |{i | vars[i] == value}| == max_count</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        |{i | vars[i] == value}| == max_count</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Count</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p><em>Overload 1:</em>
|{i | vars[i] == value}| == max_count</p>

<p>|</p>

<p><em>Overload 2:</em>
|{i | vars[i] == value}| == max_count</p>
</div>


                            </div>
                            <div id="Solver.Distribute" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Distribute">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Distribute</span><span class="signature">(self, *args) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Distribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Aggregated version of count:  |{i | v[i] == values[j]}| == cards[j]</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Aggregated version of count:  |{i | v[i] == values[j]}| == cards[j]</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 3:*</span>
<span class="sd">        Aggregated version of count:  |{i | v[i] == j}| == cards[j]</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 4:*</span>
<span class="sd">        Aggregated version of count with bounded cardinalities:</span>
<span class="sd">        forall j in 0 .. card_size - 1: card_min &lt;= |{i | v[i] == j}| &lt;= card_max</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 5:*</span>
<span class="sd">        Aggregated version of count with bounded cardinalities:</span>
<span class="sd">        forall j in 0 .. card_size - 1:</span>
<span class="sd">           card_min[j] &lt;= |{i | v[i] == j}| &lt;= card_max[j]</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 6:*</span>
<span class="sd">        Aggregated version of count with bounded cardinalities:</span>
<span class="sd">        forall j in 0 .. card_size - 1:</span>
<span class="sd">           card_min[j] &lt;= |{i | v[i] == j}| &lt;= card_max[j]</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 7:*</span>
<span class="sd">        Aggregated version of count with bounded cardinalities:</span>
<span class="sd">        forall j in 0 .. card_size - 1:</span>
<span class="sd">           card_min[j] &lt;= |{i | v[i] == values[j]}| &lt;= card_max[j]</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 8:*</span>
<span class="sd">        Aggregated version of count with bounded cardinalities:</span>
<span class="sd">        forall j in 0 .. card_size - 1:</span>
<span class="sd">           card_min[j] &lt;= |{i | v[i] == values[j]}| &lt;= card_max[j]</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Distribute</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p><em>Overload 1:</em>
Aggregated version of count:  |{i | v[i] == values[j]}| == cards[j]</p>

<p>|</p>

<p><em>Overload 2:</em>
Aggregated version of count:  |{i | v[i] == values[j]}| == cards[j]</p>

<p>|</p>

<p><em>Overload 3:</em>
Aggregated version of count:  |{i | v[i] == j}| == cards[j]</p>

<p>|</p>

<p><em>Overload 4:</em>
Aggregated version of count with bounded cardinalities:
forall j in 0 .. card_size - 1: card_min &lt;= |{i | v[i] == j}| &lt;= card_max</p>

<p>|</p>

<p><em>Overload 5:</em>
Aggregated version of count with bounded cardinalities:
forall j in 0 .. card_size - 1:
   card_min[j] &lt;= |{i | v[i] == j}| &lt;= card_max[j]</p>

<p>|</p>

<p><em>Overload 6:</em>
Aggregated version of count with bounded cardinalities:
forall j in 0 .. card_size - 1:
   card_min[j] &lt;= |{i | v[i] == j}| &lt;= card_max[j]</p>

<p>|</p>

<p><em>Overload 7:</em>
Aggregated version of count with bounded cardinalities:
forall j in 0 .. card_size - 1:
   card_min[j] &lt;= |{i | v[i] == values[j]}| &lt;= card_max[j]</p>

<p>|</p>

<p><em>Overload 8:</em>
Aggregated version of count with bounded cardinalities:
forall j in 0 .. card_size - 1:
   card_min[j] &lt;= |{i | v[i] == values[j]}| &lt;= card_max[j]</p>
</div>


                            </div>
                            <div id="Solver.Deviation" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Deviation">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Deviation</span><span class="signature">(
    self,
    vars: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;,
    deviation_var: <a href="#IntVar">pywrapcp.IntVar</a>,
    total_sum: &#39;int64_t&#39;
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Deviation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">deviation_var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">total_sum</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deviation constraint:</span>
<span class="sd">        sum_i |n * vars[i] - total_sum| &lt;= deviation_var and</span>
<span class="sd">        sum_i vars[i] == total_sum</span>
<span class="sd">        n = #vars</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Deviation</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">deviation_var</span><span class="p">,</span> <span class="n">total_sum</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Deviation constraint:
sum_i |n * vars[i] - total_sum| &lt;= deviation_var and
sum_i vars[i] == total_sum
n = #vars</p>
</div>


                            </div>
                            <div id="Solver.AllDifferent" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.AllDifferent">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AllDifferent</span><span class="signature">(self, *args) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AllDifferent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        All variables are pairwise different. This corresponds to the</span>
<span class="sd">        stronger version of the propagation algorithm.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        All variables are pairwise different.  If &#39;stronger_propagation&#39;</span>
<span class="sd">        is true, stronger, and potentially slower propagation will</span>
<span class="sd">        occur. This API will be deprecated in the future.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_AllDifferent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p><em>Overload 1:</em>
All variables are pairwise different. This corresponds to the
stronger version of the propagation algorithm.</p>

<p>|</p>

<p><em>Overload 2:</em>
All variables are pairwise different.  If 'stronger_propagation'
is true, stronger, and potentially slower propagation will
occur. This API will be deprecated in the future.</p>
</div>


                            </div>
                            <div id="Solver.AllDifferentExcept" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.AllDifferentExcept">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AllDifferentExcept</span><span class="signature">(
    self,
    vars: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;,
    escape_value: &#39;int64_t&#39;
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AllDifferentExcept</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">escape_value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        All variables are pairwise different, unless they are assigned to</span>
<span class="sd">        the escape value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_AllDifferentExcept</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">escape_value</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>All variables are pairwise different, unless they are assigned to
the escape value.</p>
</div>


                            </div>
                            <div id="Solver.SortingConstraint" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.SortingConstraint">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SortingConstraint</span><span class="signature">(
    self,
    vars: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;,
    sorted: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SortingConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a constraint binding the arrays of variables &quot;vars&quot; and</span>
<span class="sd">        &quot;sorted_vars&quot;: sorted_vars[0] must be equal to the minimum of all</span>
<span class="sd">        variables in vars, and so on: the value of sorted_vars[i] must be</span>
<span class="sd">        equal to the i-th value of variables invars.</span>

<span class="sd">        This constraint propagates in both directions: from &quot;vars&quot; to</span>
<span class="sd">        &quot;sorted_vars&quot; and vice-versa.</span>

<span class="sd">        Behind the scenes, this constraint maintains that:</span>
<span class="sd">          - sorted is always increasing.</span>
<span class="sd">          - whatever the values of vars, there exists a permutation that</span>
<span class="sd">            injects its values into the sorted variables.</span>

<span class="sd">        For more info, please have a look at:</span>
<span class="sd">          https://mpi-inf.mpg.de/~mehlhorn/ftp/Mehlhorn-Thiel.pdf</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SortingConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="nb">sorted</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates a constraint binding the arrays of variables "vars" and
"sorted_vars": sorted_vars[0] must be equal to the minimum of all
variables in vars, and so on: the value of sorted_vars[i] must be
equal to the i-th value of variables invars.</p>

<p>This constraint propagates in both directions: from "vars" to
"sorted_vars" and vice-versa.</p>

<p>Behind the scenes, this constraint maintains that:</p>

<ul>
<li>sorted is always increasing.</li>
<li>whatever the values of vars, there exists a permutation that
injects its values into the sorted variables.</li>
</ul>

<p>For more info, please have a look at:
  https://mpi-inf.mpg.de/~mehlhorn/ftp/Mehlhorn-Thiel.pdf</p>
</div>


                            </div>
                            <div id="Solver.LexicalLess" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.LexicalLess">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">LexicalLess</span><span class="signature">(
    self,
    left: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;,
    right: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">LexicalLess</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a constraint that enforces that left is lexicographically less</span>
<span class="sd">        than right.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_LexicalLess</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates a constraint that enforces that left is lexicographically less
than right.</p>
</div>


                            </div>
                            <div id="Solver.LexicalLessOrEqual" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.LexicalLessOrEqual">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">LexicalLessOrEqual</span><span class="signature">(
    self,
    left: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;,
    right: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">LexicalLessOrEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a constraint that enforces that left is lexicographically less</span>
<span class="sd">        than or equal to right.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_LexicalLessOrEqual</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates a constraint that enforces that left is lexicographically less
than or equal to right.</p>
</div>


                            </div>
                            <div id="Solver.InversePermutationConstraint" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.InversePermutationConstraint">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">InversePermutationConstraint</span><span class="signature">(
    self,
    left: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;,
    right: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">InversePermutationConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">right</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a constraint that enforces that &#39;left&#39; and &#39;right&#39; both</span>
<span class="sd">        represent permutations of [0..left.size()-1], and that &#39;right&#39; is</span>
<span class="sd">        the inverse permutation of &#39;left&#39;, i.e. for all i in</span>
<span class="sd">        [0..left.size()-1], right[left[i]] = i.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_InversePermutationConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates a constraint that enforces that 'left' and 'right' both
represent permutations of [0..left.size()-1], and that 'right' is
the inverse permutation of 'left', i.e. for all i in
[0..left.size()-1], right[left[i]] = i.</p>
</div>


                            </div>
                            <div id="Solver.NullIntersect" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.NullIntersect">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">NullIntersect</span><span class="signature">(
    self,
    first_vars: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;,
    second_vars: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">NullIntersect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">second_vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a constraint that states that all variables in the first</span>
<span class="sd">        vector are different from all variables in the second</span>
<span class="sd">        group. Thus the set of values in the first vector does not</span>
<span class="sd">        intersect with the set of values in the second vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_NullIntersect</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_vars</span><span class="p">,</span> <span class="n">second_vars</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates a constraint that states that all variables in the first
vector are different from all variables in the second
group. Thus the set of values in the first vector does not
intersect with the set of values in the second vector.</p>
</div>


                            </div>
                            <div id="Solver.NullIntersectExcept" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.NullIntersectExcept">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">NullIntersectExcept</span><span class="signature">(
    self,
    first_vars: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;,
    second_vars: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;,
    escape_value: &#39;int64_t&#39;
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">NullIntersectExcept</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">second_vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">escape_value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a constraint that states that all variables in the first</span>
<span class="sd">        vector are different from all variables from the second group,</span>
<span class="sd">        unless they are assigned to the escape value. Thus the set of</span>
<span class="sd">        values in the first vector minus the escape value does not</span>
<span class="sd">        intersect with the set of values in the second vector.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_NullIntersectExcept</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_vars</span><span class="p">,</span> <span class="n">second_vars</span><span class="p">,</span> <span class="n">escape_value</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates a constraint that states that all variables in the first
vector are different from all variables from the second group,
unless they are assigned to the escape value. Thus the set of
values in the first vector minus the escape value does not
intersect with the set of values in the second vector.</p>
</div>


                            </div>
                            <div id="Solver.Circuit" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Circuit">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Circuit</span><span class="signature">(
    self,
    nexts: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Circuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nexts</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Force the &quot;nexts&quot; variable to create a complete Hamiltonian path.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Circuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nexts</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Force the "nexts" variable to create a complete Hamiltonian path.</p>
</div>


                            </div>
                            <div id="Solver.SubCircuit" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.SubCircuit">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SubCircuit</span><span class="signature">(
    self,
    nexts: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SubCircuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nexts</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Force the &quot;nexts&quot; variable to create a complete Hamiltonian path</span>
<span class="sd">        for those that do not loop upon themselves.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SubCircuit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nexts</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Force the "nexts" variable to create a complete Hamiltonian path
for those that do not loop upon themselves.</p>
</div>


                            </div>
                            <div id="Solver.DelayedPathCumul" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.DelayedPathCumul">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DelayedPathCumul</span><span class="signature">(
    self,
    nexts: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;,
    active: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;,
    cumuls: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;,
    transits: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">DelayedPathCumul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nexts</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">active</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">cumuls</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">transits</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Delayed version of the same constraint: propagation on the nexts variables</span>
<span class="sd">        is delayed until all constraints have propagated.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_DelayedPathCumul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nexts</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">cumuls</span><span class="p">,</span> <span class="n">transits</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Delayed version of the same constraint: propagation on the nexts variables
is delayed until all constraints have propagated.</p>
</div>


                            </div>
                            <div id="Solver.PathCumul" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.PathCumul">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">PathCumul</span><span class="signature">(self, *args) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">PathCumul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Creates a constraint which accumulates values along a path such that:</span>
<span class="sd">        cumuls[next[i]] = cumuls[i] + transits[i].</span>
<span class="sd">        Active variables indicate if the corresponding next variable is active;</span>
<span class="sd">        this could be useful to model unperformed nodes in a routing problem.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Creates a constraint which accumulates values along a path such that:</span>
<span class="sd">        cumuls[next[i]] = cumuls[i] + transit_evaluator(i, next[i]).</span>
<span class="sd">        Active variables indicate if the corresponding next variable is active;</span>
<span class="sd">        this could be useful to model unperformed nodes in a routing problem.</span>
<span class="sd">        Ownership of transit_evaluator is taken and it must be a repeatable</span>
<span class="sd">        callback.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 3:*</span>
<span class="sd">        Creates a constraint which accumulates values along a path such that:</span>
<span class="sd">        cumuls[next[i]] = cumuls[i] + transit_evaluator(i, next[i]) + slacks[i].</span>
<span class="sd">        Active variables indicate if the corresponding next variable is active;</span>
<span class="sd">        this could be useful to model unperformed nodes in a routing problem.</span>
<span class="sd">        Ownership of transit_evaluator is taken and it must be a repeatable</span>
<span class="sd">        callback.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_PathCumul</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p><em>Overload 1:</em>
Creates a constraint which accumulates values along a path such that:
cumuls[next[i]] = cumuls[i] + transits[i].
Active variables indicate if the corresponding next variable is active;
this could be useful to model unperformed nodes in a routing problem.</p>

<p>|</p>

<p><em>Overload 2:</em>
Creates a constraint which accumulates values along a path such that:
cumuls[next[i]] = cumuls[i] + transit_evaluator(i, next[i]).
Active variables indicate if the corresponding next variable is active;
this could be useful to model unperformed nodes in a routing problem.
Ownership of transit_evaluator is taken and it must be a repeatable
callback.</p>

<p>|</p>

<p><em>Overload 3:</em>
Creates a constraint which accumulates values along a path such that:
cumuls[next[i]] = cumuls[i] + transit_evaluator(i, next[i]) + slacks[i].
Active variables indicate if the corresponding next variable is active;
this could be useful to model unperformed nodes in a routing problem.
Ownership of transit_evaluator is taken and it must be a repeatable
callback.</p>
</div>


                            </div>
                            <div id="Solver.AllowedAssignments" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.AllowedAssignments">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AllowedAssignments</span><span class="signature">(self, *args) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AllowedAssignments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        This method creates a constraint where the graph of the relation</span>
<span class="sd">        between the variables is given in extension. There are &#39;arity&#39;</span>
<span class="sd">        variables involved in the relation and the graph is given by a</span>
<span class="sd">        integer tuple set.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Compatibility layer for Python API.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_AllowedAssignments</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p><em>Overload 1:</em>
This method creates a constraint where the graph of the relation
between the variables is given in extension. There are 'arity'
variables involved in the relation and the graph is given by a
integer tuple set.</p>

<p>|</p>

<p><em>Overload 2:</em>
Compatibility layer for Python API.</p>
</div>


                            </div>
                            <div id="Solver.TransitionConstraint" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.TransitionConstraint">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">TransitionConstraint</span><span class="signature">(self, *args) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">TransitionConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_TransitionConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.NonOverlappingBoxesConstraint" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.NonOverlappingBoxesConstraint">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">NonOverlappingBoxesConstraint</span><span class="signature">(self, *args) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">NonOverlappingBoxesConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_NonOverlappingBoxesConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.Pack" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Pack">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Pack</span><span class="signature">(
    self,
    vars: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;,
    number_of_bins: int
) -&gt; &#39;operations_research::Pack *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Pack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">number_of_bins</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Pack *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This constraint packs all variables onto &#39;number_of_bins&#39;</span>
<span class="sd">        variables.  For any given variable, a value of &#39;number_of_bins&#39;</span>
<span class="sd">        indicates that the variable is not assigned to any bin.</span>
<span class="sd">        Dimensions, i.e., cumulative constraints on this packing, can be</span>
<span class="sd">        added directly from the pack class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Pack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">number_of_bins</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This constraint packs all variables onto 'number_of_bins'
variables.  For any given variable, a value of 'number_of_bins'
indicates that the variable is not assigned to any bin.
Dimensions, i.e., cumulative constraints on this packing, can be
added directly from the pack class.</p>
</div>


                            </div>
                            <div id="Solver.FixedDurationIntervalVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.FixedDurationIntervalVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">FixedDurationIntervalVar</span><span class="signature">(self, *args) -&gt; &#39;operations_research::IntervalVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">FixedDurationIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntervalVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Creates an interval var with a fixed duration. The duration must</span>
<span class="sd">        be greater than 0. If optional is true, then the interval can be</span>
<span class="sd">        performed or unperformed. If optional is false, then the interval</span>
<span class="sd">        is always performed.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Creates a performed interval var with a fixed duration. The duration must</span>
<span class="sd">        be greater than 0.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 3:*</span>
<span class="sd">        Creates an interval var with a fixed duration, and performed_variable.</span>
<span class="sd">        The duration must be greater than 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_FixedDurationIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p><em>Overload 1:</em>
Creates an interval var with a fixed duration. The duration must
be greater than 0. If optional is true, then the interval can be
performed or unperformed. If optional is false, then the interval
is always performed.</p>

<p>|</p>

<p><em>Overload 2:</em>
Creates a performed interval var with a fixed duration. The duration must
be greater than 0.</p>

<p>|</p>

<p><em>Overload 3:</em>
Creates an interval var with a fixed duration, and performed_variable.
The duration must be greater than 0.</p>
</div>


                            </div>
                            <div id="Solver.FixedInterval" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.FixedInterval">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">FixedInterval</span><span class="signature">(
    self,
    start: &#39;int64_t&#39;,
    duration: &#39;int64_t&#39;,
    name: &#39;std::string const &amp;&#39;
) -&gt; &#39;operations_research::IntervalVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">FixedInterval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">duration</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntervalVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Creates a fixed and performed interval.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_FixedInterval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates a fixed and performed interval.</p>
</div>


                            </div>
                            <div id="Solver.IntervalVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.IntervalVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IntervalVar</span><span class="signature">(
    self,
    start_min: &#39;int64_t&#39;,
    start_max: &#39;int64_t&#39;,
    duration_min: &#39;int64_t&#39;,
    duration_max: &#39;int64_t&#39;,
    end_min: &#39;int64_t&#39;,
    end_max: &#39;int64_t&#39;,
    optional: bool,
    name: &#39;std::string const &amp;&#39;
) -&gt; &#39;operations_research::IntervalVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_min</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">start_max</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">duration_min</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">duration_max</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">end_min</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">end_max</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">optional</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntervalVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates an interval var by specifying the bounds on start,</span>
<span class="sd">        duration, and end.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">start_min</span><span class="p">,</span> <span class="n">start_max</span><span class="p">,</span> <span class="n">duration_min</span><span class="p">,</span> <span class="n">duration_max</span><span class="p">,</span> <span class="n">end_min</span><span class="p">,</span> <span class="n">end_max</span><span class="p">,</span> <span class="n">optional</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates an interval var by specifying the bounds on start,
duration, and end.</p>
</div>


                            </div>
                            <div id="Solver.MirrorInterval" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.MirrorInterval">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">MirrorInterval</span><span class="signature">(
    self,
    interval_var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>
) -&gt; &#39;operations_research::IntervalVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">MirrorInterval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntervalVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates an interval var that is the mirror image of the given one, that</span>
<span class="sd">        is, the interval var obtained by reversing the axis.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_MirrorInterval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates an interval var that is the mirror image of the given one, that
is, the interval var obtained by reversing the axis.</p>
</div>


                            </div>
                            <div id="Solver.FixedDurationStartSyncedOnStartIntervalVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.FixedDurationStartSyncedOnStartIntervalVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">FixedDurationStartSyncedOnStartIntervalVar</span><span class="signature">(
    self,
    interval_var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>,
    duration: &#39;int64_t&#39;,
    offset: &#39;int64_t&#39;
) -&gt; &#39;operations_research::IntervalVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">FixedDurationStartSyncedOnStartIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">duration</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntervalVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates an interval var with a fixed duration whose start is</span>
<span class="sd">        synchronized with the start of another interval, with a given</span>
<span class="sd">        offset. The performed status is also in sync with the performed</span>
<span class="sd">        status of the given interval variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_FixedDurationStartSyncedOnStartIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates an interval var with a fixed duration whose start is
synchronized with the start of another interval, with a given
offset. The performed status is also in sync with the performed
status of the given interval variable.</p>
</div>


                            </div>
                            <div id="Solver.FixedDurationStartSyncedOnEndIntervalVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.FixedDurationStartSyncedOnEndIntervalVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">FixedDurationStartSyncedOnEndIntervalVar</span><span class="signature">(
    self,
    interval_var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>,
    duration: &#39;int64_t&#39;,
    offset: &#39;int64_t&#39;
) -&gt; &#39;operations_research::IntervalVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">FixedDurationStartSyncedOnEndIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">duration</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntervalVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates an interval var with a fixed duration whose start is</span>
<span class="sd">        synchronized with the end of another interval, with a given</span>
<span class="sd">        offset. The performed status is also in sync with the performed</span>
<span class="sd">        status of the given interval variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_FixedDurationStartSyncedOnEndIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates an interval var with a fixed duration whose start is
synchronized with the end of another interval, with a given
offset. The performed status is also in sync with the performed
status of the given interval variable.</p>
</div>


                            </div>
                            <div id="Solver.FixedDurationEndSyncedOnStartIntervalVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.FixedDurationEndSyncedOnStartIntervalVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">FixedDurationEndSyncedOnStartIntervalVar</span><span class="signature">(
    self,
    interval_var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>,
    duration: &#39;int64_t&#39;,
    offset: &#39;int64_t&#39;
) -&gt; &#39;operations_research::IntervalVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">FixedDurationEndSyncedOnStartIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">duration</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntervalVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates an interval var with a fixed duration whose end is</span>
<span class="sd">        synchronized with the start of another interval, with a given</span>
<span class="sd">        offset. The performed status is also in sync with the performed</span>
<span class="sd">        status of the given interval variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_FixedDurationEndSyncedOnStartIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates an interval var with a fixed duration whose end is
synchronized with the start of another interval, with a given
offset. The performed status is also in sync with the performed
status of the given interval variable.</p>
</div>


                            </div>
                            <div id="Solver.FixedDurationEndSyncedOnEndIntervalVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.FixedDurationEndSyncedOnEndIntervalVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">FixedDurationEndSyncedOnEndIntervalVar</span><span class="signature">(
    self,
    interval_var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>,
    duration: &#39;int64_t&#39;,
    offset: &#39;int64_t&#39;
) -&gt; &#39;operations_research::IntervalVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">FixedDurationEndSyncedOnEndIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">duration</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntervalVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates an interval var with a fixed duration whose end is</span>
<span class="sd">        synchronized with the end of another interval, with a given</span>
<span class="sd">        offset. The performed status is also in sync with the performed</span>
<span class="sd">        status of the given interval variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_FixedDurationEndSyncedOnEndIntervalVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates an interval var with a fixed duration whose end is
synchronized with the end of another interval, with a given
offset. The performed status is also in sync with the performed
status of the given interval variable.</p>
</div>


                            </div>
                            <div id="Solver.IntervalRelaxedMin" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.IntervalRelaxedMin">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IntervalRelaxedMin</span><span class="signature">(
    self,
    interval_var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>
) -&gt; &#39;operations_research::IntervalVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IntervalRelaxedMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntervalVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         Creates and returns an interval variable that wraps around the given one,</span>
<span class="sd">         relaxing the min start and end. Relaxing means making unbounded when</span>
<span class="sd">         optional. If the variable is non-optional, this method returns</span>
<span class="sd">         interval_var.</span>

<span class="sd">         More precisely, such an interval variable behaves as follows:</span>
<span class="sd">        When the underlying must be performed, the returned interval variable</span>
<span class="sd">             behaves exactly as the underlying;</span>
<span class="sd">        When the underlying may or may not be performed, the returned interval</span>
<span class="sd">             variable behaves like the underlying, except that it is unbounded on</span>
<span class="sd">             the min side;</span>
<span class="sd">        When the underlying cannot be performed, the returned interval variable</span>
<span class="sd">             is of duration 0 and must be performed in an interval unbounded on</span>
<span class="sd">             both sides.</span>

<span class="sd">         This is very useful to implement propagators that may only modify</span>
<span class="sd">         the start max or end max.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IntervalRelaxedMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates and returns an interval variable that wraps around the given one,
 relaxing the min start and end. Relaxing means making unbounded when
 optional. If the variable is non-optional, this method returns
 interval_var.</p>

<p>More precisely, such an interval variable behaves as follows:
When the underlying must be performed, the returned interval variable
     behaves exactly as the underlying;
When the underlying may or may not be performed, the returned interval
     variable behaves like the underlying, except that it is unbounded on
     the min side;
When the underlying cannot be performed, the returned interval variable
     is of duration 0 and must be performed in an interval unbounded on
     both sides.</p>

<p>This is very useful to implement propagators that may only modify
 the start max or end max.</p>
</div>


                            </div>
                            <div id="Solver.IntervalRelaxedMax" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.IntervalRelaxedMax">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IntervalRelaxedMax</span><span class="signature">(
    self,
    interval_var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>
) -&gt; &#39;operations_research::IntervalVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IntervalRelaxedMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntervalVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         Creates and returns an interval variable that wraps around the given one,</span>
<span class="sd">         relaxing the max start and end. Relaxing means making unbounded when</span>
<span class="sd">         optional. If the variable is non optional, this method returns</span>
<span class="sd">         interval_var.</span>

<span class="sd">         More precisely, such an interval variable behaves as follows:</span>
<span class="sd">        When the underlying must be performed, the returned interval variable</span>
<span class="sd">             behaves exactly as the underlying;</span>
<span class="sd">        When the underlying may or may not be performed, the returned interval</span>
<span class="sd">             variable behaves like the underlying, except that it is unbounded on</span>
<span class="sd">             the max side;</span>
<span class="sd">        When the underlying cannot be performed, the returned interval variable</span>
<span class="sd">             is of duration 0 and must be performed in an interval unbounded on</span>
<span class="sd">             both sides.</span>

<span class="sd">         This is very useful for implementing propagators that may only modify</span>
<span class="sd">         the start min or end min.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_IntervalRelaxedMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval_var</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates and returns an interval variable that wraps around the given one,
 relaxing the max start and end. Relaxing means making unbounded when
 optional. If the variable is non optional, this method returns
 interval_var.</p>

<p>More precisely, such an interval variable behaves as follows:
When the underlying must be performed, the returned interval variable
     behaves exactly as the underlying;
When the underlying may or may not be performed, the returned interval
     variable behaves like the underlying, except that it is unbounded on
     the max side;
When the underlying cannot be performed, the returned interval variable
     is of duration 0 and must be performed in an interval unbounded on
     both sides.</p>

<p>This is very useful for implementing propagators that may only modify
 the start min or end min.</p>
</div>


                            </div>
                            <div id="Solver.TemporalDisjunction" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.TemporalDisjunction">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">TemporalDisjunction</span><span class="signature">(self, *args) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">TemporalDisjunction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        This constraint implements a temporal disjunction between two</span>
<span class="sd">        interval vars t1 and t2. &#39;alt&#39; indicates which alternative was</span>
<span class="sd">        chosen (alt == 0 is equivalent to t1 before t2).</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        This constraint implements a temporal disjunction between two</span>
<span class="sd">        interval vars.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_TemporalDisjunction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p><em>Overload 1:</em>
This constraint implements a temporal disjunction between two
interval vars t1 and t2. 'alt' indicates which alternative was
chosen (alt == 0 is equivalent to t1 before t2).</p>

<p>|</p>

<p><em>Overload 2:</em>
This constraint implements a temporal disjunction between two
interval vars.</p>
</div>


                            </div>
                            <div id="Solver.DisjunctiveConstraint" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.DisjunctiveConstraint">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DisjunctiveConstraint</span><span class="signature">(
    self,
    intervals: &#39;std::vector&lt; operations_research::IntervalVar * &gt; const &amp;&#39;,
    name: &#39;std::string const &amp;&#39;
) -&gt; &#39;operations_research::DisjunctiveConstraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">DisjunctiveConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intervals</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntervalVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DisjunctiveConstraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This constraint forces all interval vars into an non-overlapping</span>
<span class="sd">        sequence. Intervals with zero duration can be scheduled anywhere.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_DisjunctiveConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">intervals</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This constraint forces all interval vars into an non-overlapping
sequence. Intervals with zero duration can be scheduled anywhere.</p>
</div>


                            </div>
                            <div id="Solver.Cumulative" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Cumulative">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Cumulative</span><span class="signature">(self, *args) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Cumulative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        This constraint forces that, for any integer t, the sum of the demands</span>
<span class="sd">        corresponding to an interval containing t does not exceed the given</span>
<span class="sd">        capacity.</span>

<span class="sd">        Intervals and demands should be vectors of equal size.</span>

<span class="sd">        Demands should only contain non-negative values. Zero values are</span>
<span class="sd">        supported, and the corresponding intervals are filtered out, as they</span>
<span class="sd">        neither impact nor are impacted by this constraint.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        This constraint forces that, for any integer t, the sum of the demands</span>
<span class="sd">        corresponding to an interval containing t does not exceed the given</span>
<span class="sd">        capacity.</span>

<span class="sd">        Intervals and demands should be vectors of equal size.</span>

<span class="sd">        Demands should only contain non-negative values. Zero values are</span>
<span class="sd">        supported, and the corresponding intervals are filtered out, as they</span>
<span class="sd">        neither impact nor are impacted by this constraint.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 3:*</span>
<span class="sd">        This constraint forces that, for any integer t, the sum of the demands</span>
<span class="sd">        corresponding to an interval containing t does not exceed the given</span>
<span class="sd">        capacity.</span>

<span class="sd">        Intervals and demands should be vectors of equal size.</span>

<span class="sd">        Demands should only contain non-negative values. Zero values are</span>
<span class="sd">        supported, and the corresponding intervals are filtered out, as they</span>
<span class="sd">        neither impact nor are impacted by this constraint.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 4:*</span>
<span class="sd">        This constraint enforces that, for any integer t, the sum of the demands</span>
<span class="sd">        corresponding to an interval containing t does not exceed the given</span>
<span class="sd">        capacity.</span>

<span class="sd">        Intervals and demands should be vectors of equal size.</span>

<span class="sd">        Demands should only contain non-negative values. Zero values are</span>
<span class="sd">        supported, and the corresponding intervals are filtered out, as they</span>
<span class="sd">        neither impact nor are impacted by this constraint.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 5:*</span>
<span class="sd">        This constraint enforces that, for any integer t, the sum of demands</span>
<span class="sd">        corresponding to an interval containing t does not exceed the given</span>
<span class="sd">        capacity.</span>

<span class="sd">        Intervals and demands should be vectors of equal size.</span>

<span class="sd">        Demands should be positive.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 6:*</span>
<span class="sd">        This constraint enforces that, for any integer t, the sum of demands</span>
<span class="sd">        corresponding to an interval containing t does not exceed the given</span>
<span class="sd">        capacity.</span>

<span class="sd">        Intervals and demands should be vectors of equal size.</span>

<span class="sd">        Demands should be positive.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Cumulative</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p><em>Overload 1:</em>
This constraint forces that, for any integer t, the sum of the demands
corresponding to an interval containing t does not exceed the given
capacity.</p>

<p>Intervals and demands should be vectors of equal size.</p>

<p>Demands should only contain non-negative values. Zero values are
supported, and the corresponding intervals are filtered out, as they
neither impact nor are impacted by this constraint.</p>

<p>|</p>

<p><em>Overload 2:</em>
This constraint forces that, for any integer t, the sum of the demands
corresponding to an interval containing t does not exceed the given
capacity.</p>

<p>Intervals and demands should be vectors of equal size.</p>

<p>Demands should only contain non-negative values. Zero values are
supported, and the corresponding intervals are filtered out, as they
neither impact nor are impacted by this constraint.</p>

<p>|</p>

<p><em>Overload 3:</em>
This constraint forces that, for any integer t, the sum of the demands
corresponding to an interval containing t does not exceed the given
capacity.</p>

<p>Intervals and demands should be vectors of equal size.</p>

<p>Demands should only contain non-negative values. Zero values are
supported, and the corresponding intervals are filtered out, as they
neither impact nor are impacted by this constraint.</p>

<p>|</p>

<p><em>Overload 4:</em>
This constraint enforces that, for any integer t, the sum of the demands
corresponding to an interval containing t does not exceed the given
capacity.</p>

<p>Intervals and demands should be vectors of equal size.</p>

<p>Demands should only contain non-negative values. Zero values are
supported, and the corresponding intervals are filtered out, as they
neither impact nor are impacted by this constraint.</p>

<p>|</p>

<p><em>Overload 5:</em>
This constraint enforces that, for any integer t, the sum of demands
corresponding to an interval containing t does not exceed the given
capacity.</p>

<p>Intervals and demands should be vectors of equal size.</p>

<p>Demands should be positive.</p>

<p>|</p>

<p><em>Overload 6:</em>
This constraint enforces that, for any integer t, the sum of demands
corresponding to an interval containing t does not exceed the given
capacity.</p>

<p>Intervals and demands should be vectors of equal size.</p>

<p>Demands should be positive.</p>
</div>


                            </div>
                            <div id="Solver.Cover" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Cover">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Cover</span><span class="signature">(
    self,
    vars: &#39;std::vector&lt; operations_research::IntervalVar * &gt; const &amp;&#39;,
    target_var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Cover</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntervalVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">target_var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This constraint states that the target_var is the convex hull of</span>
<span class="sd">        the intervals. If none of the interval variables is performed,</span>
<span class="sd">        then the target var is unperformed too. Also, if the target</span>
<span class="sd">        variable is unperformed, then all the intervals variables are</span>
<span class="sd">        unperformed too.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Cover</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">target_var</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This constraint states that the target_var is the convex hull of
the intervals. If none of the interval variables is performed,
then the target var is unperformed too. Also, if the target
variable is unperformed, then all the intervals variables are
unperformed too.</p>
</div>


                            </div>
                            <div id="Solver.Assignment" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Assignment">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Assignment</span><span class="signature">(self, *args) -&gt; &#39;operations_research::Assignment *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Assignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        This method creates an empty assignment.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        This method creates an assignment which is a copy of &#39;a&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Assignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p><em>Overload 1:</em>
This method creates an empty assignment.</p>

<p>|</p>

<p><em>Overload 2:</em>
This method creates an assignment which is a copy of 'a'.</p>
</div>


                            </div>
                            <div id="Solver.FirstSolutionCollector" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.FirstSolutionCollector">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">FirstSolutionCollector</span><span class="signature">(self, *args) -&gt; &#39;operations_research::SolutionCollector *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">FirstSolutionCollector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SolutionCollector *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Collect the first solution of the search.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Collect the first solution of the search. The variables will need to</span>
<span class="sd">        be added later.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_FirstSolutionCollector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p><em>Overload 1:</em>
Collect the first solution of the search.</p>

<p>|</p>

<p><em>Overload 2:</em>
Collect the first solution of the search. The variables will need to
be added later.</p>
</div>


                            </div>
                            <div id="Solver.LastSolutionCollector" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.LastSolutionCollector">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">LastSolutionCollector</span><span class="signature">(self, *args) -&gt; &#39;operations_research::SolutionCollector *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">LastSolutionCollector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SolutionCollector *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Collect the last solution of the search.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Collect the last solution of the search. The variables will need to</span>
<span class="sd">        be added later.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_LastSolutionCollector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p><em>Overload 1:</em>
Collect the last solution of the search.</p>

<p>|</p>

<p><em>Overload 2:</em>
Collect the last solution of the search. The variables will need to
be added later.</p>
</div>


                            </div>
                            <div id="Solver.BestValueSolutionCollector" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.BestValueSolutionCollector">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">BestValueSolutionCollector</span><span class="signature">(self, *args) -&gt; &#39;operations_research::SolutionCollector *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">BestValueSolutionCollector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SolutionCollector *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Collect the solution corresponding to the optimal value of the objective</span>
<span class="sd">        of &#39;assignment&#39;; if &#39;assignment&#39; does not have an objective no solution is</span>
<span class="sd">        collected. This collector only collects one solution corresponding to the</span>
<span class="sd">        best objective value (the first one found).</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Collect the solution corresponding to the optimal value of the</span>
<span class="sd">        objective of &#39;assignment&#39;; if &#39;assignment&#39; does not have an objective no</span>
<span class="sd">        solution is collected. This collector only collects one solution</span>
<span class="sd">        corresponding to the best objective value (the first one</span>
<span class="sd">        found). The variables will need to be added later.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_BestValueSolutionCollector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p><em>Overload 1:</em>
Collect the solution corresponding to the optimal value of the objective
of 'assignment'; if 'assignment' does not have an objective no solution is
collected. This collector only collects one solution corresponding to the
best objective value (the first one found).</p>

<p>|</p>

<p><em>Overload 2:</em>
Collect the solution corresponding to the optimal value of the
objective of 'assignment'; if 'assignment' does not have an objective no
solution is collected. This collector only collects one solution
corresponding to the best objective value (the first one
found). The variables will need to be added later.</p>
</div>


                            </div>
                            <div id="Solver.AllSolutionCollector" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.AllSolutionCollector">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AllSolutionCollector</span><span class="signature">(self, *args) -&gt; &#39;operations_research::SolutionCollector *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AllSolutionCollector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SolutionCollector *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Collect all solutions of the search.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Collect all solutions of the search. The variables will need to</span>
<span class="sd">        be added later.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_AllSolutionCollector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p><em>Overload 1:</em>
Collect all solutions of the search.</p>

<p>|</p>

<p><em>Overload 2:</em>
Collect all solutions of the search. The variables will need to
be added later.</p>
</div>


                            </div>
                            <div id="Solver.Minimize" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Minimize">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Minimize</span><span class="signature">(
    self,
    v: <a href="#IntVar">pywrapcp.IntVar</a>,
    step: &#39;int64_t&#39;
) -&gt; &#39;operations_research::OptimizeVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Minimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">step</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::OptimizeVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Creates a minimization objective.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Minimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates a minimization objective.</p>
</div>


                            </div>
                            <div id="Solver.Maximize" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Maximize">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Maximize</span><span class="signature">(
    self,
    v: <a href="#IntVar">pywrapcp.IntVar</a>,
    step: &#39;int64_t&#39;
) -&gt; &#39;operations_research::OptimizeVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Maximize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">step</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::OptimizeVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Creates a maximization objective.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Maximize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates a maximization objective.</p>
</div>


                            </div>
                            <div id="Solver.Optimize" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Optimize">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Optimize</span><span class="signature">(
    self,
    maximize: bool,
    v: <a href="#IntVar">pywrapcp.IntVar</a>,
    step: &#39;int64_t&#39;
) -&gt; &#39;operations_research::OptimizeVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maximize</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">step</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::OptimizeVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Creates a objective with a given sense (true = maximization).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Optimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maximize</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">step</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates a objective with a given sense (true = maximization).</p>
</div>


                            </div>
                            <div id="Solver.WeightedMinimize" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.WeightedMinimize">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">WeightedMinimize</span><span class="signature">(self, *args) -&gt; &#39;operations_research::OptimizeVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">WeightedMinimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::OptimizeVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Creates a minimization weighted objective. The actual objective is</span>
<span class="sd">        scalar_prod(sub_objectives, weights).</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Creates a minimization weighted objective. The actual objective is</span>
<span class="sd">        scalar_prod(sub_objectives, weights).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_WeightedMinimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p><em>Overload 1:</em>
Creates a minimization weighted objective. The actual objective is
scalar_prod(sub_objectives, weights).</p>

<p>|</p>

<p><em>Overload 2:</em>
Creates a minimization weighted objective. The actual objective is
scalar_prod(sub_objectives, weights).</p>
</div>


                            </div>
                            <div id="Solver.WeightedMaximize" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.WeightedMaximize">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">WeightedMaximize</span><span class="signature">(self, *args) -&gt; &#39;operations_research::OptimizeVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">WeightedMaximize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::OptimizeVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Creates a maximization weigthed objective.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Creates a maximization weigthed objective.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_WeightedMaximize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p><em>Overload 1:</em>
Creates a maximization weigthed objective.</p>

<p>|</p>

<p><em>Overload 2:</em>
Creates a maximization weigthed objective.</p>
</div>


                            </div>
                            <div id="Solver.WeightedOptimize" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.WeightedOptimize">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">WeightedOptimize</span><span class="signature">(self, *args) -&gt; &#39;operations_research::OptimizeVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">WeightedOptimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::OptimizeVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Creates a weighted objective with a given sense (true = maximization).</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Creates a weighted objective with a given sense (true = maximization).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_WeightedOptimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p><em>Overload 1:</em>
Creates a weighted objective with a given sense (true = maximization).</p>

<p>|</p>

<p><em>Overload 2:</em>
Creates a weighted objective with a given sense (true = maximization).</p>
</div>


                            </div>
                            <div id="Solver.TabuSearch" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.TabuSearch">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">TabuSearch</span><span class="signature">(
    self,
    maximize: bool,
    v: <a href="#IntVar">pywrapcp.IntVar</a>,
    step: &#39;int64_t&#39;,
    vars: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;,
    keep_tenure: &#39;int64_t&#39;,
    forbid_tenure: &#39;int64_t&#39;,
    tabu_factor: &#39;double&#39;
) -&gt; &#39;operations_research::SearchMonitor *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">TabuSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maximize</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">step</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">keep_tenure</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">forbid_tenure</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">tabu_factor</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SearchMonitor *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        MetaHeuristics which try to get the search out of local optima.</span>
<span class="sd">        Creates a Tabu Search monitor.</span>
<span class="sd">        In the context of local search the behavior is similar to MakeOptimize(),</span>
<span class="sd">        creating an objective in a given sense. The behavior differs once a local</span>
<span class="sd">        optimum is reached: thereafter solutions which degrade the value of the</span>
<span class="sd">        objective are allowed if they are not &quot;tabu&quot;. A solution is &quot;tabu&quot; if it</span>
<span class="sd">        doesn&#39;t respect the following rules:</span>
<span class="sd">        - improving the best solution found so far</span>
<span class="sd">        - variables in the &quot;keep&quot; list must keep their value, variables in the</span>
<span class="sd">        &quot;forbid&quot; list must not take the value they have in the list.</span>
<span class="sd">        Variables with new values enter the tabu lists after each new solution</span>
<span class="sd">        found and leave the lists after a given number of iterations (called</span>
<span class="sd">        tenure). Only the variables passed to the method can enter the lists.</span>
<span class="sd">        The tabu criterion is softened by the tabu factor which gives the number</span>
<span class="sd">        of &quot;tabu&quot; violations which is tolerated; a factor of 1 means no violations</span>
<span class="sd">        allowed; a factor of 0 means all violations are allowed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_TabuSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maximize</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">keep_tenure</span><span class="p">,</span> <span class="n">forbid_tenure</span><span class="p">,</span> <span class="n">tabu_factor</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>MetaHeuristics which try to get the search out of local optima.
Creates a Tabu Search monitor.
In the context of local search the behavior is similar to MakeOptimize(),
creating an objective in a given sense. The behavior differs once a local
optimum is reached: thereafter solutions which degrade the value of the
objective are allowed if they are not "tabu". A solution is "tabu" if it
doesn't respect the following rules:</p>

<ul>
<li>improving the best solution found so far</li>
<li>variables in the "keep" list must keep their value, variables in the
"forbid" list must not take the value they have in the list.
Variables with new values enter the tabu lists after each new solution
found and leave the lists after a given number of iterations (called
tenure). Only the variables passed to the method can enter the lists.
The tabu criterion is softened by the tabu factor which gives the number
of "tabu" violations which is tolerated; a factor of 1 means no violations
allowed; a factor of 0 means all violations are allowed.</li>
</ul>
</div>


                            </div>
                            <div id="Solver.SimulatedAnnealing" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.SimulatedAnnealing">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SimulatedAnnealing</span><span class="signature">(
    self,
    maximize: bool,
    v: <a href="#IntVar">pywrapcp.IntVar</a>,
    step: &#39;int64_t&#39;,
    initial_temperature: &#39;int64_t&#39;
) -&gt; &#39;operations_research::SearchMonitor *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SimulatedAnnealing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maximize</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">step</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">initial_temperature</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SearchMonitor *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Creates a Simulated Annealing monitor.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SimulatedAnnealing</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maximize</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="n">step</span><span class="p">,</span> <span class="n">initial_temperature</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates a Simulated Annealing monitor.</p>
</div>


                            </div>
                            <div id="Solver.LubyRestart" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.LubyRestart">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">LubyRestart</span><span class="signature">(self, scale_factor: int) -&gt; &#39;operations_research::SearchMonitor *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">LubyRestart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale_factor</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SearchMonitor *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This search monitor will restart the search periodically.</span>
<span class="sd">        At the iteration n, it will restart after scale_factor * Luby(n) failures</span>
<span class="sd">        where Luby is the Luby Strategy (i.e. 1 1 2 1 1 2 4 1 1 2 1 1 2 4 8...).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_LubyRestart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scale_factor</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This search monitor will restart the search periodically.
At the iteration n, it will restart after scale_factor * Luby(n) failures
where Luby is the Luby Strategy (i.e. 1 1 2 1 1 2 4 1 1 2 1 1 2 4 8...).</p>
</div>


                            </div>
                            <div id="Solver.ConstantRestart" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.ConstantRestart">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ConstantRestart</span><span class="signature">(self, frequency: int) -&gt; &#39;operations_research::SearchMonitor *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ConstantRestart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frequency</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SearchMonitor *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This search monitor will restart the search periodically after &#39;frequency&#39;</span>
<span class="sd">        failures.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ConstantRestart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">frequency</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This search monitor will restart the search periodically after 'frequency'
failures.</p>
</div>


                            </div>
                            <div id="Solver.TimeLimit" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.TimeLimit">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">TimeLimit</span><span class="signature">(self, *args) -&gt; &#39;operations_research::RegularLimit *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">TimeLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RegularLimit *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_TimeLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.BranchesLimit" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.BranchesLimit">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">BranchesLimit</span><span class="signature">(self, branches: &#39;int64_t&#39;) -&gt; &#39;operations_research::RegularLimit *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">BranchesLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">branches</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RegularLimit *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a search limit that constrains the number of branches</span>
<span class="sd">        explored in the search tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_BranchesLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">branches</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates a search limit that constrains the number of branches
explored in the search tree.</p>
</div>


                            </div>
                            <div id="Solver.FailuresLimit" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.FailuresLimit">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">FailuresLimit</span><span class="signature">(self, failures: &#39;int64_t&#39;) -&gt; &#39;operations_research::RegularLimit *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">FailuresLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">failures</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RegularLimit *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a search limit that constrains the number of failures</span>
<span class="sd">        that can happen when exploring the search tree.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_FailuresLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">failures</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates a search limit that constrains the number of failures
that can happen when exploring the search tree.</p>
</div>


                            </div>
                            <div id="Solver.SolutionsLimit" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.SolutionsLimit">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SolutionsLimit</span><span class="signature">(self, solutions: &#39;int64_t&#39;) -&gt; &#39;operations_research::RegularLimit *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SolutionsLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solutions</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RegularLimit *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a search limit that constrains the number of solutions found</span>
<span class="sd">        during the search.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SolutionsLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solutions</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates a search limit that constrains the number of solutions found
during the search.</p>
</div>


                            </div>
                            <div id="Solver.Limit" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Limit">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Limit</span><span class="signature">(self, *args) -&gt; &#39;operations_research::SearchLimit *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SearchLimit *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Limits the search with the &#39;time&#39;, &#39;branches&#39;, &#39;failures&#39; and</span>
<span class="sd">        &#39;solutions&#39; limits. &#39;smart_time_check&#39; reduces the calls to the wall</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Creates a search limit from its protobuf description</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 3:*</span>
<span class="sd">        Creates a search limit that is reached when either of the underlying limit</span>
<span class="sd">        is reached. That is, the returned limit is more stringent than both</span>
<span class="sd">        argument limits.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p><em>Overload 1:</em>
Limits the search with the 'time', 'branches', 'failures' and
'solutions' limits. 'smart_time_check' reduces the calls to the wall</p>

<p>|</p>

<p><em>Overload 2:</em>
Creates a search limit from its protobuf description</p>

<p>|</p>

<p><em>Overload 3:</em>
Creates a search limit that is reached when either of the underlying limit
is reached. That is, the returned limit is more stringent than both
argument limits.</p>
</div>


                            </div>
                            <div id="Solver.CustomLimit" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.CustomLimit">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">CustomLimit</span><span class="signature">(
    self,
    limiter: &#39;std::function&lt; bool () &gt;&#39;
) -&gt; &#39;operations_research::SearchLimit *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">CustomLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limiter</span><span class="p">:</span> <span class="s2">&quot;std::function&lt; bool () &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SearchLimit *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Callback-based search limit. Search stops when limiter returns true; if</span>
<span class="sd">        this happens at a leaf the corresponding solution will be rejected.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_CustomLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limiter</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Callback-based search limit. Search stops when limiter returns true; if
this happens at a leaf the corresponding solution will be rejected.</p>
</div>


                            </div>
                            <div id="Solver.SearchLog" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.SearchLog">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SearchLog</span><span class="signature">(self, *args) -&gt; &#39;operations_research::SearchMonitor *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SearchLog</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SearchMonitor *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SearchLog</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.SearchTrace" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.SearchTrace">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SearchTrace</span><span class="signature">(
    self,
    prefix: &#39;std::string const &amp;&#39;
) -&gt; &#39;operations_research::SearchMonitor *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SearchTrace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SearchMonitor *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a search monitor that will trace precisely the behavior of the</span>
<span class="sd">        search. Use this only for low level debugging.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SearchTrace</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prefix</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates a search monitor that will trace precisely the behavior of the
search. Use this only for low level debugging.</p>
</div>


                            </div>
                            <div id="Solver.PrintModelVisitor" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.PrintModelVisitor">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">PrintModelVisitor</span><span class="signature">(self) -&gt; &#39;operations_research::ModelVisitor *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">PrintModelVisitor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::ModelVisitor *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Prints the model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_PrintModelVisitor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Prints the model.</p>
</div>


                            </div>
                            <div id="Solver.StatisticsModelVisitor" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.StatisticsModelVisitor">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">StatisticsModelVisitor</span><span class="signature">(self) -&gt; &#39;operations_research::ModelVisitor *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">StatisticsModelVisitor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::ModelVisitor *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Displays some nice statistics on the model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_StatisticsModelVisitor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Displays some nice statistics on the model.</p>
</div>


                            </div>
                            <div id="Solver.AssignVariableValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.AssignVariableValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AssignVariableValue</span><span class="signature">(
    self,
    var: <a href="#IntVar">pywrapcp.IntVar</a>,
    val: &#39;int64_t&#39;
) -&gt; &#39;operations_research::Decision *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AssignVariableValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Decision *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Decisions.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_AssignVariableValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Decisions.</p>
</div>


                            </div>
                            <div id="Solver.VariableLessOrEqualValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.VariableLessOrEqualValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">VariableLessOrEqualValue</span><span class="signature">(
    self,
    var: <a href="#IntVar">pywrapcp.IntVar</a>,
    value: &#39;int64_t&#39;
) -&gt; &#39;operations_research::Decision *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">VariableLessOrEqualValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Decision *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_VariableLessOrEqualValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.VariableGreaterOrEqualValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.VariableGreaterOrEqualValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">VariableGreaterOrEqualValue</span><span class="signature">(
    self,
    var: <a href="#IntVar">pywrapcp.IntVar</a>,
    value: &#39;int64_t&#39;
) -&gt; &#39;operations_research::Decision *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">VariableGreaterOrEqualValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Decision *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_VariableGreaterOrEqualValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.SplitVariableDomain" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.SplitVariableDomain">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SplitVariableDomain</span><span class="signature">(
    self,
    var: <a href="#IntVar">pywrapcp.IntVar</a>,
    val: &#39;int64_t&#39;,
    start_with_lower_half: bool
) -&gt; &#39;operations_research::Decision *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SplitVariableDomain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">start_with_lower_half</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Decision *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SplitVariableDomain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">val</span><span class="p">,</span> <span class="n">start_with_lower_half</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.AssignVariableValueOrFail" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.AssignVariableValueOrFail">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AssignVariableValueOrFail</span><span class="signature">(
    self,
    var: <a href="#IntVar">pywrapcp.IntVar</a>,
    value: &#39;int64_t&#39;
) -&gt; &#39;operations_research::Decision *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AssignVariableValueOrFail</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Decision *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_AssignVariableValueOrFail</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.AssignVariablesValues" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.AssignVariablesValues">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AssignVariablesValues</span><span class="signature">(
    self,
    vars: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;,
    values: &#39;std::vector&lt; int64_t &gt; const &amp;&#39;
) -&gt; &#39;operations_research::Decision *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AssignVariablesValues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Decision *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_AssignVariablesValues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.FailDecision" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.FailDecision">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">FailDecision</span><span class="signature">(self) -&gt; &#39;operations_research::Decision *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">FailDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Decision *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_FailDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.Decision" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Decision">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Decision</span><span class="signature">(
    self,
    apply: &#39;operations_research::Solver::Action&#39;,
    refute: &#39;operations_research::Solver::Action&#39;
) -&gt; &#39;operations_research::Decision *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Decision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">apply</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::Action&quot;</span><span class="p">,</span> <span class="n">refute</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::Action&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Decision *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Decision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">apply</span><span class="p">,</span> <span class="n">refute</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.Compose" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Compose">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Compose</span><span class="signature">(
    self,
    dbs: &#39;std::vector&lt; operations_research::DecisionBuilder * &gt; const &amp;&#39;
) -&gt; &#39;operations_research::DecisionBuilder *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Compose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dbs</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::DecisionBuilder * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Compose</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dbs</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.Try" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Try">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Try</span><span class="signature">(
    self,
    dbs: &#39;std::vector&lt; operations_research::DecisionBuilder * &gt; const &amp;&#39;
) -&gt; &#39;operations_research::DecisionBuilder *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Try</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dbs</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::DecisionBuilder * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Try</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dbs</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.DefaultPhase" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.DefaultPhase">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DefaultPhase</span><span class="signature">(self, *args) -&gt; &#39;operations_research::DecisionBuilder *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">DefaultPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_DefaultPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.ScheduleOrPostpone" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.ScheduleOrPostpone">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ScheduleOrPostpone</span><span class="signature">(
    self,
    var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>,
    est: &#39;int64_t&#39;,
    marker: &#39;int64_t *const&#39;
) -&gt; &#39;operations_research::Decision *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ScheduleOrPostpone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">est</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="p">:</span> <span class="s2">&quot;int64_t *const&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Decision *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a decision that tries to schedule a task at a given time.</span>
<span class="sd">        On the Apply branch, it will set that interval var as performed and set</span>
<span class="sd">        its start to &#39;est&#39;. On the Refute branch, it will just update the</span>
<span class="sd">        &#39;marker&#39; to &#39;est&#39; + 1. This decision is used in the</span>
<span class="sd">        INTERVAL_SET_TIMES_FORWARD strategy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ScheduleOrPostpone</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">est</span><span class="p">,</span> <span class="n">marker</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns a decision that tries to schedule a task at a given time.
On the Apply branch, it will set that interval var as performed and set
its start to 'est'. On the Refute branch, it will just update the
'marker' to 'est' + 1. This decision is used in the
INTERVAL_SET_TIMES_FORWARD strategy.</p>
</div>


                            </div>
                            <div id="Solver.ScheduleOrExpedite" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.ScheduleOrExpedite">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ScheduleOrExpedite</span><span class="signature">(
    self,
    var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>,
    est: &#39;int64_t&#39;,
    marker: &#39;int64_t *const&#39;
) -&gt; &#39;operations_research::Decision *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ScheduleOrExpedite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">est</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">marker</span><span class="p">:</span> <span class="s2">&quot;int64_t *const&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Decision *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a decision that tries to schedule a task at a given time.</span>
<span class="sd">        On the Apply branch, it will set that interval var as performed and set</span>
<span class="sd">        its end to &#39;est&#39;. On the Refute branch, it will just update the</span>
<span class="sd">        &#39;marker&#39; to &#39;est&#39; - 1. This decision is used in the</span>
<span class="sd">        INTERVAL_SET_TIMES_BACKWARD strategy.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ScheduleOrExpedite</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">est</span><span class="p">,</span> <span class="n">marker</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns a decision that tries to schedule a task at a given time.
On the Apply branch, it will set that interval var as performed and set
its end to 'est'. On the Refute branch, it will just update the
'marker' to 'est' - 1. This decision is used in the
INTERVAL_SET_TIMES_BACKWARD strategy.</p>
</div>


                            </div>
                            <div id="Solver.RankFirstInterval" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.RankFirstInterval">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">RankFirstInterval</span><span class="signature">(
    self,
    sequence: <a href="#SequenceVar">pywrapcp.SequenceVar</a>,
    index: int
) -&gt; &#39;operations_research::Decision *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">RankFirstInterval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequence</span><span class="p">:</span> <span class="s2">&quot;SequenceVar&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Decision *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a decision that tries to rank first the ith interval var</span>
<span class="sd">        in the sequence variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_RankFirstInterval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequence</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns a decision that tries to rank first the ith interval var
in the sequence variable.</p>
</div>


                            </div>
                            <div id="Solver.RankLastInterval" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.RankLastInterval">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">RankLastInterval</span><span class="signature">(
    self,
    sequence: <a href="#SequenceVar">pywrapcp.SequenceVar</a>,
    index: int
) -&gt; &#39;operations_research::Decision *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">RankLastInterval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequence</span><span class="p">:</span> <span class="s2">&quot;SequenceVar&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Decision *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a decision that tries to rank last the ith interval var</span>
<span class="sd">        in the sequence variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_RankLastInterval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sequence</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns a decision that tries to rank last the ith interval var
in the sequence variable.</p>
</div>


                            </div>
                            <div id="Solver.Phase" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Phase">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Phase</span><span class="signature">(self, *args) -&gt; &#39;operations_research::DecisionBuilder *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Phase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Phase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.DecisionBuilderFromAssignment" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.DecisionBuilderFromAssignment">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DecisionBuilderFromAssignment</span><span class="signature">(
    self,
    assignment: <a href="#Assignment">pywrapcp.Assignment</a>,
    db: <a href="#DecisionBuilder">pywrapcp.DecisionBuilder</a>,
    vars: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;
) -&gt; &#39;operations_research::DecisionBuilder *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">DecisionBuilderFromAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">db</span><span class="p">:</span> <span class="s2">&quot;DecisionBuilder&quot;</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a decision builder for which the left-most leaf corresponds</span>
<span class="sd">        to assignment, the rest of the tree being explored using &#39;db&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_DecisionBuilderFromAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">,</span> <span class="n">db</span><span class="p">,</span> <span class="nb">vars</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns a decision builder for which the left-most leaf corresponds
to assignment, the rest of the tree being explored using 'db'.</p>
</div>


                            </div>
                            <div id="Solver.ConstraintAdder" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.ConstraintAdder">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ConstraintAdder</span><span class="signature">(
    self,
    ct: <a href="#Constraint">pywrapcp.Constraint</a>
) -&gt; &#39;operations_research::DecisionBuilder *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ConstraintAdder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ct</span><span class="p">:</span> <span class="s2">&quot;Constraint&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a decision builder that will add the given constraint to</span>
<span class="sd">        the model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ConstraintAdder</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ct</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns a decision builder that will add the given constraint to
the model.</p>
</div>


                            </div>
                            <div id="Solver.SolveOnce" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.SolveOnce">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SolveOnce</span><span class="signature">(
    self,
    db: <a href="#DecisionBuilder">pywrapcp.DecisionBuilder</a>,
    monitors: &#39;std::vector&lt; operations_research::SearchMonitor * &gt; const &amp;&#39;
) -&gt; &#39;operations_research::DecisionBuilder *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SolveOnce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">db</span><span class="p">:</span> <span class="s2">&quot;DecisionBuilder&quot;</span><span class="p">,</span> <span class="n">monitors</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::SearchMonitor * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SolveOnce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">db</span><span class="p">,</span> <span class="n">monitors</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.NestedOptimize" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.NestedOptimize">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">NestedOptimize</span><span class="signature">(self, *args) -&gt; &#39;operations_research::DecisionBuilder *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">NestedOptimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_NestedOptimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.RestoreAssignment" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.RestoreAssignment">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">RestoreAssignment</span><span class="signature">(
    self,
    assignment: <a href="#Assignment">pywrapcp.Assignment</a>
) -&gt; &#39;operations_research::DecisionBuilder *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">RestoreAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a DecisionBuilder which restores an Assignment</span>
<span class="sd">        (calls void Assignment::Restore())</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_RestoreAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns a DecisionBuilder which restores an Assignment
(calls void Assignment::Restore())</p>
</div>


                            </div>
                            <div id="Solver.StoreAssignment" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.StoreAssignment">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">StoreAssignment</span><span class="signature">(
    self,
    assignment: <a href="#Assignment">pywrapcp.Assignment</a>
) -&gt; &#39;operations_research::DecisionBuilder *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">StoreAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a DecisionBuilder which stores an Assignment</span>
<span class="sd">        (calls void Assignment::Store())</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_StoreAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns a DecisionBuilder which stores an Assignment
(calls void Assignment::Store())</p>
</div>


                            </div>
                            <div id="Solver.Operator" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Operator">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Operator</span><span class="signature">(self, *args) -&gt; &#39;operations_research::LocalSearchOperator *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::LocalSearchOperator *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Operator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.RandomLnsOperator" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.RandomLnsOperator">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">RandomLnsOperator</span><span class="signature">(self, *args) -&gt; &#39;operations_research::LocalSearchOperator *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">RandomLnsOperator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::LocalSearchOperator *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_RandomLnsOperator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.MoveTowardTargetOperator" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.MoveTowardTargetOperator">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">MoveTowardTargetOperator</span><span class="signature">(self, *args) -&gt; &#39;operations_research::LocalSearchOperator *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">MoveTowardTargetOperator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::LocalSearchOperator *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Creates a local search operator that tries to move the assignment of some</span>
<span class="sd">        variables toward a target. The target is given as an Assignment. This</span>
<span class="sd">        operator generates neighbors in which the only difference compared to the</span>
<span class="sd">        current state is that one variable that belongs to the target assignment</span>
<span class="sd">        is set to its target value.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Creates a local search operator that tries to move the assignment of some</span>
<span class="sd">        variables toward a target. The target is given either as two vectors: a</span>
<span class="sd">        vector of variables and a vector of associated target values. The two</span>
<span class="sd">        vectors should be of the same length. This operator generates neighbors in</span>
<span class="sd">        which the only difference compared to the current state is that one</span>
<span class="sd">        variable that belongs to the given vector is set to its target value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_MoveTowardTargetOperator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p><em>Overload 1:</em>
Creates a local search operator that tries to move the assignment of some
variables toward a target. The target is given as an Assignment. This
operator generates neighbors in which the only difference compared to the
current state is that one variable that belongs to the target assignment
is set to its target value.</p>

<p>|</p>

<p><em>Overload 2:</em>
Creates a local search operator that tries to move the assignment of some
variables toward a target. The target is given either as two vectors: a
vector of variables and a vector of associated target values. The two
vectors should be of the same length. This operator generates neighbors in
which the only difference compared to the current state is that one
variable that belongs to the given vector is set to its target value.</p>
</div>


                            </div>
                            <div id="Solver.ConcatenateOperators" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.ConcatenateOperators">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ConcatenateOperators</span><span class="signature">(self, *args) -&gt; &#39;operations_research::LocalSearchOperator *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ConcatenateOperators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::LocalSearchOperator *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ConcatenateOperators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.RandomConcatenateOperators" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.RandomConcatenateOperators">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">RandomConcatenateOperators</span><span class="signature">(self, *args) -&gt; &#39;operations_research::LocalSearchOperator *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">RandomConcatenateOperators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::LocalSearchOperator *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Randomized version of local search concatenator; calls a random operator</span>
<span class="sd">        at each call to MakeNextNeighbor().</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Randomized version of local search concatenator; calls a random operator</span>
<span class="sd">        at each call to MakeNextNeighbor(). The provided seed is used to</span>
<span class="sd">        initialize the random number generator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_RandomConcatenateOperators</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p><em>Overload 1:</em>
Randomized version of local search concatenator; calls a random operator
at each call to MakeNextNeighbor().</p>

<p>|</p>

<p><em>Overload 2:</em>
Randomized version of local search concatenator; calls a random operator
at each call to MakeNextNeighbor(). The provided seed is used to
initialize the random number generator.</p>
</div>


                            </div>
                            <div id="Solver.NeighborhoodLimit" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.NeighborhoodLimit">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">NeighborhoodLimit</span><span class="signature">(
    self,
    op: <a href="#LocalSearchOperator">pywrapcp.LocalSearchOperator</a>,
    limit: &#39;int64_t&#39;
) -&gt; &#39;operations_research::LocalSearchOperator *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">NeighborhoodLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">:</span> <span class="s2">&quot;LocalSearchOperator&quot;</span><span class="p">,</span> <span class="n">limit</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::LocalSearchOperator *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a local search operator that wraps another local search</span>
<span class="sd">        operator and limits the number of neighbors explored (i.e., calls</span>
<span class="sd">        to MakeNextNeighbor from the current solution (between two calls</span>
<span class="sd">        to Start()). When this limit is reached, MakeNextNeighbor()</span>
<span class="sd">        returns false. The counter is cleared when Start() is called.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_NeighborhoodLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">op</span><span class="p">,</span> <span class="n">limit</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates a local search operator that wraps another local search
operator and limits the number of neighbors explored (i.e., calls
to MakeNextNeighbor from the current solution (between two calls
to Start()). When this limit is reached, MakeNextNeighbor()
returns false. The counter is cleared when Start() is called.</p>
</div>


                            </div>
                            <div id="Solver.LocalSearchPhase" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.LocalSearchPhase">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">LocalSearchPhase</span><span class="signature">(self, *args) -&gt; &#39;operations_research::DecisionBuilder *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">LocalSearchPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_LocalSearchPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.LocalSearchPhaseParameters" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.LocalSearchPhaseParameters">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">LocalSearchPhaseParameters</span><span class="signature">(self, *args) -&gt; &#39;operations_research::LocalSearchPhaseParameters *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">LocalSearchPhaseParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::LocalSearchPhaseParameters *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_LocalSearchPhaseParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.SearchDepth" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.SearchDepth">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SearchDepth</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SearchDepth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the search depth of the current active search. Returns -1 if</span>
<span class="sd">        there is no active search opened.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SearchDepth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Gets the search depth of the current active search. Returns -1 if
there is no active search opened.</p>
</div>


                            </div>
                            <div id="Solver.SearchLeftDepth" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.SearchLeftDepth">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SearchLeftDepth</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SearchLeftDepth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the search left depth of the current active search. Returns -1 if</span>
<span class="sd">        there is no active search opened.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SearchLeftDepth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Gets the search left depth of the current active search. Returns -1 if
there is no active search opened.</p>
</div>


                            </div>
                            <div id="Solver.SolveDepth" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.SolveDepth">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SolveDepth</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SolveDepth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the number of nested searches. It returns 0 outside search,</span>
<span class="sd">        1 during the top level search, 2 or more in case of nested searches.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SolveDepth</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Gets the number of nested searches. It returns 0 outside search,
1 during the top level search, 2 or more in case of nested searches.</p>
</div>


                            </div>
                            <div id="Solver.Rand64" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Rand64">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Rand64</span><span class="signature">(self, size: &#39;int64_t&#39;) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Rand64</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns a random value between 0 and &#39;size&#39; - 1;&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Rand64</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns a random value between 0 and 'size' - 1;</p>
</div>


                            </div>
                            <div id="Solver.Rand32" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Rand32">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Rand32</span><span class="signature">(self, size: &#39;int32_t&#39;) -&gt; &#39;int32_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Rand32</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">:</span> <span class="s2">&quot;int32_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int32_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns a random value between 0 and &#39;size&#39; - 1;&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Rand32</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">size</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns a random value between 0 and 'size' - 1;</p>
</div>


                            </div>
                            <div id="Solver.ReSeed" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.ReSeed">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ReSeed</span><span class="signature">(self, seed: &#39;int32_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ReSeed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">:</span> <span class="s2">&quot;int32_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Reseed the solver random generator.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ReSeed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">seed</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Reseed the solver random generator.</p>
</div>


                            </div>
                            <div id="Solver.LocalSearchProfile" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.LocalSearchProfile">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">LocalSearchProfile</span><span class="signature">(self) -&gt; &#39;std::string&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">LocalSearchProfile</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns local search profiling information in a human readable format.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_LocalSearchProfile</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns local search profiling information in a human readable format.</p>
</div>


                            </div>
                            <div id="Solver.Constraints" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Constraints">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Constraints</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Counts the number of constraints that have been added</span>
<span class="sd">        to the solver before the search.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Counts the number of constraints that have been added
to the solver before the search.</p>
</div>


                            </div>
                            <div id="Solver.Accept" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Accept">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Accept</span><span class="signature">(self, visitor: &#39;operations_research::ModelVisitor *const&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Accept</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">visitor</span><span class="p">:</span> <span class="s2">&quot;operations_research::ModelVisitor *const&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Accepts the given model visitor.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_Accept</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">visitor</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Accepts the given model visitor.</p>
</div>


                            </div>
                            <div id="Solver.FinishCurrentSearch" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.FinishCurrentSearch">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">FinishCurrentSearch</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">FinishCurrentSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Tells the solver to kill or restart the current search.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_FinishCurrentSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Tells the solver to kill or restart the current search.</p>
</div>


                            </div>
                            <div id="Solver.RestartCurrentSearch" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.RestartCurrentSearch">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">RestartCurrentSearch</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">RestartCurrentSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_RestartCurrentSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.ShouldFail" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.ShouldFail">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ShouldFail</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ShouldFail</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        These methods are only useful for the SWIG wrappers, which need a way</span>
<span class="sd">        to externally cause the Solver to fail.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ShouldFail</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>These methods are only useful for the SWIG wrappers, which need a way
to externally cause the Solver to fail.</p>
</div>


                            </div>
                            <div id="Solver.Add" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Add">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Add</span><span class="signature">(self, ct)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ct</span><span class="p">):</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">ct</span><span class="p">,</span> <span class="n">PyConstraint</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__python_constraints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">AddConstraint</span><span class="p">(</span><span class="n">ct</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.TreeNoCycle" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.TreeNoCycle">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">TreeNoCycle</span><span class="signature">(
    self,
    nexts: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;,
    active: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;,
    callback: &#39;operations_research::Solver::IndexFilter1&#39; = 0
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">TreeNoCycle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nexts</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">active</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IndexFilter1&quot;</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_TreeNoCycle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">nexts</span><span class="p">,</span> <span class="n">active</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.SearchLogWithCallback" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.SearchLogWithCallback">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SearchLogWithCallback</span><span class="signature">(
    self,
    period: int,
    callback: &#39;std::function&lt; std::string () &gt;&#39;
) -&gt; &#39;operations_research::SearchMonitor *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SearchLogWithCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">period</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="s2">&quot;std::function&lt; std::string () &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SearchMonitor *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SearchLogWithCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.ElementFunction" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.ElementFunction">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ElementFunction</span><span class="signature">(
    self,
    values: &#39;std::function&lt; int64_t (int64_t) &gt;&#39;,
    index: <a href="#IntVar">pywrapcp.IntVar</a>
) -&gt; &#39;operations_research::IntExpr *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ElementFunction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="s2">&quot;std::function&lt; int64_t (int64_t) &gt;&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_ElementFunction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.VarEvalValStrPhase" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.VarEvalValStrPhase">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">VarEvalValStrPhase</span><span class="signature">(
    self,
    vars: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;,
    var_evaluator: &#39;std::function&lt; int64_t (int64_t) &gt;&#39;,
    val_str: &#39;operations_research::Solver::IntValueStrategy&#39;
) -&gt; &#39;operations_research::DecisionBuilder *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">VarEvalValStrPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">var_evaluator</span><span class="p">:</span> <span class="s2">&quot;std::function&lt; int64_t (int64_t) &gt;&quot;</span><span class="p">,</span> <span class="n">val_str</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IntValueStrategy&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_VarEvalValStrPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">var_evaluator</span><span class="p">,</span> <span class="n">val_str</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.VarStrValEvalPhase" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.VarStrValEvalPhase">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">VarStrValEvalPhase</span><span class="signature">(
    self,
    vars: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;,
    var_str: &#39;operations_research::Solver::IntVarStrategy&#39;,
    val_eval: &#39;operations_research::Solver::IndexEvaluator2&#39;
) -&gt; &#39;operations_research::DecisionBuilder *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">VarStrValEvalPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">var_str</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IntVarStrategy&quot;</span><span class="p">,</span> <span class="n">val_eval</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IndexEvaluator2&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_VarStrValEvalPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">var_str</span><span class="p">,</span> <span class="n">val_eval</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.VarEvalValEvalPhase" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.VarEvalValEvalPhase">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">VarEvalValEvalPhase</span><span class="signature">(
    self,
    vars: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;,
    var_eval: &#39;std::function&lt; int64_t (int64_t) &gt;&#39;,
    val_eval: &#39;operations_research::Solver::IndexEvaluator2&#39;
) -&gt; &#39;operations_research::DecisionBuilder *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">VarEvalValEvalPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">var_eval</span><span class="p">:</span> <span class="s2">&quot;std::function&lt; int64_t (int64_t) &gt;&quot;</span><span class="p">,</span> <span class="n">val_eval</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IndexEvaluator2&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_VarEvalValEvalPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">var_eval</span><span class="p">,</span> <span class="n">val_eval</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.VarStrValEvalTieBreakPhase" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.VarStrValEvalTieBreakPhase">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">VarStrValEvalTieBreakPhase</span><span class="signature">(
    self,
    vars: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;,
    var_str: &#39;operations_research::Solver::IntVarStrategy&#39;,
    val_eval: &#39;operations_research::Solver::IndexEvaluator2&#39;,
    tie_breaker: &#39;std::function&lt; int64_t (int64_t) &gt;&#39;
) -&gt; &#39;operations_research::DecisionBuilder *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">VarStrValEvalTieBreakPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">var_str</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IntVarStrategy&quot;</span><span class="p">,</span> <span class="n">val_eval</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IndexEvaluator2&quot;</span><span class="p">,</span> <span class="n">tie_breaker</span><span class="p">:</span> <span class="s2">&quot;std::function&lt; int64_t (int64_t) &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_VarStrValEvalTieBreakPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">var_str</span><span class="p">,</span> <span class="n">val_eval</span><span class="p">,</span> <span class="n">tie_breaker</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.VarEvalValEvalTieBreakPhase" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.VarEvalValEvalTieBreakPhase">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">VarEvalValEvalTieBreakPhase</span><span class="signature">(
    self,
    vars: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;,
    var_eval: &#39;std::function&lt; int64_t (int64_t) &gt;&#39;,
    val_eval: &#39;operations_research::Solver::IndexEvaluator2&#39;,
    tie_breaker: &#39;std::function&lt; int64_t (int64_t) &gt;&#39;
) -&gt; &#39;operations_research::DecisionBuilder *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">VarEvalValEvalTieBreakPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">var_eval</span><span class="p">:</span> <span class="s2">&quot;std::function&lt; int64_t (int64_t) &gt;&quot;</span><span class="p">,</span> <span class="n">val_eval</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IndexEvaluator2&quot;</span><span class="p">,</span> <span class="n">tie_breaker</span><span class="p">:</span> <span class="s2">&quot;std::function&lt; int64_t (int64_t) &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_VarEvalValEvalTieBreakPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">var_eval</span><span class="p">,</span> <span class="n">val_eval</span><span class="p">,</span> <span class="n">tie_breaker</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.EvalEvalStrPhase" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.EvalEvalStrPhase">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">EvalEvalStrPhase</span><span class="signature">(
    self,
    vars: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;,
    evaluator: &#39;operations_research::Solver::IndexEvaluator2&#39;,
    str: &#39;operations_research::Solver::EvaluatorStrategy&#39;
) -&gt; &#39;operations_research::DecisionBuilder *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">EvalEvalStrPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">evaluator</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IndexEvaluator2&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::EvaluatorStrategy&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_EvalEvalStrPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">evaluator</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.EvalEvalStrTieBreakPhase" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.EvalEvalStrTieBreakPhase">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">EvalEvalStrTieBreakPhase</span><span class="signature">(
    self,
    vars: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;,
    evaluator: &#39;operations_research::Solver::IndexEvaluator2&#39;,
    tie_breaker: &#39;operations_research::Solver::IndexEvaluator1&#39;,
    str: &#39;operations_research::Solver::EvaluatorStrategy&#39;
) -&gt; &#39;operations_research::DecisionBuilder *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">EvalEvalStrTieBreakPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">evaluator</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IndexEvaluator2&quot;</span><span class="p">,</span> <span class="n">tie_breaker</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IndexEvaluator1&quot;</span><span class="p">,</span> <span class="nb">str</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::EvaluatorStrategy&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_EvalEvalStrTieBreakPhase</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">evaluator</span><span class="p">,</span> <span class="n">tie_breaker</span><span class="p">,</span> <span class="nb">str</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.GuidedLocalSearch" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.GuidedLocalSearch">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GuidedLocalSearch</span><span class="signature">(self, *args) -&gt; &#39;operations_research::SearchMonitor *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GuidedLocalSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SearchMonitor *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_GuidedLocalSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.SumObjectiveFilter" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.SumObjectiveFilter">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SumObjectiveFilter</span><span class="signature">(
    self,
    vars: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;,
    values: &#39;operations_research::Solver::IndexEvaluator2&#39;,
    filter_enum: &#39;operations_research::Solver::LocalSearchFilterBound&#39;
) -&gt; &#39;operations_research::LocalSearchFilter *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SumObjectiveFilter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IndexEvaluator2&quot;</span><span class="p">,</span> <span class="n">filter_enum</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::LocalSearchFilterBound&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::LocalSearchFilter *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_SumObjectiveFilter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">filter_enum</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                </section>
                <section id="Solver_DefaultSolverParameters">
                            <div class="attr function"><a class="headerlink" href="#Solver_DefaultSolverParameters">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Solver_DefaultSolverParameters</span><span class="signature">() -&gt; &#39;operations_research::ConstraintSolverParameters&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Solver_DefaultSolverParameters</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::ConstraintSolverParameters&quot;</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Create a ConstraintSolverParameters proto with all the default values.&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_DefaultSolverParameters</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>Create a ConstraintSolverParameters proto with all the default values.</p>
</div>


                </section>
                <section id="Solver_MemoryUsage">
                            <div class="attr function"><a class="headerlink" href="#Solver_MemoryUsage">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Solver_MemoryUsage</span><span class="signature">() -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Solver_MemoryUsage</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Current memory usage in bytes&quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Solver_MemoryUsage</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>Current memory usage in bytes</p>
</div>


                </section>
                <section id="BaseObject">
                                <div class="attr class">
        <a class="headerlink" href="#BaseObject">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">BaseObject</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">BaseObject</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A BaseObject is the root of all reversibly allocated objects.</span>
<span class="sd">    A DebugString method and the associated &lt;&lt; operator are implemented</span>
<span class="sd">    as a convenience.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">BaseObject</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BaseObject_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_BaseObject</span><span class="p">(</span><span class="n">_self</span><span class="p">,</span> <span class="p">))</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_BaseObject</span>

    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BaseObject_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BaseObject___str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BaseObject___repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__disown__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">disown</span><span class="p">()</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">disown_BaseObject</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>A BaseObject is the root of all reversibly allocated objects.
A DebugString method and the associated &lt;&lt; operator are implemented
as a convenience.</p>
</div>


                            <div id="BaseObject.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#BaseObject.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">BaseObject</span><span class="signature">()</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">BaseObject</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BaseObject_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_BaseObject</span><span class="p">(</span><span class="n">_self</span><span class="p">,</span> <span class="p">))</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="BaseObject.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#BaseObject.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="BaseObject.DebugString" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#BaseObject.DebugString">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DebugString</span><span class="signature">(self) -&gt; &#39;std::string&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BaseObject_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                </section>
                <section id="PropagationBaseObject">
                                <div class="attr class">
        <a class="headerlink" href="#PropagationBaseObject">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">PropagationBaseObject</span><wbr>(<span class="base"><a href="#BaseObject">BaseObject</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">PropagationBaseObject</span><span class="p">(</span><span class="n">BaseObject</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    NOLINT</span>
<span class="sd">    The PropagationBaseObject is a subclass of BaseObject that is also</span>
<span class="sd">    friend to the Solver class. It allows accessing methods useful when</span>
<span class="sd">    writing new constraints or new expressions.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">PropagationBaseObject</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">PropagationBaseObject_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_PropagationBaseObject</span><span class="p">(</span><span class="n">_self</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_PropagationBaseObject</span>

    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">PropagationBaseObject_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Solver *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">PropagationBaseObject_solver</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Object naming.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">PropagationBaseObject_Name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__disown__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">disown</span><span class="p">()</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">disown_PropagationBaseObject</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>NOLINT
The PropagationBaseObject is a subclass of BaseObject that is also
friend to the Solver class. It allows accessing methods useful when
writing new constraints or new expressions.</p>
</div>


                            <div id="PropagationBaseObject.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PropagationBaseObject.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">PropagationBaseObject</span><span class="signature">(s: <a href="#Solver">pywrapcp.Solver</a>)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">PropagationBaseObject</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">PropagationBaseObject_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_PropagationBaseObject</span><span class="p">(</span><span class="n">_self</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="PropagationBaseObject.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#PropagationBaseObject.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="PropagationBaseObject.DebugString" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PropagationBaseObject.DebugString">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DebugString</span><span class="signature">(self) -&gt; &#39;std::string&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">PropagationBaseObject_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="PropagationBaseObject.solver" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PropagationBaseObject.solver">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">solver</span><span class="signature">(self) -&gt; &#39;operations_research::Solver *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Solver *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">PropagationBaseObject_solver</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="PropagationBaseObject.Name" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PropagationBaseObject.Name">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Name</span><span class="signature">(self) -&gt; &#39;std::string&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Object naming.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">PropagationBaseObject_Name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Object naming.</p>
</div>


                            </div>
                </section>
                <section id="Decision">
                                <div class="attr class">
        <a class="headerlink" href="#Decision">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">Decision</span><wbr>(<span class="base"><a href="#BaseObject">BaseObject</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Decision</span><span class="p">(</span><span class="n">BaseObject</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Decision represents a choice point in the search tree. The two main</span>
<span class="sd">    methods are Apply() to go left, or Refute() to go right.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">Decision</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Decision_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_Decision</span><span class="p">(</span><span class="n">_self</span><span class="p">,</span> <span class="p">))</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_Decision</span>

    <span class="k">def</span> <span class="nf">ApplyWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Apply will be called first when the decision is executed.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Decision_ApplyWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RefuteWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Refute will be called after a backtrack.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Decision_RefuteWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Decision_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Decision___repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Decision___str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__disown__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">disown</span><span class="p">()</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">disown_Decision</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>A Decision represents a choice point in the search tree. The two main
methods are Apply() to go left, or Refute() to go right.</p>
</div>


                            <div id="Decision.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Decision.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">Decision</span><span class="signature">()</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">Decision</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Decision_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_Decision</span><span class="p">(</span><span class="n">_self</span><span class="p">,</span> <span class="p">))</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Decision.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Decision.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="Decision.ApplyWrapper" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Decision.ApplyWrapper">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ApplyWrapper</span><span class="signature">(self, s: <a href="#Solver">pywrapcp.Solver</a>) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ApplyWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Apply will be called first when the decision is executed.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Decision_ApplyWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Apply will be called first when the decision is executed.</p>
</div>


                            </div>
                            <div id="Decision.RefuteWrapper" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Decision.RefuteWrapper">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">RefuteWrapper</span><span class="signature">(self, s: <a href="#Solver">pywrapcp.Solver</a>) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">RefuteWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Refute will be called after a backtrack.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Decision_RefuteWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Refute will be called after a backtrack.</p>
</div>


                            </div>
                            <div id="Decision.DebugString" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Decision.DebugString">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DebugString</span><span class="signature">(self) -&gt; &#39;std::string&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Decision_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                </section>
                <section id="DecisionBuilder">
                                <div class="attr class">
        <a class="headerlink" href="#DecisionBuilder">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">DecisionBuilder</span><wbr>(<span class="base"><a href="#BaseObject">BaseObject</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">DecisionBuilder</span><span class="p">(</span><span class="n">BaseObject</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A DecisionBuilder is responsible for creating the search tree. The</span>
<span class="sd">    important method is Next(), which returns the next decision to execute.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">DecisionBuilder</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DecisionBuilder_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_DecisionBuilder</span><span class="p">(</span><span class="n">_self</span><span class="p">,</span> <span class="p">))</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_DecisionBuilder</span>

    <span class="k">def</span> <span class="nf">NextWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Decision *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is the main method of the decision builder class. It must</span>
<span class="sd">        return a decision (an instance of the class Decision). If it</span>
<span class="sd">        returns nullptr, this means that the decision builder has finished</span>
<span class="sd">        its work.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DecisionBuilder_NextWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DecisionBuilder_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DecisionBuilder___repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DecisionBuilder___str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__disown__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">disown</span><span class="p">()</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">disown_DecisionBuilder</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>A DecisionBuilder is responsible for creating the search tree. The
important method is Next(), which returns the next decision to execute.</p>
</div>


                            <div id="DecisionBuilder.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DecisionBuilder.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">DecisionBuilder</span><span class="signature">()</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">DecisionBuilder</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DecisionBuilder_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_DecisionBuilder</span><span class="p">(</span><span class="n">_self</span><span class="p">,</span> <span class="p">))</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="DecisionBuilder.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#DecisionBuilder.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="DecisionBuilder.NextWrapper" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DecisionBuilder.NextWrapper">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">NextWrapper</span><span class="signature">(self, s: <a href="#Solver">pywrapcp.Solver</a>) -&gt; &#39;operations_research::Decision *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">NextWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Decision *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is the main method of the decision builder class. It must</span>
<span class="sd">        return a decision (an instance of the class Decision). If it</span>
<span class="sd">        returns nullptr, this means that the decision builder has finished</span>
<span class="sd">        its work.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DecisionBuilder_NextWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This is the main method of the decision builder class. It must
return a decision (an instance of the class Decision). If it
returns nullptr, this means that the decision builder has finished
its work.</p>
</div>


                            </div>
                            <div id="DecisionBuilder.DebugString" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DecisionBuilder.DebugString">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DebugString</span><span class="signature">(self) -&gt; &#39;std::string&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DecisionBuilder_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                </section>
                <section id="Demon">
                                <div class="attr class">
        <a class="headerlink" href="#Demon">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">Demon</span><wbr>(<span class="base"><a href="#BaseObject">BaseObject</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Demon</span><span class="p">(</span><span class="n">BaseObject</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A Demon is the base element of a propagation queue. It is the main</span>
<span class="sd">      object responsible for implementing the actual propagation</span>
<span class="sd">      of the constraint and pruning the inconsistent values in the domains</span>
<span class="sd">      of the variables. The main concept is that demons are listeners that are</span>
<span class="sd">      attached to the variables and listen to their modifications.</span>
<span class="sd">    There are two methods:</span>
<span class="sd">     - Run() is the actual method called when the demon is processed.</span>
<span class="sd">     - priority() returns its priority. Standard priorities are slow, normal</span>
<span class="sd">       or fast. &quot;immediate&quot; is reserved for variables and is treated separately.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This indicates the priority of a demon. Immediate demons are treated</span>
<span class="sd">        separately and corresponds to variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">Demon</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Demon_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_Demon</span><span class="p">(</span><span class="n">_self</span><span class="p">,</span> <span class="p">))</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_Demon</span>

    <span class="k">def</span> <span class="nf">RunWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This is the main callback of the demon.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Demon_RunWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Priority</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Solver::DemonPriority&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns the priority of the demon. Usually a demon is</span>
<span class="sd">        fast, slow or normal. Immediate demons are reserved for internal</span>
<span class="sd">        use to maintain variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Demon_Priority</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Demon_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Inhibit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method inhibits the demon in the search tree below the</span>
<span class="sd">        current position.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Demon_Inhibit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Desinhibit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This method un-inhibits the demon that was previously inhibited.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Demon_Desinhibit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__disown__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">disown</span><span class="p">()</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">disown_Demon</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>A Demon is the base element of a propagation queue. It is the main
  object responsible for implementing the actual propagation
  of the constraint and pruning the inconsistent values in the domains
  of the variables. The main concept is that demons are listeners that are
  attached to the variables and listen to their modifications.</p>

<h6 id="there-are-two-methods">There are two methods</h6>

<blockquote>
  <ul>
  <li>Run() is the actual method called when the demon is processed.</li>
  <li>priority() returns its priority. Standard priorities are slow, normal
  or fast. "immediate" is reserved for variables and is treated separately.</li>
  </ul>
</blockquote>
</div>


                            <div id="Demon.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Demon.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">Demon</span><span class="signature">()</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This indicates the priority of a demon. Immediate demons are treated</span>
<span class="sd">        separately and corresponds to variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">Demon</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Demon_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_Demon</span><span class="p">(</span><span class="n">_self</span><span class="p">,</span> <span class="p">))</span>
</pre></div>

        </details>

            <div class="docstring"><p>This indicates the priority of a demon. Immediate demons are treated
separately and corresponds to variables.</p>
</div>


                            </div>
                            <div id="Demon.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Demon.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="Demon.RunWrapper" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Demon.RunWrapper">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">RunWrapper</span><span class="signature">(self, s: <a href="#Solver">pywrapcp.Solver</a>) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">RunWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This is the main callback of the demon.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Demon_RunWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This is the main callback of the demon.</p>
</div>


                            </div>
                            <div id="Demon.Priority" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Demon.Priority">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Priority</span><span class="signature">(self) -&gt; &#39;operations_research::Solver::DemonPriority&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Priority</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Solver::DemonPriority&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns the priority of the demon. Usually a demon is</span>
<span class="sd">        fast, slow or normal. Immediate demons are reserved for internal</span>
<span class="sd">        use to maintain variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Demon_Priority</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method returns the priority of the demon. Usually a demon is
fast, slow or normal. Immediate demons are reserved for internal
use to maintain variables.</p>
</div>


                            </div>
                            <div id="Demon.DebugString" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Demon.DebugString">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DebugString</span><span class="signature">(self) -&gt; &#39;std::string&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Demon_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Demon.Inhibit" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Demon.Inhibit">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Inhibit</span><span class="signature">(self, s: <a href="#Solver">pywrapcp.Solver</a>) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Inhibit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method inhibits the demon in the search tree below the</span>
<span class="sd">        current position.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Demon_Inhibit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method inhibits the demon in the search tree below the
current position.</p>
</div>


                            </div>
                            <div id="Demon.Desinhibit" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Demon.Desinhibit">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Desinhibit</span><span class="signature">(self, s: <a href="#Solver">pywrapcp.Solver</a>) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Desinhibit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This method un-inhibits the demon that was previously inhibited.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Demon_Desinhibit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method un-inhibits the demon that was previously inhibited.</p>
</div>


                            </div>
                </section>
                <section id="Constraint">
                                <div class="attr class">
        <a class="headerlink" href="#Constraint">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">Constraint</span><wbr>(<span class="base"><a href="#PropagationBaseObject">PropagationBaseObject</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Constraint</span><span class="p">(</span><span class="n">PropagationBaseObject</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A constraint is the main modeling object. It provides two methods:</span>
<span class="sd">      - Post() is responsible for creating the demons and attaching them to</span>
<span class="sd">        immediate demons().</span>
<span class="sd">      - InitialPropagate() is called once just after Post and performs</span>
<span class="sd">        the initial propagation. The subsequent propagations will be performed</span>
<span class="sd">        by the demons Posted during the post() method.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">Constraint</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_Constraint</span><span class="p">(</span><span class="n">_self</span><span class="p">,</span> <span class="n">solver</span><span class="p">))</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_Constraint</span>

    <span class="k">def</span> <span class="nf">Post</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called when the constraint is processed by the</span>
<span class="sd">        solver. Its main usage is to attach demons to variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint_Post</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">InitialPropagateWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method performs the initial propagation of the</span>
<span class="sd">        constraint. It is called just after the post.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint_InitialPropagateWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a Boolean variable representing the status of the constraint</span>
<span class="sd">        (false = constraint is violated, true = constraint is satisfied). It</span>
<span class="sd">        returns nullptr if the constraint does not support this API.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint_Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint___repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint___str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint___add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint___radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint___sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint___rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint___mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint___rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__floordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint___floordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint___neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint___abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Square</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint_Square</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint___eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint___ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint___ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint___gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint___le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint___lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">MapTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint_MapTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IndexOf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint_IndexOf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__disown__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">disown</span><span class="p">()</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">disown_Constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>A constraint is the main modeling object. It provides two methods:</p>

<ul>
<li>Post() is responsible for creating the demons and attaching them to
immediate demons().</li>
<li>InitialPropagate() is called once just after Post and performs
the initial propagation. The subsequent propagations will be performed
by the demons Posted during the post() method.</li>
</ul>
</div>


                            <div id="Constraint.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Constraint.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">Constraint</span><span class="signature">(solver: <a href="#Solver">pywrapcp.Solver</a>)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">Constraint</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_Constraint</span><span class="p">(</span><span class="n">_self</span><span class="p">,</span> <span class="n">solver</span><span class="p">))</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Constraint.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Constraint.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="Constraint.Post" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Constraint.Post">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Post</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Post</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called when the constraint is processed by the</span>
<span class="sd">        solver. Its main usage is to attach demons to variables.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint_Post</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method is called when the constraint is processed by the
solver. Its main usage is to attach demons to variables.</p>
</div>


                            </div>
                            <div id="Constraint.InitialPropagateWrapper" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Constraint.InitialPropagateWrapper">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">InitialPropagateWrapper</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">InitialPropagateWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method performs the initial propagation of the</span>
<span class="sd">        constraint. It is called just after the post.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint_InitialPropagateWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method performs the initial propagation of the
constraint. It is called just after the post.</p>
</div>


                            </div>
                            <div id="Constraint.DebugString" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Constraint.DebugString">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DebugString</span><span class="signature">(self) -&gt; &#39;std::string&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Constraint.Var" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Constraint.Var">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Var</span><span class="signature">(self) -&gt; &#39;operations_research::IntVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a Boolean variable representing the status of the constraint</span>
<span class="sd">        (false = constraint is violated, true = constraint is satisfied). It</span>
<span class="sd">        returns nullptr if the constraint does not support this API.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint_Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates a Boolean variable representing the status of the constraint
(false = constraint is violated, true = constraint is satisfied). It
returns nullptr if the constraint does not support this API.</p>
</div>


                            </div>
                            <div id="Constraint.Square" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Constraint.Square">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Square</span><span class="signature">(self) -&gt; &#39;operations_research::IntExpr *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Square</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint_Square</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Constraint.MapTo" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Constraint.MapTo">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">MapTo</span><span class="signature">(
    self,
    vars: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">MapTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint_MapTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Constraint.IndexOf" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Constraint.IndexOf">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IndexOf</span><span class="signature">(self, *args) -&gt; &#39;operations_research::IntExpr *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IndexOf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Constraint_IndexOf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#PropagationBaseObject">PropagationBaseObject</a></dt>
                                <dd id="Constraint.solver" class="function"><a href="#PropagationBaseObject.solver">solver</a></dd>
                <dd id="Constraint.Name" class="function"><a href="#PropagationBaseObject.Name">Name</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="SearchMonitor">
                                <div class="attr class">
        <a class="headerlink" href="#SearchMonitor">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">SearchMonitor</span><wbr>(<span class="base"><a href="#BaseObject">BaseObject</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">SearchMonitor</span><span class="p">(</span><span class="n">BaseObject</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; A search monitor is a simple set of callbacks to monitor all search events&quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">SearchMonitor</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_SearchMonitor</span><span class="p">(</span><span class="n">_self</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_SearchMonitor</span>

    <span class="k">def</span> <span class="nf">EnterSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Beginning of the search.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_EnterSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RestartSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Restart the search.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_RestartSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ExitSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; End of the search.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_ExitSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">BeginNextDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="s2">&quot;DecisionBuilder&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Before calling DecisionBuilder::Next.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_BeginNextDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndNextDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="s2">&quot;DecisionBuilder&quot;</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="s2">&quot;Decision&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; After calling DecisionBuilder::Next, along with the returned decision.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_EndNextDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ApplyDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="s2">&quot;Decision&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Before applying the decision.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_ApplyDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RefuteDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="s2">&quot;Decision&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Before refuting the decision.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_RefuteDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AfterDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="s2">&quot;Decision&quot;</span><span class="p">,</span> <span class="n">apply</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Just after refuting or applying the decision, apply is true after Apply.</span>
<span class="sd">        This is called only if the Apply() or Refute() methods have not failed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_AfterDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">apply</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">BeginFail</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Just when the failure occurs.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_BeginFail</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndFail</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; After completing the backtrack.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_EndFail</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">BeginInitialPropagation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Before the initial propagation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_BeginInitialPropagation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndInitialPropagation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; After the initial propagation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_EndInitialPropagation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AcceptSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called when a solution is found. It asserts whether the</span>
<span class="sd">        solution is valid. A value of false indicates that the solution</span>
<span class="sd">        should be discarded.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_AcceptSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AtSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called when a valid solution is found. If the</span>
<span class="sd">        return value is true, then search will resume after. If the result</span>
<span class="sd">        is false, then search will stop there.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_AtSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NoMoreSolutions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; When the search tree is finished.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_NoMoreSolutions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">LocalOptimum</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        When a local optimum is reached. If &#39;true&#39; is returned, the last solution</span>
<span class="sd">        is discarded and the search proceeds with the next one.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_LocalOptimum</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AcceptDelta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_AcceptDelta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AcceptNeighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; After accepting a neighbor during local search.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_AcceptNeighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Solver *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_solver</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor___repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor___str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__disown__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">disown</span><span class="p">()</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">disown_SearchMonitor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>A search monitor is a simple set of callbacks to monitor all search events</p>
</div>


                            <div id="SearchMonitor.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SearchMonitor.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">SearchMonitor</span><span class="signature">(s: <a href="#Solver">pywrapcp.Solver</a>)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">SearchMonitor</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_SearchMonitor</span><span class="p">(</span><span class="n">_self</span><span class="p">,</span> <span class="n">s</span><span class="p">))</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="SearchMonitor.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#SearchMonitor.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="SearchMonitor.EnterSearch" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SearchMonitor.EnterSearch">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">EnterSearch</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">EnterSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Beginning of the search.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_EnterSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Beginning of the search.</p>
</div>


                            </div>
                            <div id="SearchMonitor.RestartSearch" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SearchMonitor.RestartSearch">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">RestartSearch</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">RestartSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Restart the search.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_RestartSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Restart the search.</p>
</div>


                            </div>
                            <div id="SearchMonitor.ExitSearch" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SearchMonitor.ExitSearch">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ExitSearch</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ExitSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; End of the search.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_ExitSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>End of the search.</p>
</div>


                            </div>
                            <div id="SearchMonitor.BeginNextDecision" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SearchMonitor.BeginNextDecision">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">BeginNextDecision</span><span class="signature">(self, b: <a href="#DecisionBuilder">pywrapcp.DecisionBuilder</a>) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">BeginNextDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="s2">&quot;DecisionBuilder&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Before calling DecisionBuilder::Next.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_BeginNextDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Before calling DecisionBuilder::Next.</p>
</div>


                            </div>
                            <div id="SearchMonitor.EndNextDecision" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SearchMonitor.EndNextDecision">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">EndNextDecision</span><span class="signature">(self, b: <a href="#DecisionBuilder">pywrapcp.DecisionBuilder</a>, d: <a href="#Decision">pywrapcp.Decision</a>) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">EndNextDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="s2">&quot;DecisionBuilder&quot;</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="s2">&quot;Decision&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; After calling DecisionBuilder::Next, along with the returned decision.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_EndNextDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>After calling DecisionBuilder::Next, along with the returned decision.</p>
</div>


                            </div>
                            <div id="SearchMonitor.ApplyDecision" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SearchMonitor.ApplyDecision">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ApplyDecision</span><span class="signature">(self, d: <a href="#Decision">pywrapcp.Decision</a>) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ApplyDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="s2">&quot;Decision&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Before applying the decision.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_ApplyDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Before applying the decision.</p>
</div>


                            </div>
                            <div id="SearchMonitor.RefuteDecision" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SearchMonitor.RefuteDecision">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">RefuteDecision</span><span class="signature">(self, d: <a href="#Decision">pywrapcp.Decision</a>) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">RefuteDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="s2">&quot;Decision&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Before refuting the decision.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_RefuteDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Before refuting the decision.</p>
</div>


                            </div>
                            <div id="SearchMonitor.AfterDecision" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SearchMonitor.AfterDecision">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AfterDecision</span><span class="signature">(self, d: <a href="#Decision">pywrapcp.Decision</a>, apply: bool) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AfterDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="s2">&quot;Decision&quot;</span><span class="p">,</span> <span class="n">apply</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Just after refuting or applying the decision, apply is true after Apply.</span>
<span class="sd">        This is called only if the Apply() or Refute() methods have not failed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_AfterDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">apply</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Just after refuting or applying the decision, apply is true after Apply.
This is called only if the Apply() or Refute() methods have not failed.</p>
</div>


                            </div>
                            <div id="SearchMonitor.BeginFail" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SearchMonitor.BeginFail">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">BeginFail</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">BeginFail</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Just when the failure occurs.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_BeginFail</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Just when the failure occurs.</p>
</div>


                            </div>
                            <div id="SearchMonitor.EndFail" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SearchMonitor.EndFail">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">EndFail</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">EndFail</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; After completing the backtrack.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_EndFail</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>After completing the backtrack.</p>
</div>


                            </div>
                            <div id="SearchMonitor.BeginInitialPropagation" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SearchMonitor.BeginInitialPropagation">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">BeginInitialPropagation</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">BeginInitialPropagation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Before the initial propagation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_BeginInitialPropagation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Before the initial propagation.</p>
</div>


                            </div>
                            <div id="SearchMonitor.EndInitialPropagation" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SearchMonitor.EndInitialPropagation">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">EndInitialPropagation</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">EndInitialPropagation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; After the initial propagation.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_EndInitialPropagation</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>After the initial propagation.</p>
</div>


                            </div>
                            <div id="SearchMonitor.AcceptSolution" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SearchMonitor.AcceptSolution">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AcceptSolution</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AcceptSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called when a solution is found. It asserts whether the</span>
<span class="sd">        solution is valid. A value of false indicates that the solution</span>
<span class="sd">        should be discarded.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_AcceptSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method is called when a solution is found. It asserts whether the
solution is valid. A value of false indicates that the solution
should be discarded.</p>
</div>


                            </div>
                            <div id="SearchMonitor.AtSolution" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SearchMonitor.AtSolution">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AtSolution</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AtSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called when a valid solution is found. If the</span>
<span class="sd">        return value is true, then search will resume after. If the result</span>
<span class="sd">        is false, then search will stop there.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_AtSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method is called when a valid solution is found. If the
return value is true, then search will resume after. If the result
is false, then search will stop there.</p>
</div>


                            </div>
                            <div id="SearchMonitor.NoMoreSolutions" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SearchMonitor.NoMoreSolutions">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">NoMoreSolutions</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">NoMoreSolutions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; When the search tree is finished.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_NoMoreSolutions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>When the search tree is finished.</p>
</div>


                            </div>
                            <div id="SearchMonitor.LocalOptimum" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SearchMonitor.LocalOptimum">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">LocalOptimum</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">LocalOptimum</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        When a local optimum is reached. If &#39;true&#39; is returned, the last solution</span>
<span class="sd">        is discarded and the search proceeds with the next one.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_LocalOptimum</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>When a local optimum is reached. If 'true' is returned, the last solution
is discarded and the search proceeds with the next one.</p>
</div>


                            </div>
                            <div id="SearchMonitor.AcceptDelta" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SearchMonitor.AcceptDelta">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AcceptDelta</span><span class="signature">(
    self,
    delta: <a href="#Assignment">pywrapcp.Assignment</a>,
    deltadelta: <a href="#Assignment">pywrapcp.Assignment</a>
) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AcceptDelta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_AcceptDelta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="SearchMonitor.AcceptNeighbor" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SearchMonitor.AcceptNeighbor">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AcceptNeighbor</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AcceptNeighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; After accepting a neighbor during local search.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_AcceptNeighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>After accepting a neighbor during local search.</p>
</div>


                            </div>
                            <div id="SearchMonitor.solver" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SearchMonitor.solver">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">solver</span><span class="signature">(self) -&gt; &#39;operations_research::Solver *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Solver *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchMonitor_solver</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#BaseObject">BaseObject</a></dt>
                                <dd id="SearchMonitor.DebugString" class="function"><a href="#BaseObject.DebugString">DebugString</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="IntExpr">
                                <div class="attr class">
        <a class="headerlink" href="#IntExpr">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">IntExpr</span><wbr>(<span class="base"><a href="#PropagationBaseObject">PropagationBaseObject</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">IntExpr</span><span class="p">(</span><span class="n">PropagationBaseObject</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The class IntExpr is the base of all integer expressions in</span>
<span class="sd">    constraint programming.</span>
<span class="sd">    It contains the basic protocol for an expression:</span>
<span class="sd">      - setting and modifying its bound</span>
<span class="sd">      - querying if it is bound</span>
<span class="sd">      - listening to events modifying its bounds</span>
<span class="sd">      - casting it into a variable (instance of IntVar)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Min</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_Min</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_SetMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Max</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_Max</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_SetMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This method sets both the min and the max of the expression.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_SetRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This method sets the value of the expression.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Bound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns true if the min and the max of the expression are equal.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_Bound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsVar</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns true if the expression is indeed a variable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_IsVar</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Creates a variable from the expression.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">VarWithName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a variable from the expression and set the name of the</span>
<span class="sd">        resulting var. If the expression is already a variable, then it</span>
<span class="sd">        will set the name of the expression, possibly overwriting it.</span>
<span class="sd">        This is just a shortcut to Var() followed by set_name().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_VarWithName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WhenRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Attach a demon that will watch the min or the max of the expression.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Attach a demon that will watch the min or the max of the expression.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_WhenRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr___repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr___str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr___add__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr___radd__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr___sub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr___rsub__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr___mul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr___rmul__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__floordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr___floordiv__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__mod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr___mod__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr___neg__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr___abs__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Square</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_Square</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr___eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr___ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr___ge__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr___gt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr___le__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr___lt__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">MapTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_MapTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IndexOf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_IndexOf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsMember</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_IsMember</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Member</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_Member</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NotMember</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">starts</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">ends</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_NotMember</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">starts</span><span class="p">,</span> <span class="n">ends</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>The class IntExpr is the base of all integer expressions in
constraint programming.</p>

<h6 id="it-contains-the-basic-protocol-for-an-expression">It contains the basic protocol for an expression</h6>

<blockquote>
  <ul>
  <li>setting and modifying its bound</li>
  <li>querying if it is bound</li>
  <li>listening to events modifying its bounds</li>
  <li>casting it into a variable (instance of IntVar)</li>
  </ul>
</blockquote>
</div>


                            <div id="IntExpr.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntExpr.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">IntExpr</span><span class="signature">(*args, **kwargs)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntExpr.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#IntExpr.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="IntExpr.Min" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntExpr.Min">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Min</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Min</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_Min</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntExpr.SetMin" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntExpr.SetMin">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetMin</span><span class="signature">(self, m: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_SetMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntExpr.Max" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntExpr.Max">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Max</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Max</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_Max</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntExpr.SetMax" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntExpr.SetMax">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetMax</span><span class="signature">(self, m: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_SetMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntExpr.SetRange" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntExpr.SetRange">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetRange</span><span class="signature">(self, l: &#39;int64_t&#39;, u: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This method sets both the min and the max of the expression.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_SetRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method sets both the min and the max of the expression.</p>
</div>


                            </div>
                            <div id="IntExpr.SetValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntExpr.SetValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetValue</span><span class="signature">(self, v: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This method sets the value of the expression.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method sets the value of the expression.</p>
</div>


                            </div>
                            <div id="IntExpr.Bound" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntExpr.Bound">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Bound</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Bound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns true if the min and the max of the expression are equal.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_Bound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns true if the min and the max of the expression are equal.</p>
</div>


                            </div>
                            <div id="IntExpr.IsVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntExpr.IsVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsVar</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsVar</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns true if the expression is indeed a variable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_IsVar</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns true if the expression is indeed a variable.</p>
</div>


                            </div>
                            <div id="IntExpr.Var" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntExpr.Var">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Var</span><span class="signature">(self) -&gt; &#39;operations_research::IntVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Creates a variable from the expression.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates a variable from the expression.</p>
</div>


                            </div>
                            <div id="IntExpr.VarWithName" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntExpr.VarWithName">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">VarWithName</span><span class="signature">(self, name: &#39;std::string const &amp;&#39;) -&gt; &#39;operations_research::IntVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">VarWithName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a variable from the expression and set the name of the</span>
<span class="sd">        resulting var. If the expression is already a variable, then it</span>
<span class="sd">        will set the name of the expression, possibly overwriting it.</span>
<span class="sd">        This is just a shortcut to Var() followed by set_name().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_VarWithName</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates a variable from the expression and set the name of the
resulting var. If the expression is already a variable, then it
will set the name of the expression, possibly overwriting it.
This is just a shortcut to Var() followed by set_name().</p>
</div>


                            </div>
                            <div id="IntExpr.WhenRange" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntExpr.WhenRange">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">WhenRange</span><span class="signature">(self, *args) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">WhenRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Attach a demon that will watch the min or the max of the expression.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Attach a demon that will watch the min or the max of the expression.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_WhenRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p><em>Overload 1:</em>
Attach a demon that will watch the min or the max of the expression.</p>

<p>|</p>

<p><em>Overload 2:</em>
Attach a demon that will watch the min or the max of the expression.</p>
</div>


                            </div>
                            <div id="IntExpr.Square" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntExpr.Square">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Square</span><span class="signature">(self) -&gt; &#39;operations_research::IntExpr *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Square</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_Square</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntExpr.MapTo" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntExpr.MapTo">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">MapTo</span><span class="signature">(
    self,
    vars: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">MapTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_MapTo</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntExpr.IndexOf" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntExpr.IndexOf">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IndexOf</span><span class="signature">(self, *args) -&gt; &#39;operations_research::IntExpr *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IndexOf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_IndexOf</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntExpr.IsMember" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntExpr.IsMember">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsMember</span><span class="signature">(
    self,
    values: &#39;std::vector&lt; int64_t &gt; const &amp;&#39;
) -&gt; &#39;operations_research::IntVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsMember</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_IsMember</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntExpr.Member" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntExpr.Member">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Member</span><span class="signature">(
    self,
    values: &#39;std::vector&lt; int64_t &gt; const &amp;&#39;
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Member</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_Member</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntExpr.NotMember" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntExpr.NotMember">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">NotMember</span><span class="signature">(
    self,
    starts: &#39;std::vector&lt; int64_t &gt; const &amp;&#39;,
    ends: &#39;std::vector&lt; int64_t &gt; const &amp;&#39;
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">NotMember</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">starts</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">ends</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntExpr_NotMember</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">starts</span><span class="p">,</span> <span class="n">ends</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#PropagationBaseObject">PropagationBaseObject</a></dt>
                                <dd id="IntExpr.DebugString" class="function"><a href="#PropagationBaseObject.DebugString">DebugString</a></dd>
                <dd id="IntExpr.solver" class="function"><a href="#PropagationBaseObject.solver">solver</a></dd>
                <dd id="IntExpr.Name" class="function"><a href="#PropagationBaseObject.Name">Name</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="IntVarIterator">
                                <div class="attr class">
        <a class="headerlink" href="#IntVarIterator">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">IntVarIterator</span><wbr>(<span class="base"><a href="#BaseObject">BaseObject</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">IntVarIterator</span><span class="p">(</span><span class="n">BaseObject</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">     The class Iterator has two direct subclasses. HoleIterators</span>
<span class="sd">     iterates over all holes, that is value removed between the</span>
<span class="sd">     current min and max of the variable since the last time the</span>
<span class="sd">     variable was processed in the queue. DomainIterators iterates</span>
<span class="sd">     over all elements of the variable domain. Both iterators are not</span>
<span class="sd">     robust to domain changes. Hole iterators can also report values outside</span>
<span class="sd">     the current min and max of the variable.</span>
<span class="sd">     HoleIterators should only be called from a demon attached to the</span>
<span class="sd">     variable that has created this iterator.</span>
<span class="sd">     IntVar* current_var;</span>
<span class="sd">     std::unique_ptr&lt;IntVarIterator&gt; it(current_var-&gt;MakeHoleIterator(false));</span>
<span class="sd">     for (const int64_t hole : InitAndGetValues(it)) {</span>
<span class="sd">    use the hole</span>
<span class="sd">     }</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">Init</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This method must be called before each loop.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarIterator_Init</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Ok</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This method indicates if we can call Value() or not.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarIterator_Ok</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This method returns the current value of the iterator.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarIterator_Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Next</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This method moves the iterator to the next value.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarIterator_Next</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Pretty Print.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarIterator_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">Init</span><span class="p">()</span>
      <span class="k">return</span> <span class="bp">self</span>

    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ok</span><span class="p">():</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Value</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">StopIteration</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__next__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">next</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>The class Iterator has two direct subclasses. HoleIterators
 iterates over all holes, that is value removed between the
 current min and max of the variable since the last time the
 variable was processed in the queue. DomainIterators iterates
 over all elements of the variable domain. Both iterators are not
 robust to domain changes. Hole iterators can also report values outside
 the current min and max of the variable.
 HoleIterators should only be called from a demon attached to the
 variable that has created this iterator.
 IntVar* current_var;
 std::unique_ptr<IntVarIterator> it(current_var->MakeHoleIterator(false));
 for (const int64_t hole : InitAndGetValues(it)) {
use the hole
 }</p>
</div>


                            <div id="IntVarIterator.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVarIterator.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">IntVarIterator</span><span class="signature">(*args, **kwargs)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntVarIterator.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#IntVarIterator.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="IntVarIterator.Init" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVarIterator.Init">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Init</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Init</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This method must be called before each loop.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarIterator_Init</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method must be called before each loop.</p>
</div>


                            </div>
                            <div id="IntVarIterator.Ok" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVarIterator.Ok">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Ok</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Ok</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This method indicates if we can call Value() or not.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarIterator_Ok</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method indicates if we can call Value() or not.</p>
</div>


                            </div>
                            <div id="IntVarIterator.Value" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVarIterator.Value">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Value</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This method returns the current value of the iterator.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarIterator_Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method returns the current value of the iterator.</p>
</div>


                            </div>
                            <div id="IntVarIterator.Next" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVarIterator.Next">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Next</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Next</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This method moves the iterator to the next value.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarIterator_Next</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method moves the iterator to the next value.</p>
</div>


                            </div>
                            <div id="IntVarIterator.DebugString" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVarIterator.DebugString">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DebugString</span><span class="signature">(self) -&gt; &#39;std::string&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Pretty Print.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarIterator_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Pretty Print.</p>
</div>


                            </div>
                            <div id="IntVarIterator.next" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVarIterator.next">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">next</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">Ok</span><span class="p">():</span>
        <span class="n">result</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Value</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Next</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">StopIteration</span><span class="p">()</span>
</pre></div>

        </details>

    

                            </div>
                </section>
                <section id="IntVar">
                                <div class="attr class">
        <a class="headerlink" href="#IntVar">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">IntVar</span><wbr>(<span class="base"><a href="#IntExpr">IntExpr</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">IntVar</span><span class="p">(</span><span class="n">IntExpr</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The class IntVar is a subset of IntExpr. In addition to the</span>
<span class="sd">    IntExpr protocol, it offers persistence, removing values from the domains,</span>
<span class="sd">    and a finer model for events.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsVar</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_IsVar</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns the value of the variable. This method checks</span>
<span class="sd">        before that the variable is bound.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RemoveValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This method removes the value &#39;v&#39; from the domain of the variable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_RemoveValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RemoveInterval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method removes the interval &#39;l&#39; .. &#39;u&#39; from the domain of</span>
<span class="sd">        the variable. It assumes that &#39;l&#39; &lt;= &#39;u&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_RemoveInterval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RemoveValues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This method remove the values from the domain of the variable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_RemoveValues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetValues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This method intersects the current domain with the values in the array.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_SetValues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WhenBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        This method attaches a demon that will be awakened when the</span>
<span class="sd">        variable is bound.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        This method attaches a closure that will be awakened when the</span>
<span class="sd">        variable is bound.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_WhenBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WhenDomain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        This method attaches a demon that will watch any domain</span>
<span class="sd">        modification of the domain of the variable.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        This method attaches a closure that will watch any domain</span>
<span class="sd">        modification of the domain of the variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_WhenDomain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;uint64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This method returns the number of values in the domain of the variable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns whether the value &#39;v&#39; is in the domain of the</span>
<span class="sd">        variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_Contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">HoleIteratorAux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reversible</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVarIterator *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a hole iterator. When &#39;reversible&#39; is false, the returned</span>
<span class="sd">        object is created on the normal C++ heap and the solver does NOT</span>
<span class="sd">        take ownership of the object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_HoleIteratorAux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reversible</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DomainIteratorAux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reversible</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVarIterator *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a domain iterator. When &#39;reversible&#39; is false, the</span>
<span class="sd">        returned object is created on the normal C++ heap and the solver</span>
<span class="sd">        does NOT take ownership of the object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_DomainIteratorAux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reversible</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">OldMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the previous min.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_OldMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">OldMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the previous max.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_OldMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar___repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar___str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DomainIterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DomainIteratorAux</span><span class="p">(</span><span class="kc">False</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">HoleIterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">HoleIteratorAux</span><span class="p">(</span><span class="kc">False</span><span class="p">))</span>
</pre></div>

        </details>

            <div class="docstring"><p>The class IntVar is a subset of IntExpr. In addition to the
IntExpr protocol, it offers persistence, removing values from the domains,
and a finer model for events.</p>
</div>


                            <div id="IntVar.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVar.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">IntVar</span><span class="signature">(*args, **kwargs)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntVar.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#IntVar.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="IntVar.IsVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVar.IsVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsVar</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsVar</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_IsVar</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns true if the expression is indeed a variable.</p>
</div>


                            </div>
                            <div id="IntVar.Var" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVar.Var">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Var</span><span class="signature">(self) -&gt; &#39;operations_research::IntVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates a variable from the expression.</p>
</div>


                            </div>
                            <div id="IntVar.Value" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVar.Value">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Value</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns the value of the variable. This method checks</span>
<span class="sd">        before that the variable is bound.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method returns the value of the variable. This method checks
before that the variable is bound.</p>
</div>


                            </div>
                            <div id="IntVar.RemoveValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVar.RemoveValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">RemoveValue</span><span class="signature">(self, v: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">RemoveValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This method removes the value &#39;v&#39; from the domain of the variable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_RemoveValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method removes the value 'v' from the domain of the variable.</p>
</div>


                            </div>
                            <div id="IntVar.RemoveInterval" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVar.RemoveInterval">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">RemoveInterval</span><span class="signature">(self, l: &#39;int64_t&#39;, u: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">RemoveInterval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method removes the interval &#39;l&#39; .. &#39;u&#39; from the domain of</span>
<span class="sd">        the variable. It assumes that &#39;l&#39; &lt;= &#39;u&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_RemoveInterval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method removes the interval 'l' .. 'u' from the domain of
the variable. It assumes that 'l' &lt;= 'u'.</p>
</div>


                            </div>
                            <div id="IntVar.RemoveValues" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVar.RemoveValues">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">RemoveValues</span><span class="signature">(self, values: &#39;std::vector&lt; int64_t &gt; const &amp;&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">RemoveValues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This method remove the values from the domain of the variable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_RemoveValues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method remove the values from the domain of the variable.</p>
</div>


                            </div>
                            <div id="IntVar.SetValues" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVar.SetValues">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetValues</span><span class="signature">(self, values: &#39;std::vector&lt; int64_t &gt; const &amp;&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetValues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This method intersects the current domain with the values in the array.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_SetValues</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method intersects the current domain with the values in the array.</p>
</div>


                            </div>
                            <div id="IntVar.WhenBound" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVar.WhenBound">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">WhenBound</span><span class="signature">(self, *args) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">WhenBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        This method attaches a demon that will be awakened when the</span>
<span class="sd">        variable is bound.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        This method attaches a closure that will be awakened when the</span>
<span class="sd">        variable is bound.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_WhenBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p><em>Overload 1:</em>
This method attaches a demon that will be awakened when the
variable is bound.</p>

<p>|</p>

<p><em>Overload 2:</em>
This method attaches a closure that will be awakened when the
variable is bound.</p>
</div>


                            </div>
                            <div id="IntVar.WhenDomain" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVar.WhenDomain">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">WhenDomain</span><span class="signature">(self, *args) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">WhenDomain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        This method attaches a demon that will watch any domain</span>
<span class="sd">        modification of the domain of the variable.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        This method attaches a closure that will watch any domain</span>
<span class="sd">        modification of the domain of the variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_WhenDomain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p><em>Overload 1:</em>
This method attaches a demon that will watch any domain
modification of the domain of the variable.</p>

<p>|</p>

<p><em>Overload 2:</em>
This method attaches a closure that will watch any domain
modification of the domain of the variable.</p>
</div>


                            </div>
                            <div id="IntVar.Size" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVar.Size">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Size</span><span class="signature">(self) -&gt; &#39;uint64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;uint64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This method returns the number of values in the domain of the variable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method returns the number of values in the domain of the variable.</p>
</div>


                            </div>
                            <div id="IntVar.Contains" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVar.Contains">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Contains</span><span class="signature">(self, v: &#39;int64_t&#39;) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method returns whether the value &#39;v&#39; is in the domain of the</span>
<span class="sd">        variable.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_Contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method returns whether the value 'v' is in the domain of the
variable.</p>
</div>


                            </div>
                            <div id="IntVar.HoleIteratorAux" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVar.HoleIteratorAux">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">HoleIteratorAux</span><span class="signature">(self, reversible: bool) -&gt; &#39;operations_research::IntVarIterator *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">HoleIteratorAux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reversible</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVarIterator *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a hole iterator. When &#39;reversible&#39; is false, the returned</span>
<span class="sd">        object is created on the normal C++ heap and the solver does NOT</span>
<span class="sd">        take ownership of the object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_HoleIteratorAux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reversible</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates a hole iterator. When 'reversible' is false, the returned
object is created on the normal C++ heap and the solver does NOT
take ownership of the object.</p>
</div>


                            </div>
                            <div id="IntVar.DomainIteratorAux" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVar.DomainIteratorAux">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DomainIteratorAux</span><span class="signature">(self, reversible: bool) -&gt; &#39;operations_research::IntVarIterator *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">DomainIteratorAux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reversible</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVarIterator *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a domain iterator. When &#39;reversible&#39; is false, the</span>
<span class="sd">        returned object is created on the normal C++ heap and the solver</span>
<span class="sd">        does NOT take ownership of the object.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_DomainIteratorAux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reversible</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates a domain iterator. When 'reversible' is false, the
returned object is created on the normal C++ heap and the solver
does NOT take ownership of the object.</p>
</div>


                            </div>
                            <div id="IntVar.OldMin" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVar.OldMin">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">OldMin</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">OldMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the previous min.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_OldMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the previous min.</p>
</div>


                            </div>
                            <div id="IntVar.OldMax" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVar.OldMax">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">OldMax</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">OldMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the previous max.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVar_OldMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the previous max.</p>
</div>


                            </div>
                            <div id="IntVar.DomainIterator" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVar.DomainIterator">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DomainIterator</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">DomainIterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">DomainIteratorAux</span><span class="p">(</span><span class="kc">False</span><span class="p">))</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntVar.HoleIterator" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVar.HoleIterator">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">HoleIterator</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">HoleIterator</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
      <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">HoleIteratorAux</span><span class="p">(</span><span class="kc">False</span><span class="p">))</span>
</pre></div>

        </details>

    

                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#IntExpr">IntExpr</a></dt>
                                <dd id="IntVar.Min" class="function"><a href="#IntExpr.Min">Min</a></dd>
                <dd id="IntVar.SetMin" class="function"><a href="#IntExpr.SetMin">SetMin</a></dd>
                <dd id="IntVar.Max" class="function"><a href="#IntExpr.Max">Max</a></dd>
                <dd id="IntVar.SetMax" class="function"><a href="#IntExpr.SetMax">SetMax</a></dd>
                <dd id="IntVar.SetRange" class="function"><a href="#IntExpr.SetRange">SetRange</a></dd>
                <dd id="IntVar.SetValue" class="function"><a href="#IntExpr.SetValue">SetValue</a></dd>
                <dd id="IntVar.Bound" class="function"><a href="#IntExpr.Bound">Bound</a></dd>
                <dd id="IntVar.VarWithName" class="function"><a href="#IntExpr.VarWithName">VarWithName</a></dd>
                <dd id="IntVar.WhenRange" class="function"><a href="#IntExpr.WhenRange">WhenRange</a></dd>
                <dd id="IntVar.Square" class="function"><a href="#IntExpr.Square">Square</a></dd>
                <dd id="IntVar.MapTo" class="function"><a href="#IntExpr.MapTo">MapTo</a></dd>
                <dd id="IntVar.IndexOf" class="function"><a href="#IntExpr.IndexOf">IndexOf</a></dd>
                <dd id="IntVar.IsMember" class="function"><a href="#IntExpr.IsMember">IsMember</a></dd>
                <dd id="IntVar.Member" class="function"><a href="#IntExpr.Member">Member</a></dd>
                <dd id="IntVar.NotMember" class="function"><a href="#IntExpr.NotMember">NotMember</a></dd>

            </div>
            <div><dt><a href="#PropagationBaseObject">PropagationBaseObject</a></dt>
                                <dd id="IntVar.DebugString" class="function"><a href="#PropagationBaseObject.DebugString">DebugString</a></dd>
                <dd id="IntVar.solver" class="function"><a href="#PropagationBaseObject.solver">solver</a></dd>
                <dd id="IntVar.Name" class="function"><a href="#PropagationBaseObject.Name">Name</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="SolutionCollector">
                                <div class="attr class">
        <a class="headerlink" href="#SolutionCollector">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">SolutionCollector</span><wbr>(<span class="base"><a href="#SearchMonitor">SearchMonitor</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">SolutionCollector</span><span class="p">(</span><span class="n">SearchMonitor</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class is the root class of all solution collectors.</span>
<span class="sd">    It implements a basic query API to be used independently</span>
<span class="sd">    of the collector used.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddObjective</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">objective</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_AddObjective</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">objective</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EnterSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Beginning of the search.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_EnterSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SolutionCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns how many solutions were stored during the search.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_SolutionCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Solution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the nth solution.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_Solution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WallTime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the wall time in ms for the nth solution.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_WallTime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Branches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the number of branches when the nth solution was found.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_Branches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Failures</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of failures encountered at the time of the nth</span>
<span class="sd">        solution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_Failures</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ObjectiveValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the objective value of the nth solution.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_ObjectiveValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This is a shortcut to get the Value of &#39;var&#39; in the nth solution.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_Value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This is a shortcut to get the StartValue of &#39;var&#39; in the nth solution.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_StartValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This is a shortcut to get the EndValue of &#39;var&#39; in the nth solution.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_EndValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DurationValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This is a shortcut to get the DurationValue of &#39;var&#39; in the nth solution.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_DurationValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">PerformedValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This is a shortcut to get the PerformedValue of &#39;var&#39; in the nth solution.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_PerformedValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ForwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;SequenceVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a shortcut to get the ForwardSequence of &#39;var&#39; in the</span>
<span class="sd">        nth solution. The forward sequence is the list of ranked interval</span>
<span class="sd">        variables starting from the start of the sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_ForwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">BackwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;SequenceVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a shortcut to get the BackwardSequence of &#39;var&#39; in the</span>
<span class="sd">        nth solution. The backward sequence is the list of ranked interval</span>
<span class="sd">        variables starting from the end of the sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_BackwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Unperformed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;SequenceVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a shortcut to get the list of unperformed of &#39;var&#39; in the</span>
<span class="sd">        nth solution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_Unperformed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This class is the root class of all solution collectors.
It implements a basic query API to be used independently
of the collector used.</p>
</div>


                            <div id="SolutionCollector.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SolutionCollector.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">SolutionCollector</span><span class="signature">(*args, **kwargs)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="SolutionCollector.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#SolutionCollector.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="SolutionCollector.DebugString" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SolutionCollector.DebugString">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DebugString</span><span class="signature">(self) -&gt; &#39;std::string&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="SolutionCollector.Add" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SolutionCollector.Add">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Add</span><span class="signature">(self, *args) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="SolutionCollector.AddObjective" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SolutionCollector.AddObjective">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddObjective</span><span class="signature">(self, objective: <a href="#IntVar">pywrapcp.IntVar</a>) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddObjective</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">objective</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_AddObjective</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">objective</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="SolutionCollector.EnterSearch" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SolutionCollector.EnterSearch">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">EnterSearch</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">EnterSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Beginning of the search.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_EnterSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Beginning of the search.</p>
</div>


                            </div>
                            <div id="SolutionCollector.SolutionCount" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SolutionCollector.SolutionCount">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SolutionCount</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SolutionCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns how many solutions were stored during the search.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_SolutionCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns how many solutions were stored during the search.</p>
</div>


                            </div>
                            <div id="SolutionCollector.Solution" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SolutionCollector.Solution">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Solution</span><span class="signature">(self, n: int) -&gt; &#39;operations_research::Assignment *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Solution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the nth solution.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_Solution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the nth solution.</p>
</div>


                            </div>
                            <div id="SolutionCollector.WallTime" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SolutionCollector.WallTime">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">WallTime</span><span class="signature">(self, n: int) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">WallTime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the wall time in ms for the nth solution.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_WallTime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the wall time in ms for the nth solution.</p>
</div>


                            </div>
                            <div id="SolutionCollector.Branches" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SolutionCollector.Branches">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Branches</span><span class="signature">(self, n: int) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Branches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the number of branches when the nth solution was found.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_Branches</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the number of branches when the nth solution was found.</p>
</div>


                            </div>
                            <div id="SolutionCollector.Failures" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SolutionCollector.Failures">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Failures</span><span class="signature">(self, n: int) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Failures</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of failures encountered at the time of the nth</span>
<span class="sd">        solution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_Failures</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the number of failures encountered at the time of the nth
solution.</p>
</div>


                            </div>
                            <div id="SolutionCollector.ObjectiveValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SolutionCollector.ObjectiveValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ObjectiveValue</span><span class="signature">(self, n: int) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ObjectiveValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the objective value of the nth solution.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_ObjectiveValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the objective value of the nth solution.</p>
</div>


                            </div>
                            <div id="SolutionCollector.Value" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SolutionCollector.Value">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Value</span><span class="signature">(self, n: int, var: <a href="#IntVar">pywrapcp.IntVar</a>) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This is a shortcut to get the Value of &#39;var&#39; in the nth solution.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_Value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This is a shortcut to get the Value of 'var' in the nth solution.</p>
</div>


                            </div>
                            <div id="SolutionCollector.StartValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SolutionCollector.StartValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">StartValue</span><span class="signature">(self, n: int, var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">StartValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This is a shortcut to get the StartValue of &#39;var&#39; in the nth solution.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_StartValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This is a shortcut to get the StartValue of 'var' in the nth solution.</p>
</div>


                            </div>
                            <div id="SolutionCollector.EndValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SolutionCollector.EndValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">EndValue</span><span class="signature">(self, n: int, var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">EndValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This is a shortcut to get the EndValue of &#39;var&#39; in the nth solution.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_EndValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This is a shortcut to get the EndValue of 'var' in the nth solution.</p>
</div>


                            </div>
                            <div id="SolutionCollector.DurationValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SolutionCollector.DurationValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DurationValue</span><span class="signature">(self, n: int, var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">DurationValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This is a shortcut to get the DurationValue of &#39;var&#39; in the nth solution.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_DurationValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This is a shortcut to get the DurationValue of 'var' in the nth solution.</p>
</div>


                            </div>
                            <div id="SolutionCollector.PerformedValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SolutionCollector.PerformedValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">PerformedValue</span><span class="signature">(self, n: int, var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">PerformedValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This is a shortcut to get the PerformedValue of &#39;var&#39; in the nth solution.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_PerformedValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This is a shortcut to get the PerformedValue of 'var' in the nth solution.</p>
</div>


                            </div>
                            <div id="SolutionCollector.ForwardSequence" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SolutionCollector.ForwardSequence">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ForwardSequence</span><span class="signature">(
    self,
    n: int,
    var: <a href="#SequenceVar">pywrapcp.SequenceVar</a>
) -&gt; &#39;std::vector&lt; int &gt; const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ForwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;SequenceVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a shortcut to get the ForwardSequence of &#39;var&#39; in the</span>
<span class="sd">        nth solution. The forward sequence is the list of ranked interval</span>
<span class="sd">        variables starting from the start of the sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_ForwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This is a shortcut to get the ForwardSequence of 'var' in the
nth solution. The forward sequence is the list of ranked interval
variables starting from the start of the sequence.</p>
</div>


                            </div>
                            <div id="SolutionCollector.BackwardSequence" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SolutionCollector.BackwardSequence">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">BackwardSequence</span><span class="signature">(
    self,
    n: int,
    var: <a href="#SequenceVar">pywrapcp.SequenceVar</a>
) -&gt; &#39;std::vector&lt; int &gt; const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">BackwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;SequenceVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a shortcut to get the BackwardSequence of &#39;var&#39; in the</span>
<span class="sd">        nth solution. The backward sequence is the list of ranked interval</span>
<span class="sd">        variables starting from the end of the sequence.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_BackwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This is a shortcut to get the BackwardSequence of 'var' in the
nth solution. The backward sequence is the list of ranked interval
variables starting from the end of the sequence.</p>
</div>


                            </div>
                            <div id="SolutionCollector.Unperformed" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SolutionCollector.Unperformed">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Unperformed</span><span class="signature">(
    self,
    n: int,
    var: <a href="#SequenceVar">pywrapcp.SequenceVar</a>
) -&gt; &#39;std::vector&lt; int &gt; const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Unperformed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;SequenceVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This is a shortcut to get the list of unperformed of &#39;var&#39; in the</span>
<span class="sd">        nth solution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolutionCollector_Unperformed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This is a shortcut to get the list of unperformed of 'var' in the
nth solution.</p>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#SearchMonitor">SearchMonitor</a></dt>
                                <dd id="SolutionCollector.RestartSearch" class="function"><a href="#SearchMonitor.RestartSearch">RestartSearch</a></dd>
                <dd id="SolutionCollector.ExitSearch" class="function"><a href="#SearchMonitor.ExitSearch">ExitSearch</a></dd>
                <dd id="SolutionCollector.BeginNextDecision" class="function"><a href="#SearchMonitor.BeginNextDecision">BeginNextDecision</a></dd>
                <dd id="SolutionCollector.EndNextDecision" class="function"><a href="#SearchMonitor.EndNextDecision">EndNextDecision</a></dd>
                <dd id="SolutionCollector.ApplyDecision" class="function"><a href="#SearchMonitor.ApplyDecision">ApplyDecision</a></dd>
                <dd id="SolutionCollector.RefuteDecision" class="function"><a href="#SearchMonitor.RefuteDecision">RefuteDecision</a></dd>
                <dd id="SolutionCollector.AfterDecision" class="function"><a href="#SearchMonitor.AfterDecision">AfterDecision</a></dd>
                <dd id="SolutionCollector.BeginFail" class="function"><a href="#SearchMonitor.BeginFail">BeginFail</a></dd>
                <dd id="SolutionCollector.EndFail" class="function"><a href="#SearchMonitor.EndFail">EndFail</a></dd>
                <dd id="SolutionCollector.BeginInitialPropagation" class="function"><a href="#SearchMonitor.BeginInitialPropagation">BeginInitialPropagation</a></dd>
                <dd id="SolutionCollector.EndInitialPropagation" class="function"><a href="#SearchMonitor.EndInitialPropagation">EndInitialPropagation</a></dd>
                <dd id="SolutionCollector.AcceptSolution" class="function"><a href="#SearchMonitor.AcceptSolution">AcceptSolution</a></dd>
                <dd id="SolutionCollector.AtSolution" class="function"><a href="#SearchMonitor.AtSolution">AtSolution</a></dd>
                <dd id="SolutionCollector.NoMoreSolutions" class="function"><a href="#SearchMonitor.NoMoreSolutions">NoMoreSolutions</a></dd>
                <dd id="SolutionCollector.LocalOptimum" class="function"><a href="#SearchMonitor.LocalOptimum">LocalOptimum</a></dd>
                <dd id="SolutionCollector.AcceptDelta" class="function"><a href="#SearchMonitor.AcceptDelta">AcceptDelta</a></dd>
                <dd id="SolutionCollector.AcceptNeighbor" class="function"><a href="#SearchMonitor.AcceptNeighbor">AcceptNeighbor</a></dd>
                <dd id="SolutionCollector.solver" class="function"><a href="#SearchMonitor.solver">solver</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="OptimizeVar">
                                <div class="attr class">
        <a class="headerlink" href="#OptimizeVar">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">OptimizeVar</span><wbr>(<span class="base"><a href="#SearchMonitor">SearchMonitor</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">OptimizeVar</span><span class="p">(</span><span class="n">SearchMonitor</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class encapsulates an objective. It requires the direction</span>
<span class="sd">    (minimize or maximize), the variable to optimize, and the</span>
<span class="sd">    improvement step.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">Best</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the best value found during search.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">OptimizeVar_Best</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the variable that is optimized.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">OptimizeVar_Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AcceptDelta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Internal methods.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">OptimizeVar_AcceptDelta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EnterSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">OptimizeVar_EnterSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">BeginNextDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">db</span><span class="p">:</span> <span class="s2">&quot;DecisionBuilder&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">OptimizeVar_BeginNextDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">db</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RefuteDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="s2">&quot;Decision&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">OptimizeVar_RefuteDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AtSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">OptimizeVar_AtSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AcceptSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">OptimizeVar_AcceptSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">OptimizeVar_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This class encapsulates an objective. It requires the direction
(minimize or maximize), the variable to optimize, and the
improvement step.</p>
</div>


                            <div id="OptimizeVar.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#OptimizeVar.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">OptimizeVar</span><span class="signature">(*args, **kwargs)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="OptimizeVar.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#OptimizeVar.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="OptimizeVar.Best" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#OptimizeVar.Best">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Best</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Best</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the best value found during search.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">OptimizeVar_Best</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the best value found during search.</p>
</div>


                            </div>
                            <div id="OptimizeVar.Var" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#OptimizeVar.Var">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Var</span><span class="signature">(self) -&gt; &#39;operations_research::IntVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the variable that is optimized.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">OptimizeVar_Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the variable that is optimized.</p>
</div>


                            </div>
                            <div id="OptimizeVar.AcceptDelta" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#OptimizeVar.AcceptDelta">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AcceptDelta</span><span class="signature">(
    self,
    delta: <a href="#Assignment">pywrapcp.Assignment</a>,
    deltadelta: <a href="#Assignment">pywrapcp.Assignment</a>
) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AcceptDelta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Internal methods.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">OptimizeVar_AcceptDelta</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Internal methods.</p>
</div>


                            </div>
                            <div id="OptimizeVar.EnterSearch" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#OptimizeVar.EnterSearch">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">EnterSearch</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">EnterSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">OptimizeVar_EnterSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Beginning of the search.</p>
</div>


                            </div>
                            <div id="OptimizeVar.BeginNextDecision" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#OptimizeVar.BeginNextDecision">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">BeginNextDecision</span><span class="signature">(self, db: <a href="#DecisionBuilder">pywrapcp.DecisionBuilder</a>) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">BeginNextDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">db</span><span class="p">:</span> <span class="s2">&quot;DecisionBuilder&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">OptimizeVar_BeginNextDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">db</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Before calling DecisionBuilder::Next.</p>
</div>


                            </div>
                            <div id="OptimizeVar.RefuteDecision" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#OptimizeVar.RefuteDecision">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">RefuteDecision</span><span class="signature">(self, d: <a href="#Decision">pywrapcp.Decision</a>) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">RefuteDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="s2">&quot;Decision&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">OptimizeVar_RefuteDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Before refuting the decision.</p>
</div>


                            </div>
                            <div id="OptimizeVar.AtSolution" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#OptimizeVar.AtSolution">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AtSolution</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AtSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">OptimizeVar_AtSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method is called when a valid solution is found. If the
return value is true, then search will resume after. If the result
is false, then search will stop there.</p>
</div>


                            </div>
                            <div id="OptimizeVar.AcceptSolution" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#OptimizeVar.AcceptSolution">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AcceptSolution</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AcceptSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">OptimizeVar_AcceptSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method is called when a solution is found. It asserts whether the
solution is valid. A value of false indicates that the solution
should be discarded.</p>
</div>


                            </div>
                            <div id="OptimizeVar.DebugString" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#OptimizeVar.DebugString">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DebugString</span><span class="signature">(self) -&gt; &#39;std::string&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">OptimizeVar_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#SearchMonitor">SearchMonitor</a></dt>
                                <dd id="OptimizeVar.RestartSearch" class="function"><a href="#SearchMonitor.RestartSearch">RestartSearch</a></dd>
                <dd id="OptimizeVar.ExitSearch" class="function"><a href="#SearchMonitor.ExitSearch">ExitSearch</a></dd>
                <dd id="OptimizeVar.EndNextDecision" class="function"><a href="#SearchMonitor.EndNextDecision">EndNextDecision</a></dd>
                <dd id="OptimizeVar.ApplyDecision" class="function"><a href="#SearchMonitor.ApplyDecision">ApplyDecision</a></dd>
                <dd id="OptimizeVar.AfterDecision" class="function"><a href="#SearchMonitor.AfterDecision">AfterDecision</a></dd>
                <dd id="OptimizeVar.BeginFail" class="function"><a href="#SearchMonitor.BeginFail">BeginFail</a></dd>
                <dd id="OptimizeVar.EndFail" class="function"><a href="#SearchMonitor.EndFail">EndFail</a></dd>
                <dd id="OptimizeVar.BeginInitialPropagation" class="function"><a href="#SearchMonitor.BeginInitialPropagation">BeginInitialPropagation</a></dd>
                <dd id="OptimizeVar.EndInitialPropagation" class="function"><a href="#SearchMonitor.EndInitialPropagation">EndInitialPropagation</a></dd>
                <dd id="OptimizeVar.NoMoreSolutions" class="function"><a href="#SearchMonitor.NoMoreSolutions">NoMoreSolutions</a></dd>
                <dd id="OptimizeVar.LocalOptimum" class="function"><a href="#SearchMonitor.LocalOptimum">LocalOptimum</a></dd>
                <dd id="OptimizeVar.AcceptNeighbor" class="function"><a href="#SearchMonitor.AcceptNeighbor">AcceptNeighbor</a></dd>
                <dd id="OptimizeVar.solver" class="function"><a href="#SearchMonitor.solver">solver</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="SearchLimit">
                                <div class="attr class">
        <a class="headerlink" href="#SearchLimit">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">SearchLimit</span><wbr>(<span class="base"><a href="#SearchMonitor">SearchMonitor</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">SearchLimit</span><span class="p">(</span><span class="n">SearchMonitor</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Base class of all search limits.&quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_SearchLimit</span>

    <span class="k">def</span> <span class="nf">Crossed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns true if the limit has been crossed.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchLimit_Crossed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Check</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called to check the status of the limit. A return</span>
<span class="sd">        value of true indicates that we have indeed crossed the limit. In</span>
<span class="sd">        that case, this method will not be called again and the remaining</span>
<span class="sd">        search will be discarded.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchLimit_Check</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Init</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This method is called when the search limit is initialized.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchLimit_Init</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EnterSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Internal methods.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchLimit_EnterSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">BeginNextDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="s2">&quot;DecisionBuilder&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchLimit_BeginNextDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RefuteDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="s2">&quot;Decision&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchLimit_RefuteDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchLimit_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Base class of all search limits.</p>
</div>


                            <div id="SearchLimit.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SearchLimit.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">SearchLimit</span><span class="signature">(*args, **kwargs)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="SearchLimit.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#SearchLimit.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="SearchLimit.Crossed" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SearchLimit.Crossed">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Crossed</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Crossed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns true if the limit has been crossed.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchLimit_Crossed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns true if the limit has been crossed.</p>
</div>


                            </div>
                            <div id="SearchLimit.Check" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SearchLimit.Check">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Check</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Check</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method is called to check the status of the limit. A return</span>
<span class="sd">        value of true indicates that we have indeed crossed the limit. In</span>
<span class="sd">        that case, this method will not be called again and the remaining</span>
<span class="sd">        search will be discarded.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchLimit_Check</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method is called to check the status of the limit. A return
value of true indicates that we have indeed crossed the limit. In
that case, this method will not be called again and the remaining
search will be discarded.</p>
</div>


                            </div>
                            <div id="SearchLimit.Init" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SearchLimit.Init">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Init</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Init</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This method is called when the search limit is initialized.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchLimit_Init</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method is called when the search limit is initialized.</p>
</div>


                            </div>
                            <div id="SearchLimit.EnterSearch" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SearchLimit.EnterSearch">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">EnterSearch</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">EnterSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Internal methods.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchLimit_EnterSearch</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Internal methods.</p>
</div>


                            </div>
                            <div id="SearchLimit.BeginNextDecision" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SearchLimit.BeginNextDecision">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">BeginNextDecision</span><span class="signature">(self, b: <a href="#DecisionBuilder">pywrapcp.DecisionBuilder</a>) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">BeginNextDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">:</span> <span class="s2">&quot;DecisionBuilder&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchLimit_BeginNextDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Before calling DecisionBuilder::Next.</p>
</div>


                            </div>
                            <div id="SearchLimit.RefuteDecision" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SearchLimit.RefuteDecision">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">RefuteDecision</span><span class="signature">(self, d: <a href="#Decision">pywrapcp.Decision</a>) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">RefuteDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="s2">&quot;Decision&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchLimit_RefuteDecision</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Before refuting the decision.</p>
</div>


                            </div>
                            <div id="SearchLimit.DebugString" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SearchLimit.DebugString">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DebugString</span><span class="signature">(self) -&gt; &#39;std::string&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SearchLimit_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#SearchMonitor">SearchMonitor</a></dt>
                                <dd id="SearchLimit.RestartSearch" class="function"><a href="#SearchMonitor.RestartSearch">RestartSearch</a></dd>
                <dd id="SearchLimit.ExitSearch" class="function"><a href="#SearchMonitor.ExitSearch">ExitSearch</a></dd>
                <dd id="SearchLimit.EndNextDecision" class="function"><a href="#SearchMonitor.EndNextDecision">EndNextDecision</a></dd>
                <dd id="SearchLimit.ApplyDecision" class="function"><a href="#SearchMonitor.ApplyDecision">ApplyDecision</a></dd>
                <dd id="SearchLimit.AfterDecision" class="function"><a href="#SearchMonitor.AfterDecision">AfterDecision</a></dd>
                <dd id="SearchLimit.BeginFail" class="function"><a href="#SearchMonitor.BeginFail">BeginFail</a></dd>
                <dd id="SearchLimit.EndFail" class="function"><a href="#SearchMonitor.EndFail">EndFail</a></dd>
                <dd id="SearchLimit.BeginInitialPropagation" class="function"><a href="#SearchMonitor.BeginInitialPropagation">BeginInitialPropagation</a></dd>
                <dd id="SearchLimit.EndInitialPropagation" class="function"><a href="#SearchMonitor.EndInitialPropagation">EndInitialPropagation</a></dd>
                <dd id="SearchLimit.AcceptSolution" class="function"><a href="#SearchMonitor.AcceptSolution">AcceptSolution</a></dd>
                <dd id="SearchLimit.AtSolution" class="function"><a href="#SearchMonitor.AtSolution">AtSolution</a></dd>
                <dd id="SearchLimit.NoMoreSolutions" class="function"><a href="#SearchMonitor.NoMoreSolutions">NoMoreSolutions</a></dd>
                <dd id="SearchLimit.LocalOptimum" class="function"><a href="#SearchMonitor.LocalOptimum">LocalOptimum</a></dd>
                <dd id="SearchLimit.AcceptDelta" class="function"><a href="#SearchMonitor.AcceptDelta">AcceptDelta</a></dd>
                <dd id="SearchLimit.AcceptNeighbor" class="function"><a href="#SearchMonitor.AcceptNeighbor">AcceptNeighbor</a></dd>
                <dd id="SearchLimit.solver" class="function"><a href="#SearchMonitor.solver">solver</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="IntervalVar">
                                <div class="attr class">
        <a class="headerlink" href="#IntervalVar">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">IntervalVar</span><wbr>(<span class="base"><a href="#PropagationBaseObject">PropagationBaseObject</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">IntervalVar</span><span class="p">(</span><span class="n">PropagationBaseObject</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Interval variables are often used in scheduling. The main characteristics</span>
<span class="sd">    of an IntervalVar are the start position, duration, and end</span>
<span class="sd">    date. All these characteristics can be queried and set, and demons can</span>
<span class="sd">    be posted on their modifications.</span>

<span class="sd">    An important aspect is optionality: an IntervalVar can be performed or not.</span>
<span class="sd">    If unperformed, then it simply does not exist, and its characteristics</span>
<span class="sd">    cannot be accessed any more. An interval var is automatically marked</span>
<span class="sd">    as unperformed when it is not consistent anymore (start greater</span>
<span class="sd">    than end, duration &lt; 0...)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        These methods query, set, and watch the start position of the</span>
<span class="sd">        interval var.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetStartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_SetStartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetStartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_SetStartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetStartRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">ma</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_SetStartRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">ma</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">OldStartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_OldStartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">OldStartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_OldStartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WhenStartRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_WhenStartRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WhenStartBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_WhenStartBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; These methods query, set, and watch the duration of the interval var.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_DurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_DurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetDurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_SetDurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetDurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_SetDurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetDurationRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">ma</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_SetDurationRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">ma</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">OldDurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_OldDurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">OldDurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_OldDurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WhenDurationRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_WhenDurationRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WhenDurationBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_WhenDurationBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; These methods query, set, and watch the end position of the interval var.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetEndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_SetEndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetEndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_SetEndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetEndRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">ma</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_SetEndRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">ma</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">OldEndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_OldEndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">OldEndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_OldEndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WhenEndRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_WhenEndRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WhenEndBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_WhenEndBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">MustBePerformed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        These methods query, set, and watch the performed status of the</span>
<span class="sd">        interval var.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_MustBePerformed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">MayBePerformed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_MayBePerformed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">CannotBePerformed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_CannotBePerformed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsPerformedBound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_IsPerformedBound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetPerformed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_SetPerformed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WasPerformedBound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_WasPerformedBound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WhenPerformedBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_WhenPerformedBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WhenAnything</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Attaches a demon awakened when anything about this interval changes.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Attaches a closure awakened when anything about this interval changes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_WhenAnything</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        These methods create expressions encapsulating the start, end</span>
<span class="sd">        and duration of the interval var. Please note that these must not</span>
<span class="sd">        be used if the interval var is unperformed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DurationExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_DurationExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">PerformedExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_PerformedExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SafeStartExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unperformed_value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        These methods create expressions encapsulating the start, end</span>
<span class="sd">        and duration of the interval var. If the interval var is</span>
<span class="sd">        unperformed, they will return the unperformed_value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_SafeStartExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unperformed_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SafeDurationExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unperformed_value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_SafeDurationExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unperformed_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SafeEndExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unperformed_value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_SafeEndExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unperformed_value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndsAfterEnd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndsAfterEnd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndsAfterEndWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndsAfterEndWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">delay</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndsAfterStart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndsAfterStart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndsAfterStartWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndsAfterStartWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">delay</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndsAtEnd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndsAtEnd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndsAtEndWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndsAtEndWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">delay</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndsAtStart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndsAtStart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndsAtStartWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndsAtStartWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">delay</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartsAfterEnd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartsAfterEnd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartsAfterEndWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartsAfterEndWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">delay</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartsAfterStart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartsAfterStart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartsAfterStartWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartsAfterStartWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">delay</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartsAtEnd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartsAtEnd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartsAtEndWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartsAtEndWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">delay</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartsAtStart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartsAtStart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartsAtStartWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartsAtStartWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">delay</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StaysInSync</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StaysInSync</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StaysInSyncWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StaysInSyncWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">delay</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndsAfter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndsAfter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndsAt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndsAt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndsBefore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndsBefore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartsAfter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartsAfter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartsAt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartsAt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartsBefore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartsBefore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">CrossesDate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_CrossesDate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AvoidsDate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_AvoidsDate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar___repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar___str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Interval variables are often used in scheduling. The main characteristics
of an IntervalVar are the start position, duration, and end
date. All these characteristics can be queried and set, and demons can
be posted on their modifications.</p>

<p>An important aspect is optionality: an IntervalVar can be performed or not.
If unperformed, then it simply does not exist, and its characteristics
cannot be accessed any more. An interval var is automatically marked
as unperformed when it is not consistent anymore (start greater
than end, duration &lt; 0...)</p>
</div>


                            <div id="IntervalVar.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">IntervalVar</span><span class="signature">(*args, **kwargs)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#IntervalVar.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="IntervalVar.StartMin" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.StartMin">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">StartMin</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">StartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        These methods query, set, and watch the start position of the</span>
<span class="sd">        interval var.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>These methods query, set, and watch the start position of the
interval var.</p>
</div>


                            </div>
                            <div id="IntervalVar.StartMax" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.StartMax">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">StartMax</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">StartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.SetStartMin" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.SetStartMin">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetStartMin</span><span class="signature">(self, m: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetStartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_SetStartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.SetStartMax" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.SetStartMax">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetStartMax</span><span class="signature">(self, m: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetStartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_SetStartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.SetStartRange" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.SetStartRange">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetStartRange</span><span class="signature">(self, mi: &#39;int64_t&#39;, ma: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetStartRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">ma</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_SetStartRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">ma</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.OldStartMin" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.OldStartMin">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">OldStartMin</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">OldStartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_OldStartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.OldStartMax" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.OldStartMax">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">OldStartMax</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">OldStartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_OldStartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.WhenStartRange" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.WhenStartRange">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">WhenStartRange</span><span class="signature">(self, *args) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">WhenStartRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_WhenStartRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.WhenStartBound" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.WhenStartBound">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">WhenStartBound</span><span class="signature">(self, *args) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">WhenStartBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_WhenStartBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.DurationMin" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.DurationMin">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DurationMin</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">DurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; These methods query, set, and watch the duration of the interval var.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_DurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>These methods query, set, and watch the duration of the interval var.</p>
</div>


                            </div>
                            <div id="IntervalVar.DurationMax" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.DurationMax">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DurationMax</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">DurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_DurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.SetDurationMin" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.SetDurationMin">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetDurationMin</span><span class="signature">(self, m: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetDurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_SetDurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.SetDurationMax" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.SetDurationMax">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetDurationMax</span><span class="signature">(self, m: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetDurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_SetDurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.SetDurationRange" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.SetDurationRange">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetDurationRange</span><span class="signature">(self, mi: &#39;int64_t&#39;, ma: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetDurationRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">ma</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_SetDurationRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">ma</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.OldDurationMin" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.OldDurationMin">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">OldDurationMin</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">OldDurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_OldDurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.OldDurationMax" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.OldDurationMax">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">OldDurationMax</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">OldDurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_OldDurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.WhenDurationRange" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.WhenDurationRange">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">WhenDurationRange</span><span class="signature">(self, *args) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">WhenDurationRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_WhenDurationRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.WhenDurationBound" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.WhenDurationBound">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">WhenDurationBound</span><span class="signature">(self, *args) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">WhenDurationBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_WhenDurationBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.EndMin" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.EndMin">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">EndMin</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">EndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; These methods query, set, and watch the end position of the interval var.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>These methods query, set, and watch the end position of the interval var.</p>
</div>


                            </div>
                            <div id="IntervalVar.EndMax" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.EndMax">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">EndMax</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">EndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.SetEndMin" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.SetEndMin">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetEndMin</span><span class="signature">(self, m: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetEndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_SetEndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.SetEndMax" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.SetEndMax">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetEndMax</span><span class="signature">(self, m: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetEndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_SetEndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.SetEndRange" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.SetEndRange">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetEndRange</span><span class="signature">(self, mi: &#39;int64_t&#39;, ma: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetEndRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">ma</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_SetEndRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">ma</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.OldEndMin" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.OldEndMin">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">OldEndMin</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">OldEndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_OldEndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.OldEndMax" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.OldEndMax">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">OldEndMax</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">OldEndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_OldEndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.WhenEndRange" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.WhenEndRange">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">WhenEndRange</span><span class="signature">(self, *args) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">WhenEndRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_WhenEndRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.WhenEndBound" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.WhenEndBound">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">WhenEndBound</span><span class="signature">(self, *args) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">WhenEndBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_WhenEndBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.MustBePerformed" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.MustBePerformed">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">MustBePerformed</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">MustBePerformed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        These methods query, set, and watch the performed status of the</span>
<span class="sd">        interval var.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_MustBePerformed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>These methods query, set, and watch the performed status of the
interval var.</p>
</div>


                            </div>
                            <div id="IntervalVar.MayBePerformed" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.MayBePerformed">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">MayBePerformed</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">MayBePerformed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_MayBePerformed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.CannotBePerformed" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.CannotBePerformed">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">CannotBePerformed</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">CannotBePerformed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_CannotBePerformed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.IsPerformedBound" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.IsPerformedBound">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsPerformedBound</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsPerformedBound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_IsPerformedBound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.SetPerformed" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.SetPerformed">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetPerformed</span><span class="signature">(self, val: bool) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetPerformed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_SetPerformed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.WasPerformedBound" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.WasPerformedBound">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">WasPerformedBound</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">WasPerformedBound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_WasPerformedBound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.WhenPerformedBound" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.WhenPerformedBound">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">WhenPerformedBound</span><span class="signature">(self, *args) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">WhenPerformedBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_WhenPerformedBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.WhenAnything" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.WhenAnything">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">WhenAnything</span><span class="signature">(self, *args) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">WhenAnything</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Attaches a demon awakened when anything about this interval changes.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Attaches a closure awakened when anything about this interval changes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_WhenAnything</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p><em>Overload 1:</em>
Attaches a demon awakened when anything about this interval changes.</p>

<p>|</p>

<p><em>Overload 2:</em>
Attaches a closure awakened when anything about this interval changes.</p>
</div>


                            </div>
                            <div id="IntervalVar.StartExpr" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.StartExpr">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">StartExpr</span><span class="signature">(self) -&gt; &#39;operations_research::IntExpr *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">StartExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        These methods create expressions encapsulating the start, end</span>
<span class="sd">        and duration of the interval var. Please note that these must not</span>
<span class="sd">        be used if the interval var is unperformed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>These methods create expressions encapsulating the start, end
and duration of the interval var. Please note that these must not
be used if the interval var is unperformed.</p>
</div>


                            </div>
                            <div id="IntervalVar.DurationExpr" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.DurationExpr">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DurationExpr</span><span class="signature">(self) -&gt; &#39;operations_research::IntExpr *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">DurationExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_DurationExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.EndExpr" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.EndExpr">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">EndExpr</span><span class="signature">(self) -&gt; &#39;operations_research::IntExpr *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">EndExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.PerformedExpr" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.PerformedExpr">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">PerformedExpr</span><span class="signature">(self) -&gt; &#39;operations_research::IntExpr *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">PerformedExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_PerformedExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.SafeStartExpr" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.SafeStartExpr">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SafeStartExpr</span><span class="signature">(
    self,
    unperformed_value: &#39;int64_t&#39;
) -&gt; &#39;operations_research::IntExpr *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SafeStartExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unperformed_value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        These methods create expressions encapsulating the start, end</span>
<span class="sd">        and duration of the interval var. If the interval var is</span>
<span class="sd">        unperformed, they will return the unperformed_value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_SafeStartExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unperformed_value</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>These methods create expressions encapsulating the start, end
and duration of the interval var. If the interval var is
unperformed, they will return the unperformed_value.</p>
</div>


                            </div>
                            <div id="IntervalVar.SafeDurationExpr" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.SafeDurationExpr">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SafeDurationExpr</span><span class="signature">(
    self,
    unperformed_value: &#39;int64_t&#39;
) -&gt; &#39;operations_research::IntExpr *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SafeDurationExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unperformed_value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_SafeDurationExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unperformed_value</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.SafeEndExpr" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.SafeEndExpr">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SafeEndExpr</span><span class="signature">(
    self,
    unperformed_value: &#39;int64_t&#39;
) -&gt; &#39;operations_research::IntExpr *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SafeEndExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unperformed_value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntExpr *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_SafeEndExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unperformed_value</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.EndsAfterEnd" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.EndsAfterEnd">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">EndsAfterEnd</span><span class="signature">(
    self,
    other: <a href="#IntervalVar">pywrapcp.IntervalVar</a>
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">EndsAfterEnd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndsAfterEnd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.EndsAfterEndWithDelay" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.EndsAfterEndWithDelay">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">EndsAfterEndWithDelay</span><span class="signature">(
    self,
    other: <a href="#IntervalVar">pywrapcp.IntervalVar</a>,
    delay: &#39;int64_t&#39;
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">EndsAfterEndWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndsAfterEndWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">delay</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.EndsAfterStart" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.EndsAfterStart">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">EndsAfterStart</span><span class="signature">(
    self,
    other: <a href="#IntervalVar">pywrapcp.IntervalVar</a>
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">EndsAfterStart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndsAfterStart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.EndsAfterStartWithDelay" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.EndsAfterStartWithDelay">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">EndsAfterStartWithDelay</span><span class="signature">(
    self,
    other: <a href="#IntervalVar">pywrapcp.IntervalVar</a>,
    delay: &#39;int64_t&#39;
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">EndsAfterStartWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndsAfterStartWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">delay</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.EndsAtEnd" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.EndsAtEnd">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">EndsAtEnd</span><span class="signature">(
    self,
    other: <a href="#IntervalVar">pywrapcp.IntervalVar</a>
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">EndsAtEnd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndsAtEnd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.EndsAtEndWithDelay" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.EndsAtEndWithDelay">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">EndsAtEndWithDelay</span><span class="signature">(
    self,
    other: <a href="#IntervalVar">pywrapcp.IntervalVar</a>,
    delay: &#39;int64_t&#39;
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">EndsAtEndWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndsAtEndWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">delay</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.EndsAtStart" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.EndsAtStart">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">EndsAtStart</span><span class="signature">(
    self,
    other: <a href="#IntervalVar">pywrapcp.IntervalVar</a>
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">EndsAtStart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndsAtStart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.EndsAtStartWithDelay" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.EndsAtStartWithDelay">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">EndsAtStartWithDelay</span><span class="signature">(
    self,
    other: <a href="#IntervalVar">pywrapcp.IntervalVar</a>,
    delay: &#39;int64_t&#39;
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">EndsAtStartWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndsAtStartWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">delay</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.StartsAfterEnd" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.StartsAfterEnd">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">StartsAfterEnd</span><span class="signature">(
    self,
    other: <a href="#IntervalVar">pywrapcp.IntervalVar</a>
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">StartsAfterEnd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartsAfterEnd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.StartsAfterEndWithDelay" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.StartsAfterEndWithDelay">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">StartsAfterEndWithDelay</span><span class="signature">(
    self,
    other: <a href="#IntervalVar">pywrapcp.IntervalVar</a>,
    delay: &#39;int64_t&#39;
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">StartsAfterEndWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartsAfterEndWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">delay</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.StartsAfterStart" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.StartsAfterStart">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">StartsAfterStart</span><span class="signature">(
    self,
    other: <a href="#IntervalVar">pywrapcp.IntervalVar</a>
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">StartsAfterStart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartsAfterStart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.StartsAfterStartWithDelay" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.StartsAfterStartWithDelay">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">StartsAfterStartWithDelay</span><span class="signature">(
    self,
    other: <a href="#IntervalVar">pywrapcp.IntervalVar</a>,
    delay: &#39;int64_t&#39;
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">StartsAfterStartWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartsAfterStartWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">delay</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.StartsAtEnd" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.StartsAtEnd">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">StartsAtEnd</span><span class="signature">(
    self,
    other: <a href="#IntervalVar">pywrapcp.IntervalVar</a>
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">StartsAtEnd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartsAtEnd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.StartsAtEndWithDelay" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.StartsAtEndWithDelay">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">StartsAtEndWithDelay</span><span class="signature">(
    self,
    other: <a href="#IntervalVar">pywrapcp.IntervalVar</a>,
    delay: &#39;int64_t&#39;
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">StartsAtEndWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartsAtEndWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">delay</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.StartsAtStart" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.StartsAtStart">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">StartsAtStart</span><span class="signature">(
    self,
    other: <a href="#IntervalVar">pywrapcp.IntervalVar</a>
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">StartsAtStart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartsAtStart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.StartsAtStartWithDelay" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.StartsAtStartWithDelay">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">StartsAtStartWithDelay</span><span class="signature">(
    self,
    other: <a href="#IntervalVar">pywrapcp.IntervalVar</a>,
    delay: &#39;int64_t&#39;
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">StartsAtStartWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartsAtStartWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">delay</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.StaysInSync" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.StaysInSync">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">StaysInSync</span><span class="signature">(
    self,
    other: <a href="#IntervalVar">pywrapcp.IntervalVar</a>
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">StaysInSync</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StaysInSync</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.StaysInSyncWithDelay" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.StaysInSyncWithDelay">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">StaysInSyncWithDelay</span><span class="signature">(
    self,
    other: <a href="#IntervalVar">pywrapcp.IntervalVar</a>,
    delay: &#39;int64_t&#39;
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">StaysInSyncWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">delay</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StaysInSyncWithDelay</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">other</span><span class="p">,</span> <span class="n">delay</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.EndsAfter" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.EndsAfter">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">EndsAfter</span><span class="signature">(self, date: &#39;int64_t&#39;) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">EndsAfter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndsAfter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.EndsAt" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.EndsAt">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">EndsAt</span><span class="signature">(self, date: &#39;int64_t&#39;) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">EndsAt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndsAt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.EndsBefore" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.EndsBefore">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">EndsBefore</span><span class="signature">(self, date: &#39;int64_t&#39;) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">EndsBefore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_EndsBefore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.StartsAfter" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.StartsAfter">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">StartsAfter</span><span class="signature">(self, date: &#39;int64_t&#39;) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">StartsAfter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartsAfter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.StartsAt" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.StartsAt">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">StartsAt</span><span class="signature">(self, date: &#39;int64_t&#39;) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">StartsAt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartsAt</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.StartsBefore" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.StartsBefore">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">StartsBefore</span><span class="signature">(self, date: &#39;int64_t&#39;) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">StartsBefore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_StartsBefore</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.CrossesDate" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.CrossesDate">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">CrossesDate</span><span class="signature">(self, date: &#39;int64_t&#39;) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">CrossesDate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_CrossesDate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVar.AvoidsDate" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVar.AvoidsDate">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AvoidsDate</span><span class="signature">(self, date: &#39;int64_t&#39;) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AvoidsDate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVar_AvoidsDate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">date</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#PropagationBaseObject">PropagationBaseObject</a></dt>
                                <dd id="IntervalVar.DebugString" class="function"><a href="#PropagationBaseObject.DebugString">DebugString</a></dd>
                <dd id="IntervalVar.solver" class="function"><a href="#PropagationBaseObject.solver">solver</a></dd>
                <dd id="IntervalVar.Name" class="function"><a href="#PropagationBaseObject.Name">Name</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="SequenceVar">
                                <div class="attr class">
        <a class="headerlink" href="#SequenceVar">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">SequenceVar</span><wbr>(<span class="base"><a href="#PropagationBaseObject">PropagationBaseObject</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">SequenceVar</span><span class="p">(</span><span class="n">PropagationBaseObject</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A sequence variable is a variable whose domain is a set of possible</span>
<span class="sd">    orderings of the interval variables. It allows ordering of tasks. It</span>
<span class="sd">    has two sets of methods: ComputePossibleFirstsAndLasts(), which</span>
<span class="sd">    returns the list of interval variables that can be ranked first or</span>
<span class="sd">    last; and RankFirst/RankNotFirst/RankLast/RankNotLast, which can be</span>
<span class="sd">    used to create the search decision.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVar_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RankFirst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ranks the index_th interval var first of all unranked interval</span>
<span class="sd">        vars. After that, it will no longer be considered ranked.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVar_RankFirst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RankNotFirst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Indicates that the index_th interval var will not be ranked first</span>
<span class="sd">        of all currently unranked interval vars.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVar_RankNotFirst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RankLast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ranks the index_th interval var first of all unranked interval</span>
<span class="sd">        vars. After that, it will no longer be considered ranked.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVar_RankLast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RankNotLast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Indicates that the index_th interval var will not be ranked first</span>
<span class="sd">        of all currently unranked interval vars.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVar_RankNotLast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Interval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntervalVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the index_th interval of the sequence.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVar_Interval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Next</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the next of the index_th interval of the sequence.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVar_Next</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the number of interval vars in the sequence.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVar_Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVar___repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVar___str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>A sequence variable is a variable whose domain is a set of possible
orderings of the interval variables. It allows ordering of tasks. It
has two sets of methods: ComputePossibleFirstsAndLasts(), which
returns the list of interval variables that can be ranked first or
last; and RankFirst/RankNotFirst/RankLast/RankNotLast, which can be
used to create the search decision.</p>
</div>


                            <div id="SequenceVar.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SequenceVar.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">SequenceVar</span><span class="signature">(*args, **kwargs)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="SequenceVar.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#SequenceVar.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="SequenceVar.DebugString" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SequenceVar.DebugString">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DebugString</span><span class="signature">(self) -&gt; &#39;std::string&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVar_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="SequenceVar.RankFirst" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SequenceVar.RankFirst">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">RankFirst</span><span class="signature">(self, index: int) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">RankFirst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ranks the index_th interval var first of all unranked interval</span>
<span class="sd">        vars. After that, it will no longer be considered ranked.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVar_RankFirst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Ranks the index_th interval var first of all unranked interval
vars. After that, it will no longer be considered ranked.</p>
</div>


                            </div>
                            <div id="SequenceVar.RankNotFirst" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SequenceVar.RankNotFirst">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">RankNotFirst</span><span class="signature">(self, index: int) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">RankNotFirst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Indicates that the index_th interval var will not be ranked first</span>
<span class="sd">        of all currently unranked interval vars.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVar_RankNotFirst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Indicates that the index_th interval var will not be ranked first
of all currently unranked interval vars.</p>
</div>


                            </div>
                            <div id="SequenceVar.RankLast" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SequenceVar.RankLast">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">RankLast</span><span class="signature">(self, index: int) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">RankLast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Ranks the index_th interval var first of all unranked interval</span>
<span class="sd">        vars. After that, it will no longer be considered ranked.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVar_RankLast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Ranks the index_th interval var first of all unranked interval
vars. After that, it will no longer be considered ranked.</p>
</div>


                            </div>
                            <div id="SequenceVar.RankNotLast" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SequenceVar.RankNotLast">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">RankNotLast</span><span class="signature">(self, index: int) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">RankNotLast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Indicates that the index_th interval var will not be ranked first</span>
<span class="sd">        of all currently unranked interval vars.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVar_RankNotLast</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Indicates that the index_th interval var will not be ranked first
of all currently unranked interval vars.</p>
</div>


                            </div>
                            <div id="SequenceVar.Interval" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SequenceVar.Interval">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Interval</span><span class="signature">(self, index: int) -&gt; &#39;operations_research::IntervalVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Interval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntervalVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the index_th interval of the sequence.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVar_Interval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the index_th interval of the sequence.</p>
</div>


                            </div>
                            <div id="SequenceVar.Next" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SequenceVar.Next">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Next</span><span class="signature">(self, index: int) -&gt; &#39;operations_research::IntVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Next</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the next of the index_th interval of the sequence.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVar_Next</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the next of the index_th interval of the sequence.</p>
</div>


                            </div>
                            <div id="SequenceVar.Size" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SequenceVar.Size">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Size</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the number of interval vars in the sequence.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVar_Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the number of interval vars in the sequence.</p>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#PropagationBaseObject">PropagationBaseObject</a></dt>
                                <dd id="SequenceVar.solver" class="function"><a href="#PropagationBaseObject.solver">solver</a></dd>
                <dd id="SequenceVar.Name" class="function"><a href="#PropagationBaseObject.Name">Name</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="AssignmentElement">
                                <div class="attr class">
        <a class="headerlink" href="#AssignmentElement">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">AssignmentElement</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">AssignmentElement</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">Activate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">AssignmentElement_Activate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Deactivate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">AssignmentElement_Deactivate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Activated</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">AssignmentElement_Activated</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_AssignmentElement</span>
</pre></div>

        </details>

    

                            <div id="AssignmentElement.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#AssignmentElement.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">AssignmentElement</span><span class="signature">(*args, **kwargs)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="AssignmentElement.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#AssignmentElement.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="AssignmentElement.Activate" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#AssignmentElement.Activate">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Activate</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Activate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">AssignmentElement_Activate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="AssignmentElement.Deactivate" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#AssignmentElement.Deactivate">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Deactivate</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Deactivate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">AssignmentElement_Deactivate</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="AssignmentElement.Activated" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#AssignmentElement.Activated">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Activated</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Activated</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">AssignmentElement_Activated</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                </section>
                <section id="IntVarElement">
                                <div class="attr class">
        <a class="headerlink" href="#IntVarElement">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">IntVarElement</span><wbr>(<span class="base"><a href="#AssignmentElement">AssignmentElement</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">IntVarElement</span><span class="p">(</span><span class="n">AssignmentElement</span><span class="p">):</span>
    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarElement_Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Min</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarElement_Min</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarElement_SetMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Max</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarElement_Max</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarElement_SetMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarElement_Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Bound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarElement_Bound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarElement_SetRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarElement_SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">:</span> <span class="s2">&quot;IntVarElement&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarElement___eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">:</span> <span class="s2">&quot;IntVarElement&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarElement___ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_IntVarElement</span>
</pre></div>

        </details>

    

                            <div id="IntVarElement.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVarElement.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">IntVarElement</span><span class="signature">(*args, **kwargs)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntVarElement.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#IntVarElement.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="IntVarElement.Var" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVarElement.Var">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Var</span><span class="signature">(self) -&gt; &#39;operations_research::IntVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarElement_Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntVarElement.Min" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVarElement.Min">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Min</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Min</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarElement_Min</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntVarElement.SetMin" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVarElement.SetMin">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetMin</span><span class="signature">(self, m: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarElement_SetMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntVarElement.Max" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVarElement.Max">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Max</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Max</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarElement_Max</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntVarElement.SetMax" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVarElement.SetMax">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetMax</span><span class="signature">(self, m: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarElement_SetMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntVarElement.Value" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVarElement.Value">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Value</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarElement_Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntVarElement.Bound" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVarElement.Bound">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Bound</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Bound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarElement_Bound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntVarElement.SetRange" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVarElement.SetRange">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetRange</span><span class="signature">(self, l: &#39;int64_t&#39;, u: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarElement_SetRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntVarElement.SetValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVarElement.SetValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetValue</span><span class="signature">(self, v: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarElement_SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#AssignmentElement">AssignmentElement</a></dt>
                                <dd id="IntVarElement.Activate" class="function"><a href="#AssignmentElement.Activate">Activate</a></dd>
                <dd id="IntVarElement.Deactivate" class="function"><a href="#AssignmentElement.Deactivate">Deactivate</a></dd>
                <dd id="IntVarElement.Activated" class="function"><a href="#AssignmentElement.Activated">Activated</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="IntervalVarElement">
                                <div class="attr class">
        <a class="headerlink" href="#IntervalVarElement">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">IntervalVarElement</span><wbr>(<span class="base"><a href="#AssignmentElement">AssignmentElement</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">IntervalVarElement</span><span class="p">(</span><span class="n">AssignmentElement</span><span class="p">):</span>
    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntervalVar *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_StartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_StartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_StartValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_DurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_DurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DurationValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_DurationValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_EndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_EndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_EndValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">PerformedMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_PerformedMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">PerformedMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_PerformedMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">PerformedValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_PerformedValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetStartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetStartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetStartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetStartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetStartRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">ma</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetStartRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">ma</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetStartValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetStartValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetDurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetDurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetDurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetDurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetDurationRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">ma</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetDurationRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">ma</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetDurationValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetDurationValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetEndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetEndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetEndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetEndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetEndRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">ma</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetEndRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">ma</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetEndValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetEndValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetPerformedMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetPerformedMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetPerformedMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetPerformedMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetPerformedRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">ma</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetPerformedRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">ma</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetPerformedValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetPerformedValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">:</span> <span class="s2">&quot;IntervalVarElement&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement___eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">:</span> <span class="s2">&quot;IntervalVarElement&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement___ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_IntervalVarElement</span>
</pre></div>

        </details>

    

                            <div id="IntervalVarElement.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVarElement.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">IntervalVarElement</span><span class="signature">(*args, **kwargs)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVarElement.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#IntervalVarElement.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="IntervalVarElement.Var" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVarElement.Var">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Var</span><span class="signature">(self) -&gt; &#39;operations_research::IntervalVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntervalVar *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVarElement.StartMin" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVarElement.StartMin">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">StartMin</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">StartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_StartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVarElement.StartMax" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVarElement.StartMax">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">StartMax</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">StartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_StartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVarElement.StartValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVarElement.StartValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">StartValue</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">StartValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_StartValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVarElement.DurationMin" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVarElement.DurationMin">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DurationMin</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">DurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_DurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVarElement.DurationMax" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVarElement.DurationMax">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DurationMax</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">DurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_DurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVarElement.DurationValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVarElement.DurationValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DurationValue</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">DurationValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_DurationValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVarElement.EndMin" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVarElement.EndMin">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">EndMin</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">EndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_EndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVarElement.EndMax" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVarElement.EndMax">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">EndMax</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">EndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_EndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVarElement.EndValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVarElement.EndValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">EndValue</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">EndValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_EndValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVarElement.PerformedMin" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVarElement.PerformedMin">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">PerformedMin</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">PerformedMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_PerformedMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVarElement.PerformedMax" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVarElement.PerformedMax">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">PerformedMax</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">PerformedMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_PerformedMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVarElement.PerformedValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVarElement.PerformedValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">PerformedValue</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">PerformedValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_PerformedValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVarElement.SetStartMin" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVarElement.SetStartMin">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetStartMin</span><span class="signature">(self, m: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetStartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetStartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVarElement.SetStartMax" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVarElement.SetStartMax">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetStartMax</span><span class="signature">(self, m: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetStartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetStartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVarElement.SetStartRange" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVarElement.SetStartRange">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetStartRange</span><span class="signature">(self, mi: &#39;int64_t&#39;, ma: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetStartRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">ma</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetStartRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">ma</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVarElement.SetStartValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVarElement.SetStartValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetStartValue</span><span class="signature">(self, v: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetStartValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetStartValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVarElement.SetDurationMin" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVarElement.SetDurationMin">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetDurationMin</span><span class="signature">(self, m: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetDurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetDurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVarElement.SetDurationMax" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVarElement.SetDurationMax">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetDurationMax</span><span class="signature">(self, m: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetDurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetDurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVarElement.SetDurationRange" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVarElement.SetDurationRange">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetDurationRange</span><span class="signature">(self, mi: &#39;int64_t&#39;, ma: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetDurationRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">ma</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetDurationRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">ma</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVarElement.SetDurationValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVarElement.SetDurationValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetDurationValue</span><span class="signature">(self, v: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetDurationValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetDurationValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVarElement.SetEndMin" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVarElement.SetEndMin">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetEndMin</span><span class="signature">(self, m: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetEndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetEndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVarElement.SetEndMax" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVarElement.SetEndMax">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetEndMax</span><span class="signature">(self, m: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetEndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetEndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVarElement.SetEndRange" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVarElement.SetEndRange">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetEndRange</span><span class="signature">(self, mi: &#39;int64_t&#39;, ma: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetEndRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">ma</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetEndRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">ma</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVarElement.SetEndValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVarElement.SetEndValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetEndValue</span><span class="signature">(self, v: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetEndValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetEndValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVarElement.SetPerformedMin" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVarElement.SetPerformedMin">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetPerformedMin</span><span class="signature">(self, m: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetPerformedMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetPerformedMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVarElement.SetPerformedMax" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVarElement.SetPerformedMax">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetPerformedMax</span><span class="signature">(self, m: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetPerformedMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetPerformedMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVarElement.SetPerformedRange" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVarElement.SetPerformedRange">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetPerformedRange</span><span class="signature">(self, mi: &#39;int64_t&#39;, ma: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetPerformedRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">ma</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetPerformedRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">ma</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVarElement.SetPerformedValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVarElement.SetPerformedValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetPerformedValue</span><span class="signature">(self, v: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetPerformedValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarElement_SetPerformedValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#AssignmentElement">AssignmentElement</a></dt>
                                <dd id="IntervalVarElement.Activate" class="function"><a href="#AssignmentElement.Activate">Activate</a></dd>
                <dd id="IntervalVarElement.Deactivate" class="function"><a href="#AssignmentElement.Deactivate">Deactivate</a></dd>
                <dd id="IntervalVarElement.Activated" class="function"><a href="#AssignmentElement.Activated">Activated</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="SequenceVarElement">
                                <div class="attr class">
        <a class="headerlink" href="#SequenceVarElement">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">SequenceVarElement</span><wbr>(<span class="base"><a href="#AssignmentElement">AssignmentElement</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">SequenceVarElement</span><span class="p">(</span><span class="n">AssignmentElement</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The SequenceVarElement stores a partial representation of ranked</span>
<span class="sd">    interval variables in the underlying sequence variable.</span>
<span class="sd">    This representation consists of three vectors:</span>
<span class="sd">      - the forward sequence. That is the list of interval variables</span>
<span class="sd">        ranked first in the sequence.  The first element of the backward</span>
<span class="sd">        sequence is the first interval in the sequence variable.</span>
<span class="sd">      - the backward sequence. That is the list of interval variables</span>
<span class="sd">        ranked last in the sequence. The first element of the backward</span>
<span class="sd">        sequence is the last interval in the sequence variable.</span>
<span class="sd">      - The list of unperformed interval variables.</span>
<span class="sd">     Furthermore, if all performed variables are ranked, then by</span>
<span class="sd">     convention, the forward_sequence will contain all such variables</span>
<span class="sd">     and the backward_sequence will be empty.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SequenceVar *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarElement_Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ForwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarElement_ForwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">BackwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarElement_BackwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Unperformed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarElement_Unperformed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forward_sequence</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">backward_sequence</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">unperformed</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarElement_SetSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forward_sequence</span><span class="p">,</span> <span class="n">backward_sequence</span><span class="p">,</span> <span class="n">unperformed</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetForwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forward_sequence</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarElement_SetForwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forward_sequence</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetBackwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">backward_sequence</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarElement_SetBackwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">backward_sequence</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetUnperformed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unperformed</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarElement_SetUnperformed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unperformed</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">:</span> <span class="s2">&quot;SequenceVarElement&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarElement___eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">:</span> <span class="s2">&quot;SequenceVarElement&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarElement___ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">element</span><span class="p">)</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_SequenceVarElement</span>
</pre></div>

        </details>

            <div class="docstring"><p>The SequenceVarElement stores a partial representation of ranked
interval variables in the underlying sequence variable.</p>

<h6 id="this-representation-consists-of-three-vectors">This representation consists of three vectors</h6>

<blockquote>
  <ul>
  <li>the forward sequence. That is the list of interval variables
  ranked first in the sequence.  The first element of the backward
  sequence is the first interval in the sequence variable.</li>
  <li>the backward sequence. That is the list of interval variables
  ranked last in the sequence. The first element of the backward
  sequence is the last interval in the sequence variable.</li>
  <li>The list of unperformed interval variables.
  Furthermore, if all performed variables are ranked, then by
  convention, the forward_sequence will contain all such variables
  and the backward_sequence will be empty.</li>
  </ul>
</blockquote>
</div>


                            <div id="SequenceVarElement.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SequenceVarElement.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">SequenceVarElement</span><span class="signature">(*args, **kwargs)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="SequenceVarElement.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#SequenceVarElement.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="SequenceVarElement.Var" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SequenceVarElement.Var">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Var</span><span class="signature">(self) -&gt; &#39;operations_research::SequenceVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SequenceVar *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarElement_Var</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="SequenceVarElement.ForwardSequence" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SequenceVarElement.ForwardSequence">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ForwardSequence</span><span class="signature">(self) -&gt; &#39;std::vector&lt; int &gt; const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ForwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarElement_ForwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="SequenceVarElement.BackwardSequence" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SequenceVarElement.BackwardSequence">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">BackwardSequence</span><span class="signature">(self) -&gt; &#39;std::vector&lt; int &gt; const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">BackwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarElement_BackwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="SequenceVarElement.Unperformed" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SequenceVarElement.Unperformed">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Unperformed</span><span class="signature">(self) -&gt; &#39;std::vector&lt; int &gt; const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Unperformed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarElement_Unperformed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="SequenceVarElement.SetSequence" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SequenceVarElement.SetSequence">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetSequence</span><span class="signature">(
    self,
    forward_sequence: &#39;std::vector&lt; int &gt; const &amp;&#39;,
    backward_sequence: &#39;std::vector&lt; int &gt; const &amp;&#39;,
    unperformed: &#39;std::vector&lt; int &gt; const &amp;&#39;
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forward_sequence</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">backward_sequence</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">unperformed</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarElement_SetSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forward_sequence</span><span class="p">,</span> <span class="n">backward_sequence</span><span class="p">,</span> <span class="n">unperformed</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="SequenceVarElement.SetForwardSequence" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SequenceVarElement.SetForwardSequence">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetForwardSequence</span><span class="signature">(self, forward_sequence: &#39;std::vector&lt; int &gt; const &amp;&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetForwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forward_sequence</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarElement_SetForwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">forward_sequence</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="SequenceVarElement.SetBackwardSequence" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SequenceVarElement.SetBackwardSequence">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetBackwardSequence</span><span class="signature">(self, backward_sequence: &#39;std::vector&lt; int &gt; const &amp;&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetBackwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">backward_sequence</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarElement_SetBackwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">backward_sequence</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="SequenceVarElement.SetUnperformed" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SequenceVarElement.SetUnperformed">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetUnperformed</span><span class="signature">(self, unperformed: &#39;std::vector&lt; int &gt; const &amp;&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetUnperformed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unperformed</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarElement_SetUnperformed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">unperformed</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#AssignmentElement">AssignmentElement</a></dt>
                                <dd id="SequenceVarElement.Activate" class="function"><a href="#AssignmentElement.Activate">Activate</a></dd>
                <dd id="SequenceVarElement.Deactivate" class="function"><a href="#AssignmentElement.Deactivate">Deactivate</a></dd>
                <dd id="SequenceVarElement.Activated" class="function"><a href="#AssignmentElement.Activated">Activated</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="Assignment">
                                <div class="attr class">
        <a class="headerlink" href="#Assignment">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">Assignment</span><wbr>(<span class="base"><a href="#PropagationBaseObject">PropagationBaseObject</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Assignment</span><span class="p">(</span><span class="n">PropagationBaseObject</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An Assignment is a variable -&gt; domains mapping, used</span>
<span class="sd">    to report solutions to the user.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">Clear</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Clear</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Empty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Empty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NumIntVars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_NumIntVars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NumIntervalVars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_NumIntervalVars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NumSequenceVars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_NumSequenceVars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Store</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Store</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Restore</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Restore</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddObjective</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_AddObjective</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Objective</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Objective</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">HasObjective</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_HasObjective</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ObjectiveMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_ObjectiveMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ObjectiveMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_ObjectiveMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ObjectiveValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_ObjectiveValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ObjectiveBound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_ObjectiveBound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetObjectiveMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetObjectiveMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetObjectiveMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetObjectiveMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetObjectiveValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetObjectiveValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetObjectiveRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetObjectiveRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Bound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Bound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_StartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_StartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">StartValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_StartValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_DurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_DurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DurationValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_DurationValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_EndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_EndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">EndValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_EndValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">PerformedMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_PerformedMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">PerformedMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_PerformedMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">PerformedValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_PerformedValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetStartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetStartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetStartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetStartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetStartRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">mi</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">ma</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetStartRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">ma</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetStartValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetStartValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetDurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetDurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetDurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetDurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetDurationRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">mi</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">ma</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetDurationRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">ma</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetDurationValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetDurationValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetEndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetEndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetEndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetEndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetEndRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">mi</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">ma</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetEndRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">ma</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetEndValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetEndValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetPerformedMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetPerformedMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetPerformedMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetPerformedMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetPerformedRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">mi</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">ma</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetPerformedRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">ma</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetPerformedValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetPerformedValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ForwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;SequenceVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_ForwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">BackwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;SequenceVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_BackwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Unperformed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;SequenceVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Unperformed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;SequenceVar&quot;</span><span class="p">,</span> <span class="n">forward_sequence</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">backward_sequence</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">unperformed</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">forward_sequence</span><span class="p">,</span> <span class="n">backward_sequence</span><span class="p">,</span> <span class="n">unperformed</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetForwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;SequenceVar&quot;</span><span class="p">,</span> <span class="n">forward_sequence</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetForwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">forward_sequence</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetBackwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;SequenceVar&quot;</span><span class="p">,</span> <span class="n">backward_sequence</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetBackwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">backward_sequence</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetUnperformed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;SequenceVar&quot;</span><span class="p">,</span> <span class="n">unperformed</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetUnperformed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">unperformed</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Activate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Activate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Deactivate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Deactivate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Activated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Activated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IntVarContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment::IntContainer const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_IntVarContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">MutableIntVarContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment::IntContainer *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_MutableIntVarContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IntervalVarContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment::IntervalContainer const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_IntervalVarContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">MutableIntervalVarContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment::IntervalContainer *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_MutableIntervalVarContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SequenceVarContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment::SequenceContainer const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SequenceVarContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">MutableSequenceVarContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment::SequenceContainer *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_MutableSequenceVarContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment___eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment___ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>An Assignment is a variable -> domains mapping, used
to report solutions to the user.</p>
</div>


                            <div id="Assignment.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">Assignment</span><span class="signature">(*args, **kwargs)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Assignment.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="Assignment.Clear" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.Clear">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Clear</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Clear</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Clear</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.Empty" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.Empty">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Empty</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Empty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Empty</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.Size" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.Size">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Size</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.NumIntVars" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.NumIntVars">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">NumIntVars</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">NumIntVars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_NumIntVars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.NumIntervalVars" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.NumIntervalVars">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">NumIntervalVars</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">NumIntervalVars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_NumIntervalVars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.NumSequenceVars" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.NumSequenceVars">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">NumSequenceVars</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">NumSequenceVars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_NumSequenceVars</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.Store" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.Store">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Store</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Store</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Store</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.Restore" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.Restore">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Restore</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Restore</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Restore</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.Load" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.Load">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Load</span><span class="signature">(self, *args) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Load</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.Save" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.Save">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Save</span><span class="signature">(self, *args) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Save</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.AddObjective" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.AddObjective">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddObjective</span><span class="signature">(self, v: <a href="#IntVar">pywrapcp.IntVar</a>) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddObjective</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_AddObjective</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.Objective" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.Objective">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Objective</span><span class="signature">(self) -&gt; &#39;operations_research::IntVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Objective</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Objective</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.HasObjective" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.HasObjective">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">HasObjective</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">HasObjective</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_HasObjective</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.ObjectiveMin" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.ObjectiveMin">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ObjectiveMin</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ObjectiveMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_ObjectiveMin</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.ObjectiveMax" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.ObjectiveMax">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ObjectiveMax</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ObjectiveMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_ObjectiveMax</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.ObjectiveValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.ObjectiveValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ObjectiveValue</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ObjectiveValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_ObjectiveValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.ObjectiveBound" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.ObjectiveBound">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ObjectiveBound</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ObjectiveBound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_ObjectiveBound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.SetObjectiveMin" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.SetObjectiveMin">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetObjectiveMin</span><span class="signature">(self, m: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetObjectiveMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetObjectiveMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.SetObjectiveMax" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.SetObjectiveMax">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetObjectiveMax</span><span class="signature">(self, m: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetObjectiveMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetObjectiveMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.SetObjectiveValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.SetObjectiveValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetObjectiveValue</span><span class="signature">(self, value: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetObjectiveValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetObjectiveValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.SetObjectiveRange" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.SetObjectiveRange">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetObjectiveRange</span><span class="signature">(self, l: &#39;int64_t&#39;, u: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetObjectiveRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetObjectiveRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.Min" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.Min">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Min</span><span class="signature">(self, var: <a href="#IntVar">pywrapcp.IntVar</a>) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Min</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.Max" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.Max">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Max</span><span class="signature">(self, var: <a href="#IntVar">pywrapcp.IntVar</a>) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Max</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.Value" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.Value">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Value</span><span class="signature">(self, var: <a href="#IntVar">pywrapcp.IntVar</a>) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.Bound" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.Bound">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Bound</span><span class="signature">(self, var: <a href="#IntVar">pywrapcp.IntVar</a>) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Bound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Bound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.SetMin" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.SetMin">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetMin</span><span class="signature">(self, var: <a href="#IntVar">pywrapcp.IntVar</a>, m: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.SetMax" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.SetMax">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetMax</span><span class="signature">(self, var: <a href="#IntVar">pywrapcp.IntVar</a>, m: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.SetRange" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.SetRange">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetRange</span><span class="signature">(self, var: <a href="#IntVar">pywrapcp.IntVar</a>, l: &#39;int64_t&#39;, u: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.SetValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.SetValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetValue</span><span class="signature">(self, var: <a href="#IntVar">pywrapcp.IntVar</a>, value: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.StartMin" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.StartMin">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">StartMin</span><span class="signature">(self, var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">StartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_StartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.StartMax" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.StartMax">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">StartMax</span><span class="signature">(self, var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">StartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_StartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.StartValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.StartValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">StartValue</span><span class="signature">(self, var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">StartValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_StartValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.DurationMin" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.DurationMin">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DurationMin</span><span class="signature">(self, var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">DurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_DurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.DurationMax" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.DurationMax">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DurationMax</span><span class="signature">(self, var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">DurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_DurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.DurationValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.DurationValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DurationValue</span><span class="signature">(self, var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">DurationValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_DurationValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.EndMin" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.EndMin">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">EndMin</span><span class="signature">(self, var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">EndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_EndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.EndMax" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.EndMax">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">EndMax</span><span class="signature">(self, var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">EndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_EndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.EndValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.EndValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">EndValue</span><span class="signature">(self, var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">EndValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_EndValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.PerformedMin" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.PerformedMin">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">PerformedMin</span><span class="signature">(self, var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">PerformedMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_PerformedMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.PerformedMax" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.PerformedMax">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">PerformedMax</span><span class="signature">(self, var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">PerformedMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_PerformedMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.PerformedValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.PerformedValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">PerformedValue</span><span class="signature">(self, var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">PerformedValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_PerformedValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.SetStartMin" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.SetStartMin">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetStartMin</span><span class="signature">(self, var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>, m: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetStartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetStartMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.SetStartMax" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.SetStartMax">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetStartMax</span><span class="signature">(self, var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>, m: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetStartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetStartMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.SetStartRange" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.SetStartRange">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetStartRange</span><span class="signature">(
    self,
    var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>,
    mi: &#39;int64_t&#39;,
    ma: &#39;int64_t&#39;
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetStartRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">mi</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">ma</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetStartRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">ma</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.SetStartValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.SetStartValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetStartValue</span><span class="signature">(self, var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>, value: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetStartValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetStartValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.SetDurationMin" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.SetDurationMin">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetDurationMin</span><span class="signature">(self, var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>, m: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetDurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetDurationMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.SetDurationMax" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.SetDurationMax">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetDurationMax</span><span class="signature">(self, var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>, m: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetDurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetDurationMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.SetDurationRange" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.SetDurationRange">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetDurationRange</span><span class="signature">(
    self,
    var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>,
    mi: &#39;int64_t&#39;,
    ma: &#39;int64_t&#39;
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetDurationRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">mi</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">ma</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetDurationRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">ma</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.SetDurationValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.SetDurationValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetDurationValue</span><span class="signature">(self, var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>, value: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetDurationValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetDurationValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.SetEndMin" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.SetEndMin">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetEndMin</span><span class="signature">(self, var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>, m: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetEndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetEndMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.SetEndMax" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.SetEndMax">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetEndMax</span><span class="signature">(self, var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>, m: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetEndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetEndMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.SetEndRange" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.SetEndRange">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetEndRange</span><span class="signature">(
    self,
    var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>,
    mi: &#39;int64_t&#39;,
    ma: &#39;int64_t&#39;
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetEndRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">mi</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">ma</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetEndRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">ma</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.SetEndValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.SetEndValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetEndValue</span><span class="signature">(self, var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>, value: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetEndValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetEndValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.SetPerformedMin" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.SetPerformedMin">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetPerformedMin</span><span class="signature">(self, var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>, m: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetPerformedMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetPerformedMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.SetPerformedMax" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.SetPerformedMax">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetPerformedMax</span><span class="signature">(self, var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>, m: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetPerformedMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetPerformedMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.SetPerformedRange" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.SetPerformedRange">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetPerformedRange</span><span class="signature">(
    self,
    var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>,
    mi: &#39;int64_t&#39;,
    ma: &#39;int64_t&#39;
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetPerformedRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">mi</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">ma</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetPerformedRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">ma</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.SetPerformedValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.SetPerformedValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetPerformedValue</span><span class="signature">(self, var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>, value: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetPerformedValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetPerformedValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.Add" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.Add">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Add</span><span class="signature">(self, *args) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.ForwardSequence" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.ForwardSequence">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ForwardSequence</span><span class="signature">(self, var: <a href="#SequenceVar">pywrapcp.SequenceVar</a>) -&gt; &#39;std::vector&lt; int &gt; const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ForwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;SequenceVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_ForwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.BackwardSequence" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.BackwardSequence">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">BackwardSequence</span><span class="signature">(self, var: <a href="#SequenceVar">pywrapcp.SequenceVar</a>) -&gt; &#39;std::vector&lt; int &gt; const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">BackwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;SequenceVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_BackwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.Unperformed" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.Unperformed">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Unperformed</span><span class="signature">(self, var: <a href="#SequenceVar">pywrapcp.SequenceVar</a>) -&gt; &#39;std::vector&lt; int &gt; const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Unperformed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;SequenceVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Unperformed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.SetSequence" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.SetSequence">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetSequence</span><span class="signature">(
    self,
    var: <a href="#SequenceVar">pywrapcp.SequenceVar</a>,
    forward_sequence: &#39;std::vector&lt; int &gt; const &amp;&#39;,
    backward_sequence: &#39;std::vector&lt; int &gt; const &amp;&#39;,
    unperformed: &#39;std::vector&lt; int &gt; const &amp;&#39;
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;SequenceVar&quot;</span><span class="p">,</span> <span class="n">forward_sequence</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">backward_sequence</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">unperformed</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">forward_sequence</span><span class="p">,</span> <span class="n">backward_sequence</span><span class="p">,</span> <span class="n">unperformed</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.SetForwardSequence" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.SetForwardSequence">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetForwardSequence</span><span class="signature">(
    self,
    var: <a href="#SequenceVar">pywrapcp.SequenceVar</a>,
    forward_sequence: &#39;std::vector&lt; int &gt; const &amp;&#39;
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetForwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;SequenceVar&quot;</span><span class="p">,</span> <span class="n">forward_sequence</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetForwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">forward_sequence</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.SetBackwardSequence" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.SetBackwardSequence">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetBackwardSequence</span><span class="signature">(
    self,
    var: <a href="#SequenceVar">pywrapcp.SequenceVar</a>,
    backward_sequence: &#39;std::vector&lt; int &gt; const &amp;&#39;
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetBackwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;SequenceVar&quot;</span><span class="p">,</span> <span class="n">backward_sequence</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetBackwardSequence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">backward_sequence</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.SetUnperformed" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.SetUnperformed">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetUnperformed</span><span class="signature">(
    self,
    var: <a href="#SequenceVar">pywrapcp.SequenceVar</a>,
    unperformed: &#39;std::vector&lt; int &gt; const &amp;&#39;
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetUnperformed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;SequenceVar&quot;</span><span class="p">,</span> <span class="n">unperformed</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SetUnperformed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">unperformed</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.Activate" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.Activate">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Activate</span><span class="signature">(self, *args) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Activate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Activate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.Deactivate" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.Deactivate">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Deactivate</span><span class="signature">(self, *args) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Deactivate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Deactivate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.Activated" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.Activated">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Activated</span><span class="signature">(self, *args) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Activated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_Activated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.DebugString" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.DebugString">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DebugString</span><span class="signature">(self) -&gt; &#39;std::string&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.IntVarContainer" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.IntVarContainer">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IntVarContainer</span><span class="signature">(self) -&gt; &#39;operations_research::Assignment::IntContainer const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IntVarContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment::IntContainer const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_IntVarContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.MutableIntVarContainer" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.MutableIntVarContainer">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">MutableIntVarContainer</span><span class="signature">(self) -&gt; &#39;operations_research::Assignment::IntContainer *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">MutableIntVarContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment::IntContainer *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_MutableIntVarContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.IntervalVarContainer" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.IntervalVarContainer">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IntervalVarContainer</span><span class="signature">(self) -&gt; &#39;operations_research::Assignment::IntervalContainer const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IntervalVarContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment::IntervalContainer const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_IntervalVarContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.MutableIntervalVarContainer" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.MutableIntervalVarContainer">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">MutableIntervalVarContainer</span><span class="signature">(self) -&gt; &#39;operations_research::Assignment::IntervalContainer *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">MutableIntervalVarContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment::IntervalContainer *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_MutableIntervalVarContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.SequenceVarContainer" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.SequenceVarContainer">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SequenceVarContainer</span><span class="signature">(self) -&gt; &#39;operations_research::Assignment::SequenceContainer const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SequenceVarContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment::SequenceContainer const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_SequenceVarContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Assignment.MutableSequenceVarContainer" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Assignment.MutableSequenceVarContainer">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">MutableSequenceVarContainer</span><span class="signature">(self) -&gt; &#39;operations_research::Assignment::SequenceContainer *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">MutableSequenceVarContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment::SequenceContainer *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Assignment_MutableSequenceVarContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#PropagationBaseObject">PropagationBaseObject</a></dt>
                                <dd id="Assignment.solver" class="function"><a href="#PropagationBaseObject.solver">solver</a></dd>
                <dd id="Assignment.Name" class="function"><a href="#PropagationBaseObject.Name">Name</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="Pack">
                                <div class="attr class">
        <a class="headerlink" href="#Pack">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">Pack</span><wbr>(<span class="base"><a href="#Constraint">Constraint</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Pack</span><span class="p">(</span><span class="n">Constraint</span><span class="p">):</span>
    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">AddWeightedSumLessOrEqualConstantDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Dimensions are additional constraints than can restrict what is</span>
<span class="sd">        possible with the pack constraint. It can be used to set capacity</span>
<span class="sd">        limits, to count objects per bin, to compute unassigned</span>
<span class="sd">        penalties...</span>
<span class="sd">        This dimension imposes that for all bins b, the weighted sum</span>
<span class="sd">        (weights[i]) of all objects i assigned to &#39;b&#39; is less or equal</span>
<span class="sd">        &#39;bounds[b]&#39;.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        This dimension imposes that for all bins b, the weighted sum</span>
<span class="sd">        (weights-&gt;Run(i)) of all objects i assigned to &#39;b&#39; is less or</span>
<span class="sd">        equal to &#39;bounds[b]&#39;. Ownership of the callback is transferred to</span>
<span class="sd">        the pack constraint.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 3:*</span>
<span class="sd">        This dimension imposes that for all bins b, the weighted sum</span>
<span class="sd">        (weights-&gt;Run(i, b) of all objects i assigned to &#39;b&#39; is less or</span>
<span class="sd">        equal to &#39;bounds[b]&#39;. Ownership of the callback is transferred to</span>
<span class="sd">        the pack constraint.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Pack_AddWeightedSumLessOrEqualConstantDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddWeightedSumEqualVarDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        This dimension imposes that for all bins b, the weighted sum</span>
<span class="sd">        (weights[i]) of all objects i assigned to &#39;b&#39; is equal to loads[b].</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        This dimension imposes that for all bins b, the weighted sum</span>
<span class="sd">        (weights-&gt;Run(i, b)) of all objects i assigned to &#39;b&#39; is equal to</span>
<span class="sd">        loads[b].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Pack_AddWeightedSumEqualVarDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddSumVariableWeightsLessOrEqualConstantDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">usage</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This dimension imposes:</span>
<span class="sd">        forall b in bins,</span>
<span class="sd">           sum (i in items: usage[i] * is_assigned(i, b)) &lt;= capacity[b]</span>
<span class="sd">        where is_assigned(i, b) is true if and only if item i is assigned</span>
<span class="sd">        to the bin b.</span>

<span class="sd">        This can be used to model shapes of items by linking variables of</span>
<span class="sd">        the same item on parallel dimensions with an allowed assignment</span>
<span class="sd">        constraint.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Pack_AddSumVariableWeightsLessOrEqualConstantDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">usage</span><span class="p">,</span> <span class="n">capacity</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddWeightedSumOfAssignedDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weights</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">cost_var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This dimension enforces that cost_var == sum of weights[i] for</span>
<span class="sd">        all objects &#39;i&#39; assigned to a bin.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Pack_AddWeightedSumOfAssignedDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">cost_var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddCountUsedBinDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count_var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This dimension links &#39;count_var&#39; to the actual number of bins used in the</span>
<span class="sd">        pack.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Pack_AddCountUsedBinDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count_var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddCountAssignedItemsDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count_var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This dimension links &#39;count_var&#39; to the actual number of items</span>
<span class="sd">        assigned to a bin in the pack.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Pack_AddCountAssignedItemsDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count_var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Post</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Pack_Post</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">InitialPropagateWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Pack_InitialPropagateWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Pack_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>A constraint is the main modeling object. It provides two methods:</p>

<ul>
<li>Post() is responsible for creating the demons and attaching them to
immediate demons().</li>
<li>InitialPropagate() is called once just after Post and performs
the initial propagation. The subsequent propagations will be performed
by the demons Posted during the post() method.</li>
</ul>
</div>


                            <div id="Pack.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Pack.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">Pack</span><span class="signature">(*args, **kwargs)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Pack.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Pack.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="Pack.AddWeightedSumLessOrEqualConstantDimension" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Pack.AddWeightedSumLessOrEqualConstantDimension">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddWeightedSumLessOrEqualConstantDimension</span><span class="signature">(self, *args) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddWeightedSumLessOrEqualConstantDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Dimensions are additional constraints than can restrict what is</span>
<span class="sd">        possible with the pack constraint. It can be used to set capacity</span>
<span class="sd">        limits, to count objects per bin, to compute unassigned</span>
<span class="sd">        penalties...</span>
<span class="sd">        This dimension imposes that for all bins b, the weighted sum</span>
<span class="sd">        (weights[i]) of all objects i assigned to &#39;b&#39; is less or equal</span>
<span class="sd">        &#39;bounds[b]&#39;.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        This dimension imposes that for all bins b, the weighted sum</span>
<span class="sd">        (weights-&gt;Run(i)) of all objects i assigned to &#39;b&#39; is less or</span>
<span class="sd">        equal to &#39;bounds[b]&#39;. Ownership of the callback is transferred to</span>
<span class="sd">        the pack constraint.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 3:*</span>
<span class="sd">        This dimension imposes that for all bins b, the weighted sum</span>
<span class="sd">        (weights-&gt;Run(i, b) of all objects i assigned to &#39;b&#39; is less or</span>
<span class="sd">        equal to &#39;bounds[b]&#39;. Ownership of the callback is transferred to</span>
<span class="sd">        the pack constraint.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Pack_AddWeightedSumLessOrEqualConstantDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p><em>Overload 1:</em>
Dimensions are additional constraints than can restrict what is
possible with the pack constraint. It can be used to set capacity
limits, to count objects per bin, to compute unassigned
penalties...
This dimension imposes that for all bins b, the weighted sum
(weights[i]) of all objects i assigned to 'b' is less or equal
'bounds[b]'.</p>

<p>|</p>

<p><em>Overload 2:</em>
This dimension imposes that for all bins b, the weighted sum
(weights->Run(i)) of all objects i assigned to 'b' is less or
equal to 'bounds[b]'. Ownership of the callback is transferred to
the pack constraint.</p>

<p>|</p>

<p><em>Overload 3:</em>
This dimension imposes that for all bins b, the weighted sum
(weights->Run(i, b) of all objects i assigned to 'b' is less or
equal to 'bounds[b]'. Ownership of the callback is transferred to
the pack constraint.</p>
</div>


                            </div>
                            <div id="Pack.AddWeightedSumEqualVarDimension" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Pack.AddWeightedSumEqualVarDimension">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddWeightedSumEqualVarDimension</span><span class="signature">(self, *args) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddWeightedSumEqualVarDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        This dimension imposes that for all bins b, the weighted sum</span>
<span class="sd">        (weights[i]) of all objects i assigned to &#39;b&#39; is equal to loads[b].</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        This dimension imposes that for all bins b, the weighted sum</span>
<span class="sd">        (weights-&gt;Run(i, b)) of all objects i assigned to &#39;b&#39; is equal to</span>
<span class="sd">        loads[b].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Pack_AddWeightedSumEqualVarDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p><em>Overload 1:</em>
This dimension imposes that for all bins b, the weighted sum
(weights[i]) of all objects i assigned to 'b' is equal to loads[b].</p>

<p>|</p>

<p><em>Overload 2:</em>
This dimension imposes that for all bins b, the weighted sum
(weights->Run(i, b)) of all objects i assigned to 'b' is equal to
loads[b].</p>
</div>


                            </div>
                            <div id="Pack.AddSumVariableWeightsLessOrEqualConstantDimension" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Pack.AddSumVariableWeightsLessOrEqualConstantDimension">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddSumVariableWeightsLessOrEqualConstantDimension</span><span class="signature">(
    self,
    usage: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;,
    capacity: &#39;std::vector&lt; int64_t &gt; const &amp;&#39;
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddSumVariableWeightsLessOrEqualConstantDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">usage</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This dimension imposes:</span>
<span class="sd">        forall b in bins,</span>
<span class="sd">           sum (i in items: usage[i] * is_assigned(i, b)) &lt;= capacity[b]</span>
<span class="sd">        where is_assigned(i, b) is true if and only if item i is assigned</span>
<span class="sd">        to the bin b.</span>

<span class="sd">        This can be used to model shapes of items by linking variables of</span>
<span class="sd">        the same item on parallel dimensions with an allowed assignment</span>
<span class="sd">        constraint.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Pack_AddSumVariableWeightsLessOrEqualConstantDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">usage</span><span class="p">,</span> <span class="n">capacity</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This dimension imposes:
forall b in bins,
   sum (i in items: usage[i] * is_assigned(i, b)) &lt;= capacity[b]
where is_assigned(i, b) is true if and only if item i is assigned
to the bin b.</p>

<p>This can be used to model shapes of items by linking variables of
the same item on parallel dimensions with an allowed assignment
constraint.</p>
</div>


                            </div>
                            <div id="Pack.AddWeightedSumOfAssignedDimension" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Pack.AddWeightedSumOfAssignedDimension">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddWeightedSumOfAssignedDimension</span><span class="signature">(
    self,
    weights: &#39;std::vector&lt; int64_t &gt; const &amp;&#39;,
    cost_var: <a href="#IntVar">pywrapcp.IntVar</a>
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddWeightedSumOfAssignedDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weights</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">cost_var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This dimension enforces that cost_var == sum of weights[i] for</span>
<span class="sd">        all objects &#39;i&#39; assigned to a bin.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Pack_AddWeightedSumOfAssignedDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weights</span><span class="p">,</span> <span class="n">cost_var</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This dimension enforces that cost_var == sum of weights[i] for
all objects 'i' assigned to a bin.</p>
</div>


                            </div>
                            <div id="Pack.AddCountUsedBinDimension" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Pack.AddCountUsedBinDimension">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddCountUsedBinDimension</span><span class="signature">(self, count_var: <a href="#IntVar">pywrapcp.IntVar</a>) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddCountUsedBinDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count_var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This dimension links &#39;count_var&#39; to the actual number of bins used in the</span>
<span class="sd">        pack.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Pack_AddCountUsedBinDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count_var</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This dimension links 'count_var' to the actual number of bins used in the
pack.</p>
</div>


                            </div>
                            <div id="Pack.AddCountAssignedItemsDimension" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Pack.AddCountAssignedItemsDimension">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddCountAssignedItemsDimension</span><span class="signature">(self, count_var: <a href="#IntVar">pywrapcp.IntVar</a>) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddCountAssignedItemsDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count_var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This dimension links &#39;count_var&#39; to the actual number of items</span>
<span class="sd">        assigned to a bin in the pack.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Pack_AddCountAssignedItemsDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">count_var</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This dimension links 'count_var' to the actual number of items
assigned to a bin in the pack.</p>
</div>


                            </div>
                            <div id="Pack.Post" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Pack.Post">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Post</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Post</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Pack_Post</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method is called when the constraint is processed by the
solver. Its main usage is to attach demons to variables.</p>
</div>


                            </div>
                            <div id="Pack.InitialPropagateWrapper" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Pack.InitialPropagateWrapper">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">InitialPropagateWrapper</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">InitialPropagateWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Pack_InitialPropagateWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method performs the initial propagation of the
constraint. It is called just after the post.</p>
</div>


                            </div>
                            <div id="Pack.DebugString" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Pack.DebugString">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DebugString</span><span class="signature">(self) -&gt; &#39;std::string&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">Pack_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#Constraint">Constraint</a></dt>
                                <dd id="Pack.Var" class="function"><a href="#Constraint.Var">Var</a></dd>
                <dd id="Pack.Square" class="function"><a href="#Constraint.Square">Square</a></dd>
                <dd id="Pack.MapTo" class="function"><a href="#Constraint.MapTo">MapTo</a></dd>
                <dd id="Pack.IndexOf" class="function"><a href="#Constraint.IndexOf">IndexOf</a></dd>

            </div>
            <div><dt><a href="#PropagationBaseObject">PropagationBaseObject</a></dt>
                                <dd id="Pack.solver" class="function"><a href="#PropagationBaseObject.solver">solver</a></dd>
                <dd id="Pack.Name" class="function"><a href="#PropagationBaseObject.Name">Name</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="DisjunctiveConstraint">
                                <div class="attr class">
        <a class="headerlink" href="#DisjunctiveConstraint">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">DisjunctiveConstraint</span><wbr>(<span class="base"><a href="#Constraint">Constraint</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">DisjunctiveConstraint</span><span class="p">(</span><span class="n">Constraint</span><span class="p">):</span>
    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">SequenceVar</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SequenceVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Creates a sequence variable from the constraint.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DisjunctiveConstraint_SequenceVar</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetTransitionTime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transition_time</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IndexEvaluator2&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a transition time between intervals.  It forces the distance between</span>
<span class="sd">        the end of interval a and start of interval b that follows it to be at</span>
<span class="sd">        least transition_time(a, b). This function must always return</span>
<span class="sd">        a positive or null value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DisjunctiveConstraint_SetTransitionTime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transition_time</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">TransitionTime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">before_index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">after_index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DisjunctiveConstraint_TransitionTime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">before_index</span><span class="p">,</span> <span class="n">after_index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>A constraint is the main modeling object. It provides two methods:</p>

<ul>
<li>Post() is responsible for creating the demons and attaching them to
immediate demons().</li>
<li>InitialPropagate() is called once just after Post and performs
the initial propagation. The subsequent propagations will be performed
by the demons Posted during the post() method.</li>
</ul>
</div>


                            <div id="DisjunctiveConstraint.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DisjunctiveConstraint.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">DisjunctiveConstraint</span><span class="signature">(*args, **kwargs)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="DisjunctiveConstraint.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#DisjunctiveConstraint.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="DisjunctiveConstraint.SequenceVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DisjunctiveConstraint.SequenceVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SequenceVar</span><span class="signature">(self) -&gt; &#39;operations_research::SequenceVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SequenceVar</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SequenceVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Creates a sequence variable from the constraint.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DisjunctiveConstraint_SequenceVar</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates a sequence variable from the constraint.</p>
</div>


                            </div>
                            <div id="DisjunctiveConstraint.SetTransitionTime" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DisjunctiveConstraint.SetTransitionTime">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetTransitionTime</span><span class="signature">(
    self,
    transition_time: &#39;operations_research::Solver::IndexEvaluator2&#39;
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetTransitionTime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transition_time</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IndexEvaluator2&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a transition time between intervals.  It forces the distance between</span>
<span class="sd">        the end of interval a and start of interval b that follows it to be at</span>
<span class="sd">        least transition_time(a, b). This function must always return</span>
<span class="sd">        a positive or null value.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DisjunctiveConstraint_SetTransitionTime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">transition_time</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Add a transition time between intervals.  It forces the distance between
the end of interval a and start of interval b that follows it to be at
least transition_time(a, b). This function must always return
a positive or null value.</p>
</div>


                            </div>
                            <div id="DisjunctiveConstraint.TransitionTime" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#DisjunctiveConstraint.TransitionTime">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">TransitionTime</span><span class="signature">(self, before_index: int, after_index: int) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">TransitionTime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">before_index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">after_index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DisjunctiveConstraint_TransitionTime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">before_index</span><span class="p">,</span> <span class="n">after_index</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#Constraint">Constraint</a></dt>
                                <dd id="DisjunctiveConstraint.Post" class="function"><a href="#Constraint.Post">Post</a></dd>
                <dd id="DisjunctiveConstraint.InitialPropagateWrapper" class="function"><a href="#Constraint.InitialPropagateWrapper">InitialPropagateWrapper</a></dd>
                <dd id="DisjunctiveConstraint.DebugString" class="function"><a href="#Constraint.DebugString">DebugString</a></dd>
                <dd id="DisjunctiveConstraint.Var" class="function"><a href="#Constraint.Var">Var</a></dd>
                <dd id="DisjunctiveConstraint.Square" class="function"><a href="#Constraint.Square">Square</a></dd>
                <dd id="DisjunctiveConstraint.MapTo" class="function"><a href="#Constraint.MapTo">MapTo</a></dd>
                <dd id="DisjunctiveConstraint.IndexOf" class="function"><a href="#Constraint.IndexOf">IndexOf</a></dd>

            </div>
            <div><dt><a href="#PropagationBaseObject">PropagationBaseObject</a></dt>
                                <dd id="DisjunctiveConstraint.solver" class="function"><a href="#PropagationBaseObject.solver">solver</a></dd>
                <dd id="DisjunctiveConstraint.Name" class="function"><a href="#PropagationBaseObject.Name">Name</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="RevInteger">
                                <div class="attr class">
        <a class="headerlink" href="#RevInteger">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">RevInteger</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">RevInteger</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class adds reversibility to a POD type.</span>
<span class="sd">    It contains the stamp optimization. i.e. the SaveValue call is done</span>
<span class="sd">    only once per node of the search tree.  Please note that actual</span>
<span class="sd">    stamps always starts at 1, thus an initial value of 0 will always</span>
<span class="sd">    trigger the first SaveValue.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="s2">&quot;long const &amp;&quot;</span><span class="p">):</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RevInteger_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_RevInteger</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;long const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RevInteger_Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="s2">&quot;long const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RevInteger_SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_RevInteger</span>
</pre></div>

        </details>

            <div class="docstring"><p>This class adds reversibility to a POD type.
It contains the stamp optimization. i.e. the SaveValue call is done
only once per node of the search tree.  Please note that actual
stamps always starts at 1, thus an initial value of 0 will always
trigger the first SaveValue.</p>
</div>


                            <div id="RevInteger.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RevInteger.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">RevInteger</span><span class="signature">(val: &#39;long const &amp;&#39;)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="s2">&quot;long const &amp;&quot;</span><span class="p">):</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RevInteger_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_RevInteger</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RevInteger.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#RevInteger.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="RevInteger.Value" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RevInteger.Value">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Value</span><span class="signature">(self) -&gt; &#39;long const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;long const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RevInteger_Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RevInteger.SetValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RevInteger.SetValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetValue</span><span class="signature">(self, s: <a href="#Solver">pywrapcp.Solver</a>, val: &#39;long const &amp;&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="s2">&quot;long const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RevInteger_SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                </section>
                <section id="NumericalRevInteger">
                                <div class="attr class">
        <a class="headerlink" href="#NumericalRevInteger">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">NumericalRevInteger</span><wbr>(<span class="base"><a href="#RevInteger">RevInteger</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">NumericalRevInteger</span><span class="p">(</span><span class="n">RevInteger</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Subclass of Rev&lt;T&gt; which adds numerical operations.&quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="s2">&quot;long const &amp;&quot;</span><span class="p">):</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">NumericalRevInteger_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_NumericalRevInteger</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">,</span> <span class="n">to_add</span><span class="p">:</span> <span class="s2">&quot;long const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">NumericalRevInteger_Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">to_add</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Incr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">NumericalRevInteger_Incr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Decr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">NumericalRevInteger_Decr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_NumericalRevInteger</span>
</pre></div>

        </details>

            <div class="docstring"><p>Subclass of Rev<T> which adds numerical operations.</p>
</div>


                            <div id="NumericalRevInteger.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#NumericalRevInteger.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">NumericalRevInteger</span><span class="signature">(val: &#39;long const &amp;&#39;)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="s2">&quot;long const &amp;&quot;</span><span class="p">):</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">NumericalRevInteger_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_NumericalRevInteger</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="NumericalRevInteger.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#NumericalRevInteger.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="NumericalRevInteger.Add" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#NumericalRevInteger.Add">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Add</span><span class="signature">(self, s: <a href="#Solver">pywrapcp.Solver</a>, to_add: &#39;long const &amp;&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">,</span> <span class="n">to_add</span><span class="p">:</span> <span class="s2">&quot;long const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">NumericalRevInteger_Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">to_add</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="NumericalRevInteger.Incr" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#NumericalRevInteger.Incr">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Incr</span><span class="signature">(self, s: <a href="#Solver">pywrapcp.Solver</a>) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Incr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">NumericalRevInteger_Incr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="NumericalRevInteger.Decr" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#NumericalRevInteger.Decr">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Decr</span><span class="signature">(self, s: <a href="#Solver">pywrapcp.Solver</a>) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Decr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">NumericalRevInteger_Decr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#RevInteger">RevInteger</a></dt>
                                <dd id="NumericalRevInteger.Value" class="function"><a href="#RevInteger.Value">Value</a></dd>
                <dd id="NumericalRevInteger.SetValue" class="function"><a href="#RevInteger.SetValue">SetValue</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="RevBool">
                                <div class="attr class">
        <a class="headerlink" href="#RevBool">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">RevBool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">RevBool</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class adds reversibility to a POD type.</span>
<span class="sd">    It contains the stamp optimization. i.e. the SaveValue call is done</span>
<span class="sd">    only once per node of the search tree.  Please note that actual</span>
<span class="sd">    stamps always starts at 1, thus an initial value of 0 will always</span>
<span class="sd">    trigger the first SaveValue.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="s2">&quot;bool const &amp;&quot;</span><span class="p">):</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RevBool_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_RevBool</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RevBool_Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="s2">&quot;bool const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RevBool_SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_RevBool</span>
</pre></div>

        </details>

            <div class="docstring"><p>This class adds reversibility to a POD type.
It contains the stamp optimization. i.e. the SaveValue call is done
only once per node of the search tree.  Please note that actual
stamps always starts at 1, thus an initial value of 0 will always
trigger the first SaveValue.</p>
</div>


                            <div id="RevBool.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RevBool.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">RevBool</span><span class="signature">(val: &#39;bool const &amp;&#39;)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="s2">&quot;bool const &amp;&quot;</span><span class="p">):</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RevBool_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_RevBool</span><span class="p">(</span><span class="n">val</span><span class="p">))</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RevBool.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#RevBool.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="RevBool.Value" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RevBool.Value">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Value</span><span class="signature">(self) -&gt; &#39;bool const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RevBool_Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RevBool.SetValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RevBool.SetValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetValue</span><span class="signature">(self, s: <a href="#Solver">pywrapcp.Solver</a>, val: &#39;bool const &amp;&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="s2">&quot;bool const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RevBool_SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                </section>
                <section id="IntVarContainer">
                                <div class="attr class">
        <a class="headerlink" href="#IntVarContainer">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">IntVarContainer</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">IntVarContainer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">Contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarContainer_Contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVarElement *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarContainer_Element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarContainer_Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Store</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarContainer_Store</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Restore</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarContainer_Restore</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">container</span><span class="p">:</span> <span class="s2">&quot;IntVarContainer&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns true if this and &#39;container&#39; both represent the same V* -&gt; E map.</span>
<span class="sd">        Runs in linear time; requires that the == operator on the type E is well</span>
<span class="sd">        defined.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarContainer___eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">container</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">container</span><span class="p">:</span> <span class="s2">&quot;IntVarContainer&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarContainer___ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">container</span><span class="p">)</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_IntVarContainer</span>
</pre></div>

        </details>

    

                            <div id="IntVarContainer.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVarContainer.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">IntVarContainer</span><span class="signature">(*args, **kwargs)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntVarContainer.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#IntVarContainer.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="IntVarContainer.Contains" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVarContainer.Contains">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Contains</span><span class="signature">(self, var: <a href="#IntVar">pywrapcp.IntVar</a>) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarContainer_Contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntVarContainer.Element" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVarContainer.Element">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Element</span><span class="signature">(self, index: int) -&gt; &#39;operations_research::IntVarElement *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVarElement *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarContainer_Element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntVarContainer.Size" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVarContainer.Size">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Size</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarContainer_Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntVarContainer.Store" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVarContainer.Store">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Store</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Store</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarContainer_Store</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntVarContainer.Restore" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVarContainer.Restore">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Restore</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Restore</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarContainer_Restore</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                </section>
                <section id="IntervalVarContainer">
                                <div class="attr class">
        <a class="headerlink" href="#IntervalVarContainer">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">IntervalVarContainer</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">IntervalVarContainer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">Contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarContainer_Contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntervalVarElement *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarContainer_Element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarContainer_Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Store</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarContainer_Store</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Restore</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarContainer_Restore</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">container</span><span class="p">:</span> <span class="s2">&quot;IntervalVarContainer&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns true if this and &#39;container&#39; both represent the same V* -&gt; E map.</span>
<span class="sd">        Runs in linear time; requires that the == operator on the type E is well</span>
<span class="sd">        defined.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarContainer___eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">container</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">container</span><span class="p">:</span> <span class="s2">&quot;IntervalVarContainer&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarContainer___ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">container</span><span class="p">)</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_IntervalVarContainer</span>
</pre></div>

        </details>

    

                            <div id="IntervalVarContainer.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVarContainer.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">IntervalVarContainer</span><span class="signature">(*args, **kwargs)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVarContainer.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#IntervalVarContainer.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="IntervalVarContainer.Contains" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVarContainer.Contains">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Contains</span><span class="signature">(self, var: <a href="#IntervalVar">pywrapcp.IntervalVar</a>) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarContainer_Contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVarContainer.Element" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVarContainer.Element">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Element</span><span class="signature">(self, index: int) -&gt; &#39;operations_research::IntervalVarElement *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntervalVarElement *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarContainer_Element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVarContainer.Size" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVarContainer.Size">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Size</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarContainer_Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVarContainer.Store" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVarContainer.Store">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Store</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Store</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarContainer_Store</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntervalVarContainer.Restore" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntervalVarContainer.Restore">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Restore</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Restore</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntervalVarContainer_Restore</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                </section>
                <section id="SequenceVarContainer">
                                <div class="attr class">
        <a class="headerlink" href="#SequenceVarContainer">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">SequenceVarContainer</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">SequenceVarContainer</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">Contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;SequenceVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarContainer_Contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SequenceVarElement *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarContainer_Element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarContainer_Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Store</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarContainer_Store</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Restore</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarContainer_Restore</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">container</span><span class="p">:</span> <span class="s2">&quot;SequenceVarContainer&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns true if this and &#39;container&#39; both represent the same V* -&gt; E map.</span>
<span class="sd">        Runs in linear time; requires that the == operator on the type E is well</span>
<span class="sd">        defined.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarContainer___eq__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">container</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">container</span><span class="p">:</span> <span class="s2">&quot;SequenceVarContainer&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarContainer___ne__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">container</span><span class="p">)</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_SequenceVarContainer</span>
</pre></div>

        </details>

    

                            <div id="SequenceVarContainer.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SequenceVarContainer.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">SequenceVarContainer</span><span class="signature">(*args, **kwargs)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="SequenceVarContainer.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#SequenceVarContainer.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="SequenceVarContainer.Contains" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SequenceVarContainer.Contains">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Contains</span><span class="signature">(self, var: <a href="#SequenceVar">pywrapcp.SequenceVar</a>) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;SequenceVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarContainer_Contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="SequenceVarContainer.Element" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SequenceVarContainer.Element">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Element</span><span class="signature">(self, index: int) -&gt; &#39;operations_research::SequenceVarElement *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::SequenceVarElement *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarContainer_Element</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="SequenceVarContainer.Size" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SequenceVarContainer.Size">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Size</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarContainer_Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="SequenceVarContainer.Store" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SequenceVarContainer.Store">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Store</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Store</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarContainer_Store</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="SequenceVarContainer.Restore" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SequenceVarContainer.Restore">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Restore</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Restore</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarContainer_Restore</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                </section>
                <section id="LocalSearchOperator">
                                <div class="attr class">
        <a class="headerlink" href="#LocalSearchOperator">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">LocalSearchOperator</span><wbr>(<span class="base"><a href="#BaseObject">BaseObject</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">LocalSearchOperator</span><span class="p">(</span><span class="n">BaseObject</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class represent a reversible FIFO structure.</span>
<span class="sd">    The main difference w.r.t a standard FIFO structure is that a Solver is</span>
<span class="sd">    given as parameter to the modifiers such that the solver can store the</span>
<span class="sd">    backtrack information</span>
<span class="sd">    Iterator&#39;s traversing order should not be changed, as some algorithm</span>
<span class="sd">    depend on it to be consistent.</span>
<span class="sd">    It&#39;s main use is to store a list of demons in the various classes of</span>
<span class="sd">    variables.</span>
<span class="sd">    The base class for all local search operators.</span>

<span class="sd">    A local search operator is an object that defines the neighborhood of a</span>
<span class="sd">    solution. In other words, a neighborhood is the set of solutions which can</span>
<span class="sd">    be reached from a given solution using an operator.</span>

<span class="sd">    The behavior of the LocalSearchOperator class is similar to iterators.</span>
<span class="sd">    The operator is synchronized with an assignment (gives the</span>
<span class="sd">    current values of the variables); this is done in the Start() method.</span>

<span class="sd">    Then one can iterate over the neighbors using the MakeNextNeighbor method.</span>
<span class="sd">    This method returns an assignment which represents the incremental changes</span>
<span class="sd">    to the current solution. It also returns a second assignment representing</span>
<span class="sd">    the changes to the last solution defined by the neighborhood operator; this</span>
<span class="sd">    assignment is empty if the neighborhood operator cannot track this</span>
<span class="sd">    information.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">NextNeighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">LocalSearchOperator_NextNeighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">LocalSearchOperator_Start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__disown__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">disown</span><span class="p">()</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">disown_LocalSearchOperator</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This class represent a reversible FIFO structure.
The main difference w.r.t a standard FIFO structure is that a Solver is
given as parameter to the modifiers such that the solver can store the
backtrack information
Iterator's traversing order should not be changed, as some algorithm
depend on it to be consistent.
It's main use is to store a list of demons in the various classes of
variables.
The base class for all local search operators.</p>

<p>A local search operator is an object that defines the neighborhood of a
solution. In other words, a neighborhood is the set of solutions which can
be reached from a given solution using an operator.</p>

<p>The behavior of the LocalSearchOperator class is similar to iterators.
The operator is synchronized with an assignment (gives the
current values of the variables); this is done in the Start() method.</p>

<p>Then one can iterate over the neighbors using the MakeNextNeighbor method.
This method returns an assignment which represents the incremental changes
to the current solution. It also returns a second assignment representing
the changes to the last solution defined by the neighborhood operator; this
assignment is empty if the neighborhood operator cannot track this
information.</p>
</div>


                            <div id="LocalSearchOperator.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#LocalSearchOperator.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">LocalSearchOperator</span><span class="signature">(*args, **kwargs)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="LocalSearchOperator.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#LocalSearchOperator.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="LocalSearchOperator.NextNeighbor" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#LocalSearchOperator.NextNeighbor">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">NextNeighbor</span><span class="signature">(
    self,
    delta: <a href="#Assignment">pywrapcp.Assignment</a>,
    deltadelta: <a href="#Assignment">pywrapcp.Assignment</a>
) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">NextNeighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">LocalSearchOperator_NextNeighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="LocalSearchOperator.Start" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#LocalSearchOperator.Start">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Start</span><span class="signature">(self, assignment: <a href="#Assignment">pywrapcp.Assignment</a>) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">LocalSearchOperator_Start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#BaseObject">BaseObject</a></dt>
                                <dd id="LocalSearchOperator.DebugString" class="function"><a href="#BaseObject.DebugString">DebugString</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="IntVarLocalSearchOperatorTemplate">
                                <div class="attr class">
        <a class="headerlink" href="#IntVarLocalSearchOperatorTemplate">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">IntVarLocalSearchOperatorTemplate</span><wbr>(<span class="base"><a href="#LocalSearchOperator">LocalSearchOperator</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">IntVarLocalSearchOperatorTemplate</span><span class="p">(</span><span class="n">LocalSearchOperator</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Base operator class for operators manipulating variables.&quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">Start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method should not be overridden. Override OnStart() instead which is</span>
<span class="sd">        called before exiting this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchOperatorTemplate_Start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsIncremental</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchOperatorTemplate_IsIncremental</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchOperatorTemplate_Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;long const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the value in the current assignment of the variable of given</span>
<span class="sd">        index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchOperatorTemplate_Value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">OldValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;long const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchOperatorTemplate_OldValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;long const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchOperatorTemplate_SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">OnStart</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called by Start() after synchronizing the operator with the current</span>
<span class="sd">        assignment. Should be overridden instead of Start() to avoid calling</span>
<span class="sd">        VarLocalSearchOperator::Start explicitly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchOperatorTemplate_OnStart</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Base operator class for operators manipulating variables.</p>
</div>


                            <div id="IntVarLocalSearchOperatorTemplate.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVarLocalSearchOperatorTemplate.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">IntVarLocalSearchOperatorTemplate</span><span class="signature">(*args, **kwargs)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntVarLocalSearchOperatorTemplate.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#IntVarLocalSearchOperatorTemplate.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="IntVarLocalSearchOperatorTemplate.Start" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVarLocalSearchOperatorTemplate.Start">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Start</span><span class="signature">(self, assignment: <a href="#Assignment">pywrapcp.Assignment</a>) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method should not be overridden. Override OnStart() instead which is</span>
<span class="sd">        called before exiting this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchOperatorTemplate_Start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method should not be overridden. Override OnStart() instead which is
called before exiting this method.</p>
</div>


                            </div>
                            <div id="IntVarLocalSearchOperatorTemplate.IsIncremental" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVarLocalSearchOperatorTemplate.IsIncremental">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsIncremental</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsIncremental</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchOperatorTemplate_IsIncremental</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntVarLocalSearchOperatorTemplate.Size" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVarLocalSearchOperatorTemplate.Size">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Size</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchOperatorTemplate_Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntVarLocalSearchOperatorTemplate.Value" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVarLocalSearchOperatorTemplate.Value">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Value</span><span class="signature">(self, index: &#39;int64_t&#39;) -&gt; &#39;long const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;long const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the value in the current assignment of the variable of given</span>
<span class="sd">        index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchOperatorTemplate_Value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the value in the current assignment of the variable of given
index.</p>
</div>


                            </div>
                            <div id="IntVarLocalSearchOperatorTemplate.OldValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVarLocalSearchOperatorTemplate.OldValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">OldValue</span><span class="signature">(self, index: &#39;int64_t&#39;) -&gt; &#39;long const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">OldValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;long const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchOperatorTemplate_OldValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntVarLocalSearchOperatorTemplate.SetValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVarLocalSearchOperatorTemplate.SetValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetValue</span><span class="signature">(self, index: &#39;int64_t&#39;, value: &#39;long const &amp;&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;long const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchOperatorTemplate_SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntVarLocalSearchOperatorTemplate.OnStart" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVarLocalSearchOperatorTemplate.OnStart">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">OnStart</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">OnStart</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called by Start() after synchronizing the operator with the current</span>
<span class="sd">        assignment. Should be overridden instead of Start() to avoid calling</span>
<span class="sd">        VarLocalSearchOperator::Start explicitly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchOperatorTemplate_OnStart</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Called by Start() after synchronizing the operator with the current
assignment. Should be overridden instead of Start() to avoid calling
VarLocalSearchOperator::Start explicitly.</p>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#LocalSearchOperator">LocalSearchOperator</a></dt>
                                <dd id="IntVarLocalSearchOperatorTemplate.NextNeighbor" class="function"><a href="#LocalSearchOperator.NextNeighbor">NextNeighbor</a></dd>

            </div>
            <div><dt><a href="#BaseObject">BaseObject</a></dt>
                                <dd id="IntVarLocalSearchOperatorTemplate.DebugString" class="function"><a href="#BaseObject.DebugString">DebugString</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="IntVarLocalSearchOperator">
                                <div class="attr class">
        <a class="headerlink" href="#IntVarLocalSearchOperator">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">IntVarLocalSearchOperator</span><wbr>(<span class="base"><a href="#IntVarLocalSearchOperatorTemplate">IntVarLocalSearchOperatorTemplate</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">IntVarLocalSearchOperator</span><span class="p">(</span><span class="n">IntVarLocalSearchOperatorTemplate</span><span class="p">):</span>
    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">IntVarLocalSearchOperator</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchOperator_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_IntVarLocalSearchOperator</span><span class="p">(</span><span class="n">_self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">))</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_IntVarLocalSearchOperator</span>

    <span class="k">def</span> <span class="nf">NextNeighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Redefines MakeNextNeighbor to export a simpler interface. The calls to</span>
<span class="sd">        ApplyChanges() and RevertChanges() are factored in this method, hiding</span>
<span class="sd">        both delta and deltadelta from subclasses which only need to override</span>
<span class="sd">        MakeOneNeighbor().</span>
<span class="sd">        Therefore this method should not be overridden. Override MakeOneNeighbor()</span>
<span class="sd">        instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchOperator_NextNeighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">OneNeighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new neighbor. It returns false when the neighborhood is</span>
<span class="sd">        completely explored.</span>
<span class="sd">        MakeNextNeighbor() in a subclass of IntVarLocalSearchOperator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchOperator_OneNeighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__disown__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">disown</span><span class="p">()</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">disown_IntVarLocalSearchOperator</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Base operator class for operators manipulating variables.</p>
</div>


                            <div id="IntVarLocalSearchOperator.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVarLocalSearchOperator.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">IntVarLocalSearchOperator</span><span class="signature">(*args)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">IntVarLocalSearchOperator</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchOperator_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_IntVarLocalSearchOperator</span><span class="p">(</span><span class="n">_self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">))</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntVarLocalSearchOperator.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#IntVarLocalSearchOperator.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="IntVarLocalSearchOperator.NextNeighbor" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVarLocalSearchOperator.NextNeighbor">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">NextNeighbor</span><span class="signature">(
    self,
    delta: <a href="#Assignment">pywrapcp.Assignment</a>,
    deltadelta: <a href="#Assignment">pywrapcp.Assignment</a>
) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">NextNeighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Redefines MakeNextNeighbor to export a simpler interface. The calls to</span>
<span class="sd">        ApplyChanges() and RevertChanges() are factored in this method, hiding</span>
<span class="sd">        both delta and deltadelta from subclasses which only need to override</span>
<span class="sd">        MakeOneNeighbor().</span>
<span class="sd">        Therefore this method should not be overridden. Override MakeOneNeighbor()</span>
<span class="sd">        instead.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchOperator_NextNeighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Redefines MakeNextNeighbor to export a simpler interface. The calls to
ApplyChanges() and RevertChanges() are factored in this method, hiding
both delta and deltadelta from subclasses which only need to override
MakeOneNeighbor().
Therefore this method should not be overridden. Override MakeOneNeighbor()
instead.</p>
</div>


                            </div>
                            <div id="IntVarLocalSearchOperator.OneNeighbor" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVarLocalSearchOperator.OneNeighbor">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">OneNeighbor</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">OneNeighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a new neighbor. It returns false when the neighborhood is</span>
<span class="sd">        completely explored.</span>
<span class="sd">        MakeNextNeighbor() in a subclass of IntVarLocalSearchOperator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchOperator_OneNeighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates a new neighbor. It returns false when the neighborhood is
completely explored.
MakeNextNeighbor() in a subclass of IntVarLocalSearchOperator.</p>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#IntVarLocalSearchOperatorTemplate">IntVarLocalSearchOperatorTemplate</a></dt>
                                <dd id="IntVarLocalSearchOperator.Start" class="function"><a href="#IntVarLocalSearchOperatorTemplate.Start">Start</a></dd>
                <dd id="IntVarLocalSearchOperator.IsIncremental" class="function"><a href="#IntVarLocalSearchOperatorTemplate.IsIncremental">IsIncremental</a></dd>
                <dd id="IntVarLocalSearchOperator.Size" class="function"><a href="#IntVarLocalSearchOperatorTemplate.Size">Size</a></dd>
                <dd id="IntVarLocalSearchOperator.Value" class="function"><a href="#IntVarLocalSearchOperatorTemplate.Value">Value</a></dd>
                <dd id="IntVarLocalSearchOperator.OldValue" class="function"><a href="#IntVarLocalSearchOperatorTemplate.OldValue">OldValue</a></dd>
                <dd id="IntVarLocalSearchOperator.SetValue" class="function"><a href="#IntVarLocalSearchOperatorTemplate.SetValue">SetValue</a></dd>
                <dd id="IntVarLocalSearchOperator.OnStart" class="function"><a href="#IntVarLocalSearchOperatorTemplate.OnStart">OnStart</a></dd>

            </div>
            <div><dt><a href="#BaseObject">BaseObject</a></dt>
                                <dd id="IntVarLocalSearchOperator.DebugString" class="function"><a href="#BaseObject.DebugString">DebugString</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="SequenceVarLocalSearchOperatorTemplate">
                                <div class="attr class">
        <a class="headerlink" href="#SequenceVarLocalSearchOperatorTemplate">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">SequenceVarLocalSearchOperatorTemplate</span><wbr>(<span class="base"><a href="#LocalSearchOperator">LocalSearchOperator</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">SequenceVarLocalSearchOperatorTemplate</span><span class="p">(</span><span class="n">LocalSearchOperator</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Base operator class for operators manipulating variables.&quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">Start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method should not be overridden. Override OnStart() instead which is</span>
<span class="sd">        called before exiting this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarLocalSearchOperatorTemplate_Start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsIncremental</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarLocalSearchOperatorTemplate_IsIncremental</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarLocalSearchOperatorTemplate_Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the value in the current assignment of the variable of given</span>
<span class="sd">        index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarLocalSearchOperatorTemplate_Value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">OldValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarLocalSearchOperatorTemplate_OldValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarLocalSearchOperatorTemplate_SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">OnStart</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called by Start() after synchronizing the operator with the current</span>
<span class="sd">        assignment. Should be overridden instead of Start() to avoid calling</span>
<span class="sd">        VarLocalSearchOperator::Start explicitly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarLocalSearchOperatorTemplate_OnStart</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Base operator class for operators manipulating variables.</p>
</div>


                            <div id="SequenceVarLocalSearchOperatorTemplate.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SequenceVarLocalSearchOperatorTemplate.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">SequenceVarLocalSearchOperatorTemplate</span><span class="signature">(*args, **kwargs)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="SequenceVarLocalSearchOperatorTemplate.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#SequenceVarLocalSearchOperatorTemplate.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="SequenceVarLocalSearchOperatorTemplate.Start" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SequenceVarLocalSearchOperatorTemplate.Start">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Start</span><span class="signature">(self, assignment: <a href="#Assignment">pywrapcp.Assignment</a>) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method should not be overridden. Override OnStart() instead which is</span>
<span class="sd">        called before exiting this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarLocalSearchOperatorTemplate_Start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method should not be overridden. Override OnStart() instead which is
called before exiting this method.</p>
</div>


                            </div>
                            <div id="SequenceVarLocalSearchOperatorTemplate.IsIncremental" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SequenceVarLocalSearchOperatorTemplate.IsIncremental">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsIncremental</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsIncremental</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarLocalSearchOperatorTemplate_IsIncremental</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="SequenceVarLocalSearchOperatorTemplate.Size" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SequenceVarLocalSearchOperatorTemplate.Size">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Size</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarLocalSearchOperatorTemplate_Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="SequenceVarLocalSearchOperatorTemplate.Value" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SequenceVarLocalSearchOperatorTemplate.Value">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Value</span><span class="signature">(self, index: &#39;int64_t&#39;) -&gt; &#39;std::vector&lt; int &gt; const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the value in the current assignment of the variable of given</span>
<span class="sd">        index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarLocalSearchOperatorTemplate_Value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the value in the current assignment of the variable of given
index.</p>
</div>


                            </div>
                            <div id="SequenceVarLocalSearchOperatorTemplate.OldValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SequenceVarLocalSearchOperatorTemplate.OldValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">OldValue</span><span class="signature">(self, index: &#39;int64_t&#39;) -&gt; &#39;std::vector&lt; int &gt; const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">OldValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarLocalSearchOperatorTemplate_OldValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="SequenceVarLocalSearchOperatorTemplate.SetValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SequenceVarLocalSearchOperatorTemplate.SetValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetValue</span><span class="signature">(
    self,
    index: &#39;int64_t&#39;,
    value: &#39;std::vector&lt; int &gt; const &amp;&#39;
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarLocalSearchOperatorTemplate_SetValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="SequenceVarLocalSearchOperatorTemplate.OnStart" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SequenceVarLocalSearchOperatorTemplate.OnStart">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">OnStart</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">OnStart</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Called by Start() after synchronizing the operator with the current</span>
<span class="sd">        assignment. Should be overridden instead of Start() to avoid calling</span>
<span class="sd">        VarLocalSearchOperator::Start explicitly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SequenceVarLocalSearchOperatorTemplate_OnStart</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Called by Start() after synchronizing the operator with the current
assignment. Should be overridden instead of Start() to avoid calling
VarLocalSearchOperator::Start explicitly.</p>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#LocalSearchOperator">LocalSearchOperator</a></dt>
                                <dd id="SequenceVarLocalSearchOperatorTemplate.NextNeighbor" class="function"><a href="#LocalSearchOperator.NextNeighbor">NextNeighbor</a></dd>

            </div>
            <div><dt><a href="#BaseObject">BaseObject</a></dt>
                                <dd id="SequenceVarLocalSearchOperatorTemplate.DebugString" class="function"><a href="#BaseObject.DebugString">DebugString</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="SequenceVarLocalSearchOperator">
                                <div class="attr class">
        <a class="headerlink" href="#SequenceVarLocalSearchOperator">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">SequenceVarLocalSearchOperator</span><wbr>(<span class="base"><a href="#SequenceVarLocalSearchOperatorTemplate">SequenceVarLocalSearchOperatorTemplate</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">SequenceVarLocalSearchOperator</span><span class="p">(</span><span class="n">SequenceVarLocalSearchOperatorTemplate</span><span class="p">):</span>
    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>
</pre></div>

        </details>

            <div class="docstring"><p>Base operator class for operators manipulating variables.</p>
</div>


                            <div id="SequenceVarLocalSearchOperator.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#SequenceVarLocalSearchOperator.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">SequenceVarLocalSearchOperator</span><span class="signature">(*args, **kwargs)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="SequenceVarLocalSearchOperator.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#SequenceVarLocalSearchOperator.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#SequenceVarLocalSearchOperatorTemplate">SequenceVarLocalSearchOperatorTemplate</a></dt>
                                <dd id="SequenceVarLocalSearchOperator.Start" class="function"><a href="#SequenceVarLocalSearchOperatorTemplate.Start">Start</a></dd>
                <dd id="SequenceVarLocalSearchOperator.IsIncremental" class="function"><a href="#SequenceVarLocalSearchOperatorTemplate.IsIncremental">IsIncremental</a></dd>
                <dd id="SequenceVarLocalSearchOperator.Size" class="function"><a href="#SequenceVarLocalSearchOperatorTemplate.Size">Size</a></dd>
                <dd id="SequenceVarLocalSearchOperator.Value" class="function"><a href="#SequenceVarLocalSearchOperatorTemplate.Value">Value</a></dd>
                <dd id="SequenceVarLocalSearchOperator.OldValue" class="function"><a href="#SequenceVarLocalSearchOperatorTemplate.OldValue">OldValue</a></dd>
                <dd id="SequenceVarLocalSearchOperator.SetValue" class="function"><a href="#SequenceVarLocalSearchOperatorTemplate.SetValue">SetValue</a></dd>
                <dd id="SequenceVarLocalSearchOperator.OnStart" class="function"><a href="#SequenceVarLocalSearchOperatorTemplate.OnStart">OnStart</a></dd>

            </div>
            <div><dt><a href="#LocalSearchOperator">LocalSearchOperator</a></dt>
                                <dd id="SequenceVarLocalSearchOperator.NextNeighbor" class="function"><a href="#LocalSearchOperator.NextNeighbor">NextNeighbor</a></dd>

            </div>
            <div><dt><a href="#BaseObject">BaseObject</a></dt>
                                <dd id="SequenceVarLocalSearchOperator.DebugString" class="function"><a href="#BaseObject.DebugString">DebugString</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="BaseLns">
                                <div class="attr class">
        <a class="headerlink" href="#BaseLns">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">BaseLns</span><wbr>(<span class="base"><a href="#IntVarLocalSearchOperator">IntVarLocalSearchOperator</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">BaseLns</span><span class="p">(</span><span class="n">IntVarLocalSearchOperator</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This is the base class for building an Lns operator. An Lns fragment is a</span>
<span class="sd">    collection of variables which will be relaxed. Fragments are built with</span>
<span class="sd">    NextFragment(), which returns false if there are no more fragments to build.</span>
<span class="sd">    Optionally one can override InitFragments, which is called from</span>
<span class="sd">    LocalSearchOperator::Start to initialize fragment data.</span>

<span class="sd">    Here&#39;s a sample relaxing one variable at a time:</span>

<span class="sd">    class OneVarLns : public BaseLns {</span>
<span class="sd">     public:</span>
<span class="sd">      OneVarLns(const std::vector&lt;IntVar*&gt;&amp; vars) : BaseLns(vars), index_(0) {}</span>
<span class="sd">      virtual ~OneVarLns() {}</span>
<span class="sd">      virtual void InitFragments() { index_ = 0; }</span>
<span class="sd">      virtual bool NextFragment() {</span>
<span class="sd">        const int size = Size();</span>
<span class="sd">        if (index_ &lt; size) {</span>
<span class="sd">          AppendToFragment(index_);</span>
<span class="sd">          ++index_;</span>
<span class="sd">          return true;</span>
<span class="sd">        } else {</span>
<span class="sd">          return false;</span>
<span class="sd">        }</span>
<span class="sd">      }</span>

<span class="sd">     private:</span>
<span class="sd">      int index_;</span>
<span class="sd">    };</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">BaseLns</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BaseLns_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_BaseLns</span><span class="p">(</span><span class="n">_self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">))</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_BaseLns</span>

    <span class="k">def</span> <span class="nf">InitFragments</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BaseLns_InitFragments</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NextFragment</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BaseLns_NextFragment</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AppendToFragment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BaseLns_AppendToFragment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">FragmentSize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BaseLns_FragmentSize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BaseLns___getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BaseLns___len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__disown__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">disown</span><span class="p">()</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">disown_BaseLns</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This is the base class for building an Lns operator. An Lns fragment is a
collection of variables which will be relaxed. Fragments are built with
NextFragment(), which returns false if there are no more fragments to build.
Optionally one can override InitFragments, which is called from
LocalSearchOperator::Start to initialize fragment data.</p>

<p>Here's a sample relaxing one variable at a time:</p>

<p>class OneVarLns : public BaseLns {
 public:
  OneVarLns(const std::vector<IntVar*>&amp; vars) : BaseLns(vars), index_(0) {}
  virtual ~OneVarLns() {}
  virtual void InitFragments() { index_ = 0; }
  virtual bool NextFragment() {
    const int size = Size();
    if (index_ &lt; size) {
      AppendToFragment(index_);
      ++index_;
      return true;
    } else {
      return false;
    }
  }</p>

<p>private:
  int index_;
};</p>
</div>


                            <div id="BaseLns.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#BaseLns.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">BaseLns</span><span class="signature">(vars: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">BaseLns</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BaseLns_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_BaseLns</span><span class="p">(</span><span class="n">_self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">))</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="BaseLns.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#BaseLns.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="BaseLns.InitFragments" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#BaseLns.InitFragments">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">InitFragments</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">InitFragments</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BaseLns_InitFragments</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="BaseLns.NextFragment" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#BaseLns.NextFragment">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">NextFragment</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">NextFragment</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BaseLns_NextFragment</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="BaseLns.AppendToFragment" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#BaseLns.AppendToFragment">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AppendToFragment</span><span class="signature">(self, index: int) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AppendToFragment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BaseLns_AppendToFragment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="BaseLns.FragmentSize" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#BaseLns.FragmentSize">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">FragmentSize</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">FragmentSize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BaseLns_FragmentSize</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#IntVarLocalSearchOperator">IntVarLocalSearchOperator</a></dt>
                                <dd id="BaseLns.NextNeighbor" class="function"><a href="#IntVarLocalSearchOperator.NextNeighbor">NextNeighbor</a></dd>
                <dd id="BaseLns.OneNeighbor" class="function"><a href="#IntVarLocalSearchOperator.OneNeighbor">OneNeighbor</a></dd>

            </div>
            <div><dt><a href="#IntVarLocalSearchOperatorTemplate">IntVarLocalSearchOperatorTemplate</a></dt>
                                <dd id="BaseLns.Start" class="function"><a href="#IntVarLocalSearchOperatorTemplate.Start">Start</a></dd>
                <dd id="BaseLns.IsIncremental" class="function"><a href="#IntVarLocalSearchOperatorTemplate.IsIncremental">IsIncremental</a></dd>
                <dd id="BaseLns.Size" class="function"><a href="#IntVarLocalSearchOperatorTemplate.Size">Size</a></dd>
                <dd id="BaseLns.Value" class="function"><a href="#IntVarLocalSearchOperatorTemplate.Value">Value</a></dd>
                <dd id="BaseLns.OldValue" class="function"><a href="#IntVarLocalSearchOperatorTemplate.OldValue">OldValue</a></dd>
                <dd id="BaseLns.SetValue" class="function"><a href="#IntVarLocalSearchOperatorTemplate.SetValue">SetValue</a></dd>
                <dd id="BaseLns.OnStart" class="function"><a href="#IntVarLocalSearchOperatorTemplate.OnStart">OnStart</a></dd>

            </div>
            <div><dt><a href="#BaseObject">BaseObject</a></dt>
                                <dd id="BaseLns.DebugString" class="function"><a href="#BaseObject.DebugString">DebugString</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="ChangeValue">
                                <div class="attr class">
        <a class="headerlink" href="#ChangeValue">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">ChangeValue</span><wbr>(<span class="base"><a href="#IntVarLocalSearchOperator">IntVarLocalSearchOperator</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">ChangeValue</span><span class="p">(</span><span class="n">IntVarLocalSearchOperator</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Defines operators which change the value of variables;</span>
<span class="sd">    each neighbor corresponds to *one* modified variable.</span>
<span class="sd">    Sub-classes have to define ModifyValue which determines what the new</span>
<span class="sd">    variable value is going to be (given the current value and the variable).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">ChangeValue</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">ChangeValue_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_ChangeValue</span><span class="p">(</span><span class="n">_self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">))</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_ChangeValue</span>

    <span class="k">def</span> <span class="nf">ModifyValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">ChangeValue_ModifyValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">OneNeighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This method should not be overridden. Override ModifyValue() instead.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">ChangeValue_OneNeighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__disown__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">disown</span><span class="p">()</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">disown_ChangeValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Defines operators which change the value of variables;
each neighbor corresponds to <em>one</em> modified variable.
Sub-classes have to define ModifyValue which determines what the new
variable value is going to be (given the current value and the variable).</p>
</div>


                            <div id="ChangeValue.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#ChangeValue.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">ChangeValue</span><span class="signature">(vars: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">ChangeValue</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">ChangeValue_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_ChangeValue</span><span class="p">(</span><span class="n">_self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">))</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="ChangeValue.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#ChangeValue.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="ChangeValue.ModifyValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#ChangeValue.ModifyValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ModifyValue</span><span class="signature">(self, index: &#39;int64_t&#39;, value: &#39;int64_t&#39;) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ModifyValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">ChangeValue_ModifyValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="ChangeValue.OneNeighbor" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#ChangeValue.OneNeighbor">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">OneNeighbor</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">OneNeighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; This method should not be overridden. Override ModifyValue() instead.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">ChangeValue_OneNeighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method should not be overridden. Override ModifyValue() instead.</p>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#IntVarLocalSearchOperator">IntVarLocalSearchOperator</a></dt>
                                <dd id="ChangeValue.NextNeighbor" class="function"><a href="#IntVarLocalSearchOperator.NextNeighbor">NextNeighbor</a></dd>

            </div>
            <div><dt><a href="#IntVarLocalSearchOperatorTemplate">IntVarLocalSearchOperatorTemplate</a></dt>
                                <dd id="ChangeValue.Start" class="function"><a href="#IntVarLocalSearchOperatorTemplate.Start">Start</a></dd>
                <dd id="ChangeValue.IsIncremental" class="function"><a href="#IntVarLocalSearchOperatorTemplate.IsIncremental">IsIncremental</a></dd>
                <dd id="ChangeValue.Size" class="function"><a href="#IntVarLocalSearchOperatorTemplate.Size">Size</a></dd>
                <dd id="ChangeValue.Value" class="function"><a href="#IntVarLocalSearchOperatorTemplate.Value">Value</a></dd>
                <dd id="ChangeValue.OldValue" class="function"><a href="#IntVarLocalSearchOperatorTemplate.OldValue">OldValue</a></dd>
                <dd id="ChangeValue.SetValue" class="function"><a href="#IntVarLocalSearchOperatorTemplate.SetValue">SetValue</a></dd>
                <dd id="ChangeValue.OnStart" class="function"><a href="#IntVarLocalSearchOperatorTemplate.OnStart">OnStart</a></dd>

            </div>
            <div><dt><a href="#BaseObject">BaseObject</a></dt>
                                <dd id="ChangeValue.DebugString" class="function"><a href="#BaseObject.DebugString">DebugString</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="PathOperator">
                                <div class="attr class">
        <a class="headerlink" href="#PathOperator">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">PathOperator</span><wbr>(<span class="base"><a href="#IntVarLocalSearchOperator">IntVarLocalSearchOperator</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">PathOperator</span><span class="p">(</span><span class="n">IntVarLocalSearchOperator</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base class of the local search operators dedicated to path modifications</span>
<span class="sd">    (a path is a set of nodes linked together by arcs).</span>
<span class="sd">    This family of neighborhoods supposes they are handling next variables</span>
<span class="sd">    representing the arcs (var[i] represents the node immediately after i on</span>
<span class="sd">    a path).</span>
<span class="sd">    Several services are provided:</span>
<span class="sd">    - arc manipulators (SetNext(), ReverseChain(), MoveChain())</span>
<span class="sd">    - path inspectors (Next(), Prev(), IsPathEnd())</span>
<span class="sd">    - path iterators: operators need a given number of nodes to define a</span>
<span class="sd">      neighbor; this class provides the iteration on a given number of (base)</span>
<span class="sd">      nodes which can be used to define a neighbor (through the BaseNode method)</span>
<span class="sd">    Subclasses only need to override MakeNeighbor to create neighbors using</span>
<span class="sd">    the services above (no direct manipulation of assignments).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">Neighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">PathOperator_Neighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Base class of the local search operators dedicated to path modifications
(a path is a set of nodes linked together by arcs).
This family of neighborhoods supposes they are handling next variables
representing the arcs (var[i] represents the node immediately after i on
a path).
Several services are provided:</p>

<ul>
<li>arc manipulators (SetNext(), ReverseChain(), MoveChain())</li>
<li>path inspectors (Next(), Prev(), IsPathEnd())</li>
<li>path iterators: operators need a given number of nodes to define a
neighbor; this class provides the iteration on a given number of (base)
nodes which can be used to define a neighbor (through the BaseNode method)
Subclasses only need to override MakeNeighbor to create neighbors using
the services above (no direct manipulation of assignments).</li>
</ul>
</div>


                            <div id="PathOperator.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PathOperator.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">PathOperator</span><span class="signature">(*args, **kwargs)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="PathOperator.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#PathOperator.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="PathOperator.Neighbor" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PathOperator.Neighbor">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Neighbor</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Neighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">PathOperator_Neighbor</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#IntVarLocalSearchOperator">IntVarLocalSearchOperator</a></dt>
                                <dd id="PathOperator.NextNeighbor" class="function"><a href="#IntVarLocalSearchOperator.NextNeighbor">NextNeighbor</a></dd>
                <dd id="PathOperator.OneNeighbor" class="function"><a href="#IntVarLocalSearchOperator.OneNeighbor">OneNeighbor</a></dd>

            </div>
            <div><dt><a href="#IntVarLocalSearchOperatorTemplate">IntVarLocalSearchOperatorTemplate</a></dt>
                                <dd id="PathOperator.Start" class="function"><a href="#IntVarLocalSearchOperatorTemplate.Start">Start</a></dd>
                <dd id="PathOperator.IsIncremental" class="function"><a href="#IntVarLocalSearchOperatorTemplate.IsIncremental">IsIncremental</a></dd>
                <dd id="PathOperator.Size" class="function"><a href="#IntVarLocalSearchOperatorTemplate.Size">Size</a></dd>
                <dd id="PathOperator.Value" class="function"><a href="#IntVarLocalSearchOperatorTemplate.Value">Value</a></dd>
                <dd id="PathOperator.OldValue" class="function"><a href="#IntVarLocalSearchOperatorTemplate.OldValue">OldValue</a></dd>
                <dd id="PathOperator.SetValue" class="function"><a href="#IntVarLocalSearchOperatorTemplate.SetValue">SetValue</a></dd>
                <dd id="PathOperator.OnStart" class="function"><a href="#IntVarLocalSearchOperatorTemplate.OnStart">OnStart</a></dd>

            </div>
            <div><dt><a href="#BaseObject">BaseObject</a></dt>
                                <dd id="PathOperator.DebugString" class="function"><a href="#BaseObject.DebugString">DebugString</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="LocalSearchFilter">
                                <div class="attr class">
        <a class="headerlink" href="#LocalSearchFilter">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">LocalSearchFilter</span><wbr>(<span class="base"><a href="#BaseObject">BaseObject</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">LocalSearchFilter</span><span class="p">(</span><span class="n">BaseObject</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Classes to which this template function can be applied to as of 04/2014.</span>
<span class="sd">    Usage: LocalSearchOperator* op = MakeLocalSearchOperator&lt;Relocate&gt;(...);</span>
<span class="sd">    class TwoOpt;</span>
<span class="sd">    class Relocate;</span>
<span class="sd">    class Exchange;</span>
<span class="sd">    class Cross;</span>
<span class="sd">    class MakeActiveOperator;</span>
<span class="sd">    class MakeInactiveOperator;</span>
<span class="sd">    class MakeChainInactiveOperator;</span>
<span class="sd">    class SwapActiveOperator;</span>
<span class="sd">    class ExtendedSwapActiveOperator;</span>
<span class="sd">    class MakeActiveAndRelocate;</span>
<span class="sd">    class RelocateAndMakeActiveOperator;</span>
<span class="sd">    class RelocateAndMakeInactiveOperator;</span>
<span class="sd">    Local Search Filters are used for fast neighbor pruning.</span>
<span class="sd">    Filtering a move is done in several phases:</span>
<span class="sd">    - in the Relax phase, filters determine which parts of their internals</span>
<span class="sd">      will be changed by the candidate, and modify intermediary State</span>
<span class="sd">    - in the Accept phase, filters check that the candidate is feasible,</span>
<span class="sd">    - if the Accept phase succeeds, the solver may decide to trigger a</span>
<span class="sd">      Synchronize phase that makes filters change their internal representation</span>
<span class="sd">      to the last candidate,</span>
<span class="sd">    - otherwise (Accept fails or the solver does not want to synchronize),</span>
<span class="sd">      a Revert phase makes filters erase any intermediary State generated by the</span>
<span class="sd">      Relax and Accept phases.</span>
<span class="sd">    A given filter has phases called with the following pattern:</span>
<span class="sd">    (Relax.Accept.Synchronize | Relax.Accept.Revert | Relax.Revert)*.</span>
<span class="sd">    Filters&#39;s Revert() is always called in the reverse order their Accept() was</span>
<span class="sd">    called, to allow late filters to use state done/undone by early filters&#39;</span>
<span class="sd">    Accept()/Revert().</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">Accept</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">objective_min</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">objective_max</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Accepts a &quot;delta&quot; given the assignment with which the filter has been</span>
<span class="sd">        synchronized; the delta holds the variables which have been modified and</span>
<span class="sd">        their new value.</span>
<span class="sd">        If the filter represents a part of the global objective, its contribution</span>
<span class="sd">        must be between objective_min and objective_max.</span>
<span class="sd">        Sample: supposing one wants to maintain a[0,1] + b[0,1] &lt;= 1,</span>
<span class="sd">        for the assignment (a,1), (b,0), the delta (b,1) will be rejected</span>
<span class="sd">        but the delta (a,0) will be accepted.</span>
<span class="sd">        TODO(user): Remove arguments when there are no more need for those.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">LocalSearchFilter_Accept</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">,</span> <span class="n">objective_min</span><span class="p">,</span> <span class="n">objective_max</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsIncremental</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">LocalSearchFilter_IsIncremental</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Synchronize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Synchronizes the filter with the current solution, delta being the</span>
<span class="sd">        difference with the solution passed to the previous call to Synchronize()</span>
<span class="sd">        or IncrementalSynchronize(). &#39;delta&#39; can be used to incrementally</span>
<span class="sd">        synchronizing the filter with the new solution by only considering the</span>
<span class="sd">        changes in delta.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">LocalSearchFilter_Synchronize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_LocalSearchFilter</span>
</pre></div>

        </details>

            <div class="docstring"><p>Classes to which this template function can be applied to as of 04/2014.
Usage: LocalSearchOperator* op = MakeLocalSearchOperator<Relocate>(...);
class TwoOpt;
class Relocate;
class Exchange;
class Cross;
class MakeActiveOperator;
class MakeInactiveOperator;
class MakeChainInactiveOperator;
class SwapActiveOperator;
class ExtendedSwapActiveOperator;
class MakeActiveAndRelocate;
class RelocateAndMakeActiveOperator;
class RelocateAndMakeInactiveOperator;
Local Search Filters are used for fast neighbor pruning.
Filtering a move is done in several phases:</p>

<ul>
<li>in the Relax phase, filters determine which parts of their internals
will be changed by the candidate, and modify intermediary State</li>
<li>in the Accept phase, filters check that the candidate is feasible,</li>
<li>if the Accept phase succeeds, the solver may decide to trigger a
Synchronize phase that makes filters change their internal representation
to the last candidate,</li>
<li>otherwise (Accept fails or the solver does not want to synchronize),
a Revert phase makes filters erase any intermediary State generated by the
Relax and Accept phases.
A given filter has phases called with the following pattern:
(Relax.Accept.Synchronize | Relax.Accept.Revert | Relax.Revert)*.
Filters's Revert() is always called in the reverse order their Accept() was
called, to allow late filters to use state done/undone by early filters'
Accept()/Revert().</li>
</ul>
</div>


                            <div id="LocalSearchFilter.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#LocalSearchFilter.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">LocalSearchFilter</span><span class="signature">(*args, **kwargs)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="LocalSearchFilter.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#LocalSearchFilter.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="LocalSearchFilter.Accept" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#LocalSearchFilter.Accept">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Accept</span><span class="signature">(
    self,
    delta: <a href="#Assignment">pywrapcp.Assignment</a>,
    deltadelta: <a href="#Assignment">pywrapcp.Assignment</a>,
    objective_min: &#39;int64_t&#39;,
    objective_max: &#39;int64_t&#39;
) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Accept</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">objective_min</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">objective_max</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Accepts a &quot;delta&quot; given the assignment with which the filter has been</span>
<span class="sd">        synchronized; the delta holds the variables which have been modified and</span>
<span class="sd">        their new value.</span>
<span class="sd">        If the filter represents a part of the global objective, its contribution</span>
<span class="sd">        must be between objective_min and objective_max.</span>
<span class="sd">        Sample: supposing one wants to maintain a[0,1] + b[0,1] &lt;= 1,</span>
<span class="sd">        for the assignment (a,1), (b,0), the delta (b,1) will be rejected</span>
<span class="sd">        but the delta (a,0) will be accepted.</span>
<span class="sd">        TODO(user): Remove arguments when there are no more need for those.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">LocalSearchFilter_Accept</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">,</span> <span class="n">objective_min</span><span class="p">,</span> <span class="n">objective_max</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Accepts a "delta" given the assignment with which the filter has been
synchronized; the delta holds the variables which have been modified and
their new value.
If the filter represents a part of the global objective, its contribution
must be between objective_min and objective_max.
Sample: supposing one wants to maintain a[0,1] + b[0,1] &lt;= 1,
for the assignment (a,1), (b,0), the delta (b,1) will be rejected
but the delta (a,0) will be accepted.
TODO(user): Remove arguments when there are no more need for those.</p>
</div>


                            </div>
                            <div id="LocalSearchFilter.IsIncremental" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#LocalSearchFilter.IsIncremental">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsIncremental</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsIncremental</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">LocalSearchFilter_IsIncremental</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="LocalSearchFilter.Synchronize" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#LocalSearchFilter.Synchronize">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Synchronize</span><span class="signature">(
    self,
    assignment: <a href="#Assignment">pywrapcp.Assignment</a>,
    delta: <a href="#Assignment">pywrapcp.Assignment</a>
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Synchronize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Synchronizes the filter with the current solution, delta being the</span>
<span class="sd">        difference with the solution passed to the previous call to Synchronize()</span>
<span class="sd">        or IncrementalSynchronize(). &#39;delta&#39; can be used to incrementally</span>
<span class="sd">        synchronizing the filter with the new solution by only considering the</span>
<span class="sd">        changes in delta.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">LocalSearchFilter_Synchronize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Synchronizes the filter with the current solution, delta being the
difference with the solution passed to the previous call to Synchronize()
or IncrementalSynchronize(). 'delta' can be used to incrementally
synchronizing the filter with the new solution by only considering the
changes in delta.</p>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#BaseObject">BaseObject</a></dt>
                                <dd id="LocalSearchFilter.DebugString" class="function"><a href="#BaseObject.DebugString">DebugString</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="LocalSearchFilterManager">
                                <div class="attr class">
        <a class="headerlink" href="#LocalSearchFilterManager">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">LocalSearchFilterManager</span><wbr>(<span class="base"><a href="#BaseObject">BaseObject</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">LocalSearchFilterManager</span><span class="p">(</span><span class="n">BaseObject</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Filter manager: when a move is made, filters are executed to decide whether</span>
<span class="sd">    the solution is feasible and compute parts of the new cost. This class</span>
<span class="sd">    schedules filter execution and composes costs as a sum.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">LocalSearchFilterManager_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">LocalSearchFilterManager_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_LocalSearchFilterManager</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">Accept</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">monitor</span><span class="p">:</span> <span class="s2">&quot;operations_research::LocalSearchMonitor *const&quot;</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">objective_min</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">objective_max</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns true iff all filters return true, and the sum of their accepted</span>
<span class="sd">        objectives is between objective_min and objective_max.</span>
<span class="sd">        The monitor has its Begin/EndFiltering events triggered.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">LocalSearchFilterManager_Accept</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">monitor</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">,</span> <span class="n">objective_min</span><span class="p">,</span> <span class="n">objective_max</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Synchronize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Synchronizes all filters to assignment.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">LocalSearchFilterManager_Synchronize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_LocalSearchFilterManager</span>
</pre></div>

        </details>

            <div class="docstring"><p>Filter manager: when a move is made, filters are executed to decide whether
the solution is feasible and compute parts of the new cost. This class
schedules filter execution and composes costs as a sum.</p>
</div>


                            <div id="LocalSearchFilterManager.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#LocalSearchFilterManager.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">LocalSearchFilterManager</span><span class="signature">(*args)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">LocalSearchFilterManager_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_LocalSearchFilterManager</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="LocalSearchFilterManager.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#LocalSearchFilterManager.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="LocalSearchFilterManager.DebugString" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#LocalSearchFilterManager.DebugString">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DebugString</span><span class="signature">(self) -&gt; &#39;std::string&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">LocalSearchFilterManager_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="LocalSearchFilterManager.Accept" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#LocalSearchFilterManager.Accept">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Accept</span><span class="signature">(
    self,
    monitor: &#39;operations_research::LocalSearchMonitor *const&#39;,
    delta: <a href="#Assignment">pywrapcp.Assignment</a>,
    deltadelta: <a href="#Assignment">pywrapcp.Assignment</a>,
    objective_min: &#39;int64_t&#39;,
    objective_max: &#39;int64_t&#39;
) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Accept</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">monitor</span><span class="p">:</span> <span class="s2">&quot;operations_research::LocalSearchMonitor *const&quot;</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">objective_min</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">objective_max</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns true iff all filters return true, and the sum of their accepted</span>
<span class="sd">        objectives is between objective_min and objective_max.</span>
<span class="sd">        The monitor has its Begin/EndFiltering events triggered.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">LocalSearchFilterManager_Accept</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">monitor</span><span class="p">,</span> <span class="n">delta</span><span class="p">,</span> <span class="n">deltadelta</span><span class="p">,</span> <span class="n">objective_min</span><span class="p">,</span> <span class="n">objective_max</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns true iff all filters return true, and the sum of their accepted
objectives is between objective_min and objective_max.
The monitor has its Begin/EndFiltering events triggered.</p>
</div>


                            </div>
                            <div id="LocalSearchFilterManager.Synchronize" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#LocalSearchFilterManager.Synchronize">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Synchronize</span><span class="signature">(
    self,
    assignment: <a href="#Assignment">pywrapcp.Assignment</a>,
    delta: <a href="#Assignment">pywrapcp.Assignment</a>
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Synchronize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Synchronizes all filters to assignment.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">LocalSearchFilterManager_Synchronize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Synchronizes all filters to assignment.</p>
</div>


                            </div>
                </section>
                <section id="IntVarLocalSearchFilter">
                                <div class="attr class">
        <a class="headerlink" href="#IntVarLocalSearchFilter">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">IntVarLocalSearchFilter</span><wbr>(<span class="base"><a href="#LocalSearchFilter">LocalSearchFilter</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">IntVarLocalSearchFilter</span><span class="p">(</span><span class="n">LocalSearchFilter</span><span class="p">):</span>
    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">IntVarLocalSearchFilter</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchFilter_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_IntVarLocalSearchFilter</span><span class="p">(</span><span class="n">_self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">))</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_IntVarLocalSearchFilter</span>

    <span class="k">def</span> <span class="nf">Synchronize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method should not be overridden. Override OnSynchronize() instead</span>
<span class="sd">        which is called before exiting this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchFilter_Synchronize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchFilter_Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchFilter_Value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IndexFromVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchFilter_IndexFromVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
    <span class="k">def</span> <span class="nf">__disown__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">disown</span><span class="p">()</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">disown_IntVarLocalSearchFilter</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">weakref</span><span class="o">.</span><span class="n">proxy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Classes to which this template function can be applied to as of 04/2014.
Usage: LocalSearchOperator* op = MakeLocalSearchOperator<Relocate>(...);
class TwoOpt;
class Relocate;
class Exchange;
class Cross;
class MakeActiveOperator;
class MakeInactiveOperator;
class MakeChainInactiveOperator;
class SwapActiveOperator;
class ExtendedSwapActiveOperator;
class MakeActiveAndRelocate;
class RelocateAndMakeActiveOperator;
class RelocateAndMakeInactiveOperator;
Local Search Filters are used for fast neighbor pruning.
Filtering a move is done in several phases:</p>

<ul>
<li>in the Relax phase, filters determine which parts of their internals
will be changed by the candidate, and modify intermediary State</li>
<li>in the Accept phase, filters check that the candidate is feasible,</li>
<li>if the Accept phase succeeds, the solver may decide to trigger a
Synchronize phase that makes filters change their internal representation
to the last candidate,</li>
<li>otherwise (Accept fails or the solver does not want to synchronize),
a Revert phase makes filters erase any intermediary State generated by the
Relax and Accept phases.
A given filter has phases called with the following pattern:
(Relax.Accept.Synchronize | Relax.Accept.Revert | Relax.Revert)*.
Filters's Revert() is always called in the reverse order their Accept() was
called, to allow late filters to use state done/undone by early filters'
Accept()/Revert().</li>
</ul>
</div>


                            <div id="IntVarLocalSearchFilter.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVarLocalSearchFilter.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">IntVarLocalSearchFilter</span><span class="signature">(vars: &#39;std::vector&lt; operations_research::IntVar * &gt; const &amp;&#39;)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt; const &amp;&quot;</span><span class="p">):</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span> <span class="o">==</span> <span class="n">IntVarLocalSearchFilter</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">_self</span> <span class="o">=</span> <span class="bp">self</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchFilter_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_IntVarLocalSearchFilter</span><span class="p">(</span><span class="n">_self</span><span class="p">,</span> <span class="nb">vars</span><span class="p">))</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntVarLocalSearchFilter.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#IntVarLocalSearchFilter.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="IntVarLocalSearchFilter.Synchronize" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVarLocalSearchFilter.Synchronize">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Synchronize</span><span class="signature">(
    self,
    assignment: <a href="#Assignment">pywrapcp.Assignment</a>,
    delta: <a href="#Assignment">pywrapcp.Assignment</a>
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Synchronize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">delta</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method should not be overridden. Override OnSynchronize() instead</span>
<span class="sd">        which is called before exiting this method.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchFilter_Synchronize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">,</span> <span class="n">delta</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method should not be overridden. Override OnSynchronize() instead
which is called before exiting this method.</p>
</div>


                            </div>
                            <div id="IntVarLocalSearchFilter.Size" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVarLocalSearchFilter.Size">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Size</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchFilter_Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntVarLocalSearchFilter.Value" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVarLocalSearchFilter.Value">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Value</span><span class="signature">(self, index: int) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchFilter_Value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="IntVarLocalSearchFilter.IndexFromVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#IntVarLocalSearchFilter.IndexFromVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IndexFromVar</span><span class="signature">(self, var: <a href="#IntVar">pywrapcp.IntVar</a>) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IndexFromVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">IntVarLocalSearchFilter_IndexFromVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#LocalSearchFilter">LocalSearchFilter</a></dt>
                                <dd id="IntVarLocalSearchFilter.Accept" class="function"><a href="#LocalSearchFilter.Accept">Accept</a></dd>
                <dd id="IntVarLocalSearchFilter.IsIncremental" class="function"><a href="#LocalSearchFilter.IsIncremental">IsIncremental</a></dd>

            </div>
            <div><dt><a href="#BaseObject">BaseObject</a></dt>
                                <dd id="IntVarLocalSearchFilter.DebugString" class="function"><a href="#BaseObject.DebugString">DebugString</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="BooleanVar">
                                <div class="attr class">
        <a class="headerlink" href="#BooleanVar">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">BooleanVar</span><wbr>(<span class="base"><a href="#IntVar">IntVar</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">BooleanVar</span><span class="p">(</span><span class="n">IntVar</span><span class="p">):</span>
    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">Min</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_Min</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_SetMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Max</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_Max</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_SetMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">ma</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_SetRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">ma</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Bound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_Bound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RemoveValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_RemoveValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RemoveInterval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_RemoveInterval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WhenBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="s2">&quot;Demon&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_WhenBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WhenRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="s2">&quot;Demon&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_WhenRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WhenDomain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="s2">&quot;Demon&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_WhenDomain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;uint64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_Contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">HoleIteratorAux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reversible</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVarIterator *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_HoleIteratorAux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reversible</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DomainIteratorAux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reversible</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVarIterator *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_DomainIteratorAux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reversible</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>The class IntVar is a subset of IntExpr. In addition to the
IntExpr protocol, it offers persistence, removing values from the domains,
and a finer model for events.</p>
</div>


                            <div id="BooleanVar.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#BooleanVar.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">BooleanVar</span><span class="signature">(*args, **kwargs)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="BooleanVar.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#BooleanVar.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="BooleanVar.Min" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#BooleanVar.Min">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Min</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Min</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_Min</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="BooleanVar.SetMin" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#BooleanVar.SetMin">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetMin</span><span class="signature">(self, m: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_SetMin</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="BooleanVar.Max" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#BooleanVar.Max">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Max</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Max</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_Max</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="BooleanVar.SetMax" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#BooleanVar.SetMax">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetMax</span><span class="signature">(self, m: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_SetMax</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">m</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="BooleanVar.SetRange" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#BooleanVar.SetRange">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetRange</span><span class="signature">(self, mi: &#39;int64_t&#39;, ma: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">ma</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_SetRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">mi</span><span class="p">,</span> <span class="n">ma</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method sets both the min and the max of the expression.</p>
</div>


                            </div>
                            <div id="BooleanVar.Bound" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#BooleanVar.Bound">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Bound</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Bound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_Bound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns true if the min and the max of the expression are equal.</p>
</div>


                            </div>
                            <div id="BooleanVar.Value" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#BooleanVar.Value">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Value</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method returns the value of the variable. This method checks
before that the variable is bound.</p>
</div>


                            </div>
                            <div id="BooleanVar.RemoveValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#BooleanVar.RemoveValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">RemoveValue</span><span class="signature">(self, v: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">RemoveValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_RemoveValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method removes the value 'v' from the domain of the variable.</p>
</div>


                            </div>
                            <div id="BooleanVar.RemoveInterval" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#BooleanVar.RemoveInterval">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">RemoveInterval</span><span class="signature">(self, l: &#39;int64_t&#39;, u: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">RemoveInterval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">u</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_RemoveInterval</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">l</span><span class="p">,</span> <span class="n">u</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method removes the interval 'l' .. 'u' from the domain of
the variable. It assumes that 'l' &lt;= 'u'.</p>
</div>


                            </div>
                            <div id="BooleanVar.WhenBound" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#BooleanVar.WhenBound">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">WhenBound</span><span class="signature">(self, d: <a href="#Demon">pywrapcp.Demon</a>) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">WhenBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="s2">&quot;Demon&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_WhenBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p><em>Overload 1:</em>
This method attaches a demon that will be awakened when the
variable is bound.</p>

<p>|</p>

<p><em>Overload 2:</em>
This method attaches a closure that will be awakened when the
variable is bound.</p>
</div>


                            </div>
                            <div id="BooleanVar.WhenRange" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#BooleanVar.WhenRange">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">WhenRange</span><span class="signature">(self, d: <a href="#Demon">pywrapcp.Demon</a>) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">WhenRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="s2">&quot;Demon&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_WhenRange</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p><em>Overload 1:</em>
Attach a demon that will watch the min or the max of the expression.</p>

<p>|</p>

<p><em>Overload 2:</em>
Attach a demon that will watch the min or the max of the expression.</p>
</div>


                            </div>
                            <div id="BooleanVar.WhenDomain" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#BooleanVar.WhenDomain">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">WhenDomain</span><span class="signature">(self, d: <a href="#Demon">pywrapcp.Demon</a>) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">WhenDomain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">:</span> <span class="s2">&quot;Demon&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_WhenDomain</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p><em>Overload 1:</em>
This method attaches a demon that will watch any domain
modification of the domain of the variable.</p>

<p>|</p>

<p><em>Overload 2:</em>
This method attaches a closure that will watch any domain
modification of the domain of the variable.</p>
</div>


                            </div>
                            <div id="BooleanVar.Size" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#BooleanVar.Size">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Size</span><span class="signature">(self) -&gt; &#39;uint64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;uint64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method returns the number of values in the domain of the variable.</p>
</div>


                            </div>
                            <div id="BooleanVar.Contains" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#BooleanVar.Contains">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Contains</span><span class="signature">(self, v: &#39;int64_t&#39;) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_Contains</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">v</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method returns whether the value 'v' is in the domain of the
variable.</p>
</div>


                            </div>
                            <div id="BooleanVar.HoleIteratorAux" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#BooleanVar.HoleIteratorAux">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">HoleIteratorAux</span><span class="signature">(self, reversible: bool) -&gt; &#39;operations_research::IntVarIterator *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">HoleIteratorAux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reversible</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVarIterator *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_HoleIteratorAux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reversible</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates a hole iterator. When 'reversible' is false, the returned
object is created on the normal C++ heap and the solver does NOT
take ownership of the object.</p>
</div>


                            </div>
                            <div id="BooleanVar.DomainIteratorAux" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#BooleanVar.DomainIteratorAux">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DomainIteratorAux</span><span class="signature">(self, reversible: bool) -&gt; &#39;operations_research::IntVarIterator *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">DomainIteratorAux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reversible</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVarIterator *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_DomainIteratorAux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">reversible</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates a domain iterator. When 'reversible' is false, the
returned object is created on the normal C++ heap and the solver
does NOT take ownership of the object.</p>
</div>


                            </div>
                            <div id="BooleanVar.DebugString" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#BooleanVar.DebugString">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DebugString</span><span class="signature">(self) -&gt; &#39;std::string&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">BooleanVar_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#IntVar">IntVar</a></dt>
                                <dd id="BooleanVar.IsVar" class="function"><a href="#IntVar.IsVar">IsVar</a></dd>
                <dd id="BooleanVar.Var" class="function"><a href="#IntVar.Var">Var</a></dd>
                <dd id="BooleanVar.RemoveValues" class="function"><a href="#IntVar.RemoveValues">RemoveValues</a></dd>
                <dd id="BooleanVar.SetValues" class="function"><a href="#IntVar.SetValues">SetValues</a></dd>
                <dd id="BooleanVar.OldMin" class="function"><a href="#IntVar.OldMin">OldMin</a></dd>
                <dd id="BooleanVar.OldMax" class="function"><a href="#IntVar.OldMax">OldMax</a></dd>
                <dd id="BooleanVar.DomainIterator" class="function"><a href="#IntVar.DomainIterator">DomainIterator</a></dd>
                <dd id="BooleanVar.HoleIterator" class="function"><a href="#IntVar.HoleIterator">HoleIterator</a></dd>

            </div>
            <div><dt><a href="#IntExpr">IntExpr</a></dt>
                                <dd id="BooleanVar.SetValue" class="function"><a href="#IntExpr.SetValue">SetValue</a></dd>
                <dd id="BooleanVar.VarWithName" class="function"><a href="#IntExpr.VarWithName">VarWithName</a></dd>
                <dd id="BooleanVar.Square" class="function"><a href="#IntExpr.Square">Square</a></dd>
                <dd id="BooleanVar.MapTo" class="function"><a href="#IntExpr.MapTo">MapTo</a></dd>
                <dd id="BooleanVar.IndexOf" class="function"><a href="#IntExpr.IndexOf">IndexOf</a></dd>
                <dd id="BooleanVar.IsMember" class="function"><a href="#IntExpr.IsMember">IsMember</a></dd>
                <dd id="BooleanVar.Member" class="function"><a href="#IntExpr.Member">Member</a></dd>
                <dd id="BooleanVar.NotMember" class="function"><a href="#IntExpr.NotMember">NotMember</a></dd>

            </div>
            <div><dt><a href="#PropagationBaseObject">PropagationBaseObject</a></dt>
                                <dd id="BooleanVar.solver" class="function"><a href="#PropagationBaseObject.solver">solver</a></dd>
                <dd id="BooleanVar.Name" class="function"><a href="#PropagationBaseObject.Name">Name</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="PyDecision">
                                <div class="attr class">
        <a class="headerlink" href="#PyDecision">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">PyDecision</span><wbr>(<span class="base"><a href="#Decision">Decision</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">PyDecision</span><span class="p">(</span><span class="n">Decision</span><span class="p">):</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">Decision</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">ApplyWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">Apply</span><span class="p">(</span><span class="n">solver</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
      <span class="k">if</span> <span class="s1">&#39;CP Solver fail&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">ShouldFail</span><span class="p">()</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span>

  <span class="k">def</span> <span class="nf">RefuteWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">Refute</span><span class="p">(</span><span class="n">solver</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
      <span class="k">if</span> <span class="s1">&#39;CP Solver fail&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">ShouldFail</span><span class="p">()</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span>

  <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="s2">&quot;PyDecision&quot;</span>
</pre></div>

        </details>

            <div class="docstring"><p>A Decision represents a choice point in the search tree. The two main
methods are Apply() to go left, or Refute() to go right.</p>
</div>


                            <div id="PyDecision.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PyDecision.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">PyDecision</span><span class="signature">()</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">Decision</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="PyDecision.ApplyWrapper" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PyDecision.ApplyWrapper">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ApplyWrapper</span><span class="signature">(self, solver)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>  <span class="k">def</span> <span class="nf">ApplyWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">Apply</span><span class="p">(</span><span class="n">solver</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
      <span class="k">if</span> <span class="s1">&#39;CP Solver fail&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">ShouldFail</span><span class="p">()</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span>
</pre></div>

        </details>

            <div class="docstring"><p>Apply will be called first when the decision is executed.</p>
</div>


                            </div>
                            <div id="PyDecision.RefuteWrapper" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PyDecision.RefuteWrapper">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">RefuteWrapper</span><span class="signature">(self, solver)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>  <span class="k">def</span> <span class="nf">RefuteWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
       <span class="bp">self</span><span class="o">.</span><span class="n">Refute</span><span class="p">(</span><span class="n">solver</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
      <span class="k">if</span> <span class="s1">&#39;CP Solver fail&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">ShouldFail</span><span class="p">()</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span>
</pre></div>

        </details>

            <div class="docstring"><p>Refute will be called after a backtrack.</p>
</div>


                            </div>
                            <div id="PyDecision.DebugString" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PyDecision.DebugString">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DebugString</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>  <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="s2">&quot;PyDecision&quot;</span>
</pre></div>

        </details>

    

                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#Decision">Decision</a></dt>
                                <dd id="PyDecision.thisown" class="variable"><a href="#Decision.thisown">thisown</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="PyDecisionBuilder">
                                <div class="attr class">
        <a class="headerlink" href="#PyDecisionBuilder">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">PyDecisionBuilder</span><wbr>(<span class="base"><a href="#DecisionBuilder">DecisionBuilder</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">PyDecisionBuilder</span><span class="p">(</span><span class="n">DecisionBuilder</span><span class="p">):</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">DecisionBuilder</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">NextWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Next</span><span class="p">(</span><span class="n">solver</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
      <span class="k">if</span> <span class="s1">&#39;CP Solver fail&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">solver</span><span class="o">.</span><span class="n">FailDecision</span><span class="p">()</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span>

  <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="s2">&quot;PyDecisionBuilder&quot;</span>
</pre></div>

        </details>

            <div class="docstring"><p>A DecisionBuilder is responsible for creating the search tree. The
important method is Next(), which returns the next decision to execute.</p>
</div>


                            <div id="PyDecisionBuilder.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PyDecisionBuilder.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">PyDecisionBuilder</span><span class="signature">()</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="n">DecisionBuilder</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="PyDecisionBuilder.NextWrapper" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PyDecisionBuilder.NextWrapper">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">NextWrapper</span><span class="signature">(self, solver)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>  <span class="k">def</span> <span class="nf">NextWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Next</span><span class="p">(</span><span class="n">solver</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
      <span class="k">if</span> <span class="s1">&#39;CP Solver fail&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">solver</span><span class="o">.</span><span class="n">FailDecision</span><span class="p">()</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span>
</pre></div>

        </details>

            <div class="docstring"><p>This is the main method of the decision builder class. It must
return a decision (an instance of the class Decision). If it
returns nullptr, this means that the decision builder has finished
its work.</p>
</div>


                            </div>
                            <div id="PyDecisionBuilder.DebugString" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PyDecisionBuilder.DebugString">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DebugString</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>  <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="s2">&quot;PyDecisionBuilder&quot;</span>
</pre></div>

        </details>

    

                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#DecisionBuilder">DecisionBuilder</a></dt>
                                <dd id="PyDecisionBuilder.thisown" class="variable"><a href="#DecisionBuilder.thisown">thisown</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="PyDemon">
                                <div class="attr class">
        <a class="headerlink" href="#PyDemon">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">PyDemon</span><wbr>(<span class="base"><a href="#Demon">Demon</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">PyDemon</span><span class="p">(</span><span class="n">Demon</span><span class="p">):</span>

  <span class="k">def</span> <span class="nf">RunWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">Run</span><span class="p">(</span><span class="n">solver</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
      <span class="k">if</span> <span class="s1">&#39;CP Solver fail&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">ShouldFail</span><span class="p">()</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span>

  <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="s2">&quot;PyDemon&quot;</span>
</pre></div>

        </details>

            <div class="docstring"><p>A Demon is the base element of a propagation queue. It is the main
  object responsible for implementing the actual propagation
  of the constraint and pruning the inconsistent values in the domains
  of the variables. The main concept is that demons are listeners that are
  attached to the variables and listen to their modifications.</p>

<h6 id="there-are-two-methods">There are two methods</h6>

<blockquote>
  <ul>
  <li>Run() is the actual method called when the demon is processed.</li>
  <li>priority() returns its priority. Standard priorities are slow, normal
  or fast. "immediate" is reserved for variables and is treated separately.</li>
  </ul>
</blockquote>
</div>


                            <div id="PyDemon.RunWrapper" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PyDemon.RunWrapper">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">RunWrapper</span><span class="signature">(self, solver)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>  <span class="k">def</span> <span class="nf">RunWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">Run</span><span class="p">(</span><span class="n">solver</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
      <span class="k">if</span> <span class="s1">&#39;CP Solver fail&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
        <span class="n">solver</span><span class="o">.</span><span class="n">ShouldFail</span><span class="p">()</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span>
</pre></div>

        </details>

            <div class="docstring"><p>This is the main callback of the demon.</p>
</div>


                            </div>
                            <div id="PyDemon.DebugString" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PyDemon.DebugString">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DebugString</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>  <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="s2">&quot;PyDemon&quot;</span>
</pre></div>

        </details>

    

                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#Demon">Demon</a></dt>
                                <dd id="PyDemon.__init__" class="function"><a href="#Demon.__init__">Demon</a></dd>
                <dd id="PyDemon.thisown" class="variable"><a href="#Demon.thisown">thisown</a></dd>
                <dd id="PyDemon.Priority" class="function"><a href="#Demon.Priority">Priority</a></dd>
                <dd id="PyDemon.Inhibit" class="function"><a href="#Demon.Inhibit">Inhibit</a></dd>
                <dd id="PyDemon.Desinhibit" class="function"><a href="#Demon.Desinhibit">Desinhibit</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="PyConstraintDemon">
                                <div class="attr class">
        <a class="headerlink" href="#PyConstraintDemon">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">PyConstraintDemon</span><wbr>(<span class="base"><a href="#PyDemon">PyDemon</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">PyConstraintDemon</span><span class="p">(</span><span class="n">PyDemon</span><span class="p">):</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ct</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">delayed</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="n">PyDemon</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__constraint</span> <span class="o">=</span> <span class="n">ct</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__method</span> <span class="o">=</span> <span class="n">method</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__delayed</span> <span class="o">=</span> <span class="n">delayed</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__args</span> <span class="o">=</span> <span class="n">args</span>

  <span class="k">def</span> <span class="nf">Run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__method</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__constraint</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">__args</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">Priority</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Solver</span><span class="o">.</span><span class="n">DELAYED_PRIORITY</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__delayed</span> <span class="k">else</span> <span class="n">Solver</span><span class="o">.</span><span class="n">NORMAL_PRIORITY</span>

  <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="s1">&#39;PyConstraintDemon&#39;</span>
</pre></div>

        </details>

            <div class="docstring"><p>A Demon is the base element of a propagation queue. It is the main
  object responsible for implementing the actual propagation
  of the constraint and pruning the inconsistent values in the domains
  of the variables. The main concept is that demons are listeners that are
  attached to the variables and listen to their modifications.</p>

<h6 id="there-are-two-methods">There are two methods</h6>

<blockquote>
  <ul>
  <li>Run() is the actual method called when the demon is processed.</li>
  <li>priority() returns its priority. Standard priorities are slow, normal
  or fast. "immediate" is reserved for variables and is treated separately.</li>
  </ul>
</blockquote>
</div>


                            <div id="PyConstraintDemon.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PyConstraintDemon.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">PyConstraintDemon</span><span class="signature">(ct, method, delayed, *args)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ct</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="n">delayed</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="n">PyDemon</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__constraint</span> <span class="o">=</span> <span class="n">ct</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__method</span> <span class="o">=</span> <span class="n">method</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__delayed</span> <span class="o">=</span> <span class="n">delayed</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__args</span> <span class="o">=</span> <span class="n">args</span>
</pre></div>

        </details>

            <div class="docstring"><p>This indicates the priority of a demon. Immediate demons are treated
separately and corresponds to variables.</p>
</div>


                            </div>
                            <div id="PyConstraintDemon.Run" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PyConstraintDemon.Run">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Run</span><span class="signature">(self, solver)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>  <span class="k">def</span> <span class="nf">Run</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver</span><span class="p">):</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__method</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__constraint</span><span class="p">,</span> <span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">__args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="PyConstraintDemon.Priority" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PyConstraintDemon.Priority">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Priority</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>  <span class="k">def</span> <span class="nf">Priority</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">Solver</span><span class="o">.</span><span class="n">DELAYED_PRIORITY</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__delayed</span> <span class="k">else</span> <span class="n">Solver</span><span class="o">.</span><span class="n">NORMAL_PRIORITY</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method returns the priority of the demon. Usually a demon is
fast, slow or normal. Immediate demons are reserved for internal
use to maintain variables.</p>
</div>


                            </div>
                            <div id="PyConstraintDemon.DebugString" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PyConstraintDemon.DebugString">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DebugString</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>  <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="s1">&#39;PyConstraintDemon&#39;</span>
</pre></div>

        </details>

    

                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#PyDemon">PyDemon</a></dt>
                                <dd id="PyConstraintDemon.RunWrapper" class="function"><a href="#PyDemon.RunWrapper">RunWrapper</a></dd>

            </div>
            <div><dt><a href="#Demon">Demon</a></dt>
                                <dd id="PyConstraintDemon.thisown" class="variable"><a href="#Demon.thisown">thisown</a></dd>
                <dd id="PyConstraintDemon.Inhibit" class="function"><a href="#Demon.Inhibit">Inhibit</a></dd>
                <dd id="PyConstraintDemon.Desinhibit" class="function"><a href="#Demon.Desinhibit">Desinhibit</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="PyConstraint">
                                <div class="attr class">
        <a class="headerlink" href="#PyConstraint">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">PyConstraint</span><wbr>(<span class="base"><a href="#Constraint">Constraint</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">PyConstraint</span><span class="p">(</span><span class="n">Constraint</span><span class="p">):</span>

  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver</span><span class="p">):</span>
    <span class="n">Constraint</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__demons</span> <span class="o">=</span> <span class="p">[]</span>

  <span class="k">def</span> <span class="nf">Demon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="n">demon</span> <span class="o">=</span> <span class="n">PyConstraintDemon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__demons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">demon</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">demon</span>

  <span class="k">def</span> <span class="nf">DelayedDemon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="n">demon</span> <span class="o">=</span> <span class="n">PyConstraintDemon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__demons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">demon</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">demon</span>

  <span class="k">def</span> <span class="nf">InitialPropagateDemon</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">()</span><span class="o">.</span><span class="n">ConstraintInitialPropagateCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">DelayedInitialPropagateDemon</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">()</span><span class="o">.</span><span class="n">DelayedConstraintInitialPropagateCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

  <span class="k">def</span> <span class="nf">InitialPropagateWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">InitialPropagate</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
      <span class="k">if</span> <span class="s1">&#39;CP Solver fail&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">()</span><span class="o">.</span><span class="n">ShouldFail</span><span class="p">()</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span>

  <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="s2">&quot;PyConstraint&quot;</span>
</pre></div>

        </details>

            <div class="docstring"><p>A constraint is the main modeling object. It provides two methods:</p>

<ul>
<li>Post() is responsible for creating the demons and attaching them to
immediate demons().</li>
<li>InitialPropagate() is called once just after Post and performs
the initial propagation. The subsequent propagations will be performed
by the demons Posted during the post() method.</li>
</ul>
</div>


                            <div id="PyConstraint.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PyConstraint.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">PyConstraint</span><span class="signature">(solver)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>  <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver</span><span class="p">):</span>
    <span class="n">Constraint</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solver</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__demons</span> <span class="o">=</span> <span class="p">[]</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="PyConstraint.Demon" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PyConstraint.Demon">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Demon</span><span class="signature">(self, method, *args)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>  <span class="k">def</span> <span class="nf">Demon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="n">demon</span> <span class="o">=</span> <span class="n">PyConstraintDemon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="kc">False</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__demons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">demon</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">demon</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="PyConstraint.DelayedDemon" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PyConstraint.DelayedDemon">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DelayedDemon</span><span class="signature">(self, method, *args)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>  <span class="k">def</span> <span class="nf">DelayedDemon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
    <span class="n">demon</span> <span class="o">=</span> <span class="n">PyConstraintDemon</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">method</span><span class="p">,</span> <span class="kc">True</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">__demons</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">demon</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">demon</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="PyConstraint.InitialPropagateDemon" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PyConstraint.InitialPropagateDemon">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">InitialPropagateDemon</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>  <span class="k">def</span> <span class="nf">InitialPropagateDemon</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">()</span><span class="o">.</span><span class="n">ConstraintInitialPropagateCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="PyConstraint.DelayedInitialPropagateDemon" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PyConstraint.DelayedInitialPropagateDemon">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DelayedInitialPropagateDemon</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>  <span class="k">def</span> <span class="nf">DelayedInitialPropagateDemon</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">()</span><span class="o">.</span><span class="n">DelayedConstraintInitialPropagateCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="PyConstraint.InitialPropagateWrapper" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PyConstraint.InitialPropagateWrapper">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">InitialPropagateWrapper</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>  <span class="k">def</span> <span class="nf">InitialPropagateWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
      <span class="bp">self</span><span class="o">.</span><span class="n">InitialPropagate</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
      <span class="k">if</span> <span class="s1">&#39;CP Solver fail&#39;</span> <span class="ow">in</span> <span class="nb">str</span><span class="p">(</span><span class="n">e</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">solver</span><span class="p">()</span><span class="o">.</span><span class="n">ShouldFail</span><span class="p">()</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method performs the initial propagation of the
constraint. It is called just after the post.</p>
</div>


                            </div>
                            <div id="PyConstraint.DebugString" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#PyConstraint.DebugString">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DebugString</span><span class="signature">(self)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>  <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">return</span> <span class="s2">&quot;PyConstraint&quot;</span>
</pre></div>

        </details>

    

                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#Constraint">Constraint</a></dt>
                                <dd id="PyConstraint.thisown" class="variable"><a href="#Constraint.thisown">thisown</a></dd>
                <dd id="PyConstraint.Post" class="function"><a href="#Constraint.Post">Post</a></dd>
                <dd id="PyConstraint.Var" class="function"><a href="#Constraint.Var">Var</a></dd>
                <dd id="PyConstraint.Square" class="function"><a href="#Constraint.Square">Square</a></dd>
                <dd id="PyConstraint.MapTo" class="function"><a href="#Constraint.MapTo">MapTo</a></dd>
                <dd id="PyConstraint.IndexOf" class="function"><a href="#Constraint.IndexOf">IndexOf</a></dd>

            </div>
            <div><dt><a href="#PropagationBaseObject">PropagationBaseObject</a></dt>
                                <dd id="PyConstraint.solver" class="function"><a href="#PropagationBaseObject.solver">solver</a></dd>
                <dd id="PyConstraint.Name" class="function"><a href="#PropagationBaseObject.Name">Name</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="RoutingIndexManager">
                                <div class="attr class">
        <a class="headerlink" href="#RoutingIndexManager">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">RoutingIndexManager</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">RoutingIndexManager</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Manager for any NodeIndex &lt;-&gt; variable index conversion. The routing solver</span>
<span class="sd">    uses variable indices internally and through its API. These variable indices</span>
<span class="sd">    are tricky to manage directly because one Node can correspond to a multitude</span>
<span class="sd">    of variables, depending on the number of times they appear in the model, and</span>
<span class="sd">    if they&#39;re used as start and/or end points. This class aims to simplify</span>
<span class="sd">    variable index usage, allowing users to use NodeIndex instead.</span>

<span class="sd">    Usage:</span>

<span class="sd">      .. code-block:: c++</span>

<span class="sd">          auto starts_ends = ...;  /// These are NodeIndex.</span>
<span class="sd">          RoutingIndexManager manager(10, 4, starts_ends);  // 10 nodes, 4 vehicles.</span>
<span class="sd">          RoutingModel model(manager);</span>

<span class="sd">    Then, use &#39;manager.NodeToIndex(node)&#39; whenever model requires a variable</span>
<span class="sd">    index.</span>

<span class="sd">    Note: the mapping between node indices and variables indices is subject to</span>
<span class="sd">    change so no assumption should be made on it. The only guarantee is that</span>
<span class="sd">    indices range between 0 and n-1, where n = number of vehicles * 2 (for start</span>
<span class="sd">    and end nodes) + number of non-start or end nodes.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingIndexManager_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_RoutingIndexManager</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_RoutingIndexManager</span>

    <span class="k">def</span> <span class="nf">GetNumberOfNodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingIndexManager_GetNumberOfNodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetNumberOfVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingIndexManager_GetNumberOfVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetNumberOfIndices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingIndexManager_GetNumberOfIndices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetStartIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingIndexManager_GetStartIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetEndIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingIndexManager_GetEndIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NodeToIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingIndexManager::NodeIndex&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingIndexManager_NodeToIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IndexToNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingIndexManager::NodeIndex&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingIndexManager_IndexToNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Manager for any NodeIndex &lt;-> variable index conversion. The routing solver
uses variable indices internally and through its API. These variable indices
are tricky to manage directly because one Node can correspond to a multitude
of variables, depending on the number of times they appear in the model, and
if they're used as start and/or end points. This class aims to simplify
variable index usage, allowing users to use NodeIndex instead.</p>

<h6 id="usage">Usage</h6>

<blockquote>
  <p>.. code-block:: c++</p>

<pre><code>auto starts_ends = ...;  /// These are NodeIndex.
RoutingIndexManager manager(10, 4, starts_ends);  // 10 nodes, 4 vehicles.
RoutingModel model(manager);
</code></pre>
</blockquote>

<p>Then, use 'manager.NodeToIndex(node)' whenever model requires a variable
index.</p>

<p>Note: the mapping between node indices and variables indices is subject to
change so no assumption should be made on it. The only guarantee is that
indices range between 0 and n-1, where n = number of vehicles * 2 (for start
and end nodes) + number of non-start or end nodes.</p>
</div>


                            <div id="RoutingIndexManager.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingIndexManager.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">RoutingIndexManager</span><span class="signature">(*args)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingIndexManager_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_RoutingIndexManager</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingIndexManager.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#RoutingIndexManager.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="RoutingIndexManager.GetNumberOfNodes" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingIndexManager.GetNumberOfNodes">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetNumberOfNodes</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetNumberOfNodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingIndexManager_GetNumberOfNodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingIndexManager.GetNumberOfVehicles" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingIndexManager.GetNumberOfVehicles">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetNumberOfVehicles</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetNumberOfVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingIndexManager_GetNumberOfVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingIndexManager.GetNumberOfIndices" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingIndexManager.GetNumberOfIndices">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetNumberOfIndices</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetNumberOfIndices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingIndexManager_GetNumberOfIndices</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingIndexManager.GetStartIndex" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingIndexManager.GetStartIndex">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetStartIndex</span><span class="signature">(self, vehicle: int) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetStartIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingIndexManager_GetStartIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingIndexManager.GetEndIndex" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingIndexManager.GetEndIndex">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetEndIndex</span><span class="signature">(self, vehicle: int) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetEndIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingIndexManager_GetEndIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingIndexManager.NodeToIndex" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingIndexManager.NodeToIndex">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">NodeToIndex</span><span class="signature">(
    self,
    node: &#39;operations_research::RoutingIndexManager::NodeIndex&#39;
) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">NodeToIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingIndexManager::NodeIndex&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingIndexManager_NodeToIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingIndexManager.IndexToNode" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingIndexManager.IndexToNode">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IndexToNode</span><span class="signature">(
    self,
    index: &#39;int64_t&#39;
) -&gt; &#39;operations_research::RoutingIndexManager::NodeIndex&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IndexToNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingIndexManager::NodeIndex&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingIndexManager_IndexToNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                </section>
                <section id="DefaultRoutingModelParameters">
                            <div class="attr function"><a class="headerlink" href="#DefaultRoutingModelParameters">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DefaultRoutingModelParameters</span><span class="signature">() -&gt; &#39;operations_research::RoutingModelParameters&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">DefaultRoutingModelParameters</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingModelParameters&quot;</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultRoutingModelParameters</span><span class="p">()</span>
</pre></div>

        </details>

    

                </section>
                <section id="DefaultRoutingSearchParameters">
                            <div class="attr function"><a class="headerlink" href="#DefaultRoutingSearchParameters">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DefaultRoutingSearchParameters</span><span class="signature">() -&gt; &#39;operations_research::RoutingSearchParameters&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">DefaultRoutingSearchParameters</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingSearchParameters&quot;</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">DefaultRoutingSearchParameters</span><span class="p">()</span>
</pre></div>

        </details>

    

                </section>
                <section id="FindErrorInRoutingSearchParameters">
                            <div class="attr function"><a class="headerlink" href="#FindErrorInRoutingSearchParameters">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">FindErrorInRoutingSearchParameters</span><span class="signature">(
    search_parameters: &#39;operations_research::RoutingSearchParameters const &amp;&#39;
) -&gt; &#39;std::string&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">FindErrorInRoutingSearchParameters</span><span class="p">(</span><span class="n">search_parameters</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingSearchParameters const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Returns an empty std::string if the routing search parameters are valid, and</span>
<span class="sd">    a non-empty, human readable error description if they&#39;re not.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">FindErrorInRoutingSearchParameters</span><span class="p">(</span><span class="n">search_parameters</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns an empty std::string if the routing search parameters are valid, and
a non-empty, human readable error description if they're not.</p>
</div>


                </section>
                <section id="RoutingModel">
                                <div class="attr class">
        <a class="headerlink" href="#RoutingModel">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">RoutingModel</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">RoutingModel</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>
    <span class="n">ROUTING_NOT_SOLVED</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_ROUTING_NOT_SOLVED</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Problem not solved yet (before calling RoutingModel::Solve()).&quot;&quot;&quot;</span>
    <span class="n">ROUTING_SUCCESS</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_ROUTING_SUCCESS</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Problem solved successfully after calling RoutingModel::Solve().&quot;&quot;&quot;</span>
    <span class="n">ROUTING_FAIL</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_ROUTING_FAIL</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; No solution found to the problem after calling RoutingModel::Solve().&quot;&quot;&quot;</span>
    <span class="n">ROUTING_FAIL_TIMEOUT</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_ROUTING_FAIL_TIMEOUT</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Time limit reached before finding a solution with RoutingModel::Solve().&quot;&quot;&quot;</span>
    <span class="n">ROUTING_INVALID</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_ROUTING_INVALID</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Model, model parameters or flags are not valid.&quot;&quot;&quot;</span>
    <span class="n">PICKUP_AND_DELIVERY_NO_ORDER</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_PICKUP_AND_DELIVERY_NO_ORDER</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Any precedence is accepted.&quot;&quot;&quot;</span>
    <span class="n">PICKUP_AND_DELIVERY_LIFO</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_PICKUP_AND_DELIVERY_LIFO</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Deliveries must be performed in reverse order of pickups.&quot;&quot;&quot;</span>
    <span class="n">PICKUP_AND_DELIVERY_FIFO</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_PICKUP_AND_DELIVERY_FIFO</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Deliveries must be performed in the same order as pickups.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_RoutingModel</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_RoutingModel</span>

    <span class="k">def</span> <span class="nf">RegisterUnaryTransitVector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Registers &#39;callback&#39; and returns its index.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_RegisterUnaryTransitVector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RegisterUnaryTransitCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingModel::TransitCallback1&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_RegisterUnaryTransitCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RegisterPositiveUnaryTransitCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingModel::TransitCallback1&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_RegisterPositiveUnaryTransitCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RegisterTransitMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; std::vector&lt; int64_t &gt; &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_RegisterTransitMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RegisterTransitCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingModel::TransitCallback2&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_RegisterTransitCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RegisterPositiveTransitCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingModel::TransitCallback2&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_RegisterPositiveTransitCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">TransitCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback_index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingModel::TransitCallback2 const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_TransitCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback_index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">UnaryTransitCallbackOrNull</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback_index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingModel::TransitCallback1 const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_UnaryTransitCallbackOrNull</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback_index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator_index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">slack_max</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Model creation</span>
<span class="sd">        Methods to add dimensions to routes; dimensions represent quantities</span>
<span class="sd">        accumulated at nodes along the routes. They represent quantities such as</span>
<span class="sd">        weights or volumes carried along the route, or distance or times.</span>
<span class="sd">        Quantities at a node are represented by &quot;cumul&quot; variables and the increase</span>
<span class="sd">        or decrease of quantities between nodes are represented by &quot;transit&quot;</span>
<span class="sd">        variables. These variables are linked as follows:</span>
<span class="sd">        if j == next(i), cumul(j) = cumul(i) + transit(i) + slack(i)</span>
<span class="sd">        where slack is a positive slack variable (can represent waiting times for</span>
<span class="sd">        a time dimension).</span>
<span class="sd">        Setting the value of fix_start_cumul_to_zero to true will force the</span>
<span class="sd">        &quot;cumul&quot; variable of the start node of all vehicles to be equal to 0.</span>
<span class="sd">        Creates a dimension where the transit variable is constrained to be</span>
<span class="sd">        equal to evaluator(i, next(i)); &#39;slack_max&#39; is the upper bound of the</span>
<span class="sd">        slack variable and &#39;capacity&#39; is the upper bound of the cumul variables.</span>
<span class="sd">        &#39;name&#39; is the name used to reference the dimension; this name is used to</span>
<span class="sd">        get cumul and transit variables from the routing model.</span>
<span class="sd">        Returns false if a dimension with the same name has already been created</span>
<span class="sd">        (and doesn&#39;t create the new dimension).</span>
<span class="sd">        Takes ownership of the callback &#39;evaluator&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator_index</span><span class="p">,</span> <span class="n">slack_max</span><span class="p">,</span> <span class="n">capacity</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddDimensionWithVehicleTransits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator_indices</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">slack_max</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddDimensionWithVehicleTransits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator_indices</span><span class="p">,</span> <span class="n">slack_max</span><span class="p">,</span> <span class="n">capacity</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddDimensionWithVehicleCapacity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator_index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">slack_max</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">vehicle_capacities</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt;&quot;</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddDimensionWithVehicleCapacity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator_index</span><span class="p">,</span> <span class="n">slack_max</span><span class="p">,</span> <span class="n">vehicle_capacities</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddDimensionWithVehicleTransitAndCapacity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator_indices</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">slack_max</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">vehicle_capacities</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt;&quot;</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddDimensionWithVehicleTransitAndCapacity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator_indices</span><span class="p">,</span> <span class="n">slack_max</span><span class="p">,</span> <span class="n">vehicle_capacities</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddConstantDimensionWithSlack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">slack_max</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::pair&lt; int,bool &gt;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a dimension where the transit variable is constrained to be</span>
<span class="sd">        equal to &#39;value&#39;; &#39;capacity&#39; is the upper bound of the cumul variables.</span>
<span class="sd">        &#39;name&#39; is the name used to reference the dimension; this name is used to</span>
<span class="sd">        get cumul and transit variables from the routing model.</span>
<span class="sd">        Returns a pair consisting of an index to the registered unary transit</span>
<span class="sd">        callback and a bool denoting whether the dimension has been created.</span>
<span class="sd">        It is false if a dimension with the same name has already been created</span>
<span class="sd">        (and doesn&#39;t create the new dimension but still register a new callback).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddConstantDimensionWithSlack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">capacity</span><span class="p">,</span> <span class="n">slack_max</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddConstantDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::pair&lt; int,bool &gt;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddConstantDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">capacity</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddVectorDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt;&quot;</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::pair&lt; int,bool &gt;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a dimension where the transit variable is constrained to be</span>
<span class="sd">        equal to &#39;values[i]&#39; for node i; &#39;capacity&#39; is the upper bound of</span>
<span class="sd">        the cumul variables. &#39;name&#39; is the name used to reference the dimension;</span>
<span class="sd">        this name is used to get cumul and transit variables from the routing</span>
<span class="sd">        model.</span>
<span class="sd">        Returns a pair consisting of an index to the registered unary transit</span>
<span class="sd">        callback and a bool denoting whether the dimension has been created.</span>
<span class="sd">        It is false if a dimension with the same name has already been created</span>
<span class="sd">        (and doesn&#39;t create the new dimension but still register a new callback).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddVectorDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">capacity</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddMatrixDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; std::vector&lt; int64_t &gt; &gt;&quot;</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::pair&lt; int,bool &gt;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a dimension where the transit variable is constrained to be</span>
<span class="sd">        equal to &#39;values[i][next(i)]&#39; for node i; &#39;capacity&#39; is the upper bound of</span>
<span class="sd">        the cumul variables. &#39;name&#39; is the name used to reference the dimension;</span>
<span class="sd">        this name is used to get cumul and transit variables from the routing</span>
<span class="sd">        model.</span>
<span class="sd">        Returns a pair consisting of an index to the registered transit callback</span>
<span class="sd">        and a bool denoting whether the dimension has been created.</span>
<span class="sd">        It is false if a dimension with the same name has already been created</span>
<span class="sd">        (and doesn&#39;t create the new dimension but still register a new callback).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddMatrixDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">capacity</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">MakePathSpansAndTotalSlacks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="s2">&quot;RoutingDimension&quot;</span><span class="p">,</span> <span class="n">spans</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt;&quot;</span><span class="p">,</span> <span class="n">total_slacks</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For every vehicle of the routing model:</span>
<span class="sd">        - if total_slacks[vehicle] is not nullptr, constrains it to be the sum of</span>
<span class="sd">          slacks on that vehicle, that is,</span>
<span class="sd">          dimension-&gt;CumulVar(end) - dimension-&gt;CumulVar(start) -</span>
<span class="sd">          sum_{node in path of vehicle} dimension-&gt;FixedTransitVar(node).</span>
<span class="sd">        - if spans[vehicle] is not nullptr, constrains it to be</span>
<span class="sd">          dimension-&gt;CumulVar(end) - dimension-&gt;CumulVar(start)</span>
<span class="sd">        This does stronger propagation than a decomposition, and takes breaks into</span>
<span class="sd">        account.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_MakePathSpansAndTotalSlacks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">spans</span><span class="p">,</span> <span class="n">total_slacks</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetAllDimensionNames</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; std::string &gt;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Outputs the names of all dimensions added to the routing engine.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetAllDimensionNames</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetDimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; operations_research::RoutingDimension * &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns all dimensions of the model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetDimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetDimensionsWithSoftOrSpanCosts</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; operations_research::RoutingDimension * &gt;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns dimensions with soft or vehicle span costs.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetDimensionsWithSoftOrSpanCosts</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetGlobalDimensionCumulOptimizers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; std::unique_ptr&lt; operations_research::GlobalDimensionCumulOptimizer &gt; &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns [global|local]_dimension_optimizers_, which are empty if the model</span>
<span class="sd">        has not been closed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetGlobalDimensionCumulOptimizers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetGlobalDimensionCumulMPOptimizers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; std::unique_ptr&lt; operations_research::GlobalDimensionCumulOptimizer &gt; &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetGlobalDimensionCumulMPOptimizers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetLocalDimensionCumulOptimizers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; std::unique_ptr&lt; operations_research::LocalDimensionCumulOptimizer &gt; &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetLocalDimensionCumulOptimizers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetLocalDimensionCumulMPOptimizers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; std::unique_ptr&lt; operations_research::LocalDimensionCumulOptimizer &gt; &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetLocalDimensionCumulMPOptimizers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetMutableGlobalCumulOptimizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="s2">&quot;RoutingDimension&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::GlobalDimensionCumulOptimizer *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the global/local dimension cumul optimizer for a given dimension,</span>
<span class="sd">        or nullptr if there is none.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetMutableGlobalCumulOptimizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetMutableGlobalCumulMPOptimizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="s2">&quot;RoutingDimension&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::GlobalDimensionCumulOptimizer *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetMutableGlobalCumulMPOptimizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetMutableLocalCumulOptimizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="s2">&quot;RoutingDimension&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::LocalDimensionCumulOptimizer *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetMutableLocalCumulOptimizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetMutableLocalCumulMPOptimizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="s2">&quot;RoutingDimension&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::LocalDimensionCumulOptimizer *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetMutableLocalCumulMPOptimizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">HasDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension_name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns true if a dimension exists for a given dimension name.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_HasDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetDimensionOrDie</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension_name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingDimension const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns a dimension from its name. Dies if the dimension does not exist.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetDimensionOrDie</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetMutableDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension_name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingDimension *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dimension from its name. Returns nullptr if the dimension does</span>
<span class="sd">        not exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetMutableDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetPrimaryConstrainedDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension_name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the given dimension as &quot;primary constrained&quot;. As of August 2013, this</span>
<span class="sd">        is only used by ArcIsMoreConstrainedThanArc().</span>
<span class="sd">        &quot;dimension&quot; must be the name of an existing dimension, or be empty, in</span>
<span class="sd">        which case there will not be a primary dimension after this call.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetPrimaryConstrainedDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetPrimaryConstrainedDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Get the primary constrained dimension, or an empty string if it is unset.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetPrimaryConstrainedDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetDimensionResourceGroupIndices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="s2">&quot;RoutingDimension&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the indices of resource groups for this dimension. This method can</span>
<span class="sd">        only be called after the model has been closed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetDimensionResourceGroupIndices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddDisjunction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingModel::DisjunctionIndex&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a disjunction constraint on the indices: exactly &#39;max_cardinality&#39; of</span>
<span class="sd">        the indices are active. Start and end indices of any vehicle cannot be</span>
<span class="sd">        part of a disjunction.</span>

<span class="sd">        If a penalty is given, at most &#39;max_cardinality&#39; of the indices can be</span>
<span class="sd">        active, and if less are active, &#39;penalty&#39; is payed per inactive index.</span>
<span class="sd">        This is equivalent to adding the constraint:</span>
<span class="sd">            p + Sum(i)active[i] == max_cardinality</span>
<span class="sd">        where p is an integer variable, and the following cost to the cost</span>
<span class="sd">        function:</span>
<span class="sd">            p * penalty.</span>
<span class="sd">        &#39;penalty&#39; must be positive to make the disjunction optional; a negative</span>
<span class="sd">        penalty will force &#39;max_cardinality&#39; indices of the disjunction to be</span>
<span class="sd">        performed, and therefore p == 0.</span>
<span class="sd">        Note: passing a vector with a single index will model an optional index</span>
<span class="sd">        with a penalty cost if it is not visited.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddDisjunction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetDisjunctionIndices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; operations_research::RoutingModel::DisjunctionIndex &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the indices of the disjunctions to which an index belongs.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetDisjunctionIndices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetDisjunctionPenalty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingModel::DisjunctionIndex&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the penalty of the node disjunction of index &#39;index&#39;.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetDisjunctionPenalty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetDisjunctionMaxCardinality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingModel::DisjunctionIndex&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the maximum number of possible active nodes of the node</span>
<span class="sd">        disjunction of index &#39;index&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetDisjunctionMaxCardinality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetNumberOfDisjunctions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the number of node disjunctions in the model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetNumberOfDisjunctions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetPerfectBinaryDisjunctions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; std::pair&lt; int64_t,int64_t &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the list of all perfect binary disjunctions, as pairs of variable</span>
<span class="sd">        indices: a disjunction is &quot;perfect&quot; when its variables do not appear in</span>
<span class="sd">        any other disjunction. Each pair is sorted (lowest variable index first),</span>
<span class="sd">        and the output vector is also sorted (lowest pairs first).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetPerfectBinaryDisjunctions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IgnoreDisjunctionsAlreadyForcedToZero</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        SPECIAL: Makes the solver ignore all the disjunctions whose active</span>
<span class="sd">        variables are all trivially zero (i.e. Max() == 0), by setting their</span>
<span class="sd">        max_cardinality to 0.</span>
<span class="sd">        This can be useful when using the BaseBinaryDisjunctionNeighborhood</span>
<span class="sd">        operators, in the context of arc-based routing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_IgnoreDisjunctionsAlreadyForcedToZero</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddSoftSameVehicleConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">cost</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a soft constraint to force a set of variable indices to be on the</span>
<span class="sd">        same vehicle. If all nodes are not on the same vehicle, each extra vehicle</span>
<span class="sd">        used adds &#39;cost&#39; to the cost function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddSoftSameVehicleConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">cost</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetAllowedVehiclesForIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicles</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the vehicles which can visit a given node. If the node is in a</span>
<span class="sd">        disjunction, this will not prevent it from being unperformed.</span>
<span class="sd">        Specifying an empty vector of vehicles has no effect (all vehicles</span>
<span class="sd">        will be allowed to visit the node).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetAllowedVehiclesForIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicles</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsVehicleAllowedForIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns true if a vehicle is allowed to visit a given node.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_IsVehicleAllowedForIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddPickupAndDelivery</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pickup</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">delivery</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Notifies that index1 and index2 form a pair of nodes which should belong</span>
<span class="sd">        to the same route. This methods helps the search find better solutions,</span>
<span class="sd">        especially in the local search phase.</span>
<span class="sd">        It should be called each time you have an equality constraint linking</span>
<span class="sd">        the vehicle variables of two node (including for instance pickup and</span>
<span class="sd">        delivery problems):</span>
<span class="sd">            Solver* const solver = routing.solver();</span>
<span class="sd">            int64_t index1 = manager.NodeToIndex(node1);</span>
<span class="sd">            int64_t index2 = manager.NodeToIndex(node2);</span>
<span class="sd">            solver-&gt;AddConstraint(solver-&gt;MakeEquality(</span>
<span class="sd">                routing.VehicleVar(index1),</span>
<span class="sd">                routing.VehicleVar(index2)));</span>
<span class="sd">            routing.AddPickupAndDelivery(index1, index2);</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddPickupAndDelivery</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pickup</span><span class="p">,</span> <span class="n">delivery</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddPickupAndDeliverySets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pickup_disjunction</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingModel::DisjunctionIndex&quot;</span><span class="p">,</span> <span class="n">delivery_disjunction</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingModel::DisjunctionIndex&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as AddPickupAndDelivery but notifying that the performed node from</span>
<span class="sd">        the disjunction of index &#39;pickup_disjunction&#39; is on the same route as the</span>
<span class="sd">        performed node from the disjunction of index &#39;delivery_disjunction&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddPickupAndDeliverySets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pickup_disjunction</span><span class="p">,</span> <span class="n">delivery_disjunction</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetPickupIndexPairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; std::pair&lt; int,int &gt; &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns pairs for which the node is a pickup; the first element of each</span>
<span class="sd">        pair is the index in the pickup and delivery pairs list in which the</span>
<span class="sd">        pickup appears, the second element is its index in the pickups list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetPickupIndexPairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetDeliveryIndexPairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; std::pair&lt; int,int &gt; &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Same as above for deliveries.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetDeliveryIndexPairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetPickupAndDeliveryPolicyOfAllVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">policy</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingModel::PickupAndDeliveryPolicy&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the Pickup and delivery policy of all vehicles. It is equivalent to</span>
<span class="sd">        calling SetPickupAndDeliveryPolicyOfVehicle on all vehicles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetPickupAndDeliveryPolicyOfAllVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">policy</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetPickupAndDeliveryPolicyOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">policy</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingModel::PickupAndDeliveryPolicy&quot;</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetPickupAndDeliveryPolicyOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">policy</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetPickupAndDeliveryPolicyOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingModel::PickupAndDeliveryPolicy&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetPickupAndDeliveryPolicyOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetNumOfSingletonNodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of non-start/end nodes which do not appear in a</span>
<span class="sd">        pickup/delivery pair.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetNumOfSingletonNodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">TYPE_ADDED_TO_VEHICLE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_TYPE_ADDED_TO_VEHICLE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; When visited, the number of types &#39;T&#39; on the vehicle increases by one.&quot;&quot;&quot;</span>
    <span class="n">ADDED_TYPE_REMOVED_FROM_VEHICLE</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_ADDED_TYPE_REMOVED_FROM_VEHICLE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    When visited, one instance of type &#39;T&#39; previously added to the route</span>
<span class="sd">    (TYPE_ADDED_TO_VEHICLE), if any, is removed from the vehicle.</span>
<span class="sd">    If the type was not previously added to the route or all added instances</span>
<span class="sd">    have already been removed, this visit has no effect on the types.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">TYPE_ON_VEHICLE_UP_TO_VISIT</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_TYPE_ON_VEHICLE_UP_TO_VISIT</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    With the following policy, the visit enforces that type &#39;T&#39; is</span>
<span class="sd">    considered on the route from its start until this node is visited.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The visit doesn&#39;t have an impact on the number of types &#39;T&#39; on the</span>
<span class="sd">    route, as it&#39;s (virtually) added and removed directly.</span>
<span class="sd">    This policy can be used for visits which are part of an incompatibility</span>
<span class="sd">    or requirement set without affecting the type count on the route.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">SetVisitType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">type_policy</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingModel::VisitTypePolicy&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetVisitType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">type_policy</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetVisitType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetVisitType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetSingleNodesOfType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetSingleNodesOfType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetPairIndicesOfType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetPairIndicesOfType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetVisitTypePolicy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingModel::VisitTypePolicy&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetVisitTypePolicy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">CloseVisitTypes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function should be called once all node visit types have been set and</span>
<span class="sd">        prior to adding any incompatibilities/requirements.</span>
<span class="sd">        &quot;close&quot; types.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_CloseVisitTypes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetNumberOfVisitTypes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetNumberOfVisitTypes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddHardTypeIncompatibility</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type1</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">type2</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Incompatibilities:</span>
<span class="sd">        Two nodes with &quot;hard&quot; incompatible types cannot share the same route at</span>
<span class="sd">        all, while with a &quot;temporal&quot; incompatibility they can&#39;t be on the same</span>
<span class="sd">        route at the same time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddHardTypeIncompatibility</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type1</span><span class="p">,</span> <span class="n">type2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddTemporalTypeIncompatibility</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type1</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">type2</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddTemporalTypeIncompatibility</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type1</span><span class="p">,</span> <span class="n">type2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetHardTypeIncompatibilitiesOfType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;absl::flat_hash_set&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns visit types incompatible with a given type.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetHardTypeIncompatibilitiesOfType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetTemporalTypeIncompatibilitiesOfType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;absl::flat_hash_set&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetTemporalTypeIncompatibilitiesOfType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">HasHardTypeIncompatibilities</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns true iff any hard (resp. temporal) type incompatibilities have</span>
<span class="sd">        been added to the model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_HasHardTypeIncompatibilities</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">HasTemporalTypeIncompatibilities</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_HasTemporalTypeIncompatibilities</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddSameVehicleRequiredTypeAlternatives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dependent_type</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">required_type_alternatives</span><span class="p">:</span> <span class="s2">&quot;absl::flat_hash_set&lt; int &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Requirements:</span>
<span class="sd">        NOTE: As of 2019-04, cycles in the requirement graph are not supported,</span>
<span class="sd">        and lead to the dependent nodes being skipped if possible (otherwise</span>
<span class="sd">        the model is considered infeasible).</span>
<span class="sd">        The following functions specify that &quot;dependent_type&quot; requires at least</span>
<span class="sd">        one of the types in &quot;required_type_alternatives&quot;.</span>

<span class="sd">        For same-vehicle requirements, a node of dependent type type_D requires at</span>
<span class="sd">        least one node of type type_R among the required alternatives on the same</span>
<span class="sd">        route.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddSameVehicleRequiredTypeAlternatives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dependent_type</span><span class="p">,</span> <span class="n">required_type_alternatives</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddRequiredTypeAlternativesWhenAddingType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dependent_type</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">required_type_alternatives</span><span class="p">:</span> <span class="s2">&quot;absl::flat_hash_set&lt; int &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If type_D depends on type_R when adding type_D, any node_D of type_D and</span>
<span class="sd">        VisitTypePolicy TYPE_ADDED_TO_VEHICLE or</span>
<span class="sd">        TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED requires at least one type_R on its</span>
<span class="sd">        vehicle at the time node_D is visited.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddRequiredTypeAlternativesWhenAddingType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dependent_type</span><span class="p">,</span> <span class="n">required_type_alternatives</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddRequiredTypeAlternativesWhenRemovingType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dependent_type</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">required_type_alternatives</span><span class="p">:</span> <span class="s2">&quot;absl::flat_hash_set&lt; int &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The following requirements apply when visiting dependent nodes that remove</span>
<span class="sd">        their type from the route, i.e. type_R must be on the vehicle when type_D</span>
<span class="sd">        of VisitTypePolicy ADDED_TYPE_REMOVED_FROM_VEHICLE,</span>
<span class="sd">        TYPE_ON_VEHICLE_UP_TO_VISIT or TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED is</span>
<span class="sd">        visited.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddRequiredTypeAlternativesWhenRemovingType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dependent_type</span><span class="p">,</span> <span class="n">required_type_alternatives</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetSameVehicleRequiredTypeAlternativesOfType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; absl::flat_hash_set&lt; int &gt; &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the set of same-vehicle requirement alternatives for the given</span>
<span class="sd">        type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetSameVehicleRequiredTypeAlternativesOfType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetRequiredTypeAlternativesWhenAddingType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; absl::flat_hash_set&lt; int &gt; &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the set of requirement alternatives when adding the given type.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetRequiredTypeAlternativesWhenAddingType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetRequiredTypeAlternativesWhenRemovingType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; absl::flat_hash_set&lt; int &gt; &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the set of requirement alternatives when removing the given type.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetRequiredTypeAlternativesWhenRemovingType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">HasSameVehicleTypeRequirements</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns true iff any same-route (resp. temporal) type requirements have</span>
<span class="sd">        been added to the model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_HasSameVehicleTypeRequirements</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">HasTemporalTypeRequirements</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_HasTemporalTypeRequirements</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">HasTypeRegulations</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns true iff the model has any incompatibilities or requirements set</span>
<span class="sd">        on node types.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_HasTypeRegulations</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">UnperformedPenalty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the &quot;unperformed&quot; penalty of a node. This is only well defined if the</span>
<span class="sd">        node is only part of a single Disjunction, and that disjunction has a</span>
<span class="sd">        penalty. For forced active nodes returns max int64_t. In all other cases,</span>
<span class="sd">        this returns 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_UnperformedPenalty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">UnperformedPenaltyOrValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">default_value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">var_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as above except that it returns default_value instead of 0 when</span>
<span class="sd">        penalty is not well defined (default value is passed as first argument to</span>
<span class="sd">        simplify the usage of the method in a callback).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_UnperformedPenaltyOrValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">default_value</span><span class="p">,</span> <span class="n">var_index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetDepot</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the variable index of the first starting or ending node of all</span>
<span class="sd">        routes. If all routes start  and end at the same node (single depot), this</span>
<span class="sd">        is the node returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetDepot</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetMaximumNumberOfActiveVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_active_vehicles</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constrains the maximum number of active vehicles, aka the number of</span>
<span class="sd">        vehicles which do not have an empty route. For instance, this can be used</span>
<span class="sd">        to limit the number of routes in the case where there are fewer drivers</span>
<span class="sd">        than vehicles and that the fleet of vehicle is heterogeneous.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetMaximumNumberOfActiveVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_active_vehicles</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetMaximumNumberOfActiveVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the maximum number of active vehicles.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetMaximumNumberOfActiveVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetArcCostEvaluatorOfAllVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator_index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the cost function of the model such that the cost of a segment of a</span>
<span class="sd">        route between node &#39;from&#39; and &#39;to&#39; is evaluator(from, to), whatever the</span>
<span class="sd">        route or vehicle performing the route.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetArcCostEvaluatorOfAllVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator_index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetArcCostEvaluatorOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator_index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Sets the cost function for a given vehicle route.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetArcCostEvaluatorOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator_index</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetFixedCostOfAllVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cost</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the fixed cost of all vehicle routes. It is equivalent to calling</span>
<span class="sd">        SetFixedCostOfVehicle on all vehicle routes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetFixedCostOfAllVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cost</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetFixedCostOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cost</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Sets the fixed cost of one vehicle route.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetFixedCostOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cost</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetFixedCostOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the route fixed cost taken into account if the route of the</span>
<span class="sd">        vehicle is not empty, aka there&#39;s at least one node on the route other</span>
<span class="sd">        than the first and last nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetFixedCostOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetAmortizedCostFactorsOfAllVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linear_cost_factor</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">quadratic_cost_factor</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The following methods set the linear and quadratic cost factors of</span>
<span class="sd">        vehicles (must be positive values). The default value of these parameters</span>
<span class="sd">        is zero for all vehicles.</span>

<span class="sd">        When set, the cost_ of the model will contain terms aiming at reducing the</span>
<span class="sd">        number of vehicles used in the model, by adding the following to the</span>
<span class="sd">        objective for every vehicle v:</span>
<span class="sd">        INDICATOR(v used in the model) *</span>
<span class="sd">          [linear_cost_factor_of_vehicle_[v]</span>
<span class="sd">           - quadratic_cost_factor_of_vehicle_[v]*(square of length of route v)]</span>
<span class="sd">        i.e. for every used vehicle, we add the linear factor as fixed cost, and</span>
<span class="sd">        subtract the square of the route length multiplied by the quadratic</span>
<span class="sd">        factor. This second term aims at making the routes as dense as possible.</span>

<span class="sd">        Sets the linear and quadratic cost factor of all vehicles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetAmortizedCostFactorsOfAllVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linear_cost_factor</span><span class="p">,</span> <span class="n">quadratic_cost_factor</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetAmortizedCostFactorsOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linear_cost_factor</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">quadratic_cost_factor</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Sets the linear and quadratic cost factor of the given vehicle.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetAmortizedCostFactorsOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linear_cost_factor</span><span class="p">,</span> <span class="n">quadratic_cost_factor</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetAmortizedLinearCostFactorOfVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int64_t &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetAmortizedLinearCostFactorOfVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetAmortizedQuadraticCostFactorOfVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int64_t &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetAmortizedQuadraticCostFactorOfVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ConsiderEmptyRouteCostsForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">consider_costs</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_ConsiderEmptyRouteCostsForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">consider_costs</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AreEmptyRouteCostsConsideredForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AreEmptyRouteCostsConsideredForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetFirstSolutionEvaluator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IndexEvaluator2&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets/sets the evaluator used during the search. Only relevant when</span>
<span class="sd">        RoutingSearchParameters.first_solution_strategy = EVALUATOR_STRATEGY.</span>
<span class="sd">        Takes ownership of evaluator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetFirstSolutionEvaluator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddLocalSearchOperator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ls_operator</span><span class="p">:</span> <span class="s2">&quot;LocalSearchOperator&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a local search operator to the set of operators used to solve the</span>
<span class="sd">        vehicle routing problem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddLocalSearchOperator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ls_operator</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddSearchMonitor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">monitor</span><span class="p">:</span> <span class="s2">&quot;SearchMonitor&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Adds a search monitor to the search used to solve the routing model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddSearchMonitor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">monitor</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddAtSolutionCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="s2">&quot;std::function&lt; void () &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a callback called each time a solution is found during the search.</span>
<span class="sd">        This is a shortcut to creating a monitor to call the callback on</span>
<span class="sd">        AtSolution() and adding it with AddSearchMonitor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddAtSolutionCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddVariableMinimizedByFinalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a variable to minimize in the solution finalizer. The solution</span>
<span class="sd">        finalizer is called each time a solution is found during the search and</span>
<span class="sd">        allows to instantiate secondary variables (such as dimension cumul</span>
<span class="sd">        variables).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddVariableMinimizedByFinalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddVariableMaximizedByFinalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a variable to maximize in the solution finalizer (see above for</span>
<span class="sd">        information on the solution finalizer).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddVariableMaximizedByFinalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddWeightedVariableMinimizedByFinalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">cost</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a variable to minimize in the solution finalizer, with a weighted</span>
<span class="sd">        priority: the higher the more priority it has.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddWeightedVariableMinimizedByFinalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">cost</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddVariableTargetToFinalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a variable to set the closest possible to the target value in the</span>
<span class="sd">        solution finalizer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddVariableTargetToFinalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">CloseModel</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Closes the current routing model; after this method is called, no</span>
<span class="sd">        modification to the model can be done, but RoutesToAssignment becomes</span>
<span class="sd">        available. Note that CloseModel() is automatically called by Solve() and</span>
<span class="sd">        other methods that produce solution.</span>
<span class="sd">        This is equivalent to calling</span>
<span class="sd">        CloseModelWithParameters(DefaultRoutingSearchParameters()).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_CloseModel</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">CloseModelWithParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">search_parameters</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingSearchParameters const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as above taking search parameters (as of 10/2015 some the parameters</span>
<span class="sd">        have to be set when closing the model).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_CloseModelWithParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">search_parameters</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment const *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solves the current routing model; closes the current model.</span>
<span class="sd">        This is equivalent to calling</span>
<span class="sd">        SolveWithParameters(DefaultRoutingSearchParameters())</span>
<span class="sd">        or</span>
<span class="sd">        SolveFromAssignmentWithParameters(assignment,</span>
<span class="sd">                                          DefaultRoutingSearchParameters()).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_Solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SolveWithParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">search_parameters</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingSearchParameters const &amp;&quot;</span><span class="p">,</span> <span class="n">solutions</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::Assignment const * &gt; *&quot;</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment const *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solves the current routing model with the given parameters. If &#39;solutions&#39;</span>
<span class="sd">        is specified, it will contain the k best solutions found during the search</span>
<span class="sd">        (from worst to best, including the one returned by this method), where k</span>
<span class="sd">        corresponds to the &#39;number_of_solutions_to_collect&#39; in</span>
<span class="sd">        &#39;search_parameters&#39;. Note that the Assignment returned by the method and</span>
<span class="sd">        the ones in solutions are owned by the underlying solver and should not be</span>
<span class="sd">        deleted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SolveWithParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">search_parameters</span><span class="p">,</span> <span class="n">solutions</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SolveFromAssignmentWithParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">search_parameters</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingSearchParameters const &amp;&quot;</span><span class="p">,</span> <span class="n">solutions</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::Assignment const * &gt; *&quot;</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment const *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as above, except that if assignment is not null, it will be used as</span>
<span class="sd">        the initial solution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SolveFromAssignmentWithParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">,</span> <span class="n">search_parameters</span><span class="p">,</span> <span class="n">solutions</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SolveFromAssignmentsWithParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignments</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::Assignment const * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">search_parameters</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingSearchParameters const &amp;&quot;</span><span class="p">,</span> <span class="n">solutions</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::Assignment const * &gt; *&quot;</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment const *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as above but will try all assignments in order as first solutions</span>
<span class="sd">        until one succeeds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SolveFromAssignmentsWithParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignments</span><span class="p">,</span> <span class="n">search_parameters</span><span class="p">,</span> <span class="n">solutions</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetAssignmentFromOtherModelAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">source_model</span><span class="p">:</span> <span class="s2">&quot;RoutingModel&quot;</span><span class="p">,</span> <span class="n">source_assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a &quot;source_model&quot; and its &quot;source_assignment&quot;, resets</span>
<span class="sd">        &quot;target_assignment&quot; with the IntVar variables (nexts_, and vehicle_vars_</span>
<span class="sd">        if costs aren&#39;t homogeneous across vehicles) of &quot;this&quot; model, with the</span>
<span class="sd">        values set according to those in &quot;other_assignment&quot;.</span>
<span class="sd">        The objective_element of target_assignment is set to this-&gt;cost_.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetAssignmentFromOtherModelAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_assignment</span><span class="p">,</span> <span class="n">source_model</span><span class="p">,</span> <span class="n">source_assignment</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ComputeLowerBound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes a lower bound to the routing problem solving a linear assignment</span>
<span class="sd">        problem. The routing model must be closed before calling this method.</span>
<span class="sd">        Note that problems with node disjunction constraints (including optional</span>
<span class="sd">        nodes) and non-homogenous costs are not supported (the method returns 0 in</span>
<span class="sd">        these cases).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_ComputeLowerBound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">status</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingModel::Status&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the current status of the routing model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_status</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ApplyLocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locks</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies a lock chain to the next search. &#39;locks&#39; represents an ordered</span>
<span class="sd">        vector of nodes representing a partial route which will be fixed during</span>
<span class="sd">        the next search; it will constrain next variables such that:</span>
<span class="sd">        next[locks[i]] == locks[i+1].</span>

<span class="sd">        Returns the next variable at the end of the locked chain; this variable is</span>
<span class="sd">        not locked. An assignment containing the locks can be obtained by calling</span>
<span class="sd">        PreAssignment().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_ApplyLocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locks</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ApplyLocksToAllVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locks</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; std::vector&lt; int64_t &gt; &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">close_routes</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies lock chains to all vehicles to the next search, such that locks[p]</span>
<span class="sd">        is the lock chain for route p. Returns false if the locks do not contain</span>
<span class="sd">        valid routes; expects that the routes do not contain the depots,</span>
<span class="sd">        i.e. there are empty vectors in place of empty routes.</span>
<span class="sd">        If close_routes is set to true, adds the end nodes to the route of each</span>
<span class="sd">        vehicle and deactivates other nodes.</span>
<span class="sd">        An assignment containing the locks can be obtained by calling</span>
<span class="sd">        PreAssignment().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_ApplyLocksToAllVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locks</span><span class="p">,</span> <span class="n">close_routes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">PreAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment const *const&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an assignment used to fix some of the variables of the problem.</span>
<span class="sd">        In practice, this assignment locks partial routes of the problem. This</span>
<span class="sd">        can be used in the context of locking the parts of the routes which have</span>
<span class="sd">        already been driven in online routing problems.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_PreAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">MutablePreAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_MutablePreAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WriteAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes the current solution to a file containing an AssignmentProto.</span>
<span class="sd">        Returns false if the file cannot be opened or if there is no current</span>
<span class="sd">        solution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_WriteAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ReadAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads an assignment from a file and returns the current solution.</span>
<span class="sd">        Returns nullptr if the file cannot be opened or if the assignment is not</span>
<span class="sd">        valid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_ReadAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RestoreAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solution</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Restores an assignment as a solution in the routing model and returns the</span>
<span class="sd">        new solution. Returns nullptr if the assignment is not valid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_RestoreAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solution</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ReadAssignmentFromRoutes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">routes</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; std::vector&lt; int64_t &gt; &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">ignore_inactive_indices</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Restores the routes as the current solution. Returns nullptr if the</span>
<span class="sd">        solution cannot be restored (routes do not contain a valid solution). Note</span>
<span class="sd">        that calling this method will run the solver to assign values to the</span>
<span class="sd">        dimension variables; this may take considerable amount of time, especially</span>
<span class="sd">        when using dimensions with slack.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_ReadAssignmentFromRoutes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">routes</span><span class="p">,</span> <span class="n">ignore_inactive_indices</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RoutesToAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">routes</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; std::vector&lt; int64_t &gt; &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">ignore_inactive_indices</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">close_routes</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fills an assignment from a specification of the routes of the</span>
<span class="sd">        vehicles. The routes are specified as lists of variable indices that</span>
<span class="sd">        appear on the routes of the vehicles. The indices of the outer vector in</span>
<span class="sd">        &#39;routes&#39; correspond to vehicles IDs, the inner vector contains the</span>
<span class="sd">        variable indices on the routes for the given vehicle. The inner vectors</span>
<span class="sd">        must not contain the start and end indices, as these are determined by the</span>
<span class="sd">        routing model.  Sets the value of NextVars in the assignment, adding the</span>
<span class="sd">        variables to the assignment if necessary. The method does not touch other</span>
<span class="sd">        variables in the assignment. The method can only be called after the model</span>
<span class="sd">        is closed.  With ignore_inactive_indices set to false, this method will</span>
<span class="sd">        fail (return nullptr) in case some of the route contain indices that are</span>
<span class="sd">        deactivated in the model; when set to true, these indices will be</span>
<span class="sd">        skipped.  Returns true if routes were successfully</span>
<span class="sd">        loaded. However, such assignment still might not be a valid</span>
<span class="sd">        solution to the routing problem due to more complex constraints;</span>
<span class="sd">        it is advisible to call solver()-&gt;CheckSolution() afterwards.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_RoutesToAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">routes</span><span class="p">,</span> <span class="n">ignore_inactive_indices</span><span class="p">,</span> <span class="n">close_routes</span><span class="p">,</span> <span class="n">assignment</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AssignmentToRoutes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">routes</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; std::vector&lt; int64_t &gt; &gt; *const&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts the solution in the given assignment to routes for all vehicles.</span>
<span class="sd">        Expects that assignment contains a valid solution (i.e. routes for all</span>
<span class="sd">        vehicles end with an end index for that vehicle).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AssignmentToRoutes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">,</span> <span class="n">routes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">CompactAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts the solution in the given assignment to routes for all vehicles.</span>
<span class="sd">        If the returned vector is route_indices, route_indices[i][j] is the index</span>
<span class="sd">        for jth location visited on route i. Note that contrary to</span>
<span class="sd">        AssignmentToRoutes, the vectors do include start and end locations.</span>
<span class="sd">        Returns a compacted version of the given assignment, in which all vehicles</span>
<span class="sd">        with id lower or equal to some N have non-empty routes, and all vehicles</span>
<span class="sd">        with id greater than N have empty routes. Does not take ownership of the</span>
<span class="sd">        returned object.</span>
<span class="sd">        If found, the cost of the compact assignment is the same as in the</span>
<span class="sd">        original assignment and it preserves the values of &#39;active&#39; variables.</span>
<span class="sd">        Returns nullptr if a compact assignment was not found.</span>
<span class="sd">        This method only works in homogenous mode, and it only swaps equivalent</span>
<span class="sd">        vehicles (vehicles with the same start and end nodes). When creating the</span>
<span class="sd">        compact assignment, the empty plan is replaced by the route assigned to</span>
<span class="sd">        the compatible vehicle with the highest id. Note that with more complex</span>
<span class="sd">        constraints on vehicle variables, this method might fail even if a compact</span>
<span class="sd">        solution exists.</span>
<span class="sd">        This method changes the vehicle and dimension variables as necessary.</span>
<span class="sd">        While compacting the solution, only basic checks on vehicle variables are</span>
<span class="sd">        performed; if one of these checks fails no attempts to repair it are made</span>
<span class="sd">        (instead, the method returns nullptr).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_CompactAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">CompactAndCheckAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as CompactAssignment() but also checks the validity of the final</span>
<span class="sd">        compact solution; if it is not valid, no attempts to repair it are made</span>
<span class="sd">        (instead, the method returns nullptr).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_CompactAndCheckAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddToAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Adds an extra variable to the vehicle routing assignment.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddToAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddIntervalToAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddIntervalToAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">PackCumulsOfOptimizerDimensionsFromAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">original_assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">duration_limit</span><span class="p">:</span> <span class="s2">&quot;absl::Duration&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment const *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For every dimension in the model with an optimizer in</span>
<span class="sd">        local/global_dimension_optimizers_, this method tries to pack the cumul</span>
<span class="sd">        values of the dimension, such that:</span>
<span class="sd">        - The cumul costs (span costs, soft lower and upper bound costs, etc) are</span>
<span class="sd">          minimized.</span>
<span class="sd">        - The cumuls of the ends of the routes are minimized for this given</span>
<span class="sd">          minimal cumul cost.</span>
<span class="sd">        - Given these minimal end cumuls, the route start cumuls are maximized.</span>
<span class="sd">        Returns the assignment resulting from allocating these packed cumuls with</span>
<span class="sd">        the solver, and nullptr if these cumuls could not be set by the solver.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_PackCumulsOfOptimizerDimensionsFromAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">original_assignment</span><span class="p">,</span> <span class="n">duration_limit</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddLocalSearchFilter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">filter</span><span class="p">:</span> <span class="s2">&quot;LocalSearchFilter&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a custom local search filter to the list of filters used to speed up</span>
<span class="sd">        local search by pruning unfeasible variable assignments.</span>
<span class="sd">        Calling this method after the routing model has been closed (CloseModel()</span>
<span class="sd">        or Solve() has been called) has no effect.</span>
<span class="sd">        The routing model does not take ownership of the filter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddLocalSearchFilter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">filter</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Model inspection.</span>
<span class="sd">        Returns the variable index of the starting node of a vehicle route.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_Start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">End</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the variable index of the ending node of a vehicle route.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_End</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsStart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns true if &#39;index&#39; represents the first node of a route.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_IsStart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsEnd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns true if &#39;index&#39; represents the last node of a route.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_IsEnd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">VehicleIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the vehicle of the given start/end index, and -1 if the given</span>
<span class="sd">        index is not a vehicle start/end.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_VehicleIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Next</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assignment inspection</span>
<span class="sd">        Returns the variable index of the node directly after the node</span>
<span class="sd">        corresponding to &#39;index&#39; in &#39;assignment&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_Next</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsVehicleUsed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns true if the route of &#39;vehicle&#39; is non empty in &#39;assignment&#39;.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_IsVehicleUsed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NextVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the next variable of the node corresponding to index. Note that</span>
<span class="sd">        NextVar(index) == index is equivalent to ActiveVar(index) == 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_NextVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ActiveVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the active variable of the node corresponding to index.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_ActiveVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ActiveVehicleVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the active variable of the vehicle. It will be equal to 1 iff the</span>
<span class="sd">        route of the vehicle is not empty, 0 otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_ActiveVehicleVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">VehicleCostsConsideredVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the variable specifying whether or not costs are considered for</span>
<span class="sd">        vehicle.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_VehicleCostsConsideredVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">VehicleVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the vehicle variable of the node corresponding to index. Note that</span>
<span class="sd">        VehicleVar(index) == -1 is equivalent to ActiveVar(index) == 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_VehicleVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">CostVar</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the global cost variable which is being minimized.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_CostVar</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetArcCostForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">to_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the cost of the transit arc between two nodes for a given vehicle.</span>
<span class="sd">        Input are variable indices of node. This returns 0 if vehicle &lt; 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetArcCostForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_index</span><span class="p">,</span> <span class="n">to_index</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">CostsAreHomogeneousAcrossVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Whether costs are homogeneous across all vehicles.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_CostsAreHomogeneousAcrossVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetHomogeneousCost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">to_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the cost of the segment between two nodes supposing all vehicle</span>
<span class="sd">        costs are the same (returns the cost for the first vehicle otherwise).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetHomogeneousCost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_index</span><span class="p">,</span> <span class="n">to_index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetArcCostForFirstSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">to_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the cost of the arc in the context of the first solution strategy.</span>
<span class="sd">        This is typically a simplification of the actual cost; see the .cc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetArcCostForFirstSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_index</span><span class="p">,</span> <span class="n">to_index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetArcCostForClass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">to_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">cost_class_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the cost of the segment between two nodes for a given cost</span>
<span class="sd">        class. Input are variable indices of nodes and the cost class.</span>
<span class="sd">        Unlike GetArcCostForVehicle(), if cost_class is kNoCost, then the</span>
<span class="sd">        returned cost won&#39;t necessarily be zero: only some of the components</span>
<span class="sd">        of the cost that depend on the cost class will be omited. See the code</span>
<span class="sd">        for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetArcCostForClass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_index</span><span class="p">,</span> <span class="n">to_index</span><span class="p">,</span> <span class="n">cost_class_index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetCostClassIndexOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingModel::CostClassIndex&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Get the cost class index of the given vehicle.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetCostClassIndexOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">HasVehicleWithCostClassIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cost_class_index</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingModel::CostClassIndex&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns true iff the model contains a vehicle with the given</span>
<span class="sd">        cost_class_index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_HasVehicleWithCostClassIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cost_class_index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetCostClassesCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the number of different cost classes in the model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetCostClassesCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetNonZeroCostClassesCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Ditto, minus the &#39;always zero&#39;, built-in cost class.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetNonZeroCostClassesCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetVehicleClassIndexOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingModel::VehicleClassIndex&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetVehicleClassIndexOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetVehicleOfClass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle_class</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingModel::VehicleClassIndex&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a vehicle of the given vehicle class, and -1 if there are no</span>
<span class="sd">        vehicles for this class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetVehicleOfClass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle_class</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetVehicleClassesCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the number of different vehicle classes in the model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetVehicleClassesCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetSameVehicleIndicesOfIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns variable indices of nodes constrained to be on the same route.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetSameVehicleIndicesOfIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetVehicleTypeContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingModel::VehicleTypeContainer const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetVehicleTypeContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ArcIsMoreConstrainedThanArc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_from</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">to1</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">to2</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns whether the arc from-&gt;to1 is more constrained than from-&gt;to2,</span>
<span class="sd">        taking into account, in order:</span>
<span class="sd">        - whether the destination node isn&#39;t an end node</span>
<span class="sd">        - whether the destination node is mandatory</span>
<span class="sd">        - whether the destination node is bound to the same vehicle as the source</span>
<span class="sd">        - the &quot;primary constrained&quot; dimension (see SetPrimaryConstrainedDimension)</span>
<span class="sd">        It then breaks ties using, in order:</span>
<span class="sd">        - the arc cost (taking unperformed penalties into account)</span>
<span class="sd">        - the size of the vehicle vars of &quot;to1&quot; and &quot;to2&quot; (lowest size wins)</span>
<span class="sd">        - the value: the lowest value of the indices to1 and to2 wins.</span>
<span class="sd">        See the .cc for details.</span>
<span class="sd">        The more constrained arc is typically preferable when building a</span>
<span class="sd">        first solution. This method is intended to be used as a callback for the</span>
<span class="sd">        BestValueByComparisonSelector value selector.</span>
<span class="sd">        Args:</span>
<span class="sd">          from: the variable index of the source node</span>
<span class="sd">          to1: the variable index of the first candidate destination node.</span>
<span class="sd">          to2: the variable index of the second candidate destination node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_ArcIsMoreConstrainedThanArc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_from</span><span class="p">,</span> <span class="n">to1</span><span class="p">,</span> <span class="n">to2</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DebugOutputAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solution_assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">dimension_to_print</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print some debugging information about an assignment, including the</span>
<span class="sd">        feasible intervals of the CumulVar for dimension &quot;dimension_to_print&quot;</span>
<span class="sd">        at each step of the routes.</span>
<span class="sd">        If &quot;dimension_to_print&quot; is omitted, all dimensions will be printed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_DebugOutputAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solution_assignment</span><span class="p">,</span> <span class="n">dimension_to_print</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Solver *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a vector cumul_bounds, for which cumul_bounds[i][j] is a pair</span>
<span class="sd">        containing the minimum and maximum of the CumulVar of the jth node on</span>
<span class="sd">        route i.</span>
<span class="sd">        - cumul_bounds[i][j].first is the minimum.</span>
<span class="sd">        - cumul_bounds[i][j].second is the maximum.</span>
<span class="sd">        Returns the underlying constraint solver. Can be used to add extra</span>
<span class="sd">        constraints and/or modify search algorithms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_solver</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">CheckLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns true if the search limit has been crossed.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_CheckLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">RemainingTime</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;absl::Duration&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the time left in the search limit.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_RemainingTime</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sizes and indices</span>
<span class="sd">        Returns the number of nodes in the model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">vehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the number of vehicle routes in the model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_vehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the number of next variables in the model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetNumberOfDecisionsInFirstSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">search_parameters</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingSearchParameters const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns statistics on first solution search, number of decisions sent to</span>
<span class="sd">        filters, number of decisions rejected by filters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetNumberOfDecisionsInFirstSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">search_parameters</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetNumberOfRejectsInFirstSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">search_parameters</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingSearchParameters const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetNumberOfRejectsInFirstSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">search_parameters</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetAutomaticFirstSolutionStrategy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::FirstSolutionStrategy::Value&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the automatic first solution strategy selected.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetAutomaticFirstSolutionStrategy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IsMatchingModel</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns true if a vehicle/node matching problem is detected.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_IsMatchingModel</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">MakeGuidedSlackFinalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="s2">&quot;RoutingDimension&quot;</span><span class="p">,</span> <span class="n">initializer</span><span class="p">:</span> <span class="s2">&quot;std::function&lt; int64_t (int64_t) &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The next few members are in the public section only for testing purposes.</span>

<span class="sd">        MakeGuidedSlackFinalizer creates a DecisionBuilder for the slacks of a</span>
<span class="sd">        dimension using a callback to choose which values to start with.</span>
<span class="sd">        The finalizer works only when all next variables in the model have</span>
<span class="sd">        been fixed. It has the following two characteristics:</span>
<span class="sd">        1. It follows the routes defined by the nexts variables when choosing a</span>
<span class="sd">           variable to make a decision on.</span>
<span class="sd">        2. When it comes to choose a value for the slack of node i, the decision</span>
<span class="sd">           builder first calls the callback with argument i, and supposingly the</span>
<span class="sd">           returned value is x it creates decisions slack[i] = x, slack[i] = x +</span>
<span class="sd">           1, slack[i] = x - 1, slack[i] = x + 2, etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_MakeGuidedSlackFinalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">initializer</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">MakeSelfDependentDimensionFinalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="s2">&quot;RoutingDimension&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        MakeSelfDependentDimensionFinalizer is a finalizer for the slacks of a</span>
<span class="sd">        self-dependent dimension. It makes an extensive use of the caches of the</span>
<span class="sd">        state dependent transits.</span>
<span class="sd">        In detail, MakeSelfDependentDimensionFinalizer returns a composition of a</span>
<span class="sd">        local search decision builder with a greedy descent operator for the cumul</span>
<span class="sd">        of the start of each route and a guided slack finalizer. Provided there</span>
<span class="sd">        are no time windows and the maximum slacks are large enough, once the</span>
<span class="sd">        cumul of the start of route is fixed, the guided finalizer can find</span>
<span class="sd">        optimal values of the slacks for the rest of the route in time</span>
<span class="sd">        proportional to the length of the route. Therefore the composed finalizer</span>
<span class="sd">        generally works in time O(log(t)*n*m), where t is the latest possible</span>
<span class="sd">        departute time, n is the number of nodes in the network and m is the</span>
<span class="sd">        number of vehicles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_MakeSelfDependentDimensionFinalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">)</span>
</pre></div>

        </details>

    

                            <div id="RoutingModel.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">RoutingModel</span><span class="signature">(*args)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_RoutingModel</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingModel.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#RoutingModel.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="RoutingModel.ROUTING_NOT_SOLVED" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#RoutingModel.ROUTING_NOT_SOLVED">#&nbsp;&nbsp</a>

        <span class="name">ROUTING_NOT_SOLVED</span><span class="default_value"> = 0</span>
    </div>

            <div class="docstring"><p>Problem not solved yet (before calling RoutingModel::Solve()).</p>
</div>


                            </div>
                            <div id="RoutingModel.ROUTING_SUCCESS" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#RoutingModel.ROUTING_SUCCESS">#&nbsp;&nbsp</a>

        <span class="name">ROUTING_SUCCESS</span><span class="default_value"> = 1</span>
    </div>

            <div class="docstring"><p>Problem solved successfully after calling RoutingModel::Solve().</p>
</div>


                            </div>
                            <div id="RoutingModel.ROUTING_FAIL" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#RoutingModel.ROUTING_FAIL">#&nbsp;&nbsp</a>

        <span class="name">ROUTING_FAIL</span><span class="default_value"> = 2</span>
    </div>

            <div class="docstring"><p>No solution found to the problem after calling RoutingModel::Solve().</p>
</div>


                            </div>
                            <div id="RoutingModel.ROUTING_FAIL_TIMEOUT" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#RoutingModel.ROUTING_FAIL_TIMEOUT">#&nbsp;&nbsp</a>

        <span class="name">ROUTING_FAIL_TIMEOUT</span><span class="default_value"> = 3</span>
    </div>

            <div class="docstring"><p>Time limit reached before finding a solution with RoutingModel::Solve().</p>
</div>


                            </div>
                            <div id="RoutingModel.ROUTING_INVALID" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#RoutingModel.ROUTING_INVALID">#&nbsp;&nbsp</a>

        <span class="name">ROUTING_INVALID</span><span class="default_value"> = 4</span>
    </div>

            <div class="docstring"><p>Model, model parameters or flags are not valid.</p>
</div>


                            </div>
                            <div id="RoutingModel.PICKUP_AND_DELIVERY_NO_ORDER" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#RoutingModel.PICKUP_AND_DELIVERY_NO_ORDER">#&nbsp;&nbsp</a>

        <span class="name">PICKUP_AND_DELIVERY_NO_ORDER</span><span class="default_value"> = 0</span>
    </div>

            <div class="docstring"><p>Any precedence is accepted.</p>
</div>


                            </div>
                            <div id="RoutingModel.PICKUP_AND_DELIVERY_LIFO" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#RoutingModel.PICKUP_AND_DELIVERY_LIFO">#&nbsp;&nbsp</a>

        <span class="name">PICKUP_AND_DELIVERY_LIFO</span><span class="default_value"> = 1</span>
    </div>

            <div class="docstring"><p>Deliveries must be performed in reverse order of pickups.</p>
</div>


                            </div>
                            <div id="RoutingModel.PICKUP_AND_DELIVERY_FIFO" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#RoutingModel.PICKUP_AND_DELIVERY_FIFO">#&nbsp;&nbsp</a>

        <span class="name">PICKUP_AND_DELIVERY_FIFO</span><span class="default_value"> = 2</span>
    </div>

            <div class="docstring"><p>Deliveries must be performed in the same order as pickups.</p>
</div>


                            </div>
                            <div id="RoutingModel.RegisterUnaryTransitVector" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.RegisterUnaryTransitVector">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">RegisterUnaryTransitVector</span><span class="signature">(self, values: &#39;std::vector&lt; int64_t &gt;&#39;) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">RegisterUnaryTransitVector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Registers &#39;callback&#39; and returns its index.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_RegisterUnaryTransitVector</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Registers 'callback' and returns its index.</p>
</div>


                            </div>
                            <div id="RoutingModel.RegisterUnaryTransitCallback" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.RegisterUnaryTransitCallback">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">RegisterUnaryTransitCallback</span><span class="signature">(
    self,
    callback: &#39;operations_research::RoutingModel::TransitCallback1&#39;
) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">RegisterUnaryTransitCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingModel::TransitCallback1&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_RegisterUnaryTransitCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingModel.RegisterPositiveUnaryTransitCallback" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.RegisterPositiveUnaryTransitCallback">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">RegisterPositiveUnaryTransitCallback</span><span class="signature">(
    self,
    callback: &#39;operations_research::RoutingModel::TransitCallback1&#39;
) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">RegisterPositiveUnaryTransitCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingModel::TransitCallback1&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_RegisterPositiveUnaryTransitCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingModel.RegisterTransitMatrix" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.RegisterTransitMatrix">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">RegisterTransitMatrix</span><span class="signature">(self, values: &#39;std::vector&lt; std::vector&lt; int64_t &gt; &gt;&#39;) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">RegisterTransitMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; std::vector&lt; int64_t &gt; &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_RegisterTransitMatrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingModel.RegisterTransitCallback" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.RegisterTransitCallback">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">RegisterTransitCallback</span><span class="signature">(
    self,
    callback: &#39;operations_research::RoutingModel::TransitCallback2&#39;
) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">RegisterTransitCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingModel::TransitCallback2&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_RegisterTransitCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingModel.RegisterPositiveTransitCallback" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.RegisterPositiveTransitCallback">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">RegisterPositiveTransitCallback</span><span class="signature">(
    self,
    callback: &#39;operations_research::RoutingModel::TransitCallback2&#39;
) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">RegisterPositiveTransitCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingModel::TransitCallback2&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_RegisterPositiveTransitCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingModel.TransitCallback" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.TransitCallback">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">TransitCallback</span><span class="signature">(
    self,
    callback_index: int
) -&gt; &#39;operations_research::RoutingModel::TransitCallback2 const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">TransitCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback_index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingModel::TransitCallback2 const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_TransitCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback_index</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingModel.UnaryTransitCallbackOrNull" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.UnaryTransitCallbackOrNull">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">UnaryTransitCallbackOrNull</span><span class="signature">(
    self,
    callback_index: int
) -&gt; &#39;operations_research::RoutingModel::TransitCallback1 const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">UnaryTransitCallbackOrNull</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback_index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingModel::TransitCallback1 const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_UnaryTransitCallbackOrNull</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback_index</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingModel.AddDimension" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.AddDimension">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddDimension</span><span class="signature">(
    self,
    evaluator_index: int,
    slack_max: &#39;int64_t&#39;,
    capacity: &#39;int64_t&#39;,
    fix_start_cumul_to_zero: bool,
    name: &#39;std::string const &amp;&#39;
) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator_index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">slack_max</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Model creation</span>
<span class="sd">        Methods to add dimensions to routes; dimensions represent quantities</span>
<span class="sd">        accumulated at nodes along the routes. They represent quantities such as</span>
<span class="sd">        weights or volumes carried along the route, or distance or times.</span>
<span class="sd">        Quantities at a node are represented by &quot;cumul&quot; variables and the increase</span>
<span class="sd">        or decrease of quantities between nodes are represented by &quot;transit&quot;</span>
<span class="sd">        variables. These variables are linked as follows:</span>
<span class="sd">        if j == next(i), cumul(j) = cumul(i) + transit(i) + slack(i)</span>
<span class="sd">        where slack is a positive slack variable (can represent waiting times for</span>
<span class="sd">        a time dimension).</span>
<span class="sd">        Setting the value of fix_start_cumul_to_zero to true will force the</span>
<span class="sd">        &quot;cumul&quot; variable of the start node of all vehicles to be equal to 0.</span>
<span class="sd">        Creates a dimension where the transit variable is constrained to be</span>
<span class="sd">        equal to evaluator(i, next(i)); &#39;slack_max&#39; is the upper bound of the</span>
<span class="sd">        slack variable and &#39;capacity&#39; is the upper bound of the cumul variables.</span>
<span class="sd">        &#39;name&#39; is the name used to reference the dimension; this name is used to</span>
<span class="sd">        get cumul and transit variables from the routing model.</span>
<span class="sd">        Returns false if a dimension with the same name has already been created</span>
<span class="sd">        (and doesn&#39;t create the new dimension).</span>
<span class="sd">        Takes ownership of the callback &#39;evaluator&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator_index</span><span class="p">,</span> <span class="n">slack_max</span><span class="p">,</span> <span class="n">capacity</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Model creation
Methods to add dimensions to routes; dimensions represent quantities
accumulated at nodes along the routes. They represent quantities such as
weights or volumes carried along the route, or distance or times.
Quantities at a node are represented by "cumul" variables and the increase
or decrease of quantities between nodes are represented by "transit"
variables. These variables are linked as follows:
if j == next(i), cumul(j) = cumul(i) + transit(i) + slack(i)
where slack is a positive slack variable (can represent waiting times for
a time dimension).
Setting the value of fix_start_cumul_to_zero to true will force the
"cumul" variable of the start node of all vehicles to be equal to 0.
Creates a dimension where the transit variable is constrained to be
equal to evaluator(i, next(i)); 'slack_max' is the upper bound of the
slack variable and 'capacity' is the upper bound of the cumul variables.
'name' is the name used to reference the dimension; this name is used to
get cumul and transit variables from the routing model.
Returns false if a dimension with the same name has already been created
(and doesn't create the new dimension).
Takes ownership of the callback 'evaluator'.</p>
</div>


                            </div>
                            <div id="RoutingModel.AddDimensionWithVehicleTransits" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.AddDimensionWithVehicleTransits">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddDimensionWithVehicleTransits</span><span class="signature">(
    self,
    evaluator_indices: &#39;std::vector&lt; int &gt; const &amp;&#39;,
    slack_max: &#39;int64_t&#39;,
    capacity: &#39;int64_t&#39;,
    fix_start_cumul_to_zero: bool,
    name: &#39;std::string const &amp;&#39;
) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddDimensionWithVehicleTransits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator_indices</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">slack_max</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddDimensionWithVehicleTransits</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator_indices</span><span class="p">,</span> <span class="n">slack_max</span><span class="p">,</span> <span class="n">capacity</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingModel.AddDimensionWithVehicleCapacity" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.AddDimensionWithVehicleCapacity">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddDimensionWithVehicleCapacity</span><span class="signature">(
    self,
    evaluator_index: int,
    slack_max: &#39;int64_t&#39;,
    vehicle_capacities: &#39;std::vector&lt; int64_t &gt;&#39;,
    fix_start_cumul_to_zero: bool,
    name: &#39;std::string const &amp;&#39;
) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddDimensionWithVehicleCapacity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator_index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">slack_max</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">vehicle_capacities</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt;&quot;</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddDimensionWithVehicleCapacity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator_index</span><span class="p">,</span> <span class="n">slack_max</span><span class="p">,</span> <span class="n">vehicle_capacities</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingModel.AddDimensionWithVehicleTransitAndCapacity" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.AddDimensionWithVehicleTransitAndCapacity">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddDimensionWithVehicleTransitAndCapacity</span><span class="signature">(
    self,
    evaluator_indices: &#39;std::vector&lt; int &gt; const &amp;&#39;,
    slack_max: &#39;int64_t&#39;,
    vehicle_capacities: &#39;std::vector&lt; int64_t &gt;&#39;,
    fix_start_cumul_to_zero: bool,
    name: &#39;std::string const &amp;&#39;
) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddDimensionWithVehicleTransitAndCapacity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator_indices</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">slack_max</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">vehicle_capacities</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt;&quot;</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddDimensionWithVehicleTransitAndCapacity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator_indices</span><span class="p">,</span> <span class="n">slack_max</span><span class="p">,</span> <span class="n">vehicle_capacities</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingModel.AddConstantDimensionWithSlack" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.AddConstantDimensionWithSlack">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddConstantDimensionWithSlack</span><span class="signature">(
    self,
    value: &#39;int64_t&#39;,
    capacity: &#39;int64_t&#39;,
    slack_max: &#39;int64_t&#39;,
    fix_start_cumul_to_zero: bool,
    name: &#39;std::string const &amp;&#39;
) -&gt; &#39;std::pair&lt; int,bool &gt;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddConstantDimensionWithSlack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">slack_max</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::pair&lt; int,bool &gt;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a dimension where the transit variable is constrained to be</span>
<span class="sd">        equal to &#39;value&#39;; &#39;capacity&#39; is the upper bound of the cumul variables.</span>
<span class="sd">        &#39;name&#39; is the name used to reference the dimension; this name is used to</span>
<span class="sd">        get cumul and transit variables from the routing model.</span>
<span class="sd">        Returns a pair consisting of an index to the registered unary transit</span>
<span class="sd">        callback and a bool denoting whether the dimension has been created.</span>
<span class="sd">        It is false if a dimension with the same name has already been created</span>
<span class="sd">        (and doesn&#39;t create the new dimension but still register a new callback).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddConstantDimensionWithSlack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">capacity</span><span class="p">,</span> <span class="n">slack_max</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates a dimension where the transit variable is constrained to be
equal to 'value'; 'capacity' is the upper bound of the cumul variables.
'name' is the name used to reference the dimension; this name is used to
get cumul and transit variables from the routing model.
Returns a pair consisting of an index to the registered unary transit
callback and a bool denoting whether the dimension has been created.
It is false if a dimension with the same name has already been created
(and doesn't create the new dimension but still register a new callback).</p>
</div>


                            </div>
                            <div id="RoutingModel.AddConstantDimension" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.AddConstantDimension">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddConstantDimension</span><span class="signature">(
    self,
    value: &#39;int64_t&#39;,
    capacity: &#39;int64_t&#39;,
    fix_start_cumul_to_zero: bool,
    name: &#39;std::string const &amp;&#39;
) -&gt; &#39;std::pair&lt; int,bool &gt;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddConstantDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::pair&lt; int,bool &gt;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddConstantDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">,</span> <span class="n">capacity</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingModel.AddVectorDimension" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.AddVectorDimension">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddVectorDimension</span><span class="signature">(
    self,
    values: &#39;std::vector&lt; int64_t &gt;&#39;,
    capacity: &#39;int64_t&#39;,
    fix_start_cumul_to_zero: bool,
    name: &#39;std::string const &amp;&#39;
) -&gt; &#39;std::pair&lt; int,bool &gt;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddVectorDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt;&quot;</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::pair&lt; int,bool &gt;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a dimension where the transit variable is constrained to be</span>
<span class="sd">        equal to &#39;values[i]&#39; for node i; &#39;capacity&#39; is the upper bound of</span>
<span class="sd">        the cumul variables. &#39;name&#39; is the name used to reference the dimension;</span>
<span class="sd">        this name is used to get cumul and transit variables from the routing</span>
<span class="sd">        model.</span>
<span class="sd">        Returns a pair consisting of an index to the registered unary transit</span>
<span class="sd">        callback and a bool denoting whether the dimension has been created.</span>
<span class="sd">        It is false if a dimension with the same name has already been created</span>
<span class="sd">        (and doesn&#39;t create the new dimension but still register a new callback).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddVectorDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">capacity</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates a dimension where the transit variable is constrained to be
equal to 'values[i]' for node i; 'capacity' is the upper bound of
the cumul variables. 'name' is the name used to reference the dimension;
this name is used to get cumul and transit variables from the routing
model.
Returns a pair consisting of an index to the registered unary transit
callback and a bool denoting whether the dimension has been created.
It is false if a dimension with the same name has already been created
(and doesn't create the new dimension but still register a new callback).</p>
</div>


                            </div>
                            <div id="RoutingModel.AddMatrixDimension" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.AddMatrixDimension">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddMatrixDimension</span><span class="signature">(
    self,
    values: &#39;std::vector&lt; std::vector&lt; int64_t &gt; &gt;&#39;,
    capacity: &#39;int64_t&#39;,
    fix_start_cumul_to_zero: bool,
    name: &#39;std::string const &amp;&#39;
) -&gt; &#39;std::pair&lt; int,bool &gt;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddMatrixDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; std::vector&lt; int64_t &gt; &gt;&quot;</span><span class="p">,</span> <span class="n">capacity</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::pair&lt; int,bool &gt;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a dimension where the transit variable is constrained to be</span>
<span class="sd">        equal to &#39;values[i][next(i)]&#39; for node i; &#39;capacity&#39; is the upper bound of</span>
<span class="sd">        the cumul variables. &#39;name&#39; is the name used to reference the dimension;</span>
<span class="sd">        this name is used to get cumul and transit variables from the routing</span>
<span class="sd">        model.</span>
<span class="sd">        Returns a pair consisting of an index to the registered transit callback</span>
<span class="sd">        and a bool denoting whether the dimension has been created.</span>
<span class="sd">        It is false if a dimension with the same name has already been created</span>
<span class="sd">        (and doesn&#39;t create the new dimension but still register a new callback).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddMatrixDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">values</span><span class="p">,</span> <span class="n">capacity</span><span class="p">,</span> <span class="n">fix_start_cumul_to_zero</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates a dimension where the transit variable is constrained to be
equal to 'values[i][next(i)]' for node i; 'capacity' is the upper bound of
the cumul variables. 'name' is the name used to reference the dimension;
this name is used to get cumul and transit variables from the routing
model.
Returns a pair consisting of an index to the registered transit callback
and a bool denoting whether the dimension has been created.
It is false if a dimension with the same name has already been created
(and doesn't create the new dimension but still register a new callback).</p>
</div>


                            </div>
                            <div id="RoutingModel.MakePathSpansAndTotalSlacks" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.MakePathSpansAndTotalSlacks">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">MakePathSpansAndTotalSlacks</span><span class="signature">(
    self,
    dimension: <a href="#RoutingDimension">pywrapcp.RoutingDimension</a>,
    spans: &#39;std::vector&lt; operations_research::IntVar * &gt;&#39;,
    total_slacks: &#39;std::vector&lt; operations_research::IntVar * &gt;&#39;
) -&gt; &#39;operations_research::Constraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">MakePathSpansAndTotalSlacks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="s2">&quot;RoutingDimension&quot;</span><span class="p">,</span> <span class="n">spans</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt;&quot;</span><span class="p">,</span> <span class="n">total_slacks</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Constraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For every vehicle of the routing model:</span>
<span class="sd">        - if total_slacks[vehicle] is not nullptr, constrains it to be the sum of</span>
<span class="sd">          slacks on that vehicle, that is,</span>
<span class="sd">          dimension-&gt;CumulVar(end) - dimension-&gt;CumulVar(start) -</span>
<span class="sd">          sum_{node in path of vehicle} dimension-&gt;FixedTransitVar(node).</span>
<span class="sd">        - if spans[vehicle] is not nullptr, constrains it to be</span>
<span class="sd">          dimension-&gt;CumulVar(end) - dimension-&gt;CumulVar(start)</span>
<span class="sd">        This does stronger propagation than a decomposition, and takes breaks into</span>
<span class="sd">        account.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_MakePathSpansAndTotalSlacks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">spans</span><span class="p">,</span> <span class="n">total_slacks</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>For every vehicle of the routing model:</p>

<ul>
<li>if total_slacks[vehicle] is not nullptr, constrains it to be the sum of
slacks on that vehicle, that is,
dimension->CumulVar(end) - dimension->CumulVar(start) -
sum_{node in path of vehicle} dimension->FixedTransitVar(node).</li>
<li>if spans[vehicle] is not nullptr, constrains it to be
dimension->CumulVar(end) - dimension->CumulVar(start)
This does stronger propagation than a decomposition, and takes breaks into
account.</li>
</ul>
</div>


                            </div>
                            <div id="RoutingModel.GetAllDimensionNames" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetAllDimensionNames">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetAllDimensionNames</span><span class="signature">(self) -&gt; &#39;std::vector&lt; std::string &gt;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetAllDimensionNames</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; std::string &gt;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Outputs the names of all dimensions added to the routing engine.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetAllDimensionNames</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Outputs the names of all dimensions added to the routing engine.</p>
</div>


                            </div>
                            <div id="RoutingModel.GetDimensions" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetDimensions">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetDimensions</span><span class="signature">(
    self
) -&gt; &#39;std::vector&lt; operations_research::RoutingDimension * &gt; const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetDimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; operations_research::RoutingDimension * &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns all dimensions of the model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetDimensions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns all dimensions of the model.</p>
</div>


                            </div>
                            <div id="RoutingModel.GetDimensionsWithSoftOrSpanCosts" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetDimensionsWithSoftOrSpanCosts">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetDimensionsWithSoftOrSpanCosts</span><span class="signature">(self) -&gt; &#39;std::vector&lt; operations_research::RoutingDimension * &gt;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetDimensionsWithSoftOrSpanCosts</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; operations_research::RoutingDimension * &gt;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns dimensions with soft or vehicle span costs.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetDimensionsWithSoftOrSpanCosts</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns dimensions with soft or vehicle span costs.</p>
</div>


                            </div>
                            <div id="RoutingModel.GetGlobalDimensionCumulOptimizers" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetGlobalDimensionCumulOptimizers">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetGlobalDimensionCumulOptimizers</span><span class="signature">(
    self
) -&gt; &#39;std::vector&lt; std::unique_ptr&lt; operations_research::GlobalDimensionCumulOptimizer &gt; &gt; const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetGlobalDimensionCumulOptimizers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; std::unique_ptr&lt; operations_research::GlobalDimensionCumulOptimizer &gt; &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns [global|local]_dimension_optimizers_, which are empty if the model</span>
<span class="sd">        has not been closed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetGlobalDimensionCumulOptimizers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns [global|local]_dimension_optimizers_, which are empty if the model
has not been closed.</p>
</div>


                            </div>
                            <div id="RoutingModel.GetGlobalDimensionCumulMPOptimizers" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetGlobalDimensionCumulMPOptimizers">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetGlobalDimensionCumulMPOptimizers</span><span class="signature">(
    self
) -&gt; &#39;std::vector&lt; std::unique_ptr&lt; operations_research::GlobalDimensionCumulOptimizer &gt; &gt; const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetGlobalDimensionCumulMPOptimizers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; std::unique_ptr&lt; operations_research::GlobalDimensionCumulOptimizer &gt; &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetGlobalDimensionCumulMPOptimizers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingModel.GetLocalDimensionCumulOptimizers" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetLocalDimensionCumulOptimizers">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetLocalDimensionCumulOptimizers</span><span class="signature">(
    self
) -&gt; &#39;std::vector&lt; std::unique_ptr&lt; operations_research::LocalDimensionCumulOptimizer &gt; &gt; const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetLocalDimensionCumulOptimizers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; std::unique_ptr&lt; operations_research::LocalDimensionCumulOptimizer &gt; &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetLocalDimensionCumulOptimizers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingModel.GetLocalDimensionCumulMPOptimizers" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetLocalDimensionCumulMPOptimizers">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetLocalDimensionCumulMPOptimizers</span><span class="signature">(
    self
) -&gt; &#39;std::vector&lt; std::unique_ptr&lt; operations_research::LocalDimensionCumulOptimizer &gt; &gt; const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetLocalDimensionCumulMPOptimizers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; std::unique_ptr&lt; operations_research::LocalDimensionCumulOptimizer &gt; &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetLocalDimensionCumulMPOptimizers</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingModel.GetMutableGlobalCumulOptimizer" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetMutableGlobalCumulOptimizer">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetMutableGlobalCumulOptimizer</span><span class="signature">(
    self,
    dimension: <a href="#RoutingDimension">pywrapcp.RoutingDimension</a>
) -&gt; &#39;operations_research::GlobalDimensionCumulOptimizer *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetMutableGlobalCumulOptimizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="s2">&quot;RoutingDimension&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::GlobalDimensionCumulOptimizer *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the global/local dimension cumul optimizer for a given dimension,</span>
<span class="sd">        or nullptr if there is none.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetMutableGlobalCumulOptimizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the global/local dimension cumul optimizer for a given dimension,
or nullptr if there is none.</p>
</div>


                            </div>
                            <div id="RoutingModel.GetMutableGlobalCumulMPOptimizer" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetMutableGlobalCumulMPOptimizer">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetMutableGlobalCumulMPOptimizer</span><span class="signature">(
    self,
    dimension: <a href="#RoutingDimension">pywrapcp.RoutingDimension</a>
) -&gt; &#39;operations_research::GlobalDimensionCumulOptimizer *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetMutableGlobalCumulMPOptimizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="s2">&quot;RoutingDimension&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::GlobalDimensionCumulOptimizer *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetMutableGlobalCumulMPOptimizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingModel.GetMutableLocalCumulOptimizer" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetMutableLocalCumulOptimizer">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetMutableLocalCumulOptimizer</span><span class="signature">(
    self,
    dimension: <a href="#RoutingDimension">pywrapcp.RoutingDimension</a>
) -&gt; &#39;operations_research::LocalDimensionCumulOptimizer *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetMutableLocalCumulOptimizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="s2">&quot;RoutingDimension&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::LocalDimensionCumulOptimizer *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetMutableLocalCumulOptimizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingModel.GetMutableLocalCumulMPOptimizer" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetMutableLocalCumulMPOptimizer">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetMutableLocalCumulMPOptimizer</span><span class="signature">(
    self,
    dimension: <a href="#RoutingDimension">pywrapcp.RoutingDimension</a>
) -&gt; &#39;operations_research::LocalDimensionCumulOptimizer *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetMutableLocalCumulMPOptimizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="s2">&quot;RoutingDimension&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::LocalDimensionCumulOptimizer *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetMutableLocalCumulMPOptimizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingModel.HasDimension" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.HasDimension">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">HasDimension</span><span class="signature">(self, dimension_name: &#39;std::string const &amp;&#39;) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">HasDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension_name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns true if a dimension exists for a given dimension name.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_HasDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension_name</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns true if a dimension exists for a given dimension name.</p>
</div>


                            </div>
                            <div id="RoutingModel.GetDimensionOrDie" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetDimensionOrDie">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetDimensionOrDie</span><span class="signature">(
    self,
    dimension_name: &#39;std::string const &amp;&#39;
) -&gt; &#39;operations_research::RoutingDimension const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetDimensionOrDie</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension_name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingDimension const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns a dimension from its name. Dies if the dimension does not exist.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetDimensionOrDie</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension_name</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns a dimension from its name. Dies if the dimension does not exist.</p>
</div>


                            </div>
                            <div id="RoutingModel.GetMutableDimension" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetMutableDimension">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetMutableDimension</span><span class="signature">(
    self,
    dimension_name: &#39;std::string const &amp;&#39;
) -&gt; &#39;operations_research::RoutingDimension *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetMutableDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension_name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingDimension *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a dimension from its name. Returns nullptr if the dimension does</span>
<span class="sd">        not exist.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetMutableDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension_name</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns a dimension from its name. Returns nullptr if the dimension does
not exist.</p>
</div>


                            </div>
                            <div id="RoutingModel.SetPrimaryConstrainedDimension" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.SetPrimaryConstrainedDimension">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetPrimaryConstrainedDimension</span><span class="signature">(self, dimension_name: &#39;std::string const &amp;&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetPrimaryConstrainedDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension_name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set the given dimension as &quot;primary constrained&quot;. As of August 2013, this</span>
<span class="sd">        is only used by ArcIsMoreConstrainedThanArc().</span>
<span class="sd">        &quot;dimension&quot; must be the name of an existing dimension, or be empty, in</span>
<span class="sd">        which case there will not be a primary dimension after this call.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetPrimaryConstrainedDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension_name</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Set the given dimension as "primary constrained". As of August 2013, this
is only used by ArcIsMoreConstrainedThanArc().
"dimension" must be the name of an existing dimension, or be empty, in
which case there will not be a primary dimension after this call.</p>
</div>


                            </div>
                            <div id="RoutingModel.GetPrimaryConstrainedDimension" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetPrimaryConstrainedDimension">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetPrimaryConstrainedDimension</span><span class="signature">(self) -&gt; &#39;std::string const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetPrimaryConstrainedDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Get the primary constrained dimension, or an empty string if it is unset.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetPrimaryConstrainedDimension</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Get the primary constrained dimension, or an empty string if it is unset.</p>
</div>


                            </div>
                            <div id="RoutingModel.GetDimensionResourceGroupIndices" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetDimensionResourceGroupIndices">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetDimensionResourceGroupIndices</span><span class="signature">(
    self,
    dimension: <a href="#RoutingDimension">pywrapcp.RoutingDimension</a>
) -&gt; &#39;std::vector&lt; int &gt; const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetDimensionResourceGroupIndices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="s2">&quot;RoutingDimension&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the indices of resource groups for this dimension. This method can</span>
<span class="sd">        only be called after the model has been closed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetDimensionResourceGroupIndices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the indices of resource groups for this dimension. This method can
only be called after the model has been closed.</p>
</div>


                            </div>
                            <div id="RoutingModel.AddDisjunction" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.AddDisjunction">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddDisjunction</span><span class="signature">(self, *args) -&gt; &#39;operations_research::RoutingModel::DisjunctionIndex&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddDisjunction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingModel::DisjunctionIndex&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a disjunction constraint on the indices: exactly &#39;max_cardinality&#39; of</span>
<span class="sd">        the indices are active. Start and end indices of any vehicle cannot be</span>
<span class="sd">        part of a disjunction.</span>

<span class="sd">        If a penalty is given, at most &#39;max_cardinality&#39; of the indices can be</span>
<span class="sd">        active, and if less are active, &#39;penalty&#39; is payed per inactive index.</span>
<span class="sd">        This is equivalent to adding the constraint:</span>
<span class="sd">            p + Sum(i)active[i] == max_cardinality</span>
<span class="sd">        where p is an integer variable, and the following cost to the cost</span>
<span class="sd">        function:</span>
<span class="sd">            p * penalty.</span>
<span class="sd">        &#39;penalty&#39; must be positive to make the disjunction optional; a negative</span>
<span class="sd">        penalty will force &#39;max_cardinality&#39; indices of the disjunction to be</span>
<span class="sd">        performed, and therefore p == 0.</span>
<span class="sd">        Note: passing a vector with a single index will model an optional index</span>
<span class="sd">        with a penalty cost if it is not visited.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddDisjunction</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds a disjunction constraint on the indices: exactly 'max_cardinality' of
the indices are active. Start and end indices of any vehicle cannot be
part of a disjunction.</p>

<p>If a penalty is given, at most 'max_cardinality' of the indices can be
active, and if less are active, 'penalty' is payed per inactive index.</p>

<h6 id="this-is-equivalent-to-adding-the-constraint">This is equivalent to adding the constraint</h6>

<blockquote>
  <p>p + Sum(i)active[i] == max_cardinality</p>
</blockquote>

<p>where p is an integer variable, and the following cost to the cost
function:
    p * penalty.
'penalty' must be positive to make the disjunction optional; a negative
penalty will force 'max_cardinality' indices of the disjunction to be
performed, and therefore p == 0.
Note: passing a vector with a single index will model an optional index
with a penalty cost if it is not visited.</p>
</div>


                            </div>
                            <div id="RoutingModel.GetDisjunctionIndices" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetDisjunctionIndices">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetDisjunctionIndices</span><span class="signature">(
    self,
    index: &#39;int64_t&#39;
) -&gt; &#39;std::vector&lt; operations_research::RoutingModel::DisjunctionIndex &gt; const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetDisjunctionIndices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; operations_research::RoutingModel::DisjunctionIndex &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the indices of the disjunctions to which an index belongs.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetDisjunctionIndices</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the indices of the disjunctions to which an index belongs.</p>
</div>


                            </div>
                            <div id="RoutingModel.GetDisjunctionPenalty" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetDisjunctionPenalty">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetDisjunctionPenalty</span><span class="signature">(
    self,
    index: &#39;operations_research::RoutingModel::DisjunctionIndex&#39;
) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetDisjunctionPenalty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingModel::DisjunctionIndex&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the penalty of the node disjunction of index &#39;index&#39;.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetDisjunctionPenalty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the penalty of the node disjunction of index 'index'.</p>
</div>


                            </div>
                            <div id="RoutingModel.GetDisjunctionMaxCardinality" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetDisjunctionMaxCardinality">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetDisjunctionMaxCardinality</span><span class="signature">(
    self,
    index: &#39;operations_research::RoutingModel::DisjunctionIndex&#39;
) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetDisjunctionMaxCardinality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingModel::DisjunctionIndex&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the maximum number of possible active nodes of the node</span>
<span class="sd">        disjunction of index &#39;index&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetDisjunctionMaxCardinality</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the maximum number of possible active nodes of the node
disjunction of index 'index'.</p>
</div>


                            </div>
                            <div id="RoutingModel.GetNumberOfDisjunctions" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetNumberOfDisjunctions">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetNumberOfDisjunctions</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetNumberOfDisjunctions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the number of node disjunctions in the model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetNumberOfDisjunctions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the number of node disjunctions in the model.</p>
</div>


                            </div>
                            <div id="RoutingModel.GetPerfectBinaryDisjunctions" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetPerfectBinaryDisjunctions">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetPerfectBinaryDisjunctions</span><span class="signature">(self) -&gt; &#39;std::vector&lt; std::pair&lt; int64_t,int64_t &gt; &gt;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetPerfectBinaryDisjunctions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; std::pair&lt; int64_t,int64_t &gt; &gt;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the list of all perfect binary disjunctions, as pairs of variable</span>
<span class="sd">        indices: a disjunction is &quot;perfect&quot; when its variables do not appear in</span>
<span class="sd">        any other disjunction. Each pair is sorted (lowest variable index first),</span>
<span class="sd">        and the output vector is also sorted (lowest pairs first).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetPerfectBinaryDisjunctions</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the list of all perfect binary disjunctions, as pairs of variable
indices: a disjunction is "perfect" when its variables do not appear in
any other disjunction. Each pair is sorted (lowest variable index first),
and the output vector is also sorted (lowest pairs first).</p>
</div>


                            </div>
                            <div id="RoutingModel.IgnoreDisjunctionsAlreadyForcedToZero" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.IgnoreDisjunctionsAlreadyForcedToZero">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IgnoreDisjunctionsAlreadyForcedToZero</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IgnoreDisjunctionsAlreadyForcedToZero</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        SPECIAL: Makes the solver ignore all the disjunctions whose active</span>
<span class="sd">        variables are all trivially zero (i.e. Max() == 0), by setting their</span>
<span class="sd">        max_cardinality to 0.</span>
<span class="sd">        This can be useful when using the BaseBinaryDisjunctionNeighborhood</span>
<span class="sd">        operators, in the context of arc-based routing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_IgnoreDisjunctionsAlreadyForcedToZero</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>SPECIAL: Makes the solver ignore all the disjunctions whose active
variables are all trivially zero (i.e. Max() == 0), by setting their
max_cardinality to 0.
This can be useful when using the BaseBinaryDisjunctionNeighborhood
operators, in the context of arc-based routing.</p>
</div>


                            </div>
                            <div id="RoutingModel.AddSoftSameVehicleConstraint" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.AddSoftSameVehicleConstraint">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddSoftSameVehicleConstraint</span><span class="signature">(
    self,
    indices: &#39;std::vector&lt; int64_t &gt; const &amp;&#39;,
    cost: &#39;int64_t&#39;
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddSoftSameVehicleConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">cost</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a soft constraint to force a set of variable indices to be on the</span>
<span class="sd">        same vehicle. If all nodes are not on the same vehicle, each extra vehicle</span>
<span class="sd">        used adds &#39;cost&#39; to the cost function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddSoftSameVehicleConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">indices</span><span class="p">,</span> <span class="n">cost</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds a soft constraint to force a set of variable indices to be on the
same vehicle. If all nodes are not on the same vehicle, each extra vehicle
used adds 'cost' to the cost function.</p>
</div>


                            </div>
                            <div id="RoutingModel.SetAllowedVehiclesForIndex" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.SetAllowedVehiclesForIndex">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetAllowedVehiclesForIndex</span><span class="signature">(
    self,
    vehicles: &#39;std::vector&lt; int &gt; const &amp;&#39;,
    index: &#39;int64_t&#39;
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetAllowedVehiclesForIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicles</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the vehicles which can visit a given node. If the node is in a</span>
<span class="sd">        disjunction, this will not prevent it from being unperformed.</span>
<span class="sd">        Specifying an empty vector of vehicles has no effect (all vehicles</span>
<span class="sd">        will be allowed to visit the node).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetAllowedVehiclesForIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicles</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Sets the vehicles which can visit a given node. If the node is in a
disjunction, this will not prevent it from being unperformed.
Specifying an empty vector of vehicles has no effect (all vehicles
will be allowed to visit the node).</p>
</div>


                            </div>
                            <div id="RoutingModel.IsVehicleAllowedForIndex" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.IsVehicleAllowedForIndex">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsVehicleAllowedForIndex</span><span class="signature">(self, vehicle: int, index: &#39;int64_t&#39;) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsVehicleAllowedForIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns true if a vehicle is allowed to visit a given node.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_IsVehicleAllowedForIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns true if a vehicle is allowed to visit a given node.</p>
</div>


                            </div>
                            <div id="RoutingModel.AddPickupAndDelivery" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.AddPickupAndDelivery">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddPickupAndDelivery</span><span class="signature">(self, pickup: &#39;int64_t&#39;, delivery: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddPickupAndDelivery</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pickup</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">delivery</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Notifies that index1 and index2 form a pair of nodes which should belong</span>
<span class="sd">        to the same route. This methods helps the search find better solutions,</span>
<span class="sd">        especially in the local search phase.</span>
<span class="sd">        It should be called each time you have an equality constraint linking</span>
<span class="sd">        the vehicle variables of two node (including for instance pickup and</span>
<span class="sd">        delivery problems):</span>
<span class="sd">            Solver* const solver = routing.solver();</span>
<span class="sd">            int64_t index1 = manager.NodeToIndex(node1);</span>
<span class="sd">            int64_t index2 = manager.NodeToIndex(node2);</span>
<span class="sd">            solver-&gt;AddConstraint(solver-&gt;MakeEquality(</span>
<span class="sd">                routing.VehicleVar(index1),</span>
<span class="sd">                routing.VehicleVar(index2)));</span>
<span class="sd">            routing.AddPickupAndDelivery(index1, index2);</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddPickupAndDelivery</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pickup</span><span class="p">,</span> <span class="n">delivery</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Notifies that index1 and index2 form a pair of nodes which should belong
to the same route. This methods helps the search find better solutions,
especially in the local search phase.
It should be called each time you have an equality constraint linking
the vehicle variables of two node (including for instance pickup and
delivery problems):
    Solver* const solver = routing.solver();
    int64_t index1 = manager.NodeToIndex(node1);
    int64_t index2 = manager.NodeToIndex(node2);
    solver->AddConstraint(solver->MakeEquality(
        routing.VehicleVar(index1),
        routing.VehicleVar(index2)));
    routing.AddPickupAndDelivery(index1, index2);</p>
</div>


                            </div>
                            <div id="RoutingModel.AddPickupAndDeliverySets" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.AddPickupAndDeliverySets">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddPickupAndDeliverySets</span><span class="signature">(
    self,
    pickup_disjunction: &#39;operations_research::RoutingModel::DisjunctionIndex&#39;,
    delivery_disjunction: &#39;operations_research::RoutingModel::DisjunctionIndex&#39;
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddPickupAndDeliverySets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pickup_disjunction</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingModel::DisjunctionIndex&quot;</span><span class="p">,</span> <span class="n">delivery_disjunction</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingModel::DisjunctionIndex&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as AddPickupAndDelivery but notifying that the performed node from</span>
<span class="sd">        the disjunction of index &#39;pickup_disjunction&#39; is on the same route as the</span>
<span class="sd">        performed node from the disjunction of index &#39;delivery_disjunction&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddPickupAndDeliverySets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pickup_disjunction</span><span class="p">,</span> <span class="n">delivery_disjunction</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Same as AddPickupAndDelivery but notifying that the performed node from
the disjunction of index 'pickup_disjunction' is on the same route as the
performed node from the disjunction of index 'delivery_disjunction'.</p>
</div>


                            </div>
                            <div id="RoutingModel.GetPickupIndexPairs" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetPickupIndexPairs">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetPickupIndexPairs</span><span class="signature">(
    self,
    node_index: &#39;int64_t&#39;
) -&gt; &#39;std::vector&lt; std::pair&lt; int,int &gt; &gt; const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetPickupIndexPairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; std::pair&lt; int,int &gt; &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns pairs for which the node is a pickup; the first element of each</span>
<span class="sd">        pair is the index in the pickup and delivery pairs list in which the</span>
<span class="sd">        pickup appears, the second element is its index in the pickups list.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetPickupIndexPairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns pairs for which the node is a pickup; the first element of each
pair is the index in the pickup and delivery pairs list in which the
pickup appears, the second element is its index in the pickups list.</p>
</div>


                            </div>
                            <div id="RoutingModel.GetDeliveryIndexPairs" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetDeliveryIndexPairs">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetDeliveryIndexPairs</span><span class="signature">(
    self,
    node_index: &#39;int64_t&#39;
) -&gt; &#39;std::vector&lt; std::pair&lt; int,int &gt; &gt; const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetDeliveryIndexPairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; std::pair&lt; int,int &gt; &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Same as above for deliveries.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetDeliveryIndexPairs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node_index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Same as above for deliveries.</p>
</div>


                            </div>
                            <div id="RoutingModel.SetPickupAndDeliveryPolicyOfAllVehicles" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.SetPickupAndDeliveryPolicyOfAllVehicles">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetPickupAndDeliveryPolicyOfAllVehicles</span><span class="signature">(
    self,
    policy: &#39;operations_research::RoutingModel::PickupAndDeliveryPolicy&#39;
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetPickupAndDeliveryPolicyOfAllVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">policy</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingModel::PickupAndDeliveryPolicy&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the Pickup and delivery policy of all vehicles. It is equivalent to</span>
<span class="sd">        calling SetPickupAndDeliveryPolicyOfVehicle on all vehicles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetPickupAndDeliveryPolicyOfAllVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">policy</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Sets the Pickup and delivery policy of all vehicles. It is equivalent to
calling SetPickupAndDeliveryPolicyOfVehicle on all vehicles.</p>
</div>


                            </div>
                            <div id="RoutingModel.SetPickupAndDeliveryPolicyOfVehicle" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.SetPickupAndDeliveryPolicyOfVehicle">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetPickupAndDeliveryPolicyOfVehicle</span><span class="signature">(
    self,
    policy: &#39;operations_research::RoutingModel::PickupAndDeliveryPolicy&#39;,
    vehicle: int
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetPickupAndDeliveryPolicyOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">policy</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingModel::PickupAndDeliveryPolicy&quot;</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetPickupAndDeliveryPolicyOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">policy</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingModel.GetPickupAndDeliveryPolicyOfVehicle" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetPickupAndDeliveryPolicyOfVehicle">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetPickupAndDeliveryPolicyOfVehicle</span><span class="signature">(
    self,
    vehicle: int
) -&gt; &#39;operations_research::RoutingModel::PickupAndDeliveryPolicy&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetPickupAndDeliveryPolicyOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingModel::PickupAndDeliveryPolicy&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetPickupAndDeliveryPolicyOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingModel.GetNumOfSingletonNodes" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetNumOfSingletonNodes">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetNumOfSingletonNodes</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetNumOfSingletonNodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of non-start/end nodes which do not appear in a</span>
<span class="sd">        pickup/delivery pair.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetNumOfSingletonNodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the number of non-start/end nodes which do not appear in a
pickup/delivery pair.</p>
</div>


                            </div>
                            <div id="RoutingModel.TYPE_ADDED_TO_VEHICLE" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#RoutingModel.TYPE_ADDED_TO_VEHICLE">#&nbsp;&nbsp</a>

        <span class="name">TYPE_ADDED_TO_VEHICLE</span><span class="default_value"> = 0</span>
    </div>

            <div class="docstring"><p>When visited, the number of types 'T' on the vehicle increases by one.</p>
</div>


                            </div>
                            <div id="RoutingModel.ADDED_TYPE_REMOVED_FROM_VEHICLE" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#RoutingModel.ADDED_TYPE_REMOVED_FROM_VEHICLE">#&nbsp;&nbsp</a>

        <span class="name">ADDED_TYPE_REMOVED_FROM_VEHICLE</span><span class="default_value"> = 1</span>
    </div>

            <div class="docstring"><p>When visited, one instance of type 'T' previously added to the route
(TYPE_ADDED_TO_VEHICLE), if any, is removed from the vehicle.
If the type was not previously added to the route or all added instances
have already been removed, this visit has no effect on the types.</p>
</div>


                            </div>
                            <div id="RoutingModel.TYPE_ON_VEHICLE_UP_TO_VISIT" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#RoutingModel.TYPE_ON_VEHICLE_UP_TO_VISIT">#&nbsp;&nbsp</a>

        <span class="name">TYPE_ON_VEHICLE_UP_TO_VISIT</span><span class="default_value"> = 2</span>
    </div>

            <div class="docstring"><p>With the following policy, the visit enforces that type 'T' is
considered on the route from its start until this node is visited.</p>
</div>


                            </div>
                            <div id="RoutingModel.TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#RoutingModel.TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED">#&nbsp;&nbsp</a>

        <span class="name">TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED</span><span class="default_value"> = 3</span>
    </div>

            <div class="docstring"><p>The visit doesn't have an impact on the number of types 'T' on the
route, as it's (virtually) added and removed directly.
This policy can be used for visits which are part of an incompatibility
or requirement set without affecting the type count on the route.</p>
</div>


                            </div>
                            <div id="RoutingModel.SetVisitType" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.SetVisitType">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetVisitType</span><span class="signature">(
    self,
    index: &#39;int64_t&#39;,
    type: int,
    type_policy: &#39;operations_research::RoutingModel::VisitTypePolicy&#39;
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetVisitType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">type_policy</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingModel::VisitTypePolicy&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetVisitType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="nb">type</span><span class="p">,</span> <span class="n">type_policy</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingModel.GetVisitType" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetVisitType">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetVisitType</span><span class="signature">(self, index: &#39;int64_t&#39;) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetVisitType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetVisitType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingModel.GetSingleNodesOfType" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetSingleNodesOfType">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetSingleNodesOfType</span><span class="signature">(self, type: int) -&gt; &#39;std::vector&lt; int &gt; const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetSingleNodesOfType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetSingleNodesOfType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingModel.GetPairIndicesOfType" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetPairIndicesOfType">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetPairIndicesOfType</span><span class="signature">(self, type: int) -&gt; &#39;std::vector&lt; int &gt; const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetPairIndicesOfType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetPairIndicesOfType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingModel.GetVisitTypePolicy" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetVisitTypePolicy">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetVisitTypePolicy</span><span class="signature">(
    self,
    index: &#39;int64_t&#39;
) -&gt; &#39;operations_research::RoutingModel::VisitTypePolicy&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetVisitTypePolicy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingModel::VisitTypePolicy&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetVisitTypePolicy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingModel.CloseVisitTypes" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.CloseVisitTypes">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">CloseVisitTypes</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">CloseVisitTypes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This function should be called once all node visit types have been set and</span>
<span class="sd">        prior to adding any incompatibilities/requirements.</span>
<span class="sd">        &quot;close&quot; types.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_CloseVisitTypes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This function should be called once all node visit types have been set and
prior to adding any incompatibilities/requirements.
"close" types.</p>
</div>


                            </div>
                            <div id="RoutingModel.GetNumberOfVisitTypes" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetNumberOfVisitTypes">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetNumberOfVisitTypes</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetNumberOfVisitTypes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetNumberOfVisitTypes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingModel.AddHardTypeIncompatibility" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.AddHardTypeIncompatibility">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddHardTypeIncompatibility</span><span class="signature">(self, type1: int, type2: int) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddHardTypeIncompatibility</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type1</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">type2</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Incompatibilities:</span>
<span class="sd">        Two nodes with &quot;hard&quot; incompatible types cannot share the same route at</span>
<span class="sd">        all, while with a &quot;temporal&quot; incompatibility they can&#39;t be on the same</span>
<span class="sd">        route at the same time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddHardTypeIncompatibility</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type1</span><span class="p">,</span> <span class="n">type2</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Incompatibilities:
Two nodes with "hard" incompatible types cannot share the same route at
all, while with a "temporal" incompatibility they can't be on the same
route at the same time.</p>
</div>


                            </div>
                            <div id="RoutingModel.AddTemporalTypeIncompatibility" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.AddTemporalTypeIncompatibility">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddTemporalTypeIncompatibility</span><span class="signature">(self, type1: int, type2: int) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddTemporalTypeIncompatibility</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type1</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">type2</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddTemporalTypeIncompatibility</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">type1</span><span class="p">,</span> <span class="n">type2</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingModel.GetHardTypeIncompatibilitiesOfType" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetHardTypeIncompatibilitiesOfType">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetHardTypeIncompatibilitiesOfType</span><span class="signature">(self, type: int) -&gt; &#39;absl::flat_hash_set&lt; int &gt; const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetHardTypeIncompatibilitiesOfType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;absl::flat_hash_set&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns visit types incompatible with a given type.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetHardTypeIncompatibilitiesOfType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns visit types incompatible with a given type.</p>
</div>


                            </div>
                            <div id="RoutingModel.GetTemporalTypeIncompatibilitiesOfType" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetTemporalTypeIncompatibilitiesOfType">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetTemporalTypeIncompatibilitiesOfType</span><span class="signature">(self, type: int) -&gt; &#39;absl::flat_hash_set&lt; int &gt; const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetTemporalTypeIncompatibilitiesOfType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;absl::flat_hash_set&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetTemporalTypeIncompatibilitiesOfType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingModel.HasHardTypeIncompatibilities" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.HasHardTypeIncompatibilities">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">HasHardTypeIncompatibilities</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">HasHardTypeIncompatibilities</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns true iff any hard (resp. temporal) type incompatibilities have</span>
<span class="sd">        been added to the model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_HasHardTypeIncompatibilities</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns true iff any hard (resp. temporal) type incompatibilities have
been added to the model.</p>
</div>


                            </div>
                            <div id="RoutingModel.HasTemporalTypeIncompatibilities" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.HasTemporalTypeIncompatibilities">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">HasTemporalTypeIncompatibilities</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">HasTemporalTypeIncompatibilities</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_HasTemporalTypeIncompatibilities</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingModel.AddSameVehicleRequiredTypeAlternatives" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.AddSameVehicleRequiredTypeAlternatives">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddSameVehicleRequiredTypeAlternatives</span><span class="signature">(
    self,
    dependent_type: int,
    required_type_alternatives: &#39;absl::flat_hash_set&lt; int &gt;&#39;
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddSameVehicleRequiredTypeAlternatives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dependent_type</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">required_type_alternatives</span><span class="p">:</span> <span class="s2">&quot;absl::flat_hash_set&lt; int &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Requirements:</span>
<span class="sd">        NOTE: As of 2019-04, cycles in the requirement graph are not supported,</span>
<span class="sd">        and lead to the dependent nodes being skipped if possible (otherwise</span>
<span class="sd">        the model is considered infeasible).</span>
<span class="sd">        The following functions specify that &quot;dependent_type&quot; requires at least</span>
<span class="sd">        one of the types in &quot;required_type_alternatives&quot;.</span>

<span class="sd">        For same-vehicle requirements, a node of dependent type type_D requires at</span>
<span class="sd">        least one node of type type_R among the required alternatives on the same</span>
<span class="sd">        route.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddSameVehicleRequiredTypeAlternatives</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dependent_type</span><span class="p">,</span> <span class="n">required_type_alternatives</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Requirements:
NOTE: As of 2019-04, cycles in the requirement graph are not supported,
and lead to the dependent nodes being skipped if possible (otherwise
the model is considered infeasible).
The following functions specify that "dependent_type" requires at least
one of the types in "required_type_alternatives".</p>

<p>For same-vehicle requirements, a node of dependent type type_D requires at
least one node of type type_R among the required alternatives on the same
route.</p>
</div>


                            </div>
                            <div id="RoutingModel.AddRequiredTypeAlternativesWhenAddingType" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.AddRequiredTypeAlternativesWhenAddingType">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddRequiredTypeAlternativesWhenAddingType</span><span class="signature">(
    self,
    dependent_type: int,
    required_type_alternatives: &#39;absl::flat_hash_set&lt; int &gt;&#39;
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddRequiredTypeAlternativesWhenAddingType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dependent_type</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">required_type_alternatives</span><span class="p">:</span> <span class="s2">&quot;absl::flat_hash_set&lt; int &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If type_D depends on type_R when adding type_D, any node_D of type_D and</span>
<span class="sd">        VisitTypePolicy TYPE_ADDED_TO_VEHICLE or</span>
<span class="sd">        TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED requires at least one type_R on its</span>
<span class="sd">        vehicle at the time node_D is visited.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddRequiredTypeAlternativesWhenAddingType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dependent_type</span><span class="p">,</span> <span class="n">required_type_alternatives</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>If type_D depends on type_R when adding type_D, any node_D of type_D and
VisitTypePolicy TYPE_ADDED_TO_VEHICLE or
TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED requires at least one type_R on its
vehicle at the time node_D is visited.</p>
</div>


                            </div>
                            <div id="RoutingModel.AddRequiredTypeAlternativesWhenRemovingType" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.AddRequiredTypeAlternativesWhenRemovingType">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddRequiredTypeAlternativesWhenRemovingType</span><span class="signature">(
    self,
    dependent_type: int,
    required_type_alternatives: &#39;absl::flat_hash_set&lt; int &gt;&#39;
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddRequiredTypeAlternativesWhenRemovingType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dependent_type</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">required_type_alternatives</span><span class="p">:</span> <span class="s2">&quot;absl::flat_hash_set&lt; int &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The following requirements apply when visiting dependent nodes that remove</span>
<span class="sd">        their type from the route, i.e. type_R must be on the vehicle when type_D</span>
<span class="sd">        of VisitTypePolicy ADDED_TYPE_REMOVED_FROM_VEHICLE,</span>
<span class="sd">        TYPE_ON_VEHICLE_UP_TO_VISIT or TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED is</span>
<span class="sd">        visited.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddRequiredTypeAlternativesWhenRemovingType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dependent_type</span><span class="p">,</span> <span class="n">required_type_alternatives</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>The following requirements apply when visiting dependent nodes that remove
their type from the route, i.e. type_R must be on the vehicle when type_D
of VisitTypePolicy ADDED_TYPE_REMOVED_FROM_VEHICLE,
TYPE_ON_VEHICLE_UP_TO_VISIT or TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED is
visited.</p>
</div>


                            </div>
                            <div id="RoutingModel.GetSameVehicleRequiredTypeAlternativesOfType" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetSameVehicleRequiredTypeAlternativesOfType">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetSameVehicleRequiredTypeAlternativesOfType</span><span class="signature">(
    self,
    type: int
) -&gt; &#39;std::vector&lt; absl::flat_hash_set&lt; int &gt; &gt; const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetSameVehicleRequiredTypeAlternativesOfType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; absl::flat_hash_set&lt; int &gt; &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the set of same-vehicle requirement alternatives for the given</span>
<span class="sd">        type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetSameVehicleRequiredTypeAlternativesOfType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the set of same-vehicle requirement alternatives for the given
type.</p>
</div>


                            </div>
                            <div id="RoutingModel.GetRequiredTypeAlternativesWhenAddingType" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetRequiredTypeAlternativesWhenAddingType">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetRequiredTypeAlternativesWhenAddingType</span><span class="signature">(
    self,
    type: int
) -&gt; &#39;std::vector&lt; absl::flat_hash_set&lt; int &gt; &gt; const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetRequiredTypeAlternativesWhenAddingType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; absl::flat_hash_set&lt; int &gt; &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the set of requirement alternatives when adding the given type.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetRequiredTypeAlternativesWhenAddingType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the set of requirement alternatives when adding the given type.</p>
</div>


                            </div>
                            <div id="RoutingModel.GetRequiredTypeAlternativesWhenRemovingType" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetRequiredTypeAlternativesWhenRemovingType">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetRequiredTypeAlternativesWhenRemovingType</span><span class="signature">(
    self,
    type: int
) -&gt; &#39;std::vector&lt; absl::flat_hash_set&lt; int &gt; &gt; const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetRequiredTypeAlternativesWhenRemovingType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; absl::flat_hash_set&lt; int &gt; &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the set of requirement alternatives when removing the given type.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetRequiredTypeAlternativesWhenRemovingType</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">type</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the set of requirement alternatives when removing the given type.</p>
</div>


                            </div>
                            <div id="RoutingModel.HasSameVehicleTypeRequirements" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.HasSameVehicleTypeRequirements">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">HasSameVehicleTypeRequirements</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">HasSameVehicleTypeRequirements</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns true iff any same-route (resp. temporal) type requirements have</span>
<span class="sd">        been added to the model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_HasSameVehicleTypeRequirements</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns true iff any same-route (resp. temporal) type requirements have
been added to the model.</p>
</div>


                            </div>
                            <div id="RoutingModel.HasTemporalTypeRequirements" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.HasTemporalTypeRequirements">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">HasTemporalTypeRequirements</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">HasTemporalTypeRequirements</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_HasTemporalTypeRequirements</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingModel.HasTypeRegulations" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.HasTypeRegulations">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">HasTypeRegulations</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">HasTypeRegulations</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns true iff the model has any incompatibilities or requirements set</span>
<span class="sd">        on node types.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_HasTypeRegulations</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns true iff the model has any incompatibilities or requirements set
on node types.</p>
</div>


                            </div>
                            <div id="RoutingModel.UnperformedPenalty" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.UnperformedPenalty">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">UnperformedPenalty</span><span class="signature">(self, var_index: &#39;int64_t&#39;) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">UnperformedPenalty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the &quot;unperformed&quot; penalty of a node. This is only well defined if the</span>
<span class="sd">        node is only part of a single Disjunction, and that disjunction has a</span>
<span class="sd">        penalty. For forced active nodes returns max int64_t. In all other cases,</span>
<span class="sd">        this returns 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_UnperformedPenalty</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Get the "unperformed" penalty of a node. This is only well defined if the
node is only part of a single Disjunction, and that disjunction has a
penalty. For forced active nodes returns max int64_t. In all other cases,
this returns 0.</p>
</div>


                            </div>
                            <div id="RoutingModel.UnperformedPenaltyOrValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.UnperformedPenaltyOrValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">UnperformedPenaltyOrValue</span><span class="signature">(self, default_value: &#39;int64_t&#39;, var_index: &#39;int64_t&#39;) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">UnperformedPenaltyOrValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">default_value</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">var_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as above except that it returns default_value instead of 0 when</span>
<span class="sd">        penalty is not well defined (default value is passed as first argument to</span>
<span class="sd">        simplify the usage of the method in a callback).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_UnperformedPenaltyOrValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">default_value</span><span class="p">,</span> <span class="n">var_index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Same as above except that it returns default_value instead of 0 when
penalty is not well defined (default value is passed as first argument to
simplify the usage of the method in a callback).</p>
</div>


                            </div>
                            <div id="RoutingModel.GetDepot" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetDepot">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetDepot</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetDepot</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the variable index of the first starting or ending node of all</span>
<span class="sd">        routes. If all routes start  and end at the same node (single depot), this</span>
<span class="sd">        is the node returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetDepot</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the variable index of the first starting or ending node of all
routes. If all routes start  and end at the same node (single depot), this
is the node returned.</p>
</div>


                            </div>
                            <div id="RoutingModel.SetMaximumNumberOfActiveVehicles" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.SetMaximumNumberOfActiveVehicles">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetMaximumNumberOfActiveVehicles</span><span class="signature">(self, max_active_vehicles: int) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetMaximumNumberOfActiveVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_active_vehicles</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Constrains the maximum number of active vehicles, aka the number of</span>
<span class="sd">        vehicles which do not have an empty route. For instance, this can be used</span>
<span class="sd">        to limit the number of routes in the case where there are fewer drivers</span>
<span class="sd">        than vehicles and that the fleet of vehicle is heterogeneous.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetMaximumNumberOfActiveVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">max_active_vehicles</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Constrains the maximum number of active vehicles, aka the number of
vehicles which do not have an empty route. For instance, this can be used
to limit the number of routes in the case where there are fewer drivers
than vehicles and that the fleet of vehicle is heterogeneous.</p>
</div>


                            </div>
                            <div id="RoutingModel.GetMaximumNumberOfActiveVehicles" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetMaximumNumberOfActiveVehicles">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetMaximumNumberOfActiveVehicles</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetMaximumNumberOfActiveVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the maximum number of active vehicles.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetMaximumNumberOfActiveVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the maximum number of active vehicles.</p>
</div>


                            </div>
                            <div id="RoutingModel.SetArcCostEvaluatorOfAllVehicles" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.SetArcCostEvaluatorOfAllVehicles">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetArcCostEvaluatorOfAllVehicles</span><span class="signature">(self, evaluator_index: int) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetArcCostEvaluatorOfAllVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator_index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the cost function of the model such that the cost of a segment of a</span>
<span class="sd">        route between node &#39;from&#39; and &#39;to&#39; is evaluator(from, to), whatever the</span>
<span class="sd">        route or vehicle performing the route.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetArcCostEvaluatorOfAllVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator_index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Sets the cost function of the model such that the cost of a segment of a
route between node 'from' and 'to' is evaluator(from, to), whatever the
route or vehicle performing the route.</p>
</div>


                            </div>
                            <div id="RoutingModel.SetArcCostEvaluatorOfVehicle" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.SetArcCostEvaluatorOfVehicle">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetArcCostEvaluatorOfVehicle</span><span class="signature">(self, evaluator_index: int, vehicle: int) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetArcCostEvaluatorOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator_index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Sets the cost function for a given vehicle route.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetArcCostEvaluatorOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator_index</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Sets the cost function for a given vehicle route.</p>
</div>


                            </div>
                            <div id="RoutingModel.SetFixedCostOfAllVehicles" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.SetFixedCostOfAllVehicles">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetFixedCostOfAllVehicles</span><span class="signature">(self, cost: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetFixedCostOfAllVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cost</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the fixed cost of all vehicle routes. It is equivalent to calling</span>
<span class="sd">        SetFixedCostOfVehicle on all vehicle routes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetFixedCostOfAllVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cost</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Sets the fixed cost of all vehicle routes. It is equivalent to calling
SetFixedCostOfVehicle on all vehicle routes.</p>
</div>


                            </div>
                            <div id="RoutingModel.SetFixedCostOfVehicle" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.SetFixedCostOfVehicle">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetFixedCostOfVehicle</span><span class="signature">(self, cost: &#39;int64_t&#39;, vehicle: int) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetFixedCostOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cost</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Sets the fixed cost of one vehicle route.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetFixedCostOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cost</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Sets the fixed cost of one vehicle route.</p>
</div>


                            </div>
                            <div id="RoutingModel.GetFixedCostOfVehicle" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetFixedCostOfVehicle">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetFixedCostOfVehicle</span><span class="signature">(self, vehicle: int) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetFixedCostOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the route fixed cost taken into account if the route of the</span>
<span class="sd">        vehicle is not empty, aka there&#39;s at least one node on the route other</span>
<span class="sd">        than the first and last nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetFixedCostOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the route fixed cost taken into account if the route of the
vehicle is not empty, aka there's at least one node on the route other
than the first and last nodes.</p>
</div>


                            </div>
                            <div id="RoutingModel.SetAmortizedCostFactorsOfAllVehicles" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.SetAmortizedCostFactorsOfAllVehicles">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetAmortizedCostFactorsOfAllVehicles</span><span class="signature">(
    self,
    linear_cost_factor: &#39;int64_t&#39;,
    quadratic_cost_factor: &#39;int64_t&#39;
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetAmortizedCostFactorsOfAllVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linear_cost_factor</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">quadratic_cost_factor</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The following methods set the linear and quadratic cost factors of</span>
<span class="sd">        vehicles (must be positive values). The default value of these parameters</span>
<span class="sd">        is zero for all vehicles.</span>

<span class="sd">        When set, the cost_ of the model will contain terms aiming at reducing the</span>
<span class="sd">        number of vehicles used in the model, by adding the following to the</span>
<span class="sd">        objective for every vehicle v:</span>
<span class="sd">        INDICATOR(v used in the model) *</span>
<span class="sd">          [linear_cost_factor_of_vehicle_[v]</span>
<span class="sd">           - quadratic_cost_factor_of_vehicle_[v]*(square of length of route v)]</span>
<span class="sd">        i.e. for every used vehicle, we add the linear factor as fixed cost, and</span>
<span class="sd">        subtract the square of the route length multiplied by the quadratic</span>
<span class="sd">        factor. This second term aims at making the routes as dense as possible.</span>

<span class="sd">        Sets the linear and quadratic cost factor of all vehicles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetAmortizedCostFactorsOfAllVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linear_cost_factor</span><span class="p">,</span> <span class="n">quadratic_cost_factor</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>The following methods set the linear and quadratic cost factors of
vehicles (must be positive values). The default value of these parameters
is zero for all vehicles.</p>

<p>When set, the cost_ of the model will contain terms aiming at reducing the
number of vehicles used in the model, by adding the following to the
objective for every vehicle v:
INDICATOR(v used in the model) *
  [linear_cost_factor_of_vehicle_[v]</p>

<ul>
<li>quadratic_cost_factor_of_vehicle_[v]*(square of length of route v)]
i.e. for every used vehicle, we add the linear factor as fixed cost, and
subtract the square of the route length multiplied by the quadratic
factor. This second term aims at making the routes as dense as possible.</li>
</ul>

<p>Sets the linear and quadratic cost factor of all vehicles.</p>
</div>


                            </div>
                            <div id="RoutingModel.SetAmortizedCostFactorsOfVehicle" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.SetAmortizedCostFactorsOfVehicle">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetAmortizedCostFactorsOfVehicle</span><span class="signature">(
    self,
    linear_cost_factor: &#39;int64_t&#39;,
    quadratic_cost_factor: &#39;int64_t&#39;,
    vehicle: int
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetAmortizedCostFactorsOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linear_cost_factor</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">quadratic_cost_factor</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Sets the linear and quadratic cost factor of the given vehicle.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetAmortizedCostFactorsOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">linear_cost_factor</span><span class="p">,</span> <span class="n">quadratic_cost_factor</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Sets the linear and quadratic cost factor of the given vehicle.</p>
</div>


                            </div>
                            <div id="RoutingModel.GetAmortizedLinearCostFactorOfVehicles" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetAmortizedLinearCostFactorOfVehicles">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetAmortizedLinearCostFactorOfVehicles</span><span class="signature">(self) -&gt; &#39;std::vector&lt; int64_t &gt; const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetAmortizedLinearCostFactorOfVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int64_t &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetAmortizedLinearCostFactorOfVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingModel.GetAmortizedQuadraticCostFactorOfVehicles" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetAmortizedQuadraticCostFactorOfVehicles">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetAmortizedQuadraticCostFactorOfVehicles</span><span class="signature">(self) -&gt; &#39;std::vector&lt; int64_t &gt; const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetAmortizedQuadraticCostFactorOfVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int64_t &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetAmortizedQuadraticCostFactorOfVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingModel.ConsiderEmptyRouteCostsForVehicle" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.ConsiderEmptyRouteCostsForVehicle">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ConsiderEmptyRouteCostsForVehicle</span><span class="signature">(self, consider_costs: bool, vehicle: int) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ConsiderEmptyRouteCostsForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">consider_costs</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_ConsiderEmptyRouteCostsForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">consider_costs</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingModel.AreEmptyRouteCostsConsideredForVehicle" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.AreEmptyRouteCostsConsideredForVehicle">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AreEmptyRouteCostsConsideredForVehicle</span><span class="signature">(self, vehicle: int) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AreEmptyRouteCostsConsideredForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AreEmptyRouteCostsConsideredForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingModel.SetFirstSolutionEvaluator" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.SetFirstSolutionEvaluator">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetFirstSolutionEvaluator</span><span class="signature">(
    self,
    evaluator: &#39;operations_research::Solver::IndexEvaluator2&#39;
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetFirstSolutionEvaluator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator</span><span class="p">:</span> <span class="s2">&quot;operations_research::Solver::IndexEvaluator2&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets/sets the evaluator used during the search. Only relevant when</span>
<span class="sd">        RoutingSearchParameters.first_solution_strategy = EVALUATOR_STRATEGY.</span>
<span class="sd">        Takes ownership of evaluator.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetFirstSolutionEvaluator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">evaluator</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Gets/sets the evaluator used during the search. Only relevant when
RoutingSearchParameters.first_solution_strategy = EVALUATOR_STRATEGY.
Takes ownership of evaluator.</p>
</div>


                            </div>
                            <div id="RoutingModel.AddLocalSearchOperator" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.AddLocalSearchOperator">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddLocalSearchOperator</span><span class="signature">(self, ls_operator: <a href="#LocalSearchOperator">pywrapcp.LocalSearchOperator</a>) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddLocalSearchOperator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ls_operator</span><span class="p">:</span> <span class="s2">&quot;LocalSearchOperator&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a local search operator to the set of operators used to solve the</span>
<span class="sd">        vehicle routing problem.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddLocalSearchOperator</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ls_operator</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds a local search operator to the set of operators used to solve the
vehicle routing problem.</p>
</div>


                            </div>
                            <div id="RoutingModel.AddSearchMonitor" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.AddSearchMonitor">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddSearchMonitor</span><span class="signature">(self, monitor: <a href="#SearchMonitor">pywrapcp.SearchMonitor</a>) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddSearchMonitor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">monitor</span><span class="p">:</span> <span class="s2">&quot;SearchMonitor&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Adds a search monitor to the search used to solve the routing model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddSearchMonitor</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">monitor</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds a search monitor to the search used to solve the routing model.</p>
</div>


                            </div>
                            <div id="RoutingModel.AddAtSolutionCallback" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.AddAtSolutionCallback">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddAtSolutionCallback</span><span class="signature">(self, callback: &#39;std::function&lt; void () &gt;&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddAtSolutionCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">:</span> <span class="s2">&quot;std::function&lt; void () &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a callback called each time a solution is found during the search.</span>
<span class="sd">        This is a shortcut to creating a monitor to call the callback on</span>
<span class="sd">        AtSolution() and adding it with AddSearchMonitor.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddAtSolutionCallback</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">callback</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds a callback called each time a solution is found during the search.
This is a shortcut to creating a monitor to call the callback on
AtSolution() and adding it with AddSearchMonitor.</p>
</div>


                            </div>
                            <div id="RoutingModel.AddVariableMinimizedByFinalizer" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.AddVariableMinimizedByFinalizer">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddVariableMinimizedByFinalizer</span><span class="signature">(self, var: <a href="#IntVar">pywrapcp.IntVar</a>) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddVariableMinimizedByFinalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a variable to minimize in the solution finalizer. The solution</span>
<span class="sd">        finalizer is called each time a solution is found during the search and</span>
<span class="sd">        allows to instantiate secondary variables (such as dimension cumul</span>
<span class="sd">        variables).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddVariableMinimizedByFinalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds a variable to minimize in the solution finalizer. The solution
finalizer is called each time a solution is found during the search and
allows to instantiate secondary variables (such as dimension cumul
variables).</p>
</div>


                            </div>
                            <div id="RoutingModel.AddVariableMaximizedByFinalizer" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.AddVariableMaximizedByFinalizer">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddVariableMaximizedByFinalizer</span><span class="signature">(self, var: <a href="#IntVar">pywrapcp.IntVar</a>) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddVariableMaximizedByFinalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a variable to maximize in the solution finalizer (see above for</span>
<span class="sd">        information on the solution finalizer).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddVariableMaximizedByFinalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds a variable to maximize in the solution finalizer (see above for
information on the solution finalizer).</p>
</div>


                            </div>
                            <div id="RoutingModel.AddWeightedVariableMinimizedByFinalizer" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.AddWeightedVariableMinimizedByFinalizer">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddWeightedVariableMinimizedByFinalizer</span><span class="signature">(self, var: <a href="#IntVar">pywrapcp.IntVar</a>, cost: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddWeightedVariableMinimizedByFinalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">cost</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a variable to minimize in the solution finalizer, with a weighted</span>
<span class="sd">        priority: the higher the more priority it has.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddWeightedVariableMinimizedByFinalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">cost</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds a variable to minimize in the solution finalizer, with a weighted
priority: the higher the more priority it has.</p>
</div>


                            </div>
                            <div id="RoutingModel.AddVariableTargetToFinalizer" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.AddVariableTargetToFinalizer">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddVariableTargetToFinalizer</span><span class="signature">(self, var: <a href="#IntVar">pywrapcp.IntVar</a>, target: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddVariableTargetToFinalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">,</span> <span class="n">target</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Add a variable to set the closest possible to the target value in the</span>
<span class="sd">        solution finalizer.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddVariableTargetToFinalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">target</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Add a variable to set the closest possible to the target value in the
solution finalizer.</p>
</div>


                            </div>
                            <div id="RoutingModel.CloseModel" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.CloseModel">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">CloseModel</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">CloseModel</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Closes the current routing model; after this method is called, no</span>
<span class="sd">        modification to the model can be done, but RoutesToAssignment becomes</span>
<span class="sd">        available. Note that CloseModel() is automatically called by Solve() and</span>
<span class="sd">        other methods that produce solution.</span>
<span class="sd">        This is equivalent to calling</span>
<span class="sd">        CloseModelWithParameters(DefaultRoutingSearchParameters()).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_CloseModel</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Closes the current routing model; after this method is called, no
modification to the model can be done, but RoutesToAssignment becomes
available. Note that CloseModel() is automatically called by Solve() and
other methods that produce solution.
This is equivalent to calling
CloseModelWithParameters(DefaultRoutingSearchParameters()).</p>
</div>


                            </div>
                            <div id="RoutingModel.CloseModelWithParameters" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.CloseModelWithParameters">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">CloseModelWithParameters</span><span class="signature">(
    self,
    search_parameters: &#39;operations_research::RoutingSearchParameters const &amp;&#39;
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">CloseModelWithParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">search_parameters</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingSearchParameters const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as above taking search parameters (as of 10/2015 some the parameters</span>
<span class="sd">        have to be set when closing the model).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_CloseModelWithParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">search_parameters</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Same as above taking search parameters (as of 10/2015 some the parameters
have to be set when closing the model).</p>
</div>


                            </div>
                            <div id="RoutingModel.Solve" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.Solve">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Solve</span><span class="signature">(
    self,
    assignment: <a href="#Assignment">pywrapcp.Assignment</a> = None
) -&gt; &#39;operations_research::Assignment const *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment const *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solves the current routing model; closes the current model.</span>
<span class="sd">        This is equivalent to calling</span>
<span class="sd">        SolveWithParameters(DefaultRoutingSearchParameters())</span>
<span class="sd">        or</span>
<span class="sd">        SolveFromAssignmentWithParameters(assignment,</span>
<span class="sd">                                          DefaultRoutingSearchParameters()).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_Solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Solves the current routing model; closes the current model.
This is equivalent to calling
SolveWithParameters(DefaultRoutingSearchParameters())
or
SolveFromAssignmentWithParameters(assignment,
                                  DefaultRoutingSearchParameters()).</p>
</div>


                            </div>
                            <div id="RoutingModel.SolveWithParameters" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.SolveWithParameters">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SolveWithParameters</span><span class="signature">(
    self,
    search_parameters: &#39;operations_research::RoutingSearchParameters const &amp;&#39;,
    solutions: &#39;std::vector&lt; operations_research::Assignment const * &gt; *&#39; = None
) -&gt; &#39;operations_research::Assignment const *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SolveWithParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">search_parameters</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingSearchParameters const &amp;&quot;</span><span class="p">,</span> <span class="n">solutions</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::Assignment const * &gt; *&quot;</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment const *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solves the current routing model with the given parameters. If &#39;solutions&#39;</span>
<span class="sd">        is specified, it will contain the k best solutions found during the search</span>
<span class="sd">        (from worst to best, including the one returned by this method), where k</span>
<span class="sd">        corresponds to the &#39;number_of_solutions_to_collect&#39; in</span>
<span class="sd">        &#39;search_parameters&#39;. Note that the Assignment returned by the method and</span>
<span class="sd">        the ones in solutions are owned by the underlying solver and should not be</span>
<span class="sd">        deleted.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SolveWithParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">search_parameters</span><span class="p">,</span> <span class="n">solutions</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Solves the current routing model with the given parameters. If 'solutions'
is specified, it will contain the k best solutions found during the search
(from worst to best, including the one returned by this method), where k
corresponds to the 'number_of_solutions_to_collect' in
'search_parameters'. Note that the Assignment returned by the method and
the ones in solutions are owned by the underlying solver and should not be
deleted.</p>
</div>


                            </div>
                            <div id="RoutingModel.SolveFromAssignmentWithParameters" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.SolveFromAssignmentWithParameters">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SolveFromAssignmentWithParameters</span><span class="signature">(
    self,
    assignment: <a href="#Assignment">pywrapcp.Assignment</a>,
    search_parameters: &#39;operations_research::RoutingSearchParameters const &amp;&#39;,
    solutions: &#39;std::vector&lt; operations_research::Assignment const * &gt; *&#39; = None
) -&gt; &#39;operations_research::Assignment const *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SolveFromAssignmentWithParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">search_parameters</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingSearchParameters const &amp;&quot;</span><span class="p">,</span> <span class="n">solutions</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::Assignment const * &gt; *&quot;</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment const *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as above, except that if assignment is not null, it will be used as</span>
<span class="sd">        the initial solution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SolveFromAssignmentWithParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">,</span> <span class="n">search_parameters</span><span class="p">,</span> <span class="n">solutions</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Same as above, except that if assignment is not null, it will be used as
the initial solution.</p>
</div>


                            </div>
                            <div id="RoutingModel.SolveFromAssignmentsWithParameters" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.SolveFromAssignmentsWithParameters">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SolveFromAssignmentsWithParameters</span><span class="signature">(
    self,
    assignments: &#39;std::vector&lt; operations_research::Assignment const * &gt; const &amp;&#39;,
    search_parameters: &#39;operations_research::RoutingSearchParameters const &amp;&#39;,
    solutions: &#39;std::vector&lt; operations_research::Assignment const * &gt; *&#39; = None
) -&gt; &#39;operations_research::Assignment const *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SolveFromAssignmentsWithParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignments</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::Assignment const * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">search_parameters</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingSearchParameters const &amp;&quot;</span><span class="p">,</span> <span class="n">solutions</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::Assignment const * &gt; *&quot;</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment const *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as above but will try all assignments in order as first solutions</span>
<span class="sd">        until one succeeds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SolveFromAssignmentsWithParameters</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignments</span><span class="p">,</span> <span class="n">search_parameters</span><span class="p">,</span> <span class="n">solutions</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Same as above but will try all assignments in order as first solutions
until one succeeds.</p>
</div>


                            </div>
                            <div id="RoutingModel.SetAssignmentFromOtherModelAssignment" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.SetAssignmentFromOtherModelAssignment">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetAssignmentFromOtherModelAssignment</span><span class="signature">(
    self,
    target_assignment: <a href="#Assignment">pywrapcp.Assignment</a>,
    source_model: <a href="#RoutingModel">pywrapcp.RoutingModel</a>,
    source_assignment: <a href="#Assignment">pywrapcp.Assignment</a>
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetAssignmentFromOtherModelAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">source_model</span><span class="p">:</span> <span class="s2">&quot;RoutingModel&quot;</span><span class="p">,</span> <span class="n">source_assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given a &quot;source_model&quot; and its &quot;source_assignment&quot;, resets</span>
<span class="sd">        &quot;target_assignment&quot; with the IntVar variables (nexts_, and vehicle_vars_</span>
<span class="sd">        if costs aren&#39;t homogeneous across vehicles) of &quot;this&quot; model, with the</span>
<span class="sd">        values set according to those in &quot;other_assignment&quot;.</span>
<span class="sd">        The objective_element of target_assignment is set to this-&gt;cost_.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_SetAssignmentFromOtherModelAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">target_assignment</span><span class="p">,</span> <span class="n">source_model</span><span class="p">,</span> <span class="n">source_assignment</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Given a "source_model" and its "source_assignment", resets
"target_assignment" with the IntVar variables (nexts_, and vehicle_vars_
if costs aren't homogeneous across vehicles) of "this" model, with the
values set according to those in "other_assignment".
The objective_element of target_assignment is set to this->cost_.</p>
</div>


                            </div>
                            <div id="RoutingModel.ComputeLowerBound" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.ComputeLowerBound">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ComputeLowerBound</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ComputeLowerBound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes a lower bound to the routing problem solving a linear assignment</span>
<span class="sd">        problem. The routing model must be closed before calling this method.</span>
<span class="sd">        Note that problems with node disjunction constraints (including optional</span>
<span class="sd">        nodes) and non-homogenous costs are not supported (the method returns 0 in</span>
<span class="sd">        these cases).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_ComputeLowerBound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Computes a lower bound to the routing problem solving a linear assignment
problem. The routing model must be closed before calling this method.
Note that problems with node disjunction constraints (including optional
nodes) and non-homogenous costs are not supported (the method returns 0 in
these cases).</p>
</div>


                            </div>
                            <div id="RoutingModel.status" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.status">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">status</span><span class="signature">(self) -&gt; &#39;operations_research::RoutingModel::Status&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">status</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingModel::Status&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the current status of the routing model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_status</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the current status of the routing model.</p>
</div>


                            </div>
                            <div id="RoutingModel.ApplyLocks" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.ApplyLocks">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ApplyLocks</span><span class="signature">(
    self,
    locks: &#39;std::vector&lt; int64_t &gt; const &amp;&#39;
) -&gt; &#39;operations_research::IntVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ApplyLocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locks</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies a lock chain to the next search. &#39;locks&#39; represents an ordered</span>
<span class="sd">        vector of nodes representing a partial route which will be fixed during</span>
<span class="sd">        the next search; it will constrain next variables such that:</span>
<span class="sd">        next[locks[i]] == locks[i+1].</span>

<span class="sd">        Returns the next variable at the end of the locked chain; this variable is</span>
<span class="sd">        not locked. An assignment containing the locks can be obtained by calling</span>
<span class="sd">        PreAssignment().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_ApplyLocks</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locks</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Applies a lock chain to the next search. 'locks' represents an ordered
vector of nodes representing a partial route which will be fixed during
the next search; it will constrain next variables such that:
next[locks[i]] == locks[i+1].</p>

<p>Returns the next variable at the end of the locked chain; this variable is
not locked. An assignment containing the locks can be obtained by calling
PreAssignment().</p>
</div>


                            </div>
                            <div id="RoutingModel.ApplyLocksToAllVehicles" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.ApplyLocksToAllVehicles">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ApplyLocksToAllVehicles</span><span class="signature">(
    self,
    locks: &#39;std::vector&lt; std::vector&lt; int64_t &gt; &gt; const &amp;&#39;,
    close_routes: bool
) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ApplyLocksToAllVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locks</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; std::vector&lt; int64_t &gt; &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">close_routes</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Applies lock chains to all vehicles to the next search, such that locks[p]</span>
<span class="sd">        is the lock chain for route p. Returns false if the locks do not contain</span>
<span class="sd">        valid routes; expects that the routes do not contain the depots,</span>
<span class="sd">        i.e. there are empty vectors in place of empty routes.</span>
<span class="sd">        If close_routes is set to true, adds the end nodes to the route of each</span>
<span class="sd">        vehicle and deactivates other nodes.</span>
<span class="sd">        An assignment containing the locks can be obtained by calling</span>
<span class="sd">        PreAssignment().</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_ApplyLocksToAllVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">locks</span><span class="p">,</span> <span class="n">close_routes</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Applies lock chains to all vehicles to the next search, such that locks[p]
is the lock chain for route p. Returns false if the locks do not contain
valid routes; expects that the routes do not contain the depots,
i.e. there are empty vectors in place of empty routes.
If close_routes is set to true, adds the end nodes to the route of each
vehicle and deactivates other nodes.
An assignment containing the locks can be obtained by calling
PreAssignment().</p>
</div>


                            </div>
                            <div id="RoutingModel.PreAssignment" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.PreAssignment">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">PreAssignment</span><span class="signature">(self) -&gt; &#39;operations_research::Assignment const *const&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">PreAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment const *const&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns an assignment used to fix some of the variables of the problem.</span>
<span class="sd">        In practice, this assignment locks partial routes of the problem. This</span>
<span class="sd">        can be used in the context of locking the parts of the routes which have</span>
<span class="sd">        already been driven in online routing problems.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_PreAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns an assignment used to fix some of the variables of the problem.
In practice, this assignment locks partial routes of the problem. This
can be used in the context of locking the parts of the routes which have
already been driven in online routing problems.</p>
</div>


                            </div>
                            <div id="RoutingModel.MutablePreAssignment" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.MutablePreAssignment">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">MutablePreAssignment</span><span class="signature">(self) -&gt; &#39;operations_research::Assignment *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">MutablePreAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_MutablePreAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingModel.WriteAssignment" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.WriteAssignment">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">WriteAssignment</span><span class="signature">(self, file_name: &#39;std::string const &amp;&#39;) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">WriteAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes the current solution to a file containing an AssignmentProto.</span>
<span class="sd">        Returns false if the file cannot be opened or if there is no current</span>
<span class="sd">        solution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_WriteAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Writes the current solution to a file containing an AssignmentProto.
Returns false if the file cannot be opened or if there is no current
solution.</p>
</div>


                            </div>
                            <div id="RoutingModel.ReadAssignment" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.ReadAssignment">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ReadAssignment</span><span class="signature">(
    self,
    file_name: &#39;std::string const &amp;&#39;
) -&gt; &#39;operations_research::Assignment *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ReadAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Reads an assignment from a file and returns the current solution.</span>
<span class="sd">        Returns nullptr if the file cannot be opened or if the assignment is not</span>
<span class="sd">        valid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_ReadAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">file_name</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Reads an assignment from a file and returns the current solution.
Returns nullptr if the file cannot be opened or if the assignment is not
valid.</p>
</div>


                            </div>
                            <div id="RoutingModel.RestoreAssignment" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.RestoreAssignment">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">RestoreAssignment</span><span class="signature">(
    self,
    solution: <a href="#Assignment">pywrapcp.Assignment</a>
) -&gt; &#39;operations_research::Assignment *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">RestoreAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solution</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Restores an assignment as a solution in the routing model and returns the</span>
<span class="sd">        new solution. Returns nullptr if the assignment is not valid.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_RestoreAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solution</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Restores an assignment as a solution in the routing model and returns the
new solution. Returns nullptr if the assignment is not valid.</p>
</div>


                            </div>
                            <div id="RoutingModel.ReadAssignmentFromRoutes" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.ReadAssignmentFromRoutes">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ReadAssignmentFromRoutes</span><span class="signature">(
    self,
    routes: &#39;std::vector&lt; std::vector&lt; int64_t &gt; &gt; const &amp;&#39;,
    ignore_inactive_indices: bool
) -&gt; &#39;operations_research::Assignment *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ReadAssignmentFromRoutes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">routes</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; std::vector&lt; int64_t &gt; &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">ignore_inactive_indices</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Restores the routes as the current solution. Returns nullptr if the</span>
<span class="sd">        solution cannot be restored (routes do not contain a valid solution). Note</span>
<span class="sd">        that calling this method will run the solver to assign values to the</span>
<span class="sd">        dimension variables; this may take considerable amount of time, especially</span>
<span class="sd">        when using dimensions with slack.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_ReadAssignmentFromRoutes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">routes</span><span class="p">,</span> <span class="n">ignore_inactive_indices</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Restores the routes as the current solution. Returns nullptr if the
solution cannot be restored (routes do not contain a valid solution). Note
that calling this method will run the solver to assign values to the
dimension variables; this may take considerable amount of time, especially
when using dimensions with slack.</p>
</div>


                            </div>
                            <div id="RoutingModel.RoutesToAssignment" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.RoutesToAssignment">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">RoutesToAssignment</span><span class="signature">(
    self,
    routes: &#39;std::vector&lt; std::vector&lt; int64_t &gt; &gt; const &amp;&#39;,
    ignore_inactive_indices: bool,
    close_routes: bool,
    assignment: <a href="#Assignment">pywrapcp.Assignment</a>
) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">RoutesToAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">routes</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; std::vector&lt; int64_t &gt; &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">ignore_inactive_indices</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">close_routes</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Fills an assignment from a specification of the routes of the</span>
<span class="sd">        vehicles. The routes are specified as lists of variable indices that</span>
<span class="sd">        appear on the routes of the vehicles. The indices of the outer vector in</span>
<span class="sd">        &#39;routes&#39; correspond to vehicles IDs, the inner vector contains the</span>
<span class="sd">        variable indices on the routes for the given vehicle. The inner vectors</span>
<span class="sd">        must not contain the start and end indices, as these are determined by the</span>
<span class="sd">        routing model.  Sets the value of NextVars in the assignment, adding the</span>
<span class="sd">        variables to the assignment if necessary. The method does not touch other</span>
<span class="sd">        variables in the assignment. The method can only be called after the model</span>
<span class="sd">        is closed.  With ignore_inactive_indices set to false, this method will</span>
<span class="sd">        fail (return nullptr) in case some of the route contain indices that are</span>
<span class="sd">        deactivated in the model; when set to true, these indices will be</span>
<span class="sd">        skipped.  Returns true if routes were successfully</span>
<span class="sd">        loaded. However, such assignment still might not be a valid</span>
<span class="sd">        solution to the routing problem due to more complex constraints;</span>
<span class="sd">        it is advisible to call solver()-&gt;CheckSolution() afterwards.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_RoutesToAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">routes</span><span class="p">,</span> <span class="n">ignore_inactive_indices</span><span class="p">,</span> <span class="n">close_routes</span><span class="p">,</span> <span class="n">assignment</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Fills an assignment from a specification of the routes of the
vehicles. The routes are specified as lists of variable indices that
appear on the routes of the vehicles. The indices of the outer vector in
'routes' correspond to vehicles IDs, the inner vector contains the
variable indices on the routes for the given vehicle. The inner vectors
must not contain the start and end indices, as these are determined by the
routing model.  Sets the value of NextVars in the assignment, adding the
variables to the assignment if necessary. The method does not touch other
variables in the assignment. The method can only be called after the model
is closed.  With ignore_inactive_indices set to false, this method will
fail (return nullptr) in case some of the route contain indices that are
deactivated in the model; when set to true, these indices will be
skipped.  Returns true if routes were successfully
loaded. However, such assignment still might not be a valid
solution to the routing problem due to more complex constraints;
it is advisible to call solver()->CheckSolution() afterwards.</p>
</div>


                            </div>
                            <div id="RoutingModel.AssignmentToRoutes" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.AssignmentToRoutes">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AssignmentToRoutes</span><span class="signature">(
    self,
    assignment: <a href="#Assignment">pywrapcp.Assignment</a>,
    routes: &#39;std::vector&lt; std::vector&lt; int64_t &gt; &gt; *const&#39;
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AssignmentToRoutes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">routes</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; std::vector&lt; int64_t &gt; &gt; *const&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts the solution in the given assignment to routes for all vehicles.</span>
<span class="sd">        Expects that assignment contains a valid solution (i.e. routes for all</span>
<span class="sd">        vehicles end with an end index for that vehicle).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AssignmentToRoutes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">,</span> <span class="n">routes</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Converts the solution in the given assignment to routes for all vehicles.
Expects that assignment contains a valid solution (i.e. routes for all
vehicles end with an end index for that vehicle).</p>
</div>


                            </div>
                            <div id="RoutingModel.CompactAssignment" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.CompactAssignment">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">CompactAssignment</span><span class="signature">(
    self,
    assignment: <a href="#Assignment">pywrapcp.Assignment</a>
) -&gt; &#39;operations_research::Assignment *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">CompactAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Converts the solution in the given assignment to routes for all vehicles.</span>
<span class="sd">        If the returned vector is route_indices, route_indices[i][j] is the index</span>
<span class="sd">        for jth location visited on route i. Note that contrary to</span>
<span class="sd">        AssignmentToRoutes, the vectors do include start and end locations.</span>
<span class="sd">        Returns a compacted version of the given assignment, in which all vehicles</span>
<span class="sd">        with id lower or equal to some N have non-empty routes, and all vehicles</span>
<span class="sd">        with id greater than N have empty routes. Does not take ownership of the</span>
<span class="sd">        returned object.</span>
<span class="sd">        If found, the cost of the compact assignment is the same as in the</span>
<span class="sd">        original assignment and it preserves the values of &#39;active&#39; variables.</span>
<span class="sd">        Returns nullptr if a compact assignment was not found.</span>
<span class="sd">        This method only works in homogenous mode, and it only swaps equivalent</span>
<span class="sd">        vehicles (vehicles with the same start and end nodes). When creating the</span>
<span class="sd">        compact assignment, the empty plan is replaced by the route assigned to</span>
<span class="sd">        the compatible vehicle with the highest id. Note that with more complex</span>
<span class="sd">        constraints on vehicle variables, this method might fail even if a compact</span>
<span class="sd">        solution exists.</span>
<span class="sd">        This method changes the vehicle and dimension variables as necessary.</span>
<span class="sd">        While compacting the solution, only basic checks on vehicle variables are</span>
<span class="sd">        performed; if one of these checks fails no attempts to repair it are made</span>
<span class="sd">        (instead, the method returns nullptr).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_CompactAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Converts the solution in the given assignment to routes for all vehicles.
If the returned vector is route_indices, route_indices[i][j] is the index
for jth location visited on route i. Note that contrary to
AssignmentToRoutes, the vectors do include start and end locations.
Returns a compacted version of the given assignment, in which all vehicles
with id lower or equal to some N have non-empty routes, and all vehicles
with id greater than N have empty routes. Does not take ownership of the
returned object.
If found, the cost of the compact assignment is the same as in the
original assignment and it preserves the values of 'active' variables.
Returns nullptr if a compact assignment was not found.
This method only works in homogenous mode, and it only swaps equivalent
vehicles (vehicles with the same start and end nodes). When creating the
compact assignment, the empty plan is replaced by the route assigned to
the compatible vehicle with the highest id. Note that with more complex
constraints on vehicle variables, this method might fail even if a compact
solution exists.
This method changes the vehicle and dimension variables as necessary.
While compacting the solution, only basic checks on vehicle variables are
performed; if one of these checks fails no attempts to repair it are made
(instead, the method returns nullptr).</p>
</div>


                            </div>
                            <div id="RoutingModel.CompactAndCheckAssignment" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.CompactAndCheckAssignment">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">CompactAndCheckAssignment</span><span class="signature">(
    self,
    assignment: <a href="#Assignment">pywrapcp.Assignment</a>
) -&gt; &#39;operations_research::Assignment *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">CompactAndCheckAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as CompactAssignment() but also checks the validity of the final</span>
<span class="sd">        compact solution; if it is not valid, no attempts to repair it are made</span>
<span class="sd">        (instead, the method returns nullptr).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_CompactAndCheckAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Same as CompactAssignment() but also checks the validity of the final
compact solution; if it is not valid, no attempts to repair it are made
(instead, the method returns nullptr).</p>
</div>


                            </div>
                            <div id="RoutingModel.AddToAssignment" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.AddToAssignment">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddToAssignment</span><span class="signature">(self, var: <a href="#IntVar">pywrapcp.IntVar</a>) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddToAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;IntVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Adds an extra variable to the vehicle routing assignment.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddToAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds an extra variable to the vehicle routing assignment.</p>
</div>


                            </div>
                            <div id="RoutingModel.AddIntervalToAssignment" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.AddIntervalToAssignment">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddIntervalToAssignment</span><span class="signature">(self, interval: <a href="#IntervalVar">pywrapcp.IntervalVar</a>) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddIntervalToAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval</span><span class="p">:</span> <span class="s2">&quot;IntervalVar&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddIntervalToAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">interval</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingModel.PackCumulsOfOptimizerDimensionsFromAssignment" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.PackCumulsOfOptimizerDimensionsFromAssignment">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">PackCumulsOfOptimizerDimensionsFromAssignment</span><span class="signature">(
    self,
    original_assignment: <a href="#Assignment">pywrapcp.Assignment</a>,
    duration_limit: &#39;absl::Duration&#39;
) -&gt; &#39;operations_research::Assignment const *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">PackCumulsOfOptimizerDimensionsFromAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">original_assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">duration_limit</span><span class="p">:</span> <span class="s2">&quot;absl::Duration&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Assignment const *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        For every dimension in the model with an optimizer in</span>
<span class="sd">        local/global_dimension_optimizers_, this method tries to pack the cumul</span>
<span class="sd">        values of the dimension, such that:</span>
<span class="sd">        - The cumul costs (span costs, soft lower and upper bound costs, etc) are</span>
<span class="sd">          minimized.</span>
<span class="sd">        - The cumuls of the ends of the routes are minimized for this given</span>
<span class="sd">          minimal cumul cost.</span>
<span class="sd">        - Given these minimal end cumuls, the route start cumuls are maximized.</span>
<span class="sd">        Returns the assignment resulting from allocating these packed cumuls with</span>
<span class="sd">        the solver, and nullptr if these cumuls could not be set by the solver.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_PackCumulsOfOptimizerDimensionsFromAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">original_assignment</span><span class="p">,</span> <span class="n">duration_limit</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>For every dimension in the model with an optimizer in
local/global_dimension_optimizers_, this method tries to pack the cumul
values of the dimension, such that:</p>

<ul>
<li>The cumul costs (span costs, soft lower and upper bound costs, etc) are
minimized.</li>
<li>The cumuls of the ends of the routes are minimized for this given
minimal cumul cost.</li>
<li>Given these minimal end cumuls, the route start cumuls are maximized.
Returns the assignment resulting from allocating these packed cumuls with
the solver, and nullptr if these cumuls could not be set by the solver.</li>
</ul>
</div>


                            </div>
                            <div id="RoutingModel.AddLocalSearchFilter" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.AddLocalSearchFilter">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddLocalSearchFilter</span><span class="signature">(self, filter: <a href="#LocalSearchFilter">pywrapcp.LocalSearchFilter</a>) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddLocalSearchFilter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">filter</span><span class="p">:</span> <span class="s2">&quot;LocalSearchFilter&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a custom local search filter to the list of filters used to speed up</span>
<span class="sd">        local search by pruning unfeasible variable assignments.</span>
<span class="sd">        Calling this method after the routing model has been closed (CloseModel()</span>
<span class="sd">        or Solve() has been called) has no effect.</span>
<span class="sd">        The routing model does not take ownership of the filter.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_AddLocalSearchFilter</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="nb">filter</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Adds a custom local search filter to the list of filters used to speed up
local search by pruning unfeasible variable assignments.
Calling this method after the routing model has been closed (CloseModel()
or Solve() has been called) has no effect.
The routing model does not take ownership of the filter.</p>
</div>


                            </div>
                            <div id="RoutingModel.Start" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.Start">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Start</span><span class="signature">(self, vehicle: int) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Model inspection.</span>
<span class="sd">        Returns the variable index of the starting node of a vehicle route.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_Start</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Model inspection.
Returns the variable index of the starting node of a vehicle route.</p>
</div>


                            </div>
                            <div id="RoutingModel.End" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.End">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">End</span><span class="signature">(self, vehicle: int) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">End</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the variable index of the ending node of a vehicle route.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_End</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the variable index of the ending node of a vehicle route.</p>
</div>


                            </div>
                            <div id="RoutingModel.IsStart" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.IsStart">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsStart</span><span class="signature">(self, index: &#39;int64_t&#39;) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsStart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns true if &#39;index&#39; represents the first node of a route.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_IsStart</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns true if 'index' represents the first node of a route.</p>
</div>


                            </div>
                            <div id="RoutingModel.IsEnd" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.IsEnd">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsEnd</span><span class="signature">(self, index: &#39;int64_t&#39;) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsEnd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns true if &#39;index&#39; represents the last node of a route.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_IsEnd</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns true if 'index' represents the last node of a route.</p>
</div>


                            </div>
                            <div id="RoutingModel.VehicleIndex" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.VehicleIndex">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">VehicleIndex</span><span class="signature">(self, index: &#39;int64_t&#39;) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">VehicleIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the vehicle of the given start/end index, and -1 if the given</span>
<span class="sd">        index is not a vehicle start/end.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_VehicleIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the vehicle of the given start/end index, and -1 if the given
index is not a vehicle start/end.</p>
</div>


                            </div>
                            <div id="RoutingModel.Next" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.Next">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Next</span><span class="signature">(self, assignment: <a href="#Assignment">pywrapcp.Assignment</a>, index: &#39;int64_t&#39;) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Next</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Assignment inspection</span>
<span class="sd">        Returns the variable index of the node directly after the node</span>
<span class="sd">        corresponding to &#39;index&#39; in &#39;assignment&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_Next</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Assignment inspection
Returns the variable index of the node directly after the node
corresponding to 'index' in 'assignment'.</p>
</div>


                            </div>
                            <div id="RoutingModel.IsVehicleUsed" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.IsVehicleUsed">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsVehicleUsed</span><span class="signature">(self, assignment: <a href="#Assignment">pywrapcp.Assignment</a>, vehicle: int) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsVehicleUsed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns true if the route of &#39;vehicle&#39; is non empty in &#39;assignment&#39;.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_IsVehicleUsed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">assignment</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns true if the route of 'vehicle' is non empty in 'assignment'.</p>
</div>


                            </div>
                            <div id="RoutingModel.NextVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.NextVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">NextVar</span><span class="signature">(self, index: &#39;int64_t&#39;) -&gt; &#39;operations_research::IntVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">NextVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the next variable of the node corresponding to index. Note that</span>
<span class="sd">        NextVar(index) == index is equivalent to ActiveVar(index) == 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_NextVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the next variable of the node corresponding to index. Note that
NextVar(index) == index is equivalent to ActiveVar(index) == 0.</p>
</div>


                            </div>
                            <div id="RoutingModel.ActiveVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.ActiveVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ActiveVar</span><span class="signature">(self, index: &#39;int64_t&#39;) -&gt; &#39;operations_research::IntVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ActiveVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the active variable of the node corresponding to index.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_ActiveVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the active variable of the node corresponding to index.</p>
</div>


                            </div>
                            <div id="RoutingModel.ActiveVehicleVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.ActiveVehicleVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ActiveVehicleVar</span><span class="signature">(self, vehicle: int) -&gt; &#39;operations_research::IntVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ActiveVehicleVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the active variable of the vehicle. It will be equal to 1 iff the</span>
<span class="sd">        route of the vehicle is not empty, 0 otherwise.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_ActiveVehicleVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the active variable of the vehicle. It will be equal to 1 iff the
route of the vehicle is not empty, 0 otherwise.</p>
</div>


                            </div>
                            <div id="RoutingModel.VehicleCostsConsideredVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.VehicleCostsConsideredVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">VehicleCostsConsideredVar</span><span class="signature">(self, vehicle: int) -&gt; &#39;operations_research::IntVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">VehicleCostsConsideredVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the variable specifying whether or not costs are considered for</span>
<span class="sd">        vehicle.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_VehicleCostsConsideredVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the variable specifying whether or not costs are considered for
vehicle.</p>
</div>


                            </div>
                            <div id="RoutingModel.VehicleVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.VehicleVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">VehicleVar</span><span class="signature">(self, index: &#39;int64_t&#39;) -&gt; &#39;operations_research::IntVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">VehicleVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the vehicle variable of the node corresponding to index. Note that</span>
<span class="sd">        VehicleVar(index) == -1 is equivalent to ActiveVar(index) == 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_VehicleVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the vehicle variable of the node corresponding to index. Note that
VehicleVar(index) == -1 is equivalent to ActiveVar(index) == 0.</p>
</div>


                            </div>
                            <div id="RoutingModel.CostVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.CostVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">CostVar</span><span class="signature">(self) -&gt; &#39;operations_research::IntVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">CostVar</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the global cost variable which is being minimized.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_CostVar</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the global cost variable which is being minimized.</p>
</div>


                            </div>
                            <div id="RoutingModel.GetArcCostForVehicle" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetArcCostForVehicle">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetArcCostForVehicle</span><span class="signature">(
    self,
    from_index: &#39;int64_t&#39;,
    to_index: &#39;int64_t&#39;,
    vehicle: &#39;int64_t&#39;
) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetArcCostForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">to_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the cost of the transit arc between two nodes for a given vehicle.</span>
<span class="sd">        Input are variable indices of node. This returns 0 if vehicle &lt; 0.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetArcCostForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_index</span><span class="p">,</span> <span class="n">to_index</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the cost of the transit arc between two nodes for a given vehicle.
Input are variable indices of node. This returns 0 if vehicle &lt; 0.</p>
</div>


                            </div>
                            <div id="RoutingModel.CostsAreHomogeneousAcrossVehicles" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.CostsAreHomogeneousAcrossVehicles">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">CostsAreHomogeneousAcrossVehicles</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">CostsAreHomogeneousAcrossVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Whether costs are homogeneous across all vehicles.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_CostsAreHomogeneousAcrossVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Whether costs are homogeneous across all vehicles.</p>
</div>


                            </div>
                            <div id="RoutingModel.GetHomogeneousCost" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetHomogeneousCost">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetHomogeneousCost</span><span class="signature">(self, from_index: &#39;int64_t&#39;, to_index: &#39;int64_t&#39;) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetHomogeneousCost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">to_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the cost of the segment between two nodes supposing all vehicle</span>
<span class="sd">        costs are the same (returns the cost for the first vehicle otherwise).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetHomogeneousCost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_index</span><span class="p">,</span> <span class="n">to_index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the cost of the segment between two nodes supposing all vehicle
costs are the same (returns the cost for the first vehicle otherwise).</p>
</div>


                            </div>
                            <div id="RoutingModel.GetArcCostForFirstSolution" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetArcCostForFirstSolution">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetArcCostForFirstSolution</span><span class="signature">(self, from_index: &#39;int64_t&#39;, to_index: &#39;int64_t&#39;) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetArcCostForFirstSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">to_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the cost of the arc in the context of the first solution strategy.</span>
<span class="sd">        This is typically a simplification of the actual cost; see the .cc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetArcCostForFirstSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_index</span><span class="p">,</span> <span class="n">to_index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the cost of the arc in the context of the first solution strategy.
This is typically a simplification of the actual cost; see the .cc.</p>
</div>


                            </div>
                            <div id="RoutingModel.GetArcCostForClass" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetArcCostForClass">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetArcCostForClass</span><span class="signature">(
    self,
    from_index: &#39;int64_t&#39;,
    to_index: &#39;int64_t&#39;,
    cost_class_index: &#39;int64_t&#39;
) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetArcCostForClass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">to_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">cost_class_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the cost of the segment between two nodes for a given cost</span>
<span class="sd">        class. Input are variable indices of nodes and the cost class.</span>
<span class="sd">        Unlike GetArcCostForVehicle(), if cost_class is kNoCost, then the</span>
<span class="sd">        returned cost won&#39;t necessarily be zero: only some of the components</span>
<span class="sd">        of the cost that depend on the cost class will be omited. See the code</span>
<span class="sd">        for details.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetArcCostForClass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_index</span><span class="p">,</span> <span class="n">to_index</span><span class="p">,</span> <span class="n">cost_class_index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the cost of the segment between two nodes for a given cost
class. Input are variable indices of nodes and the cost class.
Unlike GetArcCostForVehicle(), if cost_class is kNoCost, then the
returned cost won't necessarily be zero: only some of the components
of the cost that depend on the cost class will be omited. See the code
for details.</p>
</div>


                            </div>
                            <div id="RoutingModel.GetCostClassIndexOfVehicle" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetCostClassIndexOfVehicle">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetCostClassIndexOfVehicle</span><span class="signature">(
    self,
    vehicle: &#39;int64_t&#39;
) -&gt; &#39;operations_research::RoutingModel::CostClassIndex&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetCostClassIndexOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingModel::CostClassIndex&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Get the cost class index of the given vehicle.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetCostClassIndexOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Get the cost class index of the given vehicle.</p>
</div>


                            </div>
                            <div id="RoutingModel.HasVehicleWithCostClassIndex" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.HasVehicleWithCostClassIndex">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">HasVehicleWithCostClassIndex</span><span class="signature">(
    self,
    cost_class_index: &#39;operations_research::RoutingModel::CostClassIndex&#39;
) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">HasVehicleWithCostClassIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cost_class_index</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingModel::CostClassIndex&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns true iff the model contains a vehicle with the given</span>
<span class="sd">        cost_class_index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_HasVehicleWithCostClassIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cost_class_index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns true iff the model contains a vehicle with the given
cost_class_index.</p>
</div>


                            </div>
                            <div id="RoutingModel.GetCostClassesCount" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetCostClassesCount">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetCostClassesCount</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetCostClassesCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the number of different cost classes in the model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetCostClassesCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the number of different cost classes in the model.</p>
</div>


                            </div>
                            <div id="RoutingModel.GetNonZeroCostClassesCount" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetNonZeroCostClassesCount">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetNonZeroCostClassesCount</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetNonZeroCostClassesCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Ditto, minus the &#39;always zero&#39;, built-in cost class.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetNonZeroCostClassesCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Ditto, minus the 'always zero', built-in cost class.</p>
</div>


                            </div>
                            <div id="RoutingModel.GetVehicleClassIndexOfVehicle" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetVehicleClassIndexOfVehicle">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetVehicleClassIndexOfVehicle</span><span class="signature">(
    self,
    vehicle: &#39;int64_t&#39;
) -&gt; &#39;operations_research::RoutingModel::VehicleClassIndex&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetVehicleClassIndexOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingModel::VehicleClassIndex&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetVehicleClassIndexOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingModel.GetVehicleOfClass" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetVehicleOfClass">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetVehicleOfClass</span><span class="signature">(
    self,
    vehicle_class: &#39;operations_research::RoutingModel::VehicleClassIndex&#39;
) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetVehicleOfClass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle_class</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingModel::VehicleClassIndex&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a vehicle of the given vehicle class, and -1 if there are no</span>
<span class="sd">        vehicles for this class.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetVehicleOfClass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle_class</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns a vehicle of the given vehicle class, and -1 if there are no
vehicles for this class.</p>
</div>


                            </div>
                            <div id="RoutingModel.GetVehicleClassesCount" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetVehicleClassesCount">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetVehicleClassesCount</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetVehicleClassesCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the number of different vehicle classes in the model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetVehicleClassesCount</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the number of different vehicle classes in the model.</p>
</div>


                            </div>
                            <div id="RoutingModel.GetSameVehicleIndicesOfIndex" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetSameVehicleIndicesOfIndex">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetSameVehicleIndicesOfIndex</span><span class="signature">(self, node: int) -&gt; &#39;std::vector&lt; int &gt; const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetSameVehicleIndicesOfIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; int &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns variable indices of nodes constrained to be on the same route.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetSameVehicleIndicesOfIndex</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns variable indices of nodes constrained to be on the same route.</p>
</div>


                            </div>
                            <div id="RoutingModel.GetVehicleTypeContainer" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetVehicleTypeContainer">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetVehicleTypeContainer</span><span class="signature">(
    self
) -&gt; &#39;operations_research::RoutingModel::VehicleTypeContainer const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetVehicleTypeContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingModel::VehicleTypeContainer const &amp;&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetVehicleTypeContainer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingModel.ArcIsMoreConstrainedThanArc" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.ArcIsMoreConstrainedThanArc">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ArcIsMoreConstrainedThanArc</span><span class="signature">(self, _from: &#39;int64_t&#39;, to1: &#39;int64_t&#39;, to2: &#39;int64_t&#39;) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ArcIsMoreConstrainedThanArc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_from</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">to1</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">to2</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns whether the arc from-&gt;to1 is more constrained than from-&gt;to2,</span>
<span class="sd">        taking into account, in order:</span>
<span class="sd">        - whether the destination node isn&#39;t an end node</span>
<span class="sd">        - whether the destination node is mandatory</span>
<span class="sd">        - whether the destination node is bound to the same vehicle as the source</span>
<span class="sd">        - the &quot;primary constrained&quot; dimension (see SetPrimaryConstrainedDimension)</span>
<span class="sd">        It then breaks ties using, in order:</span>
<span class="sd">        - the arc cost (taking unperformed penalties into account)</span>
<span class="sd">        - the size of the vehicle vars of &quot;to1&quot; and &quot;to2&quot; (lowest size wins)</span>
<span class="sd">        - the value: the lowest value of the indices to1 and to2 wins.</span>
<span class="sd">        See the .cc for details.</span>
<span class="sd">        The more constrained arc is typically preferable when building a</span>
<span class="sd">        first solution. This method is intended to be used as a callback for the</span>
<span class="sd">        BestValueByComparisonSelector value selector.</span>
<span class="sd">        Args:</span>
<span class="sd">          from: the variable index of the source node</span>
<span class="sd">          to1: the variable index of the first candidate destination node.</span>
<span class="sd">          to2: the variable index of the second candidate destination node.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_ArcIsMoreConstrainedThanArc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_from</span><span class="p">,</span> <span class="n">to1</span><span class="p">,</span> <span class="n">to2</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns whether the arc from->to1 is more constrained than from->to2,
taking into account, in order:</p>

<ul>
<li>whether the destination node isn't an end node</li>
<li>whether the destination node is mandatory</li>
<li>whether the destination node is bound to the same vehicle as the source</li>
<li>the "primary constrained" dimension (see SetPrimaryConstrainedDimension)
It then breaks ties using, in order:</li>
<li>the arc cost (taking unperformed penalties into account)</li>
<li>the size of the vehicle vars of "to1" and "to2" (lowest size wins)</li>
<li>the value: the lowest value of the indices to1 and to2 wins.
See the .cc for details.
The more constrained arc is typically preferable when building a
first solution. This method is intended to be used as a callback for the
BestValueByComparisonSelector value selector.</li>
</ul>

<h6 id="args">Args</h6>

<ul>
<li><strong>from:</strong>  the variable index of the source node</li>
<li><strong>to1:</strong>  the variable index of the first candidate destination node.</li>
<li><strong>to2:</strong>  the variable index of the second candidate destination node.</li>
</ul>
</div>


                            </div>
                            <div id="RoutingModel.DebugOutputAssignment" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.DebugOutputAssignment">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DebugOutputAssignment</span><span class="signature">(
    self,
    solution_assignment: <a href="#Assignment">pywrapcp.Assignment</a>,
    dimension_to_print: &#39;std::string const &amp;&#39;
) -&gt; &#39;std::string&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">DebugOutputAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solution_assignment</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">dimension_to_print</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Print some debugging information about an assignment, including the</span>
<span class="sd">        feasible intervals of the CumulVar for dimension &quot;dimension_to_print&quot;</span>
<span class="sd">        at each step of the routes.</span>
<span class="sd">        If &quot;dimension_to_print&quot; is omitted, all dimensions will be printed.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_DebugOutputAssignment</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">solution_assignment</span><span class="p">,</span> <span class="n">dimension_to_print</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Print some debugging information about an assignment, including the
feasible intervals of the CumulVar for dimension "dimension_to_print"
at each step of the routes.
If "dimension_to_print" is omitted, all dimensions will be printed.</p>
</div>


                            </div>
                            <div id="RoutingModel.solver" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.solver">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">solver</span><span class="signature">(self) -&gt; &#39;operations_research::Solver *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">solver</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::Solver *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a vector cumul_bounds, for which cumul_bounds[i][j] is a pair</span>
<span class="sd">        containing the minimum and maximum of the CumulVar of the jth node on</span>
<span class="sd">        route i.</span>
<span class="sd">        - cumul_bounds[i][j].first is the minimum.</span>
<span class="sd">        - cumul_bounds[i][j].second is the maximum.</span>
<span class="sd">        Returns the underlying constraint solver. Can be used to add extra</span>
<span class="sd">        constraints and/or modify search algorithms.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_solver</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns a vector cumul_bounds, for which cumul_bounds[i][j] is a pair
containing the minimum and maximum of the CumulVar of the jth node on
route i.</p>

<ul>
<li>cumul_bounds[i][j].first is the minimum.</li>
<li>cumul_bounds[i][j].second is the maximum.
Returns the underlying constraint solver. Can be used to add extra
constraints and/or modify search algorithms.</li>
</ul>
</div>


                            </div>
                            <div id="RoutingModel.CheckLimit" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.CheckLimit">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">CheckLimit</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">CheckLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns true if the search limit has been crossed.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_CheckLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns true if the search limit has been crossed.</p>
</div>


                            </div>
                            <div id="RoutingModel.RemainingTime" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.RemainingTime">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">RemainingTime</span><span class="signature">(self) -&gt; &#39;absl::Duration&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">RemainingTime</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;absl::Duration&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the time left in the search limit.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_RemainingTime</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the time left in the search limit.</p>
</div>


                            </div>
                            <div id="RoutingModel.nodes" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.nodes">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">nodes</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sizes and indices</span>
<span class="sd">        Returns the number of nodes in the model.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Sizes and indices
Returns the number of nodes in the model.</p>
</div>


                            </div>
                            <div id="RoutingModel.vehicles" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.vehicles">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">vehicles</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">vehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the number of vehicle routes in the model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_vehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the number of vehicle routes in the model.</p>
</div>


                            </div>
                            <div id="RoutingModel.Size" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.Size">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Size</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the number of next variables in the model.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_Size</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the number of next variables in the model.</p>
</div>


                            </div>
                            <div id="RoutingModel.GetNumberOfDecisionsInFirstSolution" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetNumberOfDecisionsInFirstSolution">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetNumberOfDecisionsInFirstSolution</span><span class="signature">(
    self,
    search_parameters: &#39;operations_research::RoutingSearchParameters const &amp;&#39;
) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetNumberOfDecisionsInFirstSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">search_parameters</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingSearchParameters const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns statistics on first solution search, number of decisions sent to</span>
<span class="sd">        filters, number of decisions rejected by filters.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetNumberOfDecisionsInFirstSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">search_parameters</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns statistics on first solution search, number of decisions sent to
filters, number of decisions rejected by filters.</p>
</div>


                            </div>
                            <div id="RoutingModel.GetNumberOfRejectsInFirstSolution" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetNumberOfRejectsInFirstSolution">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetNumberOfRejectsInFirstSolution</span><span class="signature">(
    self,
    search_parameters: &#39;operations_research::RoutingSearchParameters const &amp;&#39;
) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetNumberOfRejectsInFirstSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">search_parameters</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingSearchParameters const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetNumberOfRejectsInFirstSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">search_parameters</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingModel.GetAutomaticFirstSolutionStrategy" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.GetAutomaticFirstSolutionStrategy">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetAutomaticFirstSolutionStrategy</span><span class="signature">(self) -&gt; &#39;operations_research::FirstSolutionStrategy::Value&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetAutomaticFirstSolutionStrategy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::FirstSolutionStrategy::Value&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the automatic first solution strategy selected.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_GetAutomaticFirstSolutionStrategy</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the automatic first solution strategy selected.</p>
</div>


                            </div>
                            <div id="RoutingModel.IsMatchingModel" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.IsMatchingModel">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IsMatchingModel</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IsMatchingModel</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns true if a vehicle/node matching problem is detected.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_IsMatchingModel</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns true if a vehicle/node matching problem is detected.</p>
</div>


                            </div>
                            <div id="RoutingModel.MakeGuidedSlackFinalizer" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.MakeGuidedSlackFinalizer">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">MakeGuidedSlackFinalizer</span><span class="signature">(
    self,
    dimension: <a href="#RoutingDimension">pywrapcp.RoutingDimension</a>,
    initializer: &#39;std::function&lt; int64_t (int64_t) &gt;&#39;
) -&gt; &#39;operations_research::DecisionBuilder *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">MakeGuidedSlackFinalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="s2">&quot;RoutingDimension&quot;</span><span class="p">,</span> <span class="n">initializer</span><span class="p">:</span> <span class="s2">&quot;std::function&lt; int64_t (int64_t) &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        The next few members are in the public section only for testing purposes.</span>

<span class="sd">        MakeGuidedSlackFinalizer creates a DecisionBuilder for the slacks of a</span>
<span class="sd">        dimension using a callback to choose which values to start with.</span>
<span class="sd">        The finalizer works only when all next variables in the model have</span>
<span class="sd">        been fixed. It has the following two characteristics:</span>
<span class="sd">        1. It follows the routes defined by the nexts variables when choosing a</span>
<span class="sd">           variable to make a decision on.</span>
<span class="sd">        2. When it comes to choose a value for the slack of node i, the decision</span>
<span class="sd">           builder first calls the callback with argument i, and supposingly the</span>
<span class="sd">           returned value is x it creates decisions slack[i] = x, slack[i] = x +</span>
<span class="sd">           1, slack[i] = x - 1, slack[i] = x + 2, etc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_MakeGuidedSlackFinalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">,</span> <span class="n">initializer</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>The next few members are in the public section only for testing purposes.</p>

<p>MakeGuidedSlackFinalizer creates a DecisionBuilder for the slacks of a
dimension using a callback to choose which values to start with.
The finalizer works only when all next variables in the model have
been fixed. It has the following two characteristics:</p>

<ol>
<li>It follows the routes defined by the nexts variables when choosing a
variable to make a decision on.</li>
<li>When it comes to choose a value for the slack of node i, the decision
builder first calls the callback with argument i, and supposingly the
returned value is x it creates decisions slack[i] = x, slack[i] = x +
1, slack[i] = x - 1, slack[i] = x + 2, etc.</li>
</ol>
</div>


                            </div>
                            <div id="RoutingModel.MakeSelfDependentDimensionFinalizer" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModel.MakeSelfDependentDimensionFinalizer">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">MakeSelfDependentDimensionFinalizer</span><span class="signature">(
    self,
    dimension: <a href="#RoutingDimension">pywrapcp.RoutingDimension</a>
) -&gt; &#39;operations_research::DecisionBuilder *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">MakeSelfDependentDimensionFinalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="s2">&quot;RoutingDimension&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        MakeSelfDependentDimensionFinalizer is a finalizer for the slacks of a</span>
<span class="sd">        self-dependent dimension. It makes an extensive use of the caches of the</span>
<span class="sd">        state dependent transits.</span>
<span class="sd">        In detail, MakeSelfDependentDimensionFinalizer returns a composition of a</span>
<span class="sd">        local search decision builder with a greedy descent operator for the cumul</span>
<span class="sd">        of the start of each route and a guided slack finalizer. Provided there</span>
<span class="sd">        are no time windows and the maximum slacks are large enough, once the</span>
<span class="sd">        cumul of the start of route is fixed, the guided finalizer can find</span>
<span class="sd">        optimal values of the slacks for the rest of the route in time</span>
<span class="sd">        proportional to the length of the route. Therefore the composed finalizer</span>
<span class="sd">        generally works in time O(log(t)*n*m), where t is the latest possible</span>
<span class="sd">        departute time, n is the number of nodes in the network and m is the</span>
<span class="sd">        number of vehicles.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModel_MakeSelfDependentDimensionFinalizer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>MakeSelfDependentDimensionFinalizer is a finalizer for the slacks of a
self-dependent dimension. It makes an extensive use of the caches of the
state dependent transits.
In detail, MakeSelfDependentDimensionFinalizer returns a composition of a
local search decision builder with a greedy descent operator for the cumul
of the start of each route and a guided slack finalizer. Provided there
are no time windows and the maximum slacks are large enough, once the
cumul of the start of route is fixed, the guided finalizer can find
optimal values of the slacks for the rest of the route in time
proportional to the length of the route. Therefore the composed finalizer
generally works in time O(log(t)<em>n</em>m), where t is the latest possible
departute time, n is the number of nodes in the network and m is the
number of vehicles.</p>
</div>


                            </div>
                            <div id="RoutingModel.kNoPenalty" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#RoutingModel.kNoPenalty">#&nbsp;&nbsp</a>

        <span class="name">kNoPenalty</span><span class="default_value"> = -1</span>
    </div>

    

                            </div>
                            <div id="RoutingModel.kNoDisjunction" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#RoutingModel.kNoDisjunction">#&nbsp;&nbsp</a>

        <span class="name">kNoDisjunction</span><span class="default_value"> = &lt;Swig Object of type &#39;operations_research::RoutingModel::DisjunctionIndex *&#39;&gt;</span>
    </div>

    

                            </div>
                            <div id="RoutingModel.kNoDimension" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#RoutingModel.kNoDimension">#&nbsp;&nbsp</a>

        <span class="name">kNoDimension</span><span class="default_value"> = &lt;Swig Object of type &#39;operations_research::RoutingModel::DimensionIndex *&#39;&gt;</span>
    </div>

    

                            </div>
                </section>
                <section id="RoutingModelVisitor">
                                <div class="attr class">
        <a class="headerlink" href="#RoutingModelVisitor">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">RoutingModelVisitor</span><wbr>(<span class="base"><a href="#BaseObject">BaseObject</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">RoutingModelVisitor</span><span class="p">(</span><span class="n">BaseObject</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Routing model visitor.&quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModelVisitor_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_RoutingModelVisitor</span><span class="p">())</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_RoutingModelVisitor</span>
</pre></div>

        </details>

            <div class="docstring"><p>Routing model visitor.</p>
</div>


                            <div id="RoutingModelVisitor.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingModelVisitor.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">RoutingModelVisitor</span><span class="signature">()</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingModelVisitor_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_RoutingModelVisitor</span><span class="p">())</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingModelVisitor.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#RoutingModelVisitor.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="RoutingModelVisitor.kLightElement" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#RoutingModelVisitor.kLightElement">#&nbsp;&nbsp</a>

        <span class="name">kLightElement</span><span class="default_value"> = &#39;LightElement&#39;</span>
    </div>

    

                            </div>
                            <div id="RoutingModelVisitor.kLightElement2" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#RoutingModelVisitor.kLightElement2">#&nbsp;&nbsp</a>

        <span class="name">kLightElement2</span><span class="default_value"> = &#39;LightElement2&#39;</span>
    </div>

    

                            </div>
                            <div id="RoutingModelVisitor.kRemoveValues" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#RoutingModelVisitor.kRemoveValues">#&nbsp;&nbsp</a>

        <span class="name">kRemoveValues</span><span class="default_value"> = &#39;RemoveValues&#39;</span>
    </div>

    

                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#BaseObject">BaseObject</a></dt>
                                <dd id="RoutingModelVisitor.DebugString" class="function"><a href="#BaseObject.DebugString">DebugString</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="GlobalVehicleBreaksConstraint">
                                <div class="attr class">
        <a class="headerlink" href="#GlobalVehicleBreaksConstraint">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">GlobalVehicleBreaksConstraint</span><wbr>(<span class="base"><a href="#Constraint">Constraint</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">GlobalVehicleBreaksConstraint</span><span class="p">(</span><span class="n">Constraint</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    GlobalVehicleBreaksConstraint ensures breaks constraints are enforced on</span>
<span class="sd">    all vehicles in the dimension passed to its constructor.</span>
<span class="sd">    It is intended to be used for dimensions representing time.</span>
<span class="sd">    A break constraint ensures break intervals fit on the route of a vehicle.</span>
<span class="sd">    For a given vehicle, it forces break intervals to be disjoint from visit</span>
<span class="sd">    intervals, where visit intervals start at CumulVar(node) and last for</span>
<span class="sd">    node_visit_transit[node]. Moreover, it ensures that there is enough time</span>
<span class="sd">    between two consecutive nodes of a route to do transit and vehicle breaks,</span>
<span class="sd">    i.e. if Next(nodeA) = nodeB, CumulVar(nodeA) = tA and CumulVar(nodeB) = tB,</span>
<span class="sd">    then SlackVar(nodeA) &gt;= sum_{breaks [tA, tB)} duration(break).</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="s2">&quot;RoutingDimension&quot;</span><span class="p">):</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">GlobalVehicleBreaksConstraint_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_GlobalVehicleBreaksConstraint</span><span class="p">(</span><span class="n">dimension</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">GlobalVehicleBreaksConstraint_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Post</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">GlobalVehicleBreaksConstraint_Post</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">InitialPropagateWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">GlobalVehicleBreaksConstraint_InitialPropagateWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_GlobalVehicleBreaksConstraint</span>
</pre></div>

        </details>

            <div class="docstring"><p>GlobalVehicleBreaksConstraint ensures breaks constraints are enforced on
all vehicles in the dimension passed to its constructor.
It is intended to be used for dimensions representing time.
A break constraint ensures break intervals fit on the route of a vehicle.
For a given vehicle, it forces break intervals to be disjoint from visit
intervals, where visit intervals start at CumulVar(node) and last for
node_visit_transit[node]. Moreover, it ensures that there is enough time
between two consecutive nodes of a route to do transit and vehicle breaks,
i.e. if Next(nodeA) = nodeB, CumulVar(nodeA) = tA and CumulVar(nodeB) = tB,
then SlackVar(nodeA) &gt;= sum_{breaks [tA, tB)} duration(break).</p>
</div>


                            <div id="GlobalVehicleBreaksConstraint.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GlobalVehicleBreaksConstraint.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">GlobalVehicleBreaksConstraint</span><span class="signature">(dimension: <a href="#RoutingDimension">pywrapcp.RoutingDimension</a>)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dimension</span><span class="p">:</span> <span class="s2">&quot;RoutingDimension&quot;</span><span class="p">):</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">GlobalVehicleBreaksConstraint_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_GlobalVehicleBreaksConstraint</span><span class="p">(</span><span class="n">dimension</span><span class="p">))</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="GlobalVehicleBreaksConstraint.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#GlobalVehicleBreaksConstraint.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="GlobalVehicleBreaksConstraint.DebugString" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GlobalVehicleBreaksConstraint.DebugString">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DebugString</span><span class="signature">(self) -&gt; &#39;std::string&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">GlobalVehicleBreaksConstraint_DebugString</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="GlobalVehicleBreaksConstraint.Post" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GlobalVehicleBreaksConstraint.Post">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Post</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Post</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">GlobalVehicleBreaksConstraint_Post</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method is called when the constraint is processed by the
solver. Its main usage is to attach demons to variables.</p>
</div>


                            </div>
                            <div id="GlobalVehicleBreaksConstraint.InitialPropagateWrapper" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#GlobalVehicleBreaksConstraint.InitialPropagateWrapper">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">InitialPropagateWrapper</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">InitialPropagateWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">GlobalVehicleBreaksConstraint_InitialPropagateWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method performs the initial propagation of the
constraint. It is called just after the post.</p>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#Constraint">Constraint</a></dt>
                                <dd id="GlobalVehicleBreaksConstraint.Var" class="function"><a href="#Constraint.Var">Var</a></dd>
                <dd id="GlobalVehicleBreaksConstraint.Square" class="function"><a href="#Constraint.Square">Square</a></dd>
                <dd id="GlobalVehicleBreaksConstraint.MapTo" class="function"><a href="#Constraint.MapTo">MapTo</a></dd>
                <dd id="GlobalVehicleBreaksConstraint.IndexOf" class="function"><a href="#Constraint.IndexOf">IndexOf</a></dd>

            </div>
            <div><dt><a href="#PropagationBaseObject">PropagationBaseObject</a></dt>
                                <dd id="GlobalVehicleBreaksConstraint.solver" class="function"><a href="#PropagationBaseObject.solver">solver</a></dd>
                <dd id="GlobalVehicleBreaksConstraint.Name" class="function"><a href="#PropagationBaseObject.Name">Name</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="TypeRegulationsChecker">
                                <div class="attr class">
        <a class="headerlink" href="#TypeRegulationsChecker">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">TypeRegulationsChecker</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">TypeRegulationsChecker</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_TypeRegulationsChecker</span>

    <span class="k">def</span> <span class="nf">CheckVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">next_accessor</span><span class="p">:</span> <span class="s2">&quot;std::function&lt; int64_t (int64_t) &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">TypeRegulationsChecker_CheckVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">,</span> <span class="n">next_accessor</span><span class="p">)</span>
</pre></div>

        </details>

    

                            <div id="TypeRegulationsChecker.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#TypeRegulationsChecker.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">TypeRegulationsChecker</span><span class="signature">(*args, **kwargs)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined - class is abstract&quot;</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="TypeRegulationsChecker.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#TypeRegulationsChecker.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="TypeRegulationsChecker.CheckVehicle" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#TypeRegulationsChecker.CheckVehicle">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">CheckVehicle</span><span class="signature">(
    self,
    vehicle: int,
    next_accessor: &#39;std::function&lt; int64_t (int64_t) &gt; const &amp;&#39;
) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">CheckVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">next_accessor</span><span class="p">:</span> <span class="s2">&quot;std::function&lt; int64_t (int64_t) &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">TypeRegulationsChecker_CheckVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">,</span> <span class="n">next_accessor</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                </section>
                <section id="TypeIncompatibilityChecker">
                                <div class="attr class">
        <a class="headerlink" href="#TypeIncompatibilityChecker">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">TypeIncompatibilityChecker</span><wbr>(<span class="base"><a href="#TypeRegulationsChecker">TypeRegulationsChecker</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">TypeIncompatibilityChecker</span><span class="p">(</span><span class="n">TypeRegulationsChecker</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Checker for type incompatibilities.&quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="s2">&quot;RoutingModel&quot;</span><span class="p">,</span> <span class="n">check_hard_incompatibilities</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">):</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">TypeIncompatibilityChecker_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_TypeIncompatibilityChecker</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">check_hard_incompatibilities</span><span class="p">))</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_TypeIncompatibilityChecker</span>
</pre></div>

        </details>

            <div class="docstring"><p>Checker for type incompatibilities.</p>
</div>


                            <div id="TypeIncompatibilityChecker.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#TypeIncompatibilityChecker.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">TypeIncompatibilityChecker</span><span class="signature">(model: <a href="#RoutingModel">pywrapcp.RoutingModel</a>, check_hard_incompatibilities: bool)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="s2">&quot;RoutingModel&quot;</span><span class="p">,</span> <span class="n">check_hard_incompatibilities</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">):</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">TypeIncompatibilityChecker_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_TypeIncompatibilityChecker</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">check_hard_incompatibilities</span><span class="p">))</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="TypeIncompatibilityChecker.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#TypeIncompatibilityChecker.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#TypeRegulationsChecker">TypeRegulationsChecker</a></dt>
                                <dd id="TypeIncompatibilityChecker.CheckVehicle" class="function"><a href="#TypeRegulationsChecker.CheckVehicle">CheckVehicle</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="TypeRequirementChecker">
                                <div class="attr class">
        <a class="headerlink" href="#TypeRequirementChecker">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">TypeRequirementChecker</span><wbr>(<span class="base"><a href="#TypeRegulationsChecker">TypeRegulationsChecker</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">TypeRequirementChecker</span><span class="p">(</span><span class="n">TypeRegulationsChecker</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Checker for type requirements.&quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="s2">&quot;RoutingModel&quot;</span><span class="p">):</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">TypeRequirementChecker_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_TypeRequirementChecker</span><span class="p">(</span><span class="n">model</span><span class="p">))</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_TypeRequirementChecker</span>
</pre></div>

        </details>

            <div class="docstring"><p>Checker for type requirements.</p>
</div>


                            <div id="TypeRequirementChecker.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#TypeRequirementChecker.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">TypeRequirementChecker</span><span class="signature">(model: <a href="#RoutingModel">pywrapcp.RoutingModel</a>)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="s2">&quot;RoutingModel&quot;</span><span class="p">):</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">TypeRequirementChecker_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_TypeRequirementChecker</span><span class="p">(</span><span class="n">model</span><span class="p">))</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="TypeRequirementChecker.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#TypeRequirementChecker.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#TypeRegulationsChecker">TypeRegulationsChecker</a></dt>
                                <dd id="TypeRequirementChecker.CheckVehicle" class="function"><a href="#TypeRegulationsChecker.CheckVehicle">CheckVehicle</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="TypeRegulationsConstraint">
                                <div class="attr class">
        <a class="headerlink" href="#TypeRegulationsConstraint">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">TypeRegulationsConstraint</span><wbr>(<span class="base"><a href="#Constraint">Constraint</a></span>):
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">TypeRegulationsConstraint</span><span class="p">(</span><span class="n">Constraint</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The following constraint ensures that incompatibilities and requirements</span>
<span class="sd">    between types are respected.</span>

<span class="sd">    It verifies both &quot;hard&quot; and &quot;temporal&quot; incompatibilities.</span>
<span class="sd">    Two nodes with hard incompatible types cannot be served by the same vehicle</span>
<span class="sd">    at all, while with a temporal incompatibility they can&#39;t be on the same</span>
<span class="sd">    route at the same time.</span>
<span class="sd">    The VisitTypePolicy of a node determines how visiting it impacts the type</span>
<span class="sd">    count on the route.</span>

<span class="sd">    For example, for</span>
<span class="sd">    - three temporally incompatible types T1 T2 and T3</span>
<span class="sd">    - 2 pairs of nodes a1/r1 and a2/r2 of type T1 and T2 respectively, with</span>
<span class="sd">        - a1 and a2 of VisitTypePolicy TYPE_ADDED_TO_VEHICLE</span>
<span class="sd">        - r1 and r2 of policy ADDED_TYPE_REMOVED_FROM_VEHICLE</span>
<span class="sd">    - 3 nodes A, UV and AR of type T3, respectively with type policies</span>
<span class="sd">      TYPE_ADDED_TO_VEHICLE, TYPE_ON_VEHICLE_UP_TO_VISIT and</span>
<span class="sd">      TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED</span>
<span class="sd">    the configurations</span>
<span class="sd">    UV --&gt; a1 --&gt; r1 --&gt; a2 --&gt; r2,   a1 --&gt; r1 --&gt; a2 --&gt; r2 --&gt; A and</span>
<span class="sd">    a1 --&gt; r1 --&gt; AR --&gt; a2 --&gt; r2 are acceptable, whereas the configurations</span>
<span class="sd">    a1 --&gt; a2 --&gt; r1 --&gt; ..., or A --&gt; a1 --&gt; r1 --&gt; ..., or</span>
<span class="sd">    a1 --&gt; r1 --&gt; UV --&gt; ... are not feasible.</span>

<span class="sd">    It also verifies same-vehicle and temporal type requirements.</span>
<span class="sd">    A node of type T_d with a same-vehicle requirement for type T_r needs to be</span>
<span class="sd">    served by the same vehicle as a node of type T_r.</span>
<span class="sd">    Temporal requirements, on the other hand, can take effect either when the</span>
<span class="sd">    dependent type is being added to the route or when it&#39;s removed from it,</span>
<span class="sd">    which is determined by the dependent node&#39;s VisitTypePolicy.</span>
<span class="sd">    In the above example:</span>
<span class="sd">    - If T3 is required on the same vehicle as T1, A, AR or UV must be on the</span>
<span class="sd">      same vehicle as a1.</span>
<span class="sd">    - If T2 is required when adding T1, a2 must be visited *before* a1, and if</span>
<span class="sd">      r2 is also visited on the route, it must be *after* a1, i.e. T2 must be on</span>
<span class="sd">      the vehicle when a1 is visited:</span>
<span class="sd">      ... --&gt; a2 --&gt; ... --&gt; a1 --&gt; ... --&gt; r2 --&gt; ...</span>
<span class="sd">    - If T3 is required when removing T1, T3 needs to be on the vehicle when</span>
<span class="sd">      r1 is visited:</span>
<span class="sd">      ... --&gt; A --&gt; ... --&gt; r1 --&gt; ...   OR   ... --&gt; r1 --&gt; ... --&gt; UV --&gt; ...</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="s2">&quot;RoutingModel&quot;</span><span class="p">):</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">TypeRegulationsConstraint_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_TypeRegulationsConstraint</span><span class="p">(</span><span class="n">model</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">Post</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">TypeRegulationsConstraint_Post</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">InitialPropagateWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">TypeRegulationsConstraint_InitialPropagateWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_TypeRegulationsConstraint</span>
</pre></div>

        </details>

            <div class="docstring"><p>The following constraint ensures that incompatibilities and requirements
between types are respected.</p>

<p>It verifies both "hard" and "temporal" incompatibilities.
Two nodes with hard incompatible types cannot be served by the same vehicle
at all, while with a temporal incompatibility they can't be on the same
route at the same time.
The VisitTypePolicy of a node determines how visiting it impacts the type
count on the route.</p>

<p>For example, for</p>

<ul>
<li>three temporally incompatible types T1 T2 and T3</li>
<li>2 pairs of nodes a1/r1 and a2/r2 of type T1 and T2 respectively, with
<ul>
<li>a1 and a2 of VisitTypePolicy TYPE_ADDED_TO_VEHICLE</li>
<li>r1 and r2 of policy ADDED_TYPE_REMOVED_FROM_VEHICLE</li>
</ul></li>
<li>3 nodes A, UV and AR of type T3, respectively with type policies
TYPE_ADDED_TO_VEHICLE, TYPE_ON_VEHICLE_UP_TO_VISIT and
TYPE_SIMULTANEOUSLY_ADDED_AND_REMOVED
the configurations
UV --> a1 --> r1 --> a2 --> r2,   a1 --> r1 --> a2 --> r2 --> A and
a1 --> r1 --> AR --> a2 --> r2 are acceptable, whereas the configurations
a1 --> a2 --> r1 --> ..., or A --> a1 --> r1 --> ..., or
a1 --> r1 --> UV --> ... are not feasible.</li>
</ul>

<p>It also verifies same-vehicle and temporal type requirements.
A node of type T_d with a same-vehicle requirement for type T_r needs to be
served by the same vehicle as a node of type T_r.
Temporal requirements, on the other hand, can take effect either when the
dependent type is being added to the route or when it's removed from it,
which is determined by the dependent node's VisitTypePolicy.
In the above example:</p>

<ul>
<li>If T3 is required on the same vehicle as T1, A, AR or UV must be on the
same vehicle as a1.</li>
<li>If T2 is required when adding T1, a2 must be visited <em>before</em> a1, and if
r2 is also visited on the route, it must be <em>after</em> a1, i.e. T2 must be on
the vehicle when a1 is visited:
... --> a2 --> ... --> a1 --> ... --> r2 --> ...</li>
<li>If T3 is required when removing T1, T3 needs to be on the vehicle when
r1 is visited:
... --> A --> ... --> r1 --> ...   OR   ... --> r1 --> ... --> UV --> ...</li>
</ul>
</div>


                            <div id="TypeRegulationsConstraint.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#TypeRegulationsConstraint.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">TypeRegulationsConstraint</span><span class="signature">(model: <a href="#RoutingModel">pywrapcp.RoutingModel</a>)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">model</span><span class="p">:</span> <span class="s2">&quot;RoutingModel&quot;</span><span class="p">):</span>
        <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">TypeRegulationsConstraint_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">new_TypeRegulationsConstraint</span><span class="p">(</span><span class="n">model</span><span class="p">))</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="TypeRegulationsConstraint.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#TypeRegulationsConstraint.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="TypeRegulationsConstraint.Post" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#TypeRegulationsConstraint.Post">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Post</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Post</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">TypeRegulationsConstraint_Post</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method is called when the constraint is processed by the
solver. Its main usage is to attach demons to variables.</p>
</div>


                            </div>
                            <div id="TypeRegulationsConstraint.InitialPropagateWrapper" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#TypeRegulationsConstraint.InitialPropagateWrapper">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">InitialPropagateWrapper</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">InitialPropagateWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">TypeRegulationsConstraint_InitialPropagateWrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This method performs the initial propagation of the
constraint. It is called just after the post.</p>
</div>


                            </div>
                            <div class="inherited">
                                <h5>Inherited Members</h5>
                                <dl>
                                    <div><dt><a href="#Constraint">Constraint</a></dt>
                                <dd id="TypeRegulationsConstraint.DebugString" class="function"><a href="#Constraint.DebugString">DebugString</a></dd>
                <dd id="TypeRegulationsConstraint.Var" class="function"><a href="#Constraint.Var">Var</a></dd>
                <dd id="TypeRegulationsConstraint.Square" class="function"><a href="#Constraint.Square">Square</a></dd>
                <dd id="TypeRegulationsConstraint.MapTo" class="function"><a href="#Constraint.MapTo">MapTo</a></dd>
                <dd id="TypeRegulationsConstraint.IndexOf" class="function"><a href="#Constraint.IndexOf">IndexOf</a></dd>

            </div>
            <div><dt><a href="#PropagationBaseObject">PropagationBaseObject</a></dt>
                                <dd id="TypeRegulationsConstraint.solver" class="function"><a href="#PropagationBaseObject.solver">solver</a></dd>
                <dd id="TypeRegulationsConstraint.Name" class="function"><a href="#PropagationBaseObject.Name">Name</a></dd>

            </div>
                                </dl>
                            </div>
                </section>
                <section id="RoutingDimension">
                                <div class="attr class">
        <a class="headerlink" href="#RoutingDimension">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">RoutingDimension</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">RoutingDimension</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Dimensions represent quantities accumulated at nodes along the routes. They</span>
<span class="sd">    represent quantities such as weights or volumes carried along the route, or</span>
<span class="sd">    distance or times.</span>

<span class="sd">    Quantities at a node are represented by &quot;cumul&quot; variables and the increase</span>
<span class="sd">    or decrease of quantities between nodes are represented by &quot;transit&quot;</span>
<span class="sd">    variables. These variables are linked as follows:</span>

<span class="sd">    if j == next(i),</span>
<span class="sd">    cumuls(j) = cumuls(i) + transits(i) + slacks(i) +</span>
<span class="sd">                state_dependent_transits(i)</span>

<span class="sd">    where slack is a positive slack variable (can represent waiting times for</span>
<span class="sd">    a time dimension), and state_dependent_transits is a non-purely functional</span>
<span class="sd">    version of transits_. Favour transits over state_dependent_transits when</span>
<span class="sd">    possible, because purely functional callbacks allow more optimisations and</span>
<span class="sd">    make the model faster and easier to solve.</span>
<span class="sd">    for a given vehicle, it is passed as an external vector, it would be better</span>
<span class="sd">    to have this information here.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">delete_RoutingDimension</span>

    <span class="k">def</span> <span class="nf">model</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingModel *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the model on which the dimension was created.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_model</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetTransitValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">to_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the transition value for a given pair of nodes (as var index);</span>
<span class="sd">        this value is the one taken by the corresponding transit variable when</span>
<span class="sd">        the &#39;next&#39; variable for &#39;from_index&#39; is bound to &#39;to_index&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_GetTransitValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_index</span><span class="p">,</span> <span class="n">to_index</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetTransitValueFromClass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">to_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">vehicle_class</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as above but taking a vehicle class of the dimension instead of a</span>
<span class="sd">        vehicle (the class of a vehicle can be obtained with vehicle_to_class()).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_GetTransitValueFromClass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_index</span><span class="p">,</span> <span class="n">to_index</span><span class="p">,</span> <span class="n">vehicle_class</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">CumulVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the cumul, transit and slack variables for the given node (given as</span>
<span class="sd">        int64_t var index).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_CumulVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">TransitVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_TransitVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">FixedTransitVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_FixedTransitVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SlackVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_SlackVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetSpanUpperBoundForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets an upper bound on the dimension span on a given vehicle. This is the</span>
<span class="sd">        preferred way to limit the &quot;length&quot; of the route of a vehicle according to</span>
<span class="sd">        a dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_SetSpanUpperBoundForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetSpanCostCoefficientForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coefficient</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets a cost proportional to the dimension span on a given vehicle,</span>
<span class="sd">        or on all vehicles at once. &quot;coefficient&quot; must be nonnegative.</span>
<span class="sd">        This is handy to model costs proportional to idle time when the dimension</span>
<span class="sd">        represents time.</span>
<span class="sd">        The cost for a vehicle is</span>
<span class="sd">          span_cost = coefficient * (dimension end value - dimension start value).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_SetSpanCostCoefficientForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coefficient</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetSpanCostCoefficientForAllVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coefficient</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_SetSpanCostCoefficientForAllVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coefficient</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetGlobalSpanCostCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coefficient</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets a cost proportional to the *global* dimension span, that is the</span>
<span class="sd">        difference between the largest value of route end cumul variables and</span>
<span class="sd">        the smallest value of route start cumul variables.</span>
<span class="sd">        In other words:</span>
<span class="sd">        global_span_cost =</span>
<span class="sd">          coefficient * (Max(dimension end value) - Min(dimension start value)).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_SetGlobalSpanCostCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coefficient</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetCumulVarSoftUpperBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">coefficient</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets a soft upper bound to the cumul variable of a given variable index.</span>
<span class="sd">        If the value of the cumul variable is greater than the bound, a cost</span>
<span class="sd">        proportional to the difference between this value and the bound is added</span>
<span class="sd">        to the cost function of the model:</span>
<span class="sd">          cumulVar &lt;= upper_bound -&gt; cost = 0</span>
<span class="sd">           cumulVar &gt; upper_bound -&gt; cost = coefficient * (cumulVar - upper_bound)</span>
<span class="sd">        This is also handy to model tardiness costs when the dimension represents</span>
<span class="sd">        time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_SetCumulVarSoftUpperBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">,</span> <span class="n">coefficient</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">HasCumulVarSoftUpperBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns true if a soft upper bound has been set for a given variable</span>
<span class="sd">        index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_HasCumulVarSoftUpperBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetCumulVarSoftUpperBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the soft upper bound of a cumul variable for a given variable</span>
<span class="sd">        index. The &quot;hard&quot; upper bound of the variable is returned if no soft upper</span>
<span class="sd">        bound has been set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_GetCumulVarSoftUpperBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetCumulVarSoftUpperBoundCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the cost coefficient of the soft upper bound of a cumul variable</span>
<span class="sd">        for a given variable index. If no soft upper bound has been set, 0 is</span>
<span class="sd">        returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_GetCumulVarSoftUpperBoundCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetCumulVarSoftLowerBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">lower_bound</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">coefficient</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets a soft lower bound to the cumul variable of a given variable index.</span>
<span class="sd">        If the value of the cumul variable is less than the bound, a cost</span>
<span class="sd">        proportional to the difference between this value and the bound is added</span>
<span class="sd">        to the cost function of the model:</span>
<span class="sd">          cumulVar &gt; lower_bound -&gt; cost = 0</span>
<span class="sd">          cumulVar &lt;= lower_bound -&gt; cost = coefficient * (lower_bound -</span>
<span class="sd">                      cumulVar).</span>
<span class="sd">        This is also handy to model earliness costs when the dimension represents</span>
<span class="sd">        time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_SetCumulVarSoftLowerBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">lower_bound</span><span class="p">,</span> <span class="n">coefficient</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">HasCumulVarSoftLowerBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns true if a soft lower bound has been set for a given variable</span>
<span class="sd">        index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_HasCumulVarSoftLowerBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetCumulVarSoftLowerBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the soft lower bound of a cumul variable for a given variable</span>
<span class="sd">        index. The &quot;hard&quot; lower bound of the variable is returned if no soft lower</span>
<span class="sd">        bound has been set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_GetCumulVarSoftLowerBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetCumulVarSoftLowerBoundCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the cost coefficient of the soft lower bound of a cumul variable</span>
<span class="sd">        for a given variable index. If no soft lower bound has been set, 0 is</span>
<span class="sd">        returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_GetCumulVarSoftLowerBoundCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetBreakIntervalsOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">breaks</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntervalVar * &gt;&quot;</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">node_visit_transits</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the breaks for a given vehicle. Breaks are represented by</span>
<span class="sd">        IntervalVars. They may interrupt transits between nodes and increase</span>
<span class="sd">        the value of corresponding slack variables.</span>
<span class="sd">        A break may take place before the start of a vehicle, after the end of</span>
<span class="sd">        a vehicle, or during a travel i -&gt; j.</span>

<span class="sd">        In that case, the interval [break.Start(), break.End()) must be a subset</span>
<span class="sd">        of [CumulVar(i) + pre_travel(i, j), CumulVar(j) - post_travel(i, j)). In</span>
<span class="sd">        other words, a break may not overlap any node n&#39;s visit, given by</span>
<span class="sd">        [CumulVar(n) - post_travel(_, n), CumulVar(n) + pre_travel(n, _)).</span>
<span class="sd">        This formula considers post_travel(_, start) and pre_travel(end, _) to be</span>
<span class="sd">        0; pre_travel will never be called on any (_, start) and post_travel will</span>
<span class="sd">        never we called on any (end, _). If pre_travel_evaluator or</span>
<span class="sd">        post_travel_evaluator is -1, it will be taken as a function that always</span>
<span class="sd">        returns 0.</span>
<span class="sd">        Deprecated, sets pre_travel(i, j) = node_visit_transit[i].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_SetBreakIntervalsOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">breaks</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">,</span> <span class="n">node_visit_transits</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetBreakDistanceDurationOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">duration</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        With breaks supposed to be consecutive, this forces the distance between</span>
<span class="sd">        breaks of size at least minimum_break_duration to be at most distance.</span>
<span class="sd">        This supposes that the time until route start and after route end are</span>
<span class="sd">        infinite breaks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_SetBreakDistanceDurationOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">InitializeBreaks</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets up vehicle_break_intervals_, vehicle_break_distance_duration_,</span>
<span class="sd">        pre_travel_evaluators and post_travel_evaluators.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_InitializeBreaks</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">HasBreakConstraints</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns true if any break interval or break distance was defined.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_HasBreakConstraints</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetPreTravelEvaluatorOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_GetPreTravelEvaluatorOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetPostTravelEvaluatorOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_GetPostTravelEvaluatorOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">base_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingDimension const *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the parent in the dependency tree if any or nullptr otherwise.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_base_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ShortestTransitionSlack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        It makes sense to use the function only for self-dependent dimension.</span>
<span class="sd">        For such dimensions the value of the slack of a node determines the</span>
<span class="sd">        transition cost of the next transit. Provided that</span>
<span class="sd">          1. cumul[node] is fixed,</span>
<span class="sd">          2. next[node] and next[next[node]] (if exists) are fixed,</span>
<span class="sd">        the value of slack[node] for which cumul[next[node]] + transit[next[node]]</span>
<span class="sd">        is minimized can be found in O(1) using this function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_ShortestTransitionSlack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the name of the dimension.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetPickupToDeliveryLimitFunctionForPair</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit_function</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingDimension::PickupToDeliveryLimitFunction&quot;</span><span class="p">,</span> <span class="n">pair_index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_SetPickupToDeliveryLimitFunctionForPair</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit_function</span><span class="p">,</span> <span class="n">pair_index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">HasPickupToDeliveryLimits</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_HasPickupToDeliveryLimits</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">AddNodePrecedence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_node</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">second_node</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_AddNodePrecedence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_node</span><span class="p">,</span> <span class="n">second_node</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetSpanUpperBoundForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_GetSpanUpperBoundForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetSpanCostCoefficientForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_GetSpanCostCoefficientForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">global_span_cost_coefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_global_span_cost_coefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetGlobalOptimizerOffset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_GetGlobalOptimizerOffset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetLocalOptimizerOffsetForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_GetLocalOptimizerOffsetForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Dimensions represent quantities accumulated at nodes along the routes. They
represent quantities such as weights or volumes carried along the route, or
distance or times.</p>

<p>Quantities at a node are represented by "cumul" variables and the increase
or decrease of quantities between nodes are represented by "transit"
variables. These variables are linked as follows:</p>

<p>if j == next(i),
cumuls(j) = cumuls(i) + transits(i) + slacks(i) +
            state_dependent_transits(i)</p>

<p>where slack is a positive slack variable (can represent waiting times for
a time dimension), and state_dependent_transits is a non-purely functional
version of transits_. Favour transits over state_dependent_transits when
possible, because purely functional callbacks allow more optimisations and
make the model faster and easier to solve.
for a given vehicle, it is passed as an external vector, it would be better
to have this information here.</p>
</div>


                            <div id="RoutingDimension.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingDimension.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">RoutingDimension</span><span class="signature">(*args, **kwargs)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingDimension.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#RoutingDimension.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="RoutingDimension.model" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingDimension.model">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">model</span><span class="signature">(self) -&gt; &#39;operations_research::RoutingModel *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">model</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingModel *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the model on which the dimension was created.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_model</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the model on which the dimension was created.</p>
</div>


                            </div>
                            <div id="RoutingDimension.GetTransitValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingDimension.GetTransitValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetTransitValue</span><span class="signature">(
    self,
    from_index: &#39;int64_t&#39;,
    to_index: &#39;int64_t&#39;,
    vehicle: &#39;int64_t&#39;
) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetTransitValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">to_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the transition value for a given pair of nodes (as var index);</span>
<span class="sd">        this value is the one taken by the corresponding transit variable when</span>
<span class="sd">        the &#39;next&#39; variable for &#39;from_index&#39; is bound to &#39;to_index&#39;.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_GetTransitValue</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_index</span><span class="p">,</span> <span class="n">to_index</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the transition value for a given pair of nodes (as var index);
this value is the one taken by the corresponding transit variable when
the 'next' variable for 'from_index' is bound to 'to_index'.</p>
</div>


                            </div>
                            <div id="RoutingDimension.GetTransitValueFromClass" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingDimension.GetTransitValueFromClass">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetTransitValueFromClass</span><span class="signature">(
    self,
    from_index: &#39;int64_t&#39;,
    to_index: &#39;int64_t&#39;,
    vehicle_class: &#39;int64_t&#39;
) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetTransitValueFromClass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">to_index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">vehicle_class</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Same as above but taking a vehicle class of the dimension instead of a</span>
<span class="sd">        vehicle (the class of a vehicle can be obtained with vehicle_to_class()).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_GetTransitValueFromClass</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">from_index</span><span class="p">,</span> <span class="n">to_index</span><span class="p">,</span> <span class="n">vehicle_class</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Same as above but taking a vehicle class of the dimension instead of a
vehicle (the class of a vehicle can be obtained with vehicle_to_class()).</p>
</div>


                            </div>
                            <div id="RoutingDimension.CumulVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingDimension.CumulVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">CumulVar</span><span class="signature">(self, index: &#39;int64_t&#39;) -&gt; &#39;operations_research::IntVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">CumulVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Get the cumul, transit and slack variables for the given node (given as</span>
<span class="sd">        int64_t var index).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_CumulVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Get the cumul, transit and slack variables for the given node (given as
int64_t var index).</p>
</div>


                            </div>
                            <div id="RoutingDimension.TransitVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingDimension.TransitVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">TransitVar</span><span class="signature">(self, index: &#39;int64_t&#39;) -&gt; &#39;operations_research::IntVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">TransitVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_TransitVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingDimension.FixedTransitVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingDimension.FixedTransitVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">FixedTransitVar</span><span class="signature">(self, index: &#39;int64_t&#39;) -&gt; &#39;operations_research::IntVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">FixedTransitVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_FixedTransitVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingDimension.SlackVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingDimension.SlackVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SlackVar</span><span class="signature">(self, index: &#39;int64_t&#39;) -&gt; &#39;operations_research::IntVar *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SlackVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::IntVar *&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_SlackVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingDimension.SetSpanUpperBoundForVehicle" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingDimension.SetSpanUpperBoundForVehicle">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetSpanUpperBoundForVehicle</span><span class="signature">(self, upper_bound: &#39;int64_t&#39;, vehicle: int) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetSpanUpperBoundForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets an upper bound on the dimension span on a given vehicle. This is the</span>
<span class="sd">        preferred way to limit the &quot;length&quot; of the route of a vehicle according to</span>
<span class="sd">        a dimension.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_SetSpanUpperBoundForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Sets an upper bound on the dimension span on a given vehicle. This is the
preferred way to limit the "length" of the route of a vehicle according to
a dimension.</p>
</div>


                            </div>
                            <div id="RoutingDimension.SetSpanCostCoefficientForVehicle" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingDimension.SetSpanCostCoefficientForVehicle">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetSpanCostCoefficientForVehicle</span><span class="signature">(self, coefficient: &#39;int64_t&#39;, vehicle: int) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetSpanCostCoefficientForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coefficient</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets a cost proportional to the dimension span on a given vehicle,</span>
<span class="sd">        or on all vehicles at once. &quot;coefficient&quot; must be nonnegative.</span>
<span class="sd">        This is handy to model costs proportional to idle time when the dimension</span>
<span class="sd">        represents time.</span>
<span class="sd">        The cost for a vehicle is</span>
<span class="sd">          span_cost = coefficient * (dimension end value - dimension start value).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_SetSpanCostCoefficientForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coefficient</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Sets a cost proportional to the dimension span on a given vehicle,
or on all vehicles at once. "coefficient" must be nonnegative.
This is handy to model costs proportional to idle time when the dimension
represents time.
The cost for a vehicle is
  span_cost = coefficient * (dimension end value - dimension start value).</p>
</div>


                            </div>
                            <div id="RoutingDimension.SetSpanCostCoefficientForAllVehicles" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingDimension.SetSpanCostCoefficientForAllVehicles">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetSpanCostCoefficientForAllVehicles</span><span class="signature">(self, coefficient: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetSpanCostCoefficientForAllVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coefficient</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_SetSpanCostCoefficientForAllVehicles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coefficient</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingDimension.SetGlobalSpanCostCoefficient" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingDimension.SetGlobalSpanCostCoefficient">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetGlobalSpanCostCoefficient</span><span class="signature">(self, coefficient: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetGlobalSpanCostCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coefficient</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets a cost proportional to the *global* dimension span, that is the</span>
<span class="sd">        difference between the largest value of route end cumul variables and</span>
<span class="sd">        the smallest value of route start cumul variables.</span>
<span class="sd">        In other words:</span>
<span class="sd">        global_span_cost =</span>
<span class="sd">          coefficient * (Max(dimension end value) - Min(dimension start value)).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_SetGlobalSpanCostCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coefficient</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Sets a cost proportional to the <em>global</em> dimension span, that is the
difference between the largest value of route end cumul variables and
the smallest value of route start cumul variables.
In other words:
global_span_cost =
  coefficient * (Max(dimension end value) - Min(dimension start value)).</p>
</div>


                            </div>
                            <div id="RoutingDimension.SetCumulVarSoftUpperBound" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingDimension.SetCumulVarSoftUpperBound">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetCumulVarSoftUpperBound</span><span class="signature">(
    self,
    index: &#39;int64_t&#39;,
    upper_bound: &#39;int64_t&#39;,
    coefficient: &#39;int64_t&#39;
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetCumulVarSoftUpperBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">coefficient</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets a soft upper bound to the cumul variable of a given variable index.</span>
<span class="sd">        If the value of the cumul variable is greater than the bound, a cost</span>
<span class="sd">        proportional to the difference between this value and the bound is added</span>
<span class="sd">        to the cost function of the model:</span>
<span class="sd">          cumulVar &lt;= upper_bound -&gt; cost = 0</span>
<span class="sd">           cumulVar &gt; upper_bound -&gt; cost = coefficient * (cumulVar - upper_bound)</span>
<span class="sd">        This is also handy to model tardiness costs when the dimension represents</span>
<span class="sd">        time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_SetCumulVarSoftUpperBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">upper_bound</span><span class="p">,</span> <span class="n">coefficient</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Sets a soft upper bound to the cumul variable of a given variable index.
If the value of the cumul variable is greater than the bound, a cost
proportional to the difference between this value and the bound is added
to the cost function of the model:
  cumulVar &lt;= upper_bound -> cost = 0
   cumulVar &gt; upper_bound -> cost = coefficient * (cumulVar - upper_bound)
This is also handy to model tardiness costs when the dimension represents
time.</p>
</div>


                            </div>
                            <div id="RoutingDimension.HasCumulVarSoftUpperBound" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingDimension.HasCumulVarSoftUpperBound">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">HasCumulVarSoftUpperBound</span><span class="signature">(self, index: &#39;int64_t&#39;) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">HasCumulVarSoftUpperBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns true if a soft upper bound has been set for a given variable</span>
<span class="sd">        index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_HasCumulVarSoftUpperBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns true if a soft upper bound has been set for a given variable
index.</p>
</div>


                            </div>
                            <div id="RoutingDimension.GetCumulVarSoftUpperBound" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingDimension.GetCumulVarSoftUpperBound">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetCumulVarSoftUpperBound</span><span class="signature">(self, index: &#39;int64_t&#39;) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetCumulVarSoftUpperBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the soft upper bound of a cumul variable for a given variable</span>
<span class="sd">        index. The &quot;hard&quot; upper bound of the variable is returned if no soft upper</span>
<span class="sd">        bound has been set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_GetCumulVarSoftUpperBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the soft upper bound of a cumul variable for a given variable
index. The "hard" upper bound of the variable is returned if no soft upper
bound has been set.</p>
</div>


                            </div>
                            <div id="RoutingDimension.GetCumulVarSoftUpperBoundCoefficient" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingDimension.GetCumulVarSoftUpperBoundCoefficient">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetCumulVarSoftUpperBoundCoefficient</span><span class="signature">(self, index: &#39;int64_t&#39;) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetCumulVarSoftUpperBoundCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the cost coefficient of the soft upper bound of a cumul variable</span>
<span class="sd">        for a given variable index. If no soft upper bound has been set, 0 is</span>
<span class="sd">        returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_GetCumulVarSoftUpperBoundCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the cost coefficient of the soft upper bound of a cumul variable
for a given variable index. If no soft upper bound has been set, 0 is
returned.</p>
</div>


                            </div>
                            <div id="RoutingDimension.SetCumulVarSoftLowerBound" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingDimension.SetCumulVarSoftLowerBound">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetCumulVarSoftLowerBound</span><span class="signature">(
    self,
    index: &#39;int64_t&#39;,
    lower_bound: &#39;int64_t&#39;,
    coefficient: &#39;int64_t&#39;
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetCumulVarSoftLowerBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">lower_bound</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">coefficient</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets a soft lower bound to the cumul variable of a given variable index.</span>
<span class="sd">        If the value of the cumul variable is less than the bound, a cost</span>
<span class="sd">        proportional to the difference between this value and the bound is added</span>
<span class="sd">        to the cost function of the model:</span>
<span class="sd">          cumulVar &gt; lower_bound -&gt; cost = 0</span>
<span class="sd">          cumulVar &lt;= lower_bound -&gt; cost = coefficient * (lower_bound -</span>
<span class="sd">                      cumulVar).</span>
<span class="sd">        This is also handy to model earliness costs when the dimension represents</span>
<span class="sd">        time.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_SetCumulVarSoftLowerBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">lower_bound</span><span class="p">,</span> <span class="n">coefficient</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Sets a soft lower bound to the cumul variable of a given variable index.
If the value of the cumul variable is less than the bound, a cost
proportional to the difference between this value and the bound is added
to the cost function of the model:
  cumulVar &gt; lower_bound -> cost = 0
  cumulVar &lt;= lower_bound -> cost = coefficient * (lower_bound -
              cumulVar).
This is also handy to model earliness costs when the dimension represents
time.</p>
</div>


                            </div>
                            <div id="RoutingDimension.HasCumulVarSoftLowerBound" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingDimension.HasCumulVarSoftLowerBound">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">HasCumulVarSoftLowerBound</span><span class="signature">(self, index: &#39;int64_t&#39;) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">HasCumulVarSoftLowerBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns true if a soft lower bound has been set for a given variable</span>
<span class="sd">        index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_HasCumulVarSoftLowerBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns true if a soft lower bound has been set for a given variable
index.</p>
</div>


                            </div>
                            <div id="RoutingDimension.GetCumulVarSoftLowerBound" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingDimension.GetCumulVarSoftLowerBound">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetCumulVarSoftLowerBound</span><span class="signature">(self, index: &#39;int64_t&#39;) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetCumulVarSoftLowerBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the soft lower bound of a cumul variable for a given variable</span>
<span class="sd">        index. The &quot;hard&quot; lower bound of the variable is returned if no soft lower</span>
<span class="sd">        bound has been set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_GetCumulVarSoftLowerBound</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the soft lower bound of a cumul variable for a given variable
index. The "hard" lower bound of the variable is returned if no soft lower
bound has been set.</p>
</div>


                            </div>
                            <div id="RoutingDimension.GetCumulVarSoftLowerBoundCoefficient" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingDimension.GetCumulVarSoftLowerBoundCoefficient">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetCumulVarSoftLowerBoundCoefficient</span><span class="signature">(self, index: &#39;int64_t&#39;) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetCumulVarSoftLowerBoundCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the cost coefficient of the soft lower bound of a cumul variable</span>
<span class="sd">        for a given variable index. If no soft lower bound has been set, 0 is</span>
<span class="sd">        returned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_GetCumulVarSoftLowerBoundCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the cost coefficient of the soft lower bound of a cumul variable
for a given variable index. If no soft lower bound has been set, 0 is
returned.</p>
</div>


                            </div>
                            <div id="RoutingDimension.SetBreakIntervalsOfVehicle" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingDimension.SetBreakIntervalsOfVehicle">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetBreakIntervalsOfVehicle</span><span class="signature">(
    self,
    breaks: &#39;std::vector&lt; operations_research::IntervalVar * &gt;&#39;,
    vehicle: int,
    node_visit_transits: &#39;std::vector&lt; int64_t &gt;&#39;
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetBreakIntervalsOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">breaks</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntervalVar * &gt;&quot;</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">,</span> <span class="n">node_visit_transits</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the breaks for a given vehicle. Breaks are represented by</span>
<span class="sd">        IntervalVars. They may interrupt transits between nodes and increase</span>
<span class="sd">        the value of corresponding slack variables.</span>
<span class="sd">        A break may take place before the start of a vehicle, after the end of</span>
<span class="sd">        a vehicle, or during a travel i -&gt; j.</span>

<span class="sd">        In that case, the interval [break.Start(), break.End()) must be a subset</span>
<span class="sd">        of [CumulVar(i) + pre_travel(i, j), CumulVar(j) - post_travel(i, j)). In</span>
<span class="sd">        other words, a break may not overlap any node n&#39;s visit, given by</span>
<span class="sd">        [CumulVar(n) - post_travel(_, n), CumulVar(n) + pre_travel(n, _)).</span>
<span class="sd">        This formula considers post_travel(_, start) and pre_travel(end, _) to be</span>
<span class="sd">        0; pre_travel will never be called on any (_, start) and post_travel will</span>
<span class="sd">        never we called on any (end, _). If pre_travel_evaluator or</span>
<span class="sd">        post_travel_evaluator is -1, it will be taken as a function that always</span>
<span class="sd">        returns 0.</span>
<span class="sd">        Deprecated, sets pre_travel(i, j) = node_visit_transit[i].</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_SetBreakIntervalsOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">breaks</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">,</span> <span class="n">node_visit_transits</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Sets the breaks for a given vehicle. Breaks are represented by
IntervalVars. They may interrupt transits between nodes and increase
the value of corresponding slack variables.
A break may take place before the start of a vehicle, after the end of
a vehicle, or during a travel i -> j.</p>

<p>In that case, the interval [break.Start(), break.End()) must be a subset
of [CumulVar(i) + pre_travel(i, j), CumulVar(j) - post_travel(i, j)). In
other words, a break may not overlap any node n's visit, given by
[CumulVar(n) - post_travel(_, n), CumulVar(n) + pre_travel(n, _)).
This formula considers post_travel(_, start) and pre_travel(end, _) to be
0; pre_travel will never be called on any (_, start) and post_travel will
never we called on any (end, _). If pre_travel_evaluator or
post_travel_evaluator is -1, it will be taken as a function that always
returns 0.
Deprecated, sets pre_travel(i, j) = node_visit_transit[i].</p>
</div>


                            </div>
                            <div id="RoutingDimension.SetBreakDistanceDurationOfVehicle" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingDimension.SetBreakDistanceDurationOfVehicle">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetBreakDistanceDurationOfVehicle</span><span class="signature">(
    self,
    distance: &#39;int64_t&#39;,
    duration: &#39;int64_t&#39;,
    vehicle: int
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetBreakDistanceDurationOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">duration</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        With breaks supposed to be consecutive, this forces the distance between</span>
<span class="sd">        breaks of size at least minimum_break_duration to be at most distance.</span>
<span class="sd">        This supposes that the time until route start and after route end are</span>
<span class="sd">        infinite breaks.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_SetBreakDistanceDurationOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">distance</span><span class="p">,</span> <span class="n">duration</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>With breaks supposed to be consecutive, this forces the distance between
breaks of size at least minimum_break_duration to be at most distance.
This supposes that the time until route start and after route end are
infinite breaks.</p>
</div>


                            </div>
                            <div id="RoutingDimension.InitializeBreaks" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingDimension.InitializeBreaks">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">InitializeBreaks</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">InitializeBreaks</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets up vehicle_break_intervals_, vehicle_break_distance_duration_,</span>
<span class="sd">        pre_travel_evaluators and post_travel_evaluators.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_InitializeBreaks</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Sets up vehicle_break_intervals_, vehicle_break_distance_duration_,
pre_travel_evaluators and post_travel_evaluators.</p>
</div>


                            </div>
                            <div id="RoutingDimension.HasBreakConstraints" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingDimension.HasBreakConstraints">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">HasBreakConstraints</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">HasBreakConstraints</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns true if any break interval or break distance was defined.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_HasBreakConstraints</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns true if any break interval or break distance was defined.</p>
</div>


                            </div>
                            <div id="RoutingDimension.GetPreTravelEvaluatorOfVehicle" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingDimension.GetPreTravelEvaluatorOfVehicle">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetPreTravelEvaluatorOfVehicle</span><span class="signature">(self, vehicle: int) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetPreTravelEvaluatorOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_GetPreTravelEvaluatorOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingDimension.GetPostTravelEvaluatorOfVehicle" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingDimension.GetPostTravelEvaluatorOfVehicle">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetPostTravelEvaluatorOfVehicle</span><span class="signature">(self, vehicle: int) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetPostTravelEvaluatorOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_GetPostTravelEvaluatorOfVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingDimension.base_dimension" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingDimension.base_dimension">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">base_dimension</span><span class="signature">(self) -&gt; &#39;operations_research::RoutingDimension const *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">base_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::RoutingDimension const *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the parent in the dependency tree if any or nullptr otherwise.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_base_dimension</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the parent in the dependency tree if any or nullptr otherwise.</p>
</div>


                            </div>
                            <div id="RoutingDimension.ShortestTransitionSlack" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingDimension.ShortestTransitionSlack">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ShortestTransitionSlack</span><span class="signature">(self, node: &#39;int64_t&#39;) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ShortestTransitionSlack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        It makes sense to use the function only for self-dependent dimension.</span>
<span class="sd">        For such dimensions the value of the slack of a node determines the</span>
<span class="sd">        transition cost of the next transit. Provided that</span>
<span class="sd">          1. cumul[node] is fixed,</span>
<span class="sd">          2. next[node] and next[next[node]] (if exists) are fixed,</span>
<span class="sd">        the value of slack[node] for which cumul[next[node]] + transit[next[node]]</span>
<span class="sd">        is minimized can be found in O(1) using this function.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_ShortestTransitionSlack</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>It makes sense to use the function only for self-dependent dimension.
For such dimensions the value of the slack of a node determines the
transition cost of the next transit. Provided that</p>

<ol>
<li>cumul[node] is fixed,</li>
<li>next[node] and next[next[node]] (if exists) are fixed,
the value of slack[node] for which cumul[next[node]] + transit[next[node]]
is minimized can be found in O(1) using this function.</li>
</ol>
</div>


                            </div>
                            <div id="RoutingDimension.name" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingDimension.name">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">name</span><span class="signature">(self) -&gt; &#39;std::string const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the name of the dimension.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the name of the dimension.</p>
</div>


                            </div>
                            <div id="RoutingDimension.SetPickupToDeliveryLimitFunctionForPair" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingDimension.SetPickupToDeliveryLimitFunctionForPair">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetPickupToDeliveryLimitFunctionForPair</span><span class="signature">(
    self,
    limit_function: &#39;operations_research::RoutingDimension::PickupToDeliveryLimitFunction&#39;,
    pair_index: int
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetPickupToDeliveryLimitFunctionForPair</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit_function</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingDimension::PickupToDeliveryLimitFunction&quot;</span><span class="p">,</span> <span class="n">pair_index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_SetPickupToDeliveryLimitFunctionForPair</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">limit_function</span><span class="p">,</span> <span class="n">pair_index</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingDimension.HasPickupToDeliveryLimits" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingDimension.HasPickupToDeliveryLimits">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">HasPickupToDeliveryLimits</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">HasPickupToDeliveryLimits</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_HasPickupToDeliveryLimits</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingDimension.AddNodePrecedence" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingDimension.AddNodePrecedence">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">AddNodePrecedence</span><span class="signature">(
    self,
    first_node: &#39;int64_t&#39;,
    second_node: &#39;int64_t&#39;,
    offset: &#39;int64_t&#39;
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">AddNodePrecedence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_node</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">second_node</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">,</span> <span class="n">offset</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_AddNodePrecedence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">first_node</span><span class="p">,</span> <span class="n">second_node</span><span class="p">,</span> <span class="n">offset</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingDimension.GetSpanUpperBoundForVehicle" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingDimension.GetSpanUpperBoundForVehicle">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetSpanUpperBoundForVehicle</span><span class="signature">(self, vehicle: int) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetSpanUpperBoundForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_GetSpanUpperBoundForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingDimension.GetSpanCostCoefficientForVehicle" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingDimension.GetSpanCostCoefficientForVehicle">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetSpanCostCoefficientForVehicle</span><span class="signature">(self, vehicle: int) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetSpanCostCoefficientForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_GetSpanCostCoefficientForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingDimension.global_span_cost_coefficient" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingDimension.global_span_cost_coefficient">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">global_span_cost_coefficient</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">global_span_cost_coefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_global_span_cost_coefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingDimension.GetGlobalOptimizerOffset" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingDimension.GetGlobalOptimizerOffset">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetGlobalOptimizerOffset</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetGlobalOptimizerOffset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_GetGlobalOptimizerOffset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="RoutingDimension.GetLocalOptimizerOffsetForVehicle" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#RoutingDimension.GetLocalOptimizerOffsetForVehicle">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetLocalOptimizerOffsetForVehicle</span><span class="signature">(self, vehicle: int) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetLocalOptimizerOffsetForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">RoutingDimension_GetLocalOptimizerOffsetForVehicle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">vehicle</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                </section>
                <section id="MakeSetValuesFromTargets">
                            <div class="attr function"><a class="headerlink" href="#MakeSetValuesFromTargets">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">MakeSetValuesFromTargets</span><span class="signature">(
    solver: <a href="#Solver">pywrapcp.Solver</a>,
    variables: &#39;std::vector&lt; operations_research::IntVar * &gt;&#39;,
    targets: &#39;std::vector&lt; int64_t &gt;&#39;
) -&gt; &#39;operations_research::DecisionBuilder *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">MakeSetValuesFromTargets</span><span class="p">(</span><span class="n">solver</span><span class="p">:</span> <span class="s2">&quot;Solver&quot;</span><span class="p">,</span> <span class="n">variables</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::IntVar * &gt;&quot;</span><span class="p">,</span> <span class="n">targets</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; int64_t &gt;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::DecisionBuilder *&quot;</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A decision builder which tries to assign values to variables as close as</span>
<span class="sd">    possible to target values first.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">MakeSetValuesFromTargets</span><span class="p">(</span><span class="n">solver</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">targets</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>A decision builder which tries to assign values to variables as close as
possible to target values first.</p>
</div>


                </section>
                <section id="SolveModelWithSat">
                            <div class="attr function"><a class="headerlink" href="#SolveModelWithSat">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SolveModelWithSat</span><span class="signature">(
    model: <a href="#RoutingModel">pywrapcp.RoutingModel</a>,
    search_parameters: &#39;operations_research::RoutingSearchParameters const &amp;&#39;,
    initial_solution: <a href="#Assignment">pywrapcp.Assignment</a>,
    solution: <a href="#Assignment">pywrapcp.Assignment</a>
) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">SolveModelWithSat</span><span class="p">(</span><span class="n">model</span><span class="p">:</span> <span class="s2">&quot;RoutingModel&quot;</span><span class="p">,</span> <span class="n">search_parameters</span><span class="p">:</span> <span class="s2">&quot;operations_research::RoutingSearchParameters const &amp;&quot;</span><span class="p">,</span> <span class="n">initial_solution</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">,</span> <span class="n">solution</span><span class="p">:</span> <span class="s2">&quot;Assignment&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Attempts to solve the model using the cp-sat solver. As of 5/2019, will</span>
<span class="sd">    solve the TSP corresponding to the model if it has a single vehicle.</span>
<span class="sd">    Therefore the resulting solution might not actually be feasible. Will return</span>
<span class="sd">    false if a solution could not be found.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_pywrapcp</span><span class="o">.</span><span class="n">SolveModelWithSat</span><span class="p">(</span><span class="n">model</span><span class="p">,</span> <span class="n">search_parameters</span><span class="p">,</span> <span class="n">initial_solution</span><span class="p">,</span> <span class="n">solution</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Attempts to solve the model using the cp-sat solver. As of 5/2019, will
solve the TSP corresponding to the model if it has a single vehicle.
Therefore the resulting solution might not actually be feasible. Will return
false if a solution could not be found.</p>
</div>


                </section>
    </main>
</body>
</html>