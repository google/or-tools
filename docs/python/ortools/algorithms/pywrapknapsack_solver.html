<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.0" />
<title>pywrapknapsack_solver API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<style type="text/css">
a:link { color: #46641e; text-decoration: none}
.ident { color: #46641e }
</style>
<link rel="icon" href="https://developers.google.com/optimization/images/orLogo.png">
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>pywrapknapsack_solver</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># This file was automatically generated by SWIG (http://www.swig.org).
# Version 4.0.1
#
# Do not make changes to this file unless you know what you are doing--modify
# the SWIG interface file instead.

from sys import version_info as _swig_python_version_info
if _swig_python_version_info &lt; (2, 7, 0):
    raise RuntimeError(&#34;Python 2.7 or later required&#34;)

# Import the low-level C/C++ module
if __package__ or &#34;.&#34; in __name__:
    from . import _pywrapknapsack_solver
else:
    import _pywrapknapsack_solver

try:
    import builtins as __builtin__
except ImportError:
    import __builtin__

def _swig_repr(self):
    try:
        strthis = &#34;proxy of &#34; + self.this.__repr__()
    except __builtin__.Exception:
        strthis = &#34;&#34;
    return &#34;&lt;%s.%s; %s &gt;&#34; % (self.__class__.__module__, self.__class__.__name__, strthis,)


def _swig_setattr_nondynamic_instance_variable(set):
    def set_instance_attr(self, name, value):
        if name == &#34;thisown&#34;:
            self.this.own(value)
        elif name == &#34;this&#34;:
            set(self, name, value)
        elif hasattr(self, name) and isinstance(getattr(type(self), name), property):
            set(self, name, value)
        else:
            raise AttributeError(&#34;You cannot add instance attributes to %s&#34; % self)
    return set_instance_attr


def _swig_setattr_nondynamic_class_variable(set):
    def set_class_attr(cls, name, value):
        if hasattr(cls, name) and not isinstance(getattr(cls, name), property):
            set(cls, name, value)
        else:
            raise AttributeError(&#34;You cannot add class attributes to %s&#34; % cls)
    return set_class_attr


def _swig_add_metaclass(metaclass):
    &#34;&#34;&#34;Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass&#34;&#34;&#34;
    def wrapper(cls):
        return metaclass(cls.__name__, cls.__bases__, cls.__dict__.copy())
    return wrapper


class _SwigNonDynamicMeta(type):
    &#34;&#34;&#34;Meta class to enforce nondynamic attributes (no new attributes) for a class&#34;&#34;&#34;
    __setattr__ = _swig_setattr_nondynamic_class_variable(type.__setattr__)


class KnapsackSolver(object):
    r&#34;&#34;&#34;
     This library solves knapsack problems.

     Problems the library solves include:
      - 0-1 knapsack problems,
      - Multi-dimensional knapsack problems,

    Given n items, each with a profit and a weight, given a knapsack of
    capacity c, the goal is to find a subset of items which fits inside c
    and maximizes the total profit.
    The knapsack problem can easily be extended from 1 to d dimensions.
    As an example, this can be useful to constrain the maximum number of
    items inside the knapsack.
    Without loss of generality, profits and weights are assumed to be positive.

    From a mathematical point of view, the multi-dimensional knapsack problem
    can be modeled by d linear constraints:

        ForEach(j:1..d)(Sum(i:1..n)(weight_ij * item_i) &lt;= c_j
            where item_i is a 0-1 integer variable.

    Then the goal is to maximize:

        Sum(i:1..n)(profit_i * item_i).

    There are several ways to solve knapsack problems. One of the most
    efficient is based on dynamic programming (mainly when weights, profits
    and dimensions are small, and the algorithm runs in pseudo polynomial time).
    Unfortunately, when adding conflict constraints the problem becomes strongly
    NP-hard, i.e. there is no pseudo-polynomial algorithm to solve it.
    That&#39;s the reason why the most of the following code is based on branch and
    bound search.

    For instance to solve a 2-dimensional knapsack problem with 9 items,
    one just has to feed a profit vector with the 9 profits, a vector of 2
    vectors for weights, and a vector of capacities.
    E.g.:

      **Python**:

      .. code-block:: c++

              profits = [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
              weights = [ [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ],
                          [ 1, 1, 1, 1, 1, 1, 1, 1, 1 ]
                        ]
              capacities = [ 34, 4 ]

              solver = pywrapknapsack_solver.KnapsackSolver(
                  pywrapknapsack_solver.KnapsackSolver
                      .KNAPSACK_MULTIDIMENSION_BRANCH_AND_BOUND_SOLVER,
                  &#39;Multi-dimensional solver&#39;)
              solver.Init(profits, weights, capacities)
              profit = solver.Solve()

      **C++**:

      .. code-block:: c++

             const std::vectorint64 profits = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
             const std::vectorstd::vector&lt;int64 weights =
                 { { 1, 2, 3, 4, 5, 6, 7, 8, 9 },
                   { 1, 1, 1, 1, 1, 1, 1, 1, 1 } };
             const std::vectorint64 capacities = { 34, 4 };

             KnapsackSolver solver(
                 KnapsackSolver::KNAPSACK_MULTIDIMENSION_BRANCH_AND_BOUND_SOLVER,
                 &#34;Multi-dimensional solver&#34;);
             solver.Init(profits, weights, capacities);
             const int64 profit = solver.Solve();

      **Java**:

      .. code-block:: c++

            final long[] profits = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
            final long[][] weights = { { 1, 2, 3, 4, 5, 6, 7, 8, 9 },
                   { 1, 1, 1, 1, 1, 1, 1, 1, 1 } };
            final long[] capacities = { 34, 4 };

            KnapsackSolver solver = new KnapsackSolver(
                KnapsackSolver.SolverType.KNAPSACK_MULTIDIMENSION_BRANCH_AND_BOUND_SOLVER,
                &#34;Multi-dimensional solver&#34;);
            solver.init(profits, weights, capacities);
            final long profit = solver.solve();
    &#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)
    __repr__ = _swig_repr
    KNAPSACK_BRUTE_FORCE_SOLVER = _pywrapknapsack_solver.KnapsackSolver_KNAPSACK_BRUTE_FORCE_SOLVER
    r&#34;&#34;&#34;
     Brute force method.

    Limited to 30 items and one dimension, this
    solver uses a brute force algorithm, ie. explores all possible states.
    Experiments show competitive performance for instances with less than
    15 items.
    &#34;&#34;&#34;
    KNAPSACK_64ITEMS_SOLVER = _pywrapknapsack_solver.KnapsackSolver_KNAPSACK_64ITEMS_SOLVER
    r&#34;&#34;&#34;
     Optimized method for single dimension small problems

    Limited to 64 items and one dimension, this
    solver uses a branch &amp; bound algorithm. This solver is about 4 times
    faster than KNAPSACK_MULTIDIMENSION_BRANCH_AND_BOUND_SOLVER.
    &#34;&#34;&#34;
    KNAPSACK_DYNAMIC_PROGRAMMING_SOLVER = _pywrapknapsack_solver.KnapsackSolver_KNAPSACK_DYNAMIC_PROGRAMMING_SOLVER
    r&#34;&#34;&#34;
     Dynamic Programming approach for single dimension problems

    Limited to one dimension, this solver is based on a dynamic programming
    algorithm. The time and space complexity is O(capacity *
    number_of_items).
    &#34;&#34;&#34;
    KNAPSACK_MULTIDIMENSION_CBC_MIP_SOLVER = _pywrapknapsack_solver.KnapsackSolver_KNAPSACK_MULTIDIMENSION_CBC_MIP_SOLVER
    r&#34;&#34;&#34;
     CBC Based Solver

     This solver can deal with both large number of items and several
    dimensions. This solver is based on Integer Programming solver CBC.
    &#34;&#34;&#34;
    KNAPSACK_MULTIDIMENSION_BRANCH_AND_BOUND_SOLVER = _pywrapknapsack_solver.KnapsackSolver_KNAPSACK_MULTIDIMENSION_BRANCH_AND_BOUND_SOLVER
    r&#34;&#34;&#34;
     Generic Solver.

    This solver can deal with both large number of items and several
    dimensions. This solver is based on branch and bound.
    &#34;&#34;&#34;

    def __init__(self, *args):
        _pywrapknapsack_solver.KnapsackSolver_swiginit(self, _pywrapknapsack_solver.new_KnapsackSolver(*args))
    __swig_destroy__ = _pywrapknapsack_solver.delete_KnapsackSolver

    def Init(self, profits: &#34;std::vector&lt; int64 &gt; const &amp;&#34;, weights: &#34;std::vector&lt; std::vector&lt; int64 &gt; &gt; const &amp;&#34;, capacities: &#34;std::vector&lt; int64 &gt; const &amp;&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34;Initializes the solver and enters the problem to be solved.&#34;&#34;&#34;
        return _pywrapknapsack_solver.KnapsackSolver_Init(self, profits, weights, capacities)

    def Solve(self) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34;Solves the problem and returns the profit of the optimal solution.&#34;&#34;&#34;
        return _pywrapknapsack_solver.KnapsackSolver_Solve(self)

    def BestSolutionContains(self, item_id: &#34;int&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34;Returns true if the item &#39;item_id&#39; is packed in the optimal knapsack.&#34;&#34;&#34;
        return _pywrapknapsack_solver.KnapsackSolver_BestSolutionContains(self, item_id)

    def set_use_reduction(self, use_reduction: &#34;bool&#34;) -&gt; &#34;void&#34;:
        return _pywrapknapsack_solver.KnapsackSolver_set_use_reduction(self, use_reduction)

    def set_time_limit(self, time_limit_seconds: &#34;double&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34;
         Time limit in seconds.

        When a finite time limit is set the solution obtained might not be optimal
        if the limit is reached.
        &#34;&#34;&#34;
        return _pywrapknapsack_solver.KnapsackSolver_set_time_limit(self, time_limit_seconds)

# Register KnapsackSolver in _pywrapknapsack_solver:
_pywrapknapsack_solver.KnapsackSolver_swigregister(KnapsackSolver)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="pywrapknapsack_solver.KnapsackSolver"><code class="flex name class">
<span>class <span class="ident">KnapsackSolver</span></span>
<span>(</span><span>*args)</span>
</code></dt>
<dd>
<section class="desc"><p>This library solves knapsack problems.</p>
<p>Problems the library solves include:
- 0-1 knapsack problems,
- Multi-dimensional knapsack problems,</p>
<p>Given n items, each with a profit and a weight, given a knapsack of
capacity c, the goal is to find a subset of items which fits inside c
and maximizes the total profit.
The knapsack problem can easily be extended from 1 to d dimensions.
As an example, this can be useful to constrain the maximum number of
items inside the knapsack.
Without loss of generality, profits and weights are assumed to be positive.</p>
<p>From a mathematical point of view, the multi-dimensional knapsack problem
can be modeled by d linear constraints:</p>
<pre><code>ForEach(j:1..d)(Sum(i:1..n)(weight_ij * item_i) &lt;= c_j
    where item_i is a 0-1 integer variable.
</code></pre>
<p>Then the goal is to maximize:</p>
<pre><code>Sum(i:1..n)(profit_i * item_i).
</code></pre>
<p>There are several ways to solve knapsack problems. One of the most
efficient is based on dynamic programming (mainly when weights, profits
and dimensions are small, and the algorithm runs in pseudo polynomial time).
Unfortunately, when adding conflict constraints the problem becomes strongly
NP-hard, i.e. there is no pseudo-polynomial algorithm to solve it.
That's the reason why the most of the following code is based on branch and
bound search.</p>
<p>For instance to solve a 2-dimensional knapsack problem with 9 items,
one just has to feed a profit vector with the 9 profits, a vector of 2
vectors for weights, and a vector of capacities.
E.g.:</p>
<p><strong>Python</strong>:</p>
<p>.. code-block:: c++</p>
<pre><code>      profits = [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
      weights = [ [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ],
                  [ 1, 1, 1, 1, 1, 1, 1, 1, 1 ]
                ]
      capacities = [ 34, 4 ]

      solver = pywrapknapsack_solver.KnapsackSolver(
          pywrapknapsack_solver.KnapsackSolver
              .KNAPSACK_MULTIDIMENSION_BRANCH_AND_BOUND_SOLVER,
          'Multi-dimensional solver')
      solver.Init(profits, weights, capacities)
      profit = solver.Solve()
</code></pre>
<p><strong>C++</strong>:</p>
<p>.. code-block:: c++</p>
<pre><code>     const std::vectorint64 profits = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
     const std::vectorstd::vector&lt;int64 weights =
         { { 1, 2, 3, 4, 5, 6, 7, 8, 9 },
           { 1, 1, 1, 1, 1, 1, 1, 1, 1 } };
     const std::vectorint64 capacities = { 34, 4 };

     KnapsackSolver solver(
         KnapsackSolver::KNAPSACK_MULTIDIMENSION_BRANCH_AND_BOUND_SOLVER,
         "Multi-dimensional solver");
     solver.Init(profits, weights, capacities);
     const int64 profit = solver.Solve();
</code></pre>
<p><strong>Java</strong>:</p>
<p>.. code-block:: c++</p>
<pre><code>    final long[] profits = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
    final long[][] weights = { { 1, 2, 3, 4, 5, 6, 7, 8, 9 },
           { 1, 1, 1, 1, 1, 1, 1, 1, 1 } };
    final long[] capacities = { 34, 4 };

    KnapsackSolver solver = new KnapsackSolver(
        KnapsackSolver.SolverType.KNAPSACK_MULTIDIMENSION_BRANCH_AND_BOUND_SOLVER,
        "Multi-dimensional solver");
    solver.init(profits, weights, capacities);
    final long profit = solver.solve();
</code></pre></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KnapsackSolver(object):
    r&#34;&#34;&#34;
     This library solves knapsack problems.

     Problems the library solves include:
      - 0-1 knapsack problems,
      - Multi-dimensional knapsack problems,

    Given n items, each with a profit and a weight, given a knapsack of
    capacity c, the goal is to find a subset of items which fits inside c
    and maximizes the total profit.
    The knapsack problem can easily be extended from 1 to d dimensions.
    As an example, this can be useful to constrain the maximum number of
    items inside the knapsack.
    Without loss of generality, profits and weights are assumed to be positive.

    From a mathematical point of view, the multi-dimensional knapsack problem
    can be modeled by d linear constraints:

        ForEach(j:1..d)(Sum(i:1..n)(weight_ij * item_i) &lt;= c_j
            where item_i is a 0-1 integer variable.

    Then the goal is to maximize:

        Sum(i:1..n)(profit_i * item_i).

    There are several ways to solve knapsack problems. One of the most
    efficient is based on dynamic programming (mainly when weights, profits
    and dimensions are small, and the algorithm runs in pseudo polynomial time).
    Unfortunately, when adding conflict constraints the problem becomes strongly
    NP-hard, i.e. there is no pseudo-polynomial algorithm to solve it.
    That&#39;s the reason why the most of the following code is based on branch and
    bound search.

    For instance to solve a 2-dimensional knapsack problem with 9 items,
    one just has to feed a profit vector with the 9 profits, a vector of 2
    vectors for weights, and a vector of capacities.
    E.g.:

      **Python**:

      .. code-block:: c++

              profits = [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ]
              weights = [ [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ],
                          [ 1, 1, 1, 1, 1, 1, 1, 1, 1 ]
                        ]
              capacities = [ 34, 4 ]

              solver = pywrapknapsack_solver.KnapsackSolver(
                  pywrapknapsack_solver.KnapsackSolver
                      .KNAPSACK_MULTIDIMENSION_BRANCH_AND_BOUND_SOLVER,
                  &#39;Multi-dimensional solver&#39;)
              solver.Init(profits, weights, capacities)
              profit = solver.Solve()

      **C++**:

      .. code-block:: c++

             const std::vectorint64 profits = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
             const std::vectorstd::vector&lt;int64 weights =
                 { { 1, 2, 3, 4, 5, 6, 7, 8, 9 },
                   { 1, 1, 1, 1, 1, 1, 1, 1, 1 } };
             const std::vectorint64 capacities = { 34, 4 };

             KnapsackSolver solver(
                 KnapsackSolver::KNAPSACK_MULTIDIMENSION_BRANCH_AND_BOUND_SOLVER,
                 &#34;Multi-dimensional solver&#34;);
             solver.Init(profits, weights, capacities);
             const int64 profit = solver.Solve();

      **Java**:

      .. code-block:: c++

            final long[] profits = { 1, 2, 3, 4, 5, 6, 7, 8, 9 };
            final long[][] weights = { { 1, 2, 3, 4, 5, 6, 7, 8, 9 },
                   { 1, 1, 1, 1, 1, 1, 1, 1, 1 } };
            final long[] capacities = { 34, 4 };

            KnapsackSolver solver = new KnapsackSolver(
                KnapsackSolver.SolverType.KNAPSACK_MULTIDIMENSION_BRANCH_AND_BOUND_SOLVER,
                &#34;Multi-dimensional solver&#34;);
            solver.init(profits, weights, capacities);
            final long profit = solver.solve();
    &#34;&#34;&#34;

    thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)
    __repr__ = _swig_repr
    KNAPSACK_BRUTE_FORCE_SOLVER = _pywrapknapsack_solver.KnapsackSolver_KNAPSACK_BRUTE_FORCE_SOLVER
    r&#34;&#34;&#34;
     Brute force method.

    Limited to 30 items and one dimension, this
    solver uses a brute force algorithm, ie. explores all possible states.
    Experiments show competitive performance for instances with less than
    15 items.
    &#34;&#34;&#34;
    KNAPSACK_64ITEMS_SOLVER = _pywrapknapsack_solver.KnapsackSolver_KNAPSACK_64ITEMS_SOLVER
    r&#34;&#34;&#34;
     Optimized method for single dimension small problems

    Limited to 64 items and one dimension, this
    solver uses a branch &amp; bound algorithm. This solver is about 4 times
    faster than KNAPSACK_MULTIDIMENSION_BRANCH_AND_BOUND_SOLVER.
    &#34;&#34;&#34;
    KNAPSACK_DYNAMIC_PROGRAMMING_SOLVER = _pywrapknapsack_solver.KnapsackSolver_KNAPSACK_DYNAMIC_PROGRAMMING_SOLVER
    r&#34;&#34;&#34;
     Dynamic Programming approach for single dimension problems

    Limited to one dimension, this solver is based on a dynamic programming
    algorithm. The time and space complexity is O(capacity *
    number_of_items).
    &#34;&#34;&#34;
    KNAPSACK_MULTIDIMENSION_CBC_MIP_SOLVER = _pywrapknapsack_solver.KnapsackSolver_KNAPSACK_MULTIDIMENSION_CBC_MIP_SOLVER
    r&#34;&#34;&#34;
     CBC Based Solver

     This solver can deal with both large number of items and several
    dimensions. This solver is based on Integer Programming solver CBC.
    &#34;&#34;&#34;
    KNAPSACK_MULTIDIMENSION_BRANCH_AND_BOUND_SOLVER = _pywrapknapsack_solver.KnapsackSolver_KNAPSACK_MULTIDIMENSION_BRANCH_AND_BOUND_SOLVER
    r&#34;&#34;&#34;
     Generic Solver.

    This solver can deal with both large number of items and several
    dimensions. This solver is based on branch and bound.
    &#34;&#34;&#34;

    def __init__(self, *args):
        _pywrapknapsack_solver.KnapsackSolver_swiginit(self, _pywrapknapsack_solver.new_KnapsackSolver(*args))
    __swig_destroy__ = _pywrapknapsack_solver.delete_KnapsackSolver

    def Init(self, profits: &#34;std::vector&lt; int64 &gt; const &amp;&#34;, weights: &#34;std::vector&lt; std::vector&lt; int64 &gt; &gt; const &amp;&#34;, capacities: &#34;std::vector&lt; int64 &gt; const &amp;&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34;Initializes the solver and enters the problem to be solved.&#34;&#34;&#34;
        return _pywrapknapsack_solver.KnapsackSolver_Init(self, profits, weights, capacities)

    def Solve(self) -&gt; &#34;int64&#34;:
        r&#34;&#34;&#34;Solves the problem and returns the profit of the optimal solution.&#34;&#34;&#34;
        return _pywrapknapsack_solver.KnapsackSolver_Solve(self)

    def BestSolutionContains(self, item_id: &#34;int&#34;) -&gt; &#34;bool&#34;:
        r&#34;&#34;&#34;Returns true if the item &#39;item_id&#39; is packed in the optimal knapsack.&#34;&#34;&#34;
        return _pywrapknapsack_solver.KnapsackSolver_BestSolutionContains(self, item_id)

    def set_use_reduction(self, use_reduction: &#34;bool&#34;) -&gt; &#34;void&#34;:
        return _pywrapknapsack_solver.KnapsackSolver_set_use_reduction(self, use_reduction)

    def set_time_limit(self, time_limit_seconds: &#34;double&#34;) -&gt; &#34;void&#34;:
        r&#34;&#34;&#34;
         Time limit in seconds.

        When a finite time limit is set the solution obtained might not be optimal
        if the limit is reached.
        &#34;&#34;&#34;
        return _pywrapknapsack_solver.KnapsackSolver_set_time_limit(self, time_limit_seconds)</code></pre>
</details>
<h3>Class variables</h3>
<dl>
<dt id="pywrapknapsack_solver.KnapsackSolver.KNAPSACK_64ITEMS_SOLVER"><code class="name">var <span class="ident">KNAPSACK_64ITEMS_SOLVER</span></code></dt>
<dd>
<section class="desc"><p>Optimized method for single dimension small problems</p>
<p>Limited to 64 items and one dimension, this
solver uses a branch &amp; bound algorithm. This solver is about 4 times
faster than KNAPSACK_MULTIDIMENSION_BRANCH_AND_BOUND_SOLVER.</p></section>
</dd>
<dt id="pywrapknapsack_solver.KnapsackSolver.KNAPSACK_BRUTE_FORCE_SOLVER"><code class="name">var <span class="ident">KNAPSACK_BRUTE_FORCE_SOLVER</span></code></dt>
<dd>
<section class="desc"><p>Brute force method.</p>
<p>Limited to 30 items and one dimension, this
solver uses a brute force algorithm, ie. explores all possible states.
Experiments show competitive performance for instances with less than
15 items.</p></section>
</dd>
<dt id="pywrapknapsack_solver.KnapsackSolver.KNAPSACK_DYNAMIC_PROGRAMMING_SOLVER"><code class="name">var <span class="ident">KNAPSACK_DYNAMIC_PROGRAMMING_SOLVER</span></code></dt>
<dd>
<section class="desc"><p>Dynamic Programming approach for single dimension problems</p>
<p>Limited to one dimension, this solver is based on a dynamic programming
algorithm. The time and space complexity is O(capacity *
number_of_items).</p></section>
</dd>
<dt id="pywrapknapsack_solver.KnapsackSolver.KNAPSACK_MULTIDIMENSION_BRANCH_AND_BOUND_SOLVER"><code class="name">var <span class="ident">KNAPSACK_MULTIDIMENSION_BRANCH_AND_BOUND_SOLVER</span></code></dt>
<dd>
<section class="desc"><p>Generic Solver.</p>
<p>This solver can deal with both large number of items and several
dimensions. This solver is based on branch and bound.</p></section>
</dd>
<dt id="pywrapknapsack_solver.KnapsackSolver.KNAPSACK_MULTIDIMENSION_CBC_MIP_SOLVER"><code class="name">var <span class="ident">KNAPSACK_MULTIDIMENSION_CBC_MIP_SOLVER</span></code></dt>
<dd>
<section class="desc"><p>CBC Based Solver</p>
<p>This solver can deal with both large number of items and several
dimensions. This solver is based on Integer Programming solver CBC.</p></section>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="pywrapknapsack_solver.KnapsackSolver.thisown"><code class="name">var <span class="ident">thisown</span></code></dt>
<dd>
<section class="desc"><p>The membership flag</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">thisown = property(lambda x: x.this.own(), lambda x, v: x.this.own(v), doc=&#34;The membership flag&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="pywrapknapsack_solver.KnapsackSolver.BestSolutionContains"><code class="name flex">
<span>def <span class="ident">BestSolutionContains</span></span>(<span>self, item_id)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns true if the item 'item_id' is packed in the optimal knapsack.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def BestSolutionContains(self, item_id: &#34;int&#34;) -&gt; &#34;bool&#34;:
    r&#34;&#34;&#34;Returns true if the item &#39;item_id&#39; is packed in the optimal knapsack.&#34;&#34;&#34;
    return _pywrapknapsack_solver.KnapsackSolver_BestSolutionContains(self, item_id)</code></pre>
</details>
</dd>
<dt id="pywrapknapsack_solver.KnapsackSolver.Init"><code class="name flex">
<span>def <span class="ident">Init</span></span>(<span>self, profits, weights, capacities)</span>
</code></dt>
<dd>
<section class="desc"><p>Initializes the solver and enters the problem to be solved.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Init(self, profits: &#34;std::vector&lt; int64 &gt; const &amp;&#34;, weights: &#34;std::vector&lt; std::vector&lt; int64 &gt; &gt; const &amp;&#34;, capacities: &#34;std::vector&lt; int64 &gt; const &amp;&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34;Initializes the solver and enters the problem to be solved.&#34;&#34;&#34;
    return _pywrapknapsack_solver.KnapsackSolver_Init(self, profits, weights, capacities)</code></pre>
</details>
</dd>
<dt id="pywrapknapsack_solver.KnapsackSolver.Solve"><code class="name flex">
<span>def <span class="ident">Solve</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Solves the problem and returns the profit of the optimal solution.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def Solve(self) -&gt; &#34;int64&#34;:
    r&#34;&#34;&#34;Solves the problem and returns the profit of the optimal solution.&#34;&#34;&#34;
    return _pywrapknapsack_solver.KnapsackSolver_Solve(self)</code></pre>
</details>
</dd>
<dt id="pywrapknapsack_solver.KnapsackSolver.set_time_limit"><code class="name flex">
<span>def <span class="ident">set_time_limit</span></span>(<span>self, time_limit_seconds)</span>
</code></dt>
<dd>
<section class="desc"><p>Time limit in seconds.</p>
<p>When a finite time limit is set the solution obtained might not be optimal
if the limit is reached.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_time_limit(self, time_limit_seconds: &#34;double&#34;) -&gt; &#34;void&#34;:
    r&#34;&#34;&#34;
     Time limit in seconds.

    When a finite time limit is set the solution obtained might not be optimal
    if the limit is reached.
    &#34;&#34;&#34;
    return _pywrapknapsack_solver.KnapsackSolver_set_time_limit(self, time_limit_seconds)</code></pre>
</details>
</dd>
<dt id="pywrapknapsack_solver.KnapsackSolver.set_use_reduction"><code class="name flex">
<span>def <span class="ident">set_use_reduction</span></span>(<span>self, use_reduction)</span>
</code></dt>
<dd>
<section class="desc"></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_use_reduction(self, use_reduction: &#34;bool&#34;) -&gt; &#34;void&#34;:
    return _pywrapknapsack_solver.KnapsackSolver_set_use_reduction(self, use_reduction)</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<header>
<a class="homelink" rel="home" title="OR-Tools Home" href="https://google.github.io/or-tools/">
<img src="https://developers.google.com/optimization/images/orLogo.png" alt=""> OR-Tools
</a>
</header>
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="pywrapknapsack_solver.KnapsackSolver" href="#pywrapknapsack_solver.KnapsackSolver">KnapsackSolver</a></code></h4>
<ul class="">
<li><code><a title="pywrapknapsack_solver.KnapsackSolver.BestSolutionContains" href="#pywrapknapsack_solver.KnapsackSolver.BestSolutionContains">BestSolutionContains</a></code></li>
<li><code><a title="pywrapknapsack_solver.KnapsackSolver.Init" href="#pywrapknapsack_solver.KnapsackSolver.Init">Init</a></code></li>
<li><code><a title="pywrapknapsack_solver.KnapsackSolver.KNAPSACK_64ITEMS_SOLVER" href="#pywrapknapsack_solver.KnapsackSolver.KNAPSACK_64ITEMS_SOLVER">KNAPSACK_64ITEMS_SOLVER</a></code></li>
<li><code><a title="pywrapknapsack_solver.KnapsackSolver.KNAPSACK_BRUTE_FORCE_SOLVER" href="#pywrapknapsack_solver.KnapsackSolver.KNAPSACK_BRUTE_FORCE_SOLVER">KNAPSACK_BRUTE_FORCE_SOLVER</a></code></li>
<li><code><a title="pywrapknapsack_solver.KnapsackSolver.KNAPSACK_DYNAMIC_PROGRAMMING_SOLVER" href="#pywrapknapsack_solver.KnapsackSolver.KNAPSACK_DYNAMIC_PROGRAMMING_SOLVER">KNAPSACK_DYNAMIC_PROGRAMMING_SOLVER</a></code></li>
<li><code><a title="pywrapknapsack_solver.KnapsackSolver.KNAPSACK_MULTIDIMENSION_BRANCH_AND_BOUND_SOLVER" href="#pywrapknapsack_solver.KnapsackSolver.KNAPSACK_MULTIDIMENSION_BRANCH_AND_BOUND_SOLVER">KNAPSACK_MULTIDIMENSION_BRANCH_AND_BOUND_SOLVER</a></code></li>
<li><code><a title="pywrapknapsack_solver.KnapsackSolver.KNAPSACK_MULTIDIMENSION_CBC_MIP_SOLVER" href="#pywrapknapsack_solver.KnapsackSolver.KNAPSACK_MULTIDIMENSION_CBC_MIP_SOLVER">KNAPSACK_MULTIDIMENSION_CBC_MIP_SOLVER</a></code></li>
<li><code><a title="pywrapknapsack_solver.KnapsackSolver.Solve" href="#pywrapknapsack_solver.KnapsackSolver.Solve">Solve</a></code></li>
<li><code><a title="pywrapknapsack_solver.KnapsackSolver.set_time_limit" href="#pywrapknapsack_solver.KnapsackSolver.set_time_limit">set_time_limit</a></code></li>
<li><code><a title="pywrapknapsack_solver.KnapsackSolver.set_use_reduction" href="#pywrapknapsack_solver.KnapsackSolver.set_use_reduction">set_use_reduction</a></code></li>
<li><code><a title="pywrapknapsack_solver.KnapsackSolver.thisown" href="#pywrapknapsack_solver.KnapsackSolver.thisown">thisown</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p><span style="color:#ddd">&#21328;</span></p>
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.0</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>