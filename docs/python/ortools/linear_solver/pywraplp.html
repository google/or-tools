<!doctype html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="generator" content="pdoc 8.0.0" />
    <title>pywraplp API documentation</title>
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20width%3D%2264%22%20height%3D%2264%22%20viewBox%3D%2244.5%202.5%2015%2015%22%3E%3Cpath%20d%3D%22M49.351%2021.041c-.233-.721-.546-2.408-.772-4.076-.042-.09-.067-.187-.046-.288-.166-1.347-.277-2.625-.241-3.351-1.378-1.008-2.271-2.586-2.271-4.362%200-.976.272-1.935.788-2.774.057-.094.122-.18.184-.268-.033-.167-.052-.339-.052-.516%200-1.477%201.202-2.679%202.679-2.679.791%200%201.496.352%201.987.9a6.3%206.3%200%200%201%201.001.029c.492-.564%201.207-.929%202.012-.929%201.477%200%202.679%201.202%202.679%202.679a2.65%202.65%200%200%201-.269%201.148c.383.747.595%201.572.595%202.41%200%202.311-1.507%204.29-3.635%205.107.037.699.147%202.27.423%203.294l.137.461c.156%202.136-4.612%205.166-5.199%203.215zm.127-4.919a4.78%204.78%200%200%200%20.775-.584c-.172-.115-.505-.254-.88-.378zm.331%202.302l.828-.502c-.202-.143-.576-.328-.984-.49zm.45%202.157l.701-.403c-.214-.115-.536-.249-.891-.376l.19.779zM49.13%204.141c0%20.152.123.276.276.276s.275-.124.275-.276-.123-.276-.276-.276-.275.124-.275.276zm.735-.389a1.15%201.15%200%200%201%20.314.783%201.16%201.16%200%200%201-1.162%201.162c-.457%200-.842-.27-1.032-.653-.026.117-.042.238-.042.362a1.68%201.68%200%200%200%201.679%201.679%201.68%201.68%200%200%200%201.679-1.679c0-.843-.626-1.535-1.436-1.654zm3.076%201.654a1.68%201.68%200%200%200%201.679%201.679%201.68%201.68%200%200%200%201.679-1.679c0-.037-.009-.072-.011-.109-.21.3-.541.508-.935.508a1.16%201.16%200%200%201-1.162-1.162%201.14%201.14%200%200%201%20.474-.912c-.015%200-.03-.005-.045-.005-.926.001-1.679.754-1.679%201.68zm1.861-1.265c0%20.152.123.276.276.276s.275-.124.275-.276-.123-.276-.276-.276-.275.124-.275.276zm1.823%204.823c0-.52-.103-1.035-.288-1.52-.466.394-1.06.64-1.717.64-1.144%200-2.116-.725-2.499-1.738-.383%201.012-1.355%201.738-2.499%201.738-.867%200-1.631-.421-2.121-1.062-.307.605-.478%201.267-.478%201.942%200%202.486%202.153%204.51%204.801%204.51s4.801-2.023%204.801-4.51zm-3.032%209.156l-.146-.492c-.276-1.02-.395-2.457-.444-3.268a6.11%206.11%200%200%201-1.18.115%206.01%206.01%200%200%201-2.536-.562l.006.175c.802.215%201.848.612%202.021%201.25.079.295-.021.601-.274.837l-.598.501c.667.304%201.243.698%201.311%201.179.02.144.022.507-.393.787l-.564.365c1.285.521%201.361.96%201.381%201.126.018.142.011.496-.427.746l-.854.489c.064-1.19%201.985-2.585%202.697-3.248zM49.34%209.925c0-.667%201-.667%201%200%200%20.653.818%201.205%201.787%201.205s1.787-.552%201.787-1.205c0-.667%201-.667%201%200%200%201.216-1.25%202.205-2.787%202.205s-2.787-.989-2.787-2.205zm-.887-7.633c-.093.077-.205.114-.317.114a.5.5%200%200%201-.318-.886L49.183.397a.5.5%200%200%201%20.703.068.5.5%200%200%201-.069.703zm7.661-.065c-.086%200-.173-.022-.253-.068l-1.523-.893c-.575-.337-.069-1.2.506-.863l1.523.892a.5.5%200%200%201%20.179.685c-.094.158-.261.247-.432.247z%22%20fill%3D%22%233bb300%22/%3E%3C/svg%3E"/>


<style>/*! * Bootstrap Reboot v5.0.0 (https://getbootstrap.com/) * Copyright 2011-2021 The Bootstrap Authors * Copyright 2011-2021 Twitter, Inc. * Licensed under MIT (https://github.com/twbs/bootstrap/blob/main/LICENSE) * Forked from Normalize.css, licensed MIT (https://github.com/necolas/normalize.css/blob/master/LICENSE.md) */*,::after,::before{box-sizing:border-box}@media (prefers-reduced-motion:no-preference){:root{scroll-behavior:smooth}}body{margin:0;font-family:system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial,"Noto Sans","Liberation Sans",sans-serif,"Apple Color Emoji","Segoe UI Emoji","Segoe UI Symbol","Noto Color Emoji";font-size:1rem;font-weight:400;line-height:1.5;color:#212529;background-color:#fff;-webkit-text-size-adjust:100%;-webkit-tap-highlight-color:transparent}hr{margin:1rem 0;color:inherit;background-color:currentColor;border:0;opacity:.25}hr:not([size]){height:1px}h1,h2,h3,h4,h5,h6{margin-top:0;margin-bottom:.5rem;font-weight:500;line-height:1.2}h1{font-size:calc(1.375rem + 1.5vw)}@media (min-width:1200px){h1{font-size:2.5rem}}h2{font-size:calc(1.325rem + .9vw)}@media (min-width:1200px){h2{font-size:2rem}}h3{font-size:calc(1.3rem + .6vw)}@media (min-width:1200px){h3{font-size:1.75rem}}h4{font-size:calc(1.275rem + .3vw)}@media (min-width:1200px){h4{font-size:1.5rem}}h5{font-size:1.25rem}h6{font-size:1rem}p{margin-top:0;margin-bottom:1rem}abbr[data-bs-original-title],abbr[title]{-webkit-text-decoration:underline dotted;text-decoration:underline dotted;cursor:help;-webkit-text-decoration-skip-ink:none;text-decoration-skip-ink:none}address{margin-bottom:1rem;font-style:normal;line-height:inherit}ol,ul{padding-left:2rem}dl,ol,ul{margin-top:0;margin-bottom:1rem}ol ol,ol ul,ul ol,ul ul{margin-bottom:0}dt{font-weight:700}dd{margin-bottom:.5rem;margin-left:0}blockquote{margin:0 0 1rem}b,strong{font-weight:bolder}small{font-size:.875em}mark{padding:.2em;background-color:#fcf8e3}sub,sup{position:relative;font-size:.75em;line-height:0;vertical-align:baseline}sub{bottom:-.25em}sup{top:-.5em}a{color:#0d6efd;text-decoration:underline}a:hover{color:#0a58ca}a:not([href]):not([class]),a:not([href]):not([class]):hover{color:inherit;text-decoration:none}code,kbd,pre,samp{font-family:SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;font-size:1em;direction:ltr;unicode-bidi:bidi-override}pre{display:block;margin-top:0;margin-bottom:1rem;overflow:auto;font-size:.875em}pre code{font-size:inherit;color:inherit;word-break:normal}code{font-size:.875em;color:#d63384;word-wrap:break-word}a>code{color:inherit}kbd{padding:.2rem .4rem;font-size:.875em;color:#fff;background-color:#212529;border-radius:.2rem}kbd kbd{padding:0;font-size:1em;font-weight:700}figure{margin:0 0 1rem}img,svg{vertical-align:middle}table{caption-side:bottom;border-collapse:collapse}caption{padding-top:.5rem;padding-bottom:.5rem;color:#6c757d;text-align:left}th{text-align:inherit;text-align:-webkit-match-parent}tbody,td,tfoot,th,thead,tr{border-color:inherit;border-style:solid;border-width:0}label{display:inline-block}button{border-radius:0}button:focus:not(:focus-visible){outline:0}button,input,optgroup,select,textarea{margin:0;font-family:inherit;font-size:inherit;line-height:inherit}button,select{text-transform:none}[role=button]{cursor:pointer}select{word-wrap:normal}select:disabled{opacity:1}[list]::-webkit-calendar-picker-indicator{display:none}[type=button],[type=reset],[type=submit],button{-webkit-appearance:button}[type=button]:not(:disabled),[type=reset]:not(:disabled),[type=submit]:not(:disabled),button:not(:disabled){cursor:pointer}::-moz-focus-inner{padding:0;border-style:none}textarea{resize:vertical}fieldset{min-width:0;padding:0;margin:0;border:0}legend{float:left;width:100%;padding:0;margin-bottom:.5rem;font-size:calc(1.275rem + .3vw);line-height:inherit}@media (min-width:1200px){legend{font-size:1.5rem}}legend+*{clear:left}::-webkit-datetime-edit-day-field,::-webkit-datetime-edit-fields-wrapper,::-webkit-datetime-edit-hour-field,::-webkit-datetime-edit-minute,::-webkit-datetime-edit-month-field,::-webkit-datetime-edit-text,::-webkit-datetime-edit-year-field{padding:0}::-webkit-inner-spin-button{height:auto}[type=search]{outline-offset:-2px;-webkit-appearance:textfield}::-webkit-search-decoration{-webkit-appearance:none}::-webkit-color-swatch-wrapper{padding:0}::file-selector-button{font:inherit}::-webkit-file-upload-button{font:inherit;-webkit-appearance:button}output{display:inline-block}iframe{border:0}summary{display:list-item;cursor:pointer}progress{vertical-align:baseline}[hidden]{display:none!important}</style>
<style>/*! pygments syntax highlighting */pre{line-height:125%;}td.linenos pre{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}span.linenos{color:#000000; background-color:#f0f0f0; padding-left:5px; padding-right:5px;}td.linenos pre.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}span.linenos.special{color:#000000; background-color:#ffffc0; padding-left:5px; padding-right:5px;}.pdoc .hll{background-color:#ffffcc}.pdoc{background:#f8f8f8;}.pdoc .c{color:#408080; font-style:italic}.pdoc .err{border:1px solid #FF0000}.pdoc .k{color:#008000; font-weight:bold}.pdoc .o{color:#666666}.pdoc .ch{color:#408080; font-style:italic}.pdoc .cm{color:#408080; font-style:italic}.pdoc .cp{color:#BC7A00}.pdoc .cpf{color:#408080; font-style:italic}.pdoc .c1{color:#408080; font-style:italic}.pdoc .cs{color:#408080; font-style:italic}.pdoc .gd{color:#A00000}.pdoc .ge{font-style:italic}.pdoc .gr{color:#FF0000}.pdoc .gh{color:#000080; font-weight:bold}.pdoc .gi{color:#00A000}.pdoc .go{color:#888888}.pdoc .gp{color:#000080; font-weight:bold}.pdoc .gs{font-weight:bold}.pdoc .gu{color:#800080; font-weight:bold}.pdoc .gt{color:#0044DD}.pdoc .kc{color:#008000; font-weight:bold}.pdoc .kd{color:#008000; font-weight:bold}.pdoc .kn{color:#008000; font-weight:bold}.pdoc .kp{color:#008000}.pdoc .kr{color:#008000; font-weight:bold}.pdoc .kt{color:#B00040}.pdoc .m{color:#666666}.pdoc .s{color:#BA2121}.pdoc .na{color:#7D9029}.pdoc .nb{color:#008000}.pdoc .nc{color:#0000FF; font-weight:bold}.pdoc .no{color:#880000}.pdoc .nd{color:#AA22FF}.pdoc .ni{color:#999999; font-weight:bold}.pdoc .ne{color:#D2413A; font-weight:bold}.pdoc .nf{color:#0000FF}.pdoc .nl{color:#A0A000}.pdoc .nn{color:#0000FF; font-weight:bold}.pdoc .nt{color:#008000; font-weight:bold}.pdoc .nv{color:#19177C}.pdoc .ow{color:#AA22FF; font-weight:bold}.pdoc .w{color:#bbbbbb}.pdoc .mb{color:#666666}.pdoc .mf{color:#666666}.pdoc .mh{color:#666666}.pdoc .mi{color:#666666}.pdoc .mo{color:#666666}.pdoc .sa{color:#BA2121}.pdoc .sb{color:#BA2121}.pdoc .sc{color:#BA2121}.pdoc .dl{color:#BA2121}.pdoc .sd{color:#BA2121; font-style:italic}.pdoc .s2{color:#BA2121}.pdoc .se{color:#BB6622; font-weight:bold}.pdoc .sh{color:#BA2121}.pdoc .si{color:#BB6688; font-weight:bold}.pdoc .sx{color:#008000}.pdoc .sr{color:#BB6688}.pdoc .s1{color:#BA2121}.pdoc .ss{color:#19177C}.pdoc .bp{color:#008000}.pdoc .fm{color:#0000FF}.pdoc .vc{color:#19177C}.pdoc .vg{color:#19177C}.pdoc .vi{color:#19177C}.pdoc .vm{color:#19177C}.pdoc .il{color:#666666}</style>
<style>/*! pdoc */:root{--pdoc-background:#fff;}.pdoc{--text:#212529;--muted:#6c757d;--link:#3660a5;--link-hover:#1659c5;--code:#f7f7f7;--active:#fff598;--accent:#eee;--accent2:#c1c1c1;--nav-hover:rgba(255, 255, 255, 0.5);--name:#0066BB;--def:#008800;--annotation:#007020;}body{background-color:var(--pdoc-background);}html, body{width:100%;height:100%;}@media (max-width:769px){#navtoggle{cursor:pointer;position:absolute;width:50px;height:40px;top:1rem;right:1rem;border-color:var(--text);color:var(--text);display:flex;opacity:0.8;}#navtoggle:hover{opacity:1;}#togglestate + div{display:none;}#togglestate:checked + div{display:inherit;}main, header{padding:2rem 3vw;}.git-button{display:none !important;}nav input[type="search"]:valid ~ *{display:none !important;}}@media (min-width:770px){:root{--sidebar-width:clamp(12.5rem, 28vw, 22rem);}nav{position:fixed;overflow:auto;height:100vh;width:var(--sidebar-width);}main, header{padding:3rem 2rem 3rem calc(var(--sidebar-width) + 3rem);width:calc(54rem + var(--sidebar-width));max-width:100%;}#navtoggle{display:none;}}#togglestate{display:none;}nav.pdoc{--pad:1.75rem;--indent:1.5rem;background-color:var(--accent);border-right:1px solid var(--accent2);box-shadow:0 0 20px rgba(50, 50, 50, .2) inset;padding:0 0 0 var(--pad);overflow-wrap:anywhere;scrollbar-width:thin; scrollbar-color:var(--accent2) transparent }nav.pdoc::-webkit-scrollbar{width:.4rem; }nav.pdoc::-webkit-scrollbar-thumb{background-color:var(--accent2); }nav.pdoc > div{padding:var(--pad) 0;}nav.pdoc .module-list-button{display:inline-flex;align-items:center;color:var(--text);border-color:var(--muted);margin-bottom:1rem;}nav.pdoc .module-list-button:hover{border-color:var(--text);}nav.pdoc input[type=search]{display:block;outline-offset:0;width:calc(100% - var(--pad));}nav.pdoc .logo{max-width:calc(100% - var(--pad));max-height:35vh;display:block;margin:0 auto 1rem;transform:translate(calc(-.5 * var(--pad)), 0);}nav.pdoc ul{list-style:none;padding-left:0;}nav.pdoc li{display:block;margin:0;padding:.2rem 0 .2rem var(--indent);transition:all 100ms;}nav.pdoc > div > ul > li{padding-left:0;}nav.pdoc li:hover{background-color:var(--nav-hover);}nav.pdoc a, nav.pdoc a:hover{color:var(--text);}nav.pdoc a{display:block;}nav.pdoc > h2:first-of-type{margin-top:1.5rem;}nav.pdoc .class:before{content:"class ";color:var(--muted);}nav.pdoc .function:after{content:"()";color:var(--muted);}nav.pdoc footer:before{content:"";display:block;width:calc(100% - var(--pad));border-top:solid var(--accent2) 1px;margin-top:1.5rem;padding-top:.5rem;}nav.pdoc footer{font-size:small;}html, main{scroll-behavior:smooth;}.pdoc{color:var(--text);box-sizing:border-box;line-height:1.5;background:none;}.pdoc .pdoc-button{display:inline-block;border:solid black 1px;border-radius:2px;font-size:.75rem;padding:calc(0.5em - 1px) 1em;transition:100ms all;}.pdoc .visually-hidden{position:absolute !important;width:1px !important;height:1px !important;padding:0 !important;margin:-1px !important;overflow:hidden !important;clip:rect(0, 0, 0, 0) !important;white-space:nowrap !important;border:0 !important;}.pdoc h1, .pdoc h2, .pdoc h3{font-weight:300;margin:.3em 0;padding:.2em 0;}.pdoc a{text-decoration:none;color:var(--link);}.pdoc a:hover{color:var(--link-hover);}.pdoc blockquote{margin-left:2rem;}.pdoc pre{background-color:var(--code);border-top:1px solid var(--accent2);border-bottom:1px solid var(--accent2);margin-bottom:1em;padding:.5rem 0 .5rem .5rem;overflow-x:auto;}.pdoc code{color:var(--text);padding:.2em .4em;margin:0;font-size:85%;background-color:var(--code);border-radius:6px;}.pdoc a > code{color:inherit;}.pdoc pre > code{display:inline-block;font-size:inherit;background:none;border:none;padding:0;}.pdoc .modulename{margin-top:0;font-weight:bold;}.pdoc .modulename a{color:var(--link);transition:100ms all;}.pdoc .git-button{float:right;border:solid var(--link) 1px;}.pdoc .git-button:hover{background-color:var(--link);color:var(--pdoc-background);}.pdoc details{--shift:-40px;text-align:right;margin-top:var(--shift);margin-bottom:calc(0px - var(--shift));clear:both;filter:opacity(1);}.pdoc details:not([open]){height:0;overflow:visible;}.pdoc details > summary{font-size:.75rem;cursor:pointer;color:var(--muted);border-width:0;padding:0 .7em;display:inline-block;display:inline list-item;user-select:none;}.pdoc details > summary:focus{outline:0;}.pdoc details > div{margin-top:calc(0px - var(--shift) / 2);text-align:left;}.pdoc .docstring{margin-bottom:1.5rem;}.pdoc > section:first-of-type > .docstring{margin-bottom:3rem;}.pdoc .docstring pre{margin-left:1em;margin-right:1em;}.pdoc h1:target,.pdoc h2:target,.pdoc h3:target,.pdoc h4:target,.pdoc h5:target,.pdoc h6:target{background-color:var(--active);box-shadow:-1rem 0 0 0 var(--active);}.pdoc div:target > .attr,.pdoc section:target > .attr,.pdoc dd:target > a{background-color:var(--active);}.pdoc .attr:hover{filter:contrast(0.95);}.pdoc .headerlink{position:absolute;width:0;margin-left:-1.5rem;line-height:1.4rem;font-size:1.5rem;font-weight:normal;transition:all 100ms ease-in-out;opacity:0;}.pdoc .attr > .headerlink{margin-left:-2.5rem;}.pdoc *:hover > .headerlink,.pdoc *:target > .attr > .headerlink{opacity:1;}.pdoc .attr{display:block;color:var(--text);margin:1rem 0 .5rem;padding:.4rem 5rem .4rem 1rem;background-color:var(--accent);}.pdoc .classattr{margin-left:2rem;}.pdoc .name{color:var(--name);font-weight:bold;}.pdoc .def{color:var(--def);font-weight:bold;}.pdoc .signature{white-space:pre-wrap;}.pdoc .annotation{color:var(--annotation);}.pdoc .inherited{margin-left:2rem;}.pdoc .inherited dt{font-weight:700;}.pdoc .inherited dt, .pdoc .inherited dd{display:inline;margin-left:0;margin-bottom:.5rem;}.pdoc .inherited dd:not(:last-child):after{content:", ";}.pdoc .inherited .class:before{content:"class ";}.pdoc .inherited .function a:after{content:"()";}.pdoc .search-result .docstring{overflow:auto;max-height:25vh;}.pdoc .search-result.focused > .attr{background-color:var(--active);}.pdoc .attribution{margin-top:2rem;display:block;opacity:0.5;transition:all 200ms;filter:grayscale(100%);}.pdoc .attribution:hover{opacity:1;filter:grayscale(0%);}.pdoc .attribution img{margin-left:5px;height:35px;vertical-align:middle;width:70px;transition:all 200ms;}</style>
</head>
<body>        <nav class="pdoc">
            <label id="navtoggle" for="togglestate" class="pdoc-button"><svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'><path stroke-linecap='round' stroke="currentColor" stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/></svg></label>
            <input id="togglestate" type="checkbox">
            <div>

                        <img src="https://developers.google.com/optimization/images/orLogo.png" class="logo" alt="project logo"/>




                    <h2>API Documentation</h2>
                        <ul class="memberlist">
            <li>
                    <a class="class" href="#Solver">Solver</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#Solver.__init__">Solver</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.CLP_LINEAR_PROGRAMMING">CLP_LINEAR_PROGRAMMING</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.GLPK_LINEAR_PROGRAMMING">GLPK_LINEAR_PROGRAMMING</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.GLOP_LINEAR_PROGRAMMING">GLOP_LINEAR_PROGRAMMING</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.SCIP_MIXED_INTEGER_PROGRAMMING">SCIP_MIXED_INTEGER_PROGRAMMING</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.GLPK_MIXED_INTEGER_PROGRAMMING">GLPK_MIXED_INTEGER_PROGRAMMING</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.CBC_MIXED_INTEGER_PROGRAMMING">CBC_MIXED_INTEGER_PROGRAMMING</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.GUROBI_LINEAR_PROGRAMMING">GUROBI_LINEAR_PROGRAMMING</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.GUROBI_MIXED_INTEGER_PROGRAMMING">GUROBI_MIXED_INTEGER_PROGRAMMING</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.CPLEX_LINEAR_PROGRAMMING">CPLEX_LINEAR_PROGRAMMING</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.CPLEX_MIXED_INTEGER_PROGRAMMING">CPLEX_MIXED_INTEGER_PROGRAMMING</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.XPRESS_LINEAR_PROGRAMMING">XPRESS_LINEAR_PROGRAMMING</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.XPRESS_MIXED_INTEGER_PROGRAMMING">XPRESS_MIXED_INTEGER_PROGRAMMING</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.BOP_INTEGER_PROGRAMMING">BOP_INTEGER_PROGRAMMING</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.SAT_INTEGER_PROGRAMMING">SAT_INTEGER_PROGRAMMING</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.CreateSolver">CreateSolver</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.SupportsProblemType">SupportsProblemType</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Clear">Clear</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.NumVariables">NumVariables</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.variables">variables</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.variable">variable</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.LookupVariable">LookupVariable</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Var">Var</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.NumVar">NumVar</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.IntVar">IntVar</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.BoolVar">BoolVar</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.NumConstraints">NumConstraints</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.constraints">constraints</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.constraint">constraint</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.LookupConstraint">LookupConstraint</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Constraint">Constraint</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Objective">Objective</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.OPTIMAL">OPTIMAL</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.FEASIBLE">FEASIBLE</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.INFEASIBLE">INFEASIBLE</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.UNBOUNDED">UNBOUNDED</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.ABNORMAL">ABNORMAL</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.NOT_SOLVED">NOT_SOLVED</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Solve">Solve</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.ComputeConstraintActivities">ComputeConstraintActivities</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.VerifySolution">VerifySolution</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.InterruptSolve">InterruptSolve</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.FillSolutionResponseProto">FillSolutionResponseProto</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.SolveWithProto">SolveWithProto</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.ExportModelToProto">ExportModelToProto</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.SetSolverSpecificParametersAsString">SetSolverSpecificParametersAsString</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.FREE">FREE</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.AT_LOWER_BOUND">AT_LOWER_BOUND</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.AT_UPPER_BOUND">AT_UPPER_BOUND</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.FIXED_VALUE">FIXED_VALUE</a>
                        </li>
                        <li>
                                <a class="variable" href="#Solver.BASIC">BASIC</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.infinity">infinity</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.EnableOutput">EnableOutput</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.SuppressOutput">SuppressOutput</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.iterations">iterations</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.nodes">nodes</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.ComputeExactConditionNumber">ComputeExactConditionNumber</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.NextSolution">NextSolution</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.set_time_limit">set_time_limit</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.wall_time">wall_time</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.LoadModelFromProto">LoadModelFromProto</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.LoadModelFromProtoWithUniqueNamesOrDie">LoadModelFromProtoWithUniqueNamesOrDie</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.LoadSolutionFromProto">LoadSolutionFromProto</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.ExportModelAsLpFormat">ExportModelAsLpFormat</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.ExportModelAsMpsFormat">ExportModelAsMpsFormat</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.SetHint">SetHint</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.SetNumThreads">SetNumThreads</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Add">Add</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Sum">Sum</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.RowConstraint">RowConstraint</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Minimize">Minimize</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Maximize">Maximize</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Infinity">Infinity</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.SetTimeLimit">SetTimeLimit</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.WallTime">WallTime</a>
                        </li>
                        <li>
                                <a class="function" href="#Solver.Iterations">Iterations</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="function" href="#Solver_CreateSolver">Solver_CreateSolver</a>
            </li>
            <li>
                    <a class="function" href="#Solver_SupportsProblemType">Solver_SupportsProblemType</a>
            </li>
            <li>
                    <a class="function" href="#Solver_SolveWithProto">Solver_SolveWithProto</a>
            </li>
            <li>
                    <a class="function" href="#Solver_infinity">Solver_infinity</a>
            </li>
            <li>
                    <a class="function" href="#Solver_Infinity">Solver_Infinity</a>
            </li>
            <li>
                    <a class="class" href="#Objective">Objective</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#Objective.__init__">Objective</a>
                        </li>
                        <li>
                                <a class="variable" href="#Objective.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#Objective.Clear">Clear</a>
                        </li>
                        <li>
                                <a class="function" href="#Objective.SetCoefficient">SetCoefficient</a>
                        </li>
                        <li>
                                <a class="function" href="#Objective.GetCoefficient">GetCoefficient</a>
                        </li>
                        <li>
                                <a class="function" href="#Objective.SetOffset">SetOffset</a>
                        </li>
                        <li>
                                <a class="function" href="#Objective.offset">offset</a>
                        </li>
                        <li>
                                <a class="function" href="#Objective.SetOptimizationDirection">SetOptimizationDirection</a>
                        </li>
                        <li>
                                <a class="function" href="#Objective.SetMinimization">SetMinimization</a>
                        </li>
                        <li>
                                <a class="function" href="#Objective.SetMaximization">SetMaximization</a>
                        </li>
                        <li>
                                <a class="function" href="#Objective.maximization">maximization</a>
                        </li>
                        <li>
                                <a class="function" href="#Objective.minimization">minimization</a>
                        </li>
                        <li>
                                <a class="function" href="#Objective.Value">Value</a>
                        </li>
                        <li>
                                <a class="function" href="#Objective.BestBound">BestBound</a>
                        </li>
                        <li>
                                <a class="function" href="#Objective.Offset">Offset</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#Variable">Variable</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#Variable.__init__">Variable</a>
                        </li>
                        <li>
                                <a class="variable" href="#Variable.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#Variable.name">name</a>
                        </li>
                        <li>
                                <a class="function" href="#Variable.SetInteger">SetInteger</a>
                        </li>
                        <li>
                                <a class="function" href="#Variable.integer">integer</a>
                        </li>
                        <li>
                                <a class="function" href="#Variable.solution_value">solution_value</a>
                        </li>
                        <li>
                                <a class="function" href="#Variable.index">index</a>
                        </li>
                        <li>
                                <a class="function" href="#Variable.lb">lb</a>
                        </li>
                        <li>
                                <a class="function" href="#Variable.ub">ub</a>
                        </li>
                        <li>
                                <a class="function" href="#Variable.SetBounds">SetBounds</a>
                        </li>
                        <li>
                                <a class="function" href="#Variable.reduced_cost">reduced_cost</a>
                        </li>
                        <li>
                                <a class="function" href="#Variable.basis_status">basis_status</a>
                        </li>
                        <li>
                                <a class="function" href="#Variable.branching_priority">branching_priority</a>
                        </li>
                        <li>
                                <a class="function" href="#Variable.SetBranchingPriority">SetBranchingPriority</a>
                        </li>
                        <li>
                                <a class="function" href="#Variable.SolutionValue">SolutionValue</a>
                        </li>
                        <li>
                                <a class="function" href="#Variable.Integer">Integer</a>
                        </li>
                        <li>
                                <a class="function" href="#Variable.Lb">Lb</a>
                        </li>
                        <li>
                                <a class="function" href="#Variable.Ub">Ub</a>
                        </li>
                        <li>
                                <a class="function" href="#Variable.SetLb">SetLb</a>
                        </li>
                        <li>
                                <a class="function" href="#Variable.SetUb">SetUb</a>
                        </li>
                        <li>
                                <a class="function" href="#Variable.ReducedCost">ReducedCost</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#Constraint">Constraint</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#Constraint.__init__">Constraint</a>
                        </li>
                        <li>
                                <a class="variable" href="#Constraint.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="function" href="#Constraint.name">name</a>
                        </li>
                        <li>
                                <a class="function" href="#Constraint.Clear">Clear</a>
                        </li>
                        <li>
                                <a class="function" href="#Constraint.SetCoefficient">SetCoefficient</a>
                        </li>
                        <li>
                                <a class="function" href="#Constraint.GetCoefficient">GetCoefficient</a>
                        </li>
                        <li>
                                <a class="function" href="#Constraint.lb">lb</a>
                        </li>
                        <li>
                                <a class="function" href="#Constraint.ub">ub</a>
                        </li>
                        <li>
                                <a class="function" href="#Constraint.SetBounds">SetBounds</a>
                        </li>
                        <li>
                                <a class="function" href="#Constraint.set_is_lazy">set_is_lazy</a>
                        </li>
                        <li>
                                <a class="function" href="#Constraint.index">index</a>
                        </li>
                        <li>
                                <a class="function" href="#Constraint.dual_value">dual_value</a>
                        </li>
                        <li>
                                <a class="function" href="#Constraint.basis_status">basis_status</a>
                        </li>
                        <li>
                                <a class="function" href="#Constraint.Lb">Lb</a>
                        </li>
                        <li>
                                <a class="function" href="#Constraint.Ub">Ub</a>
                        </li>
                        <li>
                                <a class="function" href="#Constraint.SetLb">SetLb</a>
                        </li>
                        <li>
                                <a class="function" href="#Constraint.SetUb">SetUb</a>
                        </li>
                        <li>
                                <a class="function" href="#Constraint.DualValue">DualValue</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#MPSolverParameters">MPSolverParameters</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#MPSolverParameters.__init__">MPSolverParameters</a>
                        </li>
                        <li>
                                <a class="variable" href="#MPSolverParameters.thisown">thisown</a>
                        </li>
                        <li>
                                <a class="variable" href="#MPSolverParameters.RELATIVE_MIP_GAP">RELATIVE_MIP_GAP</a>
                        </li>
                        <li>
                                <a class="variable" href="#MPSolverParameters.PRIMAL_TOLERANCE">PRIMAL_TOLERANCE</a>
                        </li>
                        <li>
                                <a class="variable" href="#MPSolverParameters.DUAL_TOLERANCE">DUAL_TOLERANCE</a>
                        </li>
                        <li>
                                <a class="variable" href="#MPSolverParameters.PRESOLVE">PRESOLVE</a>
                        </li>
                        <li>
                                <a class="variable" href="#MPSolverParameters.LP_ALGORITHM">LP_ALGORITHM</a>
                        </li>
                        <li>
                                <a class="variable" href="#MPSolverParameters.INCREMENTALITY">INCREMENTALITY</a>
                        </li>
                        <li>
                                <a class="variable" href="#MPSolverParameters.SCALING">SCALING</a>
                        </li>
                        <li>
                                <a class="variable" href="#MPSolverParameters.PRESOLVE_OFF">PRESOLVE_OFF</a>
                        </li>
                        <li>
                                <a class="variable" href="#MPSolverParameters.PRESOLVE_ON">PRESOLVE_ON</a>
                        </li>
                        <li>
                                <a class="variable" href="#MPSolverParameters.DUAL">DUAL</a>
                        </li>
                        <li>
                                <a class="variable" href="#MPSolverParameters.PRIMAL">PRIMAL</a>
                        </li>
                        <li>
                                <a class="variable" href="#MPSolverParameters.BARRIER">BARRIER</a>
                        </li>
                        <li>
                                <a class="variable" href="#MPSolverParameters.INCREMENTALITY_OFF">INCREMENTALITY_OFF</a>
                        </li>
                        <li>
                                <a class="variable" href="#MPSolverParameters.INCREMENTALITY_ON">INCREMENTALITY_ON</a>
                        </li>
                        <li>
                                <a class="variable" href="#MPSolverParameters.SCALING_OFF">SCALING_OFF</a>
                        </li>
                        <li>
                                <a class="variable" href="#MPSolverParameters.SCALING_ON">SCALING_ON</a>
                        </li>
                        <li>
                                <a class="function" href="#MPSolverParameters.SetDoubleParam">SetDoubleParam</a>
                        </li>
                        <li>
                                <a class="function" href="#MPSolverParameters.SetIntegerParam">SetIntegerParam</a>
                        </li>
                        <li>
                                <a class="function" href="#MPSolverParameters.GetDoubleParam">GetDoubleParam</a>
                        </li>
                        <li>
                                <a class="function" href="#MPSolverParameters.GetIntegerParam">GetIntegerParam</a>
                        </li>
                        <li>
                                <a class="variable" href="#MPSolverParameters.kDefaultRelativeMipGap">kDefaultRelativeMipGap</a>
                        </li>
                        <li>
                                <a class="variable" href="#MPSolverParameters.kDefaultPrimalTolerance">kDefaultPrimalTolerance</a>
                        </li>
                        <li>
                                <a class="variable" href="#MPSolverParameters.kDefaultDualTolerance">kDefaultDualTolerance</a>
                        </li>
                        <li>
                                <a class="variable" href="#MPSolverParameters.kDefaultPresolve">kDefaultPresolve</a>
                        </li>
                        <li>
                                <a class="variable" href="#MPSolverParameters.kDefaultIncrementality">kDefaultIncrementality</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="class" href="#ModelExportOptions">ModelExportOptions</a>
                            <ul class="memberlist">
                        <li>
                                <a class="function" href="#ModelExportOptions.__init__">ModelExportOptions</a>
                        </li>
                        <li>
                                <a class="variable" href="#ModelExportOptions.thisown">thisown</a>
                        </li>
                </ul>

            </li>
            <li>
                    <a class="function" href="#ExportModelAsLpFormat">ExportModelAsLpFormat</a>
            </li>
            <li>
                    <a class="function" href="#ExportModelAsMpsFormat">ExportModelAsMpsFormat</a>
            </li>
            <li>
                    <a class="function" href="#FindErrorInModelProto">FindErrorInModelProto</a>
            </li>
            <li>
                    <a class="function" href="#setup_variable_operator">setup_variable_operator</a>
            </li>
    </ul>


                    <footer>OR-Tools 9.1</footer>

                    <a class="attribution" title="pdoc: Python API documentation generator" href="https://pdoc.dev">
                        built with <span class="visually-hidden">pdoc</span><img
                            alt="pdoc logo"
                            src="data:image/svg+xml,%3Csvg%20xmlns%3D%22http%3A//www.w3.org/2000/svg%22%20role%3D%22img%22%20aria-label%3D%22pdoc%20logo%22%20width%3D%22300%22%20height%3D%22150%22%20viewBox%3D%22-1%200%2060%2030%22%3E%3Ctitle%3Epdoc%3C/title%3E%3Cpath%20d%3D%22M29.621%2021.293c-.011-.273-.214-.475-.511-.481a.5.5%200%200%200-.489.503l-.044%201.393c-.097.551-.695%201.215-1.566%201.704-.577.428-1.306.486-2.193.182-1.426-.617-2.467-1.654-3.304-2.487l-.173-.172a3.43%203.43%200%200%200-.365-.306.49.49%200%200%200-.286-.196c-1.718-1.06-4.931-1.47-7.353.191l-.219.15c-1.707%201.187-3.413%202.131-4.328%201.03-.02-.027-.49-.685-.141-1.763.233-.721.546-2.408.772-4.076.042-.09.067-.187.046-.288.166-1.347.277-2.625.241-3.351%201.378-1.008%202.271-2.586%202.271-4.362%200-.976-.272-1.935-.788-2.774-.057-.094-.122-.18-.184-.268.033-.167.052-.339.052-.516%200-1.477-1.202-2.679-2.679-2.679-.791%200-1.496.352-1.987.9a6.3%206.3%200%200%200-1.001.029c-.492-.564-1.207-.929-2.012-.929-1.477%200-2.679%201.202-2.679%202.679A2.65%202.65%200%200%200%20.97%206.554c-.383.747-.595%201.572-.595%202.41%200%202.311%201.507%204.29%203.635%205.107-.037.699-.147%202.27-.423%203.294l-.137.461c-.622%202.042-2.515%208.257%201.727%2010.643%201.614.908%203.06%201.248%204.317%201.248%202.665%200%204.492-1.524%205.322-2.401%201.476-1.559%202.886-1.854%206.491.82%201.877%201.393%203.514%201.753%204.861%201.068%202.223-1.713%202.811-3.867%203.399-6.374.077-.846.056-1.469.054-1.537zm-4.835%204.313c-.054.305-.156.586-.242.629-.034-.007-.131-.022-.307-.157-.145-.111-.314-.478-.456-.908.221.121.432.25.675.355.115.039.219.051.33.081zm-2.251-1.238c-.05.33-.158.648-.252.694-.022.001-.125-.018-.307-.157-.217-.166-.488-.906-.639-1.573.358.344.754.693%201.198%201.036zm-3.887-2.337c-.006-.116-.018-.231-.041-.342.635.145%201.189.368%201.599.625.097.231.166.481.174.642-.03.049-.055.101-.067.158-.046.013-.128.026-.298.004-.278-.037-.901-.57-1.367-1.087zm-1.127-.497c.116.306.176.625.12.71-.019.014-.117.045-.345.016-.206-.027-.604-.332-.986-.695.41-.051.816-.056%201.211-.031zm-4.535%201.535c.209.22.379.47.358.598-.006.041-.088.138-.351.234-.144.055-.539-.063-.979-.259a11.66%2011.66%200%200%200%20.972-.573zm.983-.664c.359-.237.738-.418%201.126-.554.25.237.479.548.457.694-.006.042-.087.138-.351.235-.174.064-.694-.105-1.232-.375zm-3.381%201.794c-.022.145-.061.29-.149.401-.133.166-.358.248-.69.251h-.002c-.133%200-.306-.26-.45-.621.417.091.854.07%201.291-.031zm-2.066-8.077a4.78%204.78%200%200%201-.775-.584c.172-.115.505-.254.88-.378l-.105.962zm-.331%202.302a10.32%2010.32%200%200%201-.828-.502c.202-.143.576-.328.984-.49l-.156.992zm-.45%202.157l-.701-.403c.214-.115.536-.249.891-.376a11.57%2011.57%200%200%201-.19.779zm-.181%201.716c.064.398.194.702.298.893-.194-.051-.435-.162-.736-.398.061-.119.224-.3.438-.495zM8.87%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zm-.735-.389a1.15%201.15%200%200%200-.314.783%201.16%201.16%200%200%200%201.162%201.162c.457%200%20.842-.27%201.032-.653.026.117.042.238.042.362a1.68%201.68%200%200%201-1.679%201.679%201.68%201.68%200%200%201-1.679-1.679c0-.843.626-1.535%201.436-1.654zM5.059%205.406A1.68%201.68%200%200%201%203.38%207.085a1.68%201.68%200%200%201-1.679-1.679c0-.037.009-.072.011-.109.21.3.541.508.935.508a1.16%201.16%200%200%200%201.162-1.162%201.14%201.14%200%200%200-.474-.912c.015%200%20.03-.005.045-.005.926.001%201.679.754%201.679%201.68zM3.198%204.141c0%20.152-.123.276-.276.276s-.275-.124-.275-.276.123-.276.276-.276.275.124.275.276zM1.375%208.964c0-.52.103-1.035.288-1.52.466.394%201.06.64%201.717.64%201.144%200%202.116-.725%202.499-1.738.383%201.012%201.355%201.738%202.499%201.738.867%200%201.631-.421%202.121-1.062.307.605.478%201.267.478%201.942%200%202.486-2.153%204.51-4.801%204.51s-4.801-2.023-4.801-4.51zm24.342%2019.349c-.985.498-2.267.168-3.813-.979-3.073-2.281-5.453-3.199-7.813-.705-1.315%201.391-4.163%203.365-8.423.97-3.174-1.786-2.239-6.266-1.261-9.479l.146-.492c.276-1.02.395-2.457.444-3.268a6.11%206.11%200%200%200%201.18.115%206.01%206.01%200%200%200%202.536-.562l-.006.175c-.802.215-1.848.612-2.021%201.25-.079.295.021.601.274.837.219.203.415.364.598.501-.667.304-1.243.698-1.311%201.179-.02.144-.022.507.393.787.213.144.395.26.564.365-1.285.521-1.361.96-1.381%201.126-.018.142-.011.496.427.746l.854.489c-.473.389-.971.914-.999%201.429-.018.278.095.532.316.713.675.556%201.231.721%201.653.721.059%200%20.104-.014.158-.02.207.707.641%201.64%201.513%201.64h.013c.8-.008%201.236-.345%201.462-.626.173-.216.268-.457.325-.692.424.195.93.374%201.372.374.151%200%20.294-.021.423-.068.732-.27.944-.704.993-1.021.009-.061.003-.119.002-.179.266.086.538.147.789.147.15%200%20.294-.021.423-.069.542-.2.797-.489.914-.754.237.147.478.258.704.288.106.014.205.021.296.021.356%200%20.595-.101.767-.229.438.435%201.094.992%201.656%201.067.106.014.205.021.296.021a1.56%201.56%200%200%200%20.323-.035c.17.575.453%201.289.866%201.605.358.273.665.362.914.362a.99.99%200%200%200%20.421-.093%201.03%201.03%200%200%200%20.245-.164c.168.428.39.846.68%201.068.358.273.665.362.913.362a.99.99%200%200%200%20.421-.093c.317-.148.512-.448.639-.762.251.157.495.257.726.257.127%200%20.25-.024.37-.071.427-.17.706-.617.841-1.314.022-.015.047-.022.068-.038.067-.051.133-.104.196-.159-.443%201.486-1.107%202.761-2.086%203.257zM8.66%209.925a.5.5%200%201%200-1%200c0%20.653-.818%201.205-1.787%201.205s-1.787-.552-1.787-1.205a.5.5%200%201%200-1%200c0%201.216%201.25%202.205%202.787%202.205s2.787-.989%202.787-2.205zm4.4%2015.965l-.208.097c-2.661%201.258-4.708%201.436-6.086.527-1.542-1.017-1.88-3.19-1.844-4.198a.4.4%200%200%200-.385-.414c-.242-.029-.406.164-.414.385-.046%201.249.367%203.686%202.202%204.896.708.467%201.547.7%202.51.7%201.248%200%202.706-.392%204.362-1.174l.185-.086a.4.4%200%200%200%20.205-.527c-.089-.204-.326-.291-.527-.206zM9.547%202.292c.093.077.205.114.317.114a.5.5%200%200%200%20.318-.886L8.817.397a.5.5%200%200%200-.703.068.5.5%200%200%200%20.069.703l1.364%201.124zm-7.661-.065c.086%200%20.173-.022.253-.068l1.523-.893a.5.5%200%200%200-.506-.863l-1.523.892a.5.5%200%200%200-.179.685c.094.158.261.247.432.247z%22%20transform%3D%22matrix%28-1%200%200%201%2058%200%29%22%20fill%3D%22%233bb300%22/%3E%3Cpath%20d%3D%22M.3%2021.86V10.18q0-.46.02-.68.04-.22.18-.5.28-.54%201.34-.54%201.06%200%201.42.28.38.26.44.78.76-1.04%202.38-1.04%201.64%200%203.1%201.54%201.46%201.54%201.46%203.58%200%202.04-1.46%203.58-1.44%201.54-3.08%201.54-1.64%200-2.38-.92v4.04q0%20.46-.04.68-.02.22-.18.5-.14.3-.5.42-.36.12-.98.12-.62%200-1-.12-.36-.12-.52-.4-.14-.28-.18-.5-.02-.22-.02-.68zm3.96-9.42q-.46.54-.46%201.18%200%20.64.46%201.18.48.52%201.2.52.74%200%201.24-.52.52-.52.52-1.18%200-.66-.48-1.18-.48-.54-1.26-.54-.76%200-1.22.54zm14.741-8.36q.16-.3.54-.42.38-.12%201-.12.64%200%201.02.12.38.12.52.42.16.3.18.54.04.22.04.68v11.94q0%20.46-.04.7-.02.22-.18.5-.3.54-1.7.54-1.38%200-1.54-.98-.84.96-2.34.96-1.8%200-3.28-1.56-1.48-1.58-1.48-3.66%200-2.1%201.48-3.68%201.5-1.58%203.28-1.58%201.48%200%202.3%201v-4.2q0-.46.02-.68.04-.24.18-.52zm-3.24%2010.86q.52.54%201.26.54.74%200%201.22-.54.5-.54.5-1.18%200-.66-.48-1.22-.46-.56-1.26-.56-.8%200-1.28.56-.48.54-.48%201.2%200%20.66.52%201.2zm7.833-1.2q0-2.4%201.68-3.96%201.68-1.56%203.84-1.56%202.16%200%203.82%201.56%201.66%201.54%201.66%203.94%200%201.66-.86%202.96-.86%201.28-2.1%201.9-1.22.6-2.54.6-1.32%200-2.56-.64-1.24-.66-2.1-1.92-.84-1.28-.84-2.88zm4.18%201.44q.64.48%201.3.48.66%200%201.32-.5.66-.5.66-1.48%200-.98-.62-1.46-.62-.48-1.34-.48-.72%200-1.34.5-.62.5-.62%201.48%200%20.96.64%201.46zm11.412-1.44q0%20.84.56%201.32.56.46%201.18.46.64%200%201.18-.36.56-.38.9-.38.6%200%201.46%201.06.46.58.46%201.04%200%20.76-1.1%201.42-1.14.8-2.8.8-1.86%200-3.58-1.34-.82-.64-1.34-1.7-.52-1.08-.52-2.36%200-1.3.52-2.34.52-1.06%201.34-1.7%201.66-1.32%203.54-1.32.76%200%201.48.22.72.2%201.06.4l.32.2q.36.24.56.38.52.4.52.92%200%20.5-.42%201.14-.72%201.1-1.38%201.1-.38%200-1.08-.44-.36-.34-1.04-.34-.66%200-1.24.48-.58.48-.58%201.34z%22%20fill%3D%22green%22/%3E%3C/svg%3E"/>
                    </a>
            </div>
        </nav>
    <main class="pdoc">
            <section>
                    <h1 class="modulename">
pywraplp    </h1>

                
                        <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="c1"># This file was automatically generated by SWIG (http://www.swig.org).</span>
<span class="c1"># Version 4.0.2</span>
<span class="c1">#</span>
<span class="c1"># Do not make changes to this file unless you know what you are doing--modify</span>
<span class="c1"># the SWIG interface file instead.</span>

<span class="kn">from</span> <span class="nn">sys</span> <span class="kn">import</span> <span class="n">version_info</span> <span class="k">as</span> <span class="n">_swig_python_version_info</span>
<span class="k">if</span> <span class="n">_swig_python_version_info</span> <span class="o">&lt;</span> <span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">):</span>
    <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s2">&quot;Python 2.7 or later required&quot;</span><span class="p">)</span>

<span class="c1"># Import the low-level C/C++ module</span>
<span class="k">if</span> <span class="n">__package__</span> <span class="ow">or</span> <span class="s2">&quot;.&quot;</span> <span class="ow">in</span> <span class="vm">__name__</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">.</span> <span class="kn">import</span> <span class="n">_pywraplp</span>
<span class="k">else</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">_pywraplp</span>

<span class="k">try</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">builtins</span> <span class="k">as</span> <span class="nn">__builtin__</span>
<span class="k">except</span> <span class="ne">ImportError</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">__builtin__</span>

<span class="k">def</span> <span class="nf">_swig_repr</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">strthis</span> <span class="o">=</span> <span class="s2">&quot;proxy of &quot;</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">()</span>
    <span class="k">except</span> <span class="n">__builtin__</span><span class="o">.</span><span class="n">Exception</span><span class="p">:</span>
        <span class="n">strthis</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
    <span class="k">return</span> <span class="s2">&quot;&lt;</span><span class="si">%s</span><span class="s2">.</span><span class="si">%s</span><span class="s2">; </span><span class="si">%s</span><span class="s2"> &gt;&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__module__</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="vm">__class__</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="n">strthis</span><span class="p">,)</span>


<span class="k">def</span> <span class="nf">_swig_setattr_nondynamic_instance_variable</span><span class="p">(</span><span class="nb">set</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">set_instance_attr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;thisown&quot;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">name</span> <span class="o">==</span> <span class="s2">&quot;this&quot;</span><span class="p">:</span>
            <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="ow">and</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">name</span><span class="p">),</span> <span class="nb">property</span><span class="p">):</span>
            <span class="nb">set</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;You cannot add instance attributes to </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">set_instance_attr</span>


<span class="k">def</span> <span class="nf">_swig_setattr_nondynamic_class_variable</span><span class="p">(</span><span class="nb">set</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">set_class_attr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="ow">and</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="nb">getattr</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">),</span> <span class="nb">property</span><span class="p">):</span>
            <span class="nb">set</span><span class="p">(</span><span class="bp">cls</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;You cannot add class attributes to </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="bp">cls</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">set_class_attr</span>


<span class="k">def</span> <span class="nf">_swig_add_metaclass</span><span class="p">(</span><span class="n">metaclass</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Class decorator for adding a metaclass to a SWIG wrapped class - a slimmed down version of six.add_metaclass&quot;&quot;&quot;</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="bp">cls</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">metaclass</span><span class="p">(</span><span class="bp">cls</span><span class="o">.</span><span class="vm">__name__</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__bases__</span><span class="p">,</span> <span class="bp">cls</span><span class="o">.</span><span class="vm">__dict__</span><span class="o">.</span><span class="n">copy</span><span class="p">())</span>
    <span class="k">return</span> <span class="n">wrapper</span>


<span class="k">class</span> <span class="nc">_SwigNonDynamicMeta</span><span class="p">(</span><span class="nb">type</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Meta class to enforce nondynamic attributes (no new attributes) for a class&quot;&quot;&quot;</span>
    <span class="fm">__setattr__</span> <span class="o">=</span> <span class="n">_swig_setattr_nondynamic_class_variable</span><span class="p">(</span><span class="nb">type</span><span class="o">.</span><span class="fm">__setattr__</span><span class="p">)</span>



<span class="kn">import</span> <span class="nn">numbers</span>
<span class="kn">from</span> <span class="nn">ortools.linear_solver.linear_solver_natural_api</span> <span class="kn">import</span> <span class="n">OFFSET_KEY</span>
<span class="kn">from</span> <span class="nn">ortools.linear_solver.linear_solver_natural_api</span> <span class="kn">import</span> <span class="n">inf</span>
<span class="kn">from</span> <span class="nn">ortools.linear_solver.linear_solver_natural_api</span> <span class="kn">import</span> <span class="n">LinearExpr</span>
<span class="kn">from</span> <span class="nn">ortools.linear_solver.linear_solver_natural_api</span> <span class="kn">import</span> <span class="n">ProductCst</span>
<span class="kn">from</span> <span class="nn">ortools.linear_solver.linear_solver_natural_api</span> <span class="kn">import</span> <span class="n">Sum</span>
<span class="kn">from</span> <span class="nn">ortools.linear_solver.linear_solver_natural_api</span> <span class="kn">import</span> <span class="n">SumArray</span>
<span class="kn">from</span> <span class="nn">ortools.linear_solver.linear_solver_natural_api</span> <span class="kn">import</span> <span class="n">SumCst</span>
<span class="kn">from</span> <span class="nn">ortools.linear_solver.linear_solver_natural_api</span> <span class="kn">import</span> <span class="n">LinearConstraint</span>
<span class="kn">from</span> <span class="nn">ortools.linear_solver.linear_solver_natural_api</span> <span class="kn">import</span> <span class="n">VariableExpr</span>

<span class="k">class</span> <span class="nc">Solver</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This mathematical programming (MP) solver class is the main class</span>
<span class="sd">    though which users build and solve problems.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>
    <span class="n">CLP_LINEAR_PROGRAMMING</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_CLP_LINEAR_PROGRAMMING</span>
    <span class="n">GLPK_LINEAR_PROGRAMMING</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_GLPK_LINEAR_PROGRAMMING</span>
    <span class="n">GLOP_LINEAR_PROGRAMMING</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_GLOP_LINEAR_PROGRAMMING</span>
    <span class="n">SCIP_MIXED_INTEGER_PROGRAMMING</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_SCIP_MIXED_INTEGER_PROGRAMMING</span>
    <span class="n">GLPK_MIXED_INTEGER_PROGRAMMING</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_GLPK_MIXED_INTEGER_PROGRAMMING</span>
    <span class="n">CBC_MIXED_INTEGER_PROGRAMMING</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_CBC_MIXED_INTEGER_PROGRAMMING</span>
    <span class="n">GUROBI_LINEAR_PROGRAMMING</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_GUROBI_LINEAR_PROGRAMMING</span>
    <span class="n">GUROBI_MIXED_INTEGER_PROGRAMMING</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_GUROBI_MIXED_INTEGER_PROGRAMMING</span>
    <span class="n">CPLEX_LINEAR_PROGRAMMING</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_CPLEX_LINEAR_PROGRAMMING</span>
    <span class="n">CPLEX_MIXED_INTEGER_PROGRAMMING</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_CPLEX_MIXED_INTEGER_PROGRAMMING</span>
    <span class="n">XPRESS_LINEAR_PROGRAMMING</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_XPRESS_LINEAR_PROGRAMMING</span>
    <span class="n">XPRESS_MIXED_INTEGER_PROGRAMMING</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_XPRESS_MIXED_INTEGER_PROGRAMMING</span>
    <span class="n">BOP_INTEGER_PROGRAMMING</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_BOP_INTEGER_PROGRAMMING</span>
    <span class="n">SAT_INTEGER_PROGRAMMING</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_SAT_INTEGER_PROGRAMMING</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">,</span> <span class="n">problem_type</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPSolver::OptimizationProblemType&quot;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Create a solver with the given name and underlying solver backend.&quot;&quot;&quot;</span>
        <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">new_Solver</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">problem_type</span><span class="p">))</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">delete_Solver</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">CreateSolver</span><span class="p">(</span><span class="n">solver_id</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPSolver *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recommended factory method to create a MPSolver instance, especially in</span>
<span class="sd">        non C++ languages.</span>

<span class="sd">        It returns a newly created solver instance if successful, or a nullptr</span>
<span class="sd">        otherwise. This can occur if the relevant interface is not linked in, or if</span>
<span class="sd">        a needed license is not accessible for commercial solvers.</span>

<span class="sd">        Ownership of the solver is passed on to the caller of this method.</span>
<span class="sd">        It will accept both string names of the OptimizationProblemType enum, as</span>
<span class="sd">        well as a short version (i.e. &quot;SCIP_MIXED_INTEGER_PROGRAMMING&quot; or &quot;SCIP&quot;).</span>

<span class="sd">        solver_id is case insensitive, and the following names are supported:</span>
<span class="sd">          - CLP_LINEAR_PROGRAMMING or CLP</span>
<span class="sd">          - CBC_MIXED_INTEGER_PROGRAMMING or CBC</span>
<span class="sd">          - GLOP_LINEAR_PROGRAMMING or GLOP</span>
<span class="sd">          - BOP_INTEGER_PROGRAMMING or BOP</span>
<span class="sd">          - SAT_INTEGER_PROGRAMMING or SAT or CP_SAT</span>
<span class="sd">          - SCIP_MIXED_INTEGER_PROGRAMMING or SCIP</span>
<span class="sd">          - GUROBI_LINEAR_PROGRAMMING or GUROBI_LP</span>
<span class="sd">          - GUROBI_MIXED_INTEGER_PROGRAMMING or GUROBI or GUROBI_MIP</span>
<span class="sd">          - CPLEX_LINEAR_PROGRAMMING or CPLEX_LP</span>
<span class="sd">          - CPLEX_MIXED_INTEGER_PROGRAMMING or CPLEX or CPLEX_MIP</span>
<span class="sd">          - XPRESS_LINEAR_PROGRAMMING or XPRESS_LP</span>
<span class="sd">          - XPRESS_MIXED_INTEGER_PROGRAMMING or XPRESS or XPRESS_MIP</span>
<span class="sd">          - GLPK_LINEAR_PROGRAMMING or GLPK_LP</span>
<span class="sd">          - GLPK_MIXED_INTEGER_PROGRAMMING or GLPK or GLPK_MIP</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_CreateSolver</span><span class="p">(</span><span class="n">solver_id</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">SupportsProblemType</span><span class="p">(</span><span class="n">problem_type</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPSolver::OptimizationProblemType&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether the given problem type is supported (this will depend on the</span>
<span class="sd">        targets that you linked).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_SupportsProblemType</span><span class="p">(</span><span class="n">problem_type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Clear</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clears the objective (including the optimization direction), all variables</span>
<span class="sd">        and constraints. All the other properties of the MPSolver (like the time</span>
<span class="sd">        limit) are kept untouched.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_Clear</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NumVariables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the number of variables.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_NumVariables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">variables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; operations_research::MPVariable * &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the array of variables handled by the MPSolver. (They are listed in</span>
<span class="sd">        the order in which they were created.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPVariable *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the variable at position index.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">LookupVariable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPVariable *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Looks up a variable by name, and returns nullptr if it does not exist. The</span>
<span class="sd">        first call has a O(n) complexity, as the variable name index is lazily</span>
<span class="sd">        created upon first use. Will crash if variable names are not unique.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_LookupVariable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lb</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">ub</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">integer</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPVariable *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a variable with the given bounds, integrality requirement and</span>
<span class="sd">        name. Bounds can be finite or +/- MPSolver::infinity(). The MPSolver owns</span>
<span class="sd">        the variable (i.e. the returned pointer is borrowed). Variable names are</span>
<span class="sd">        optional. If you give an empty name, name() will auto-generate one for you</span>
<span class="sd">        upon request.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_Var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">,</span> <span class="n">integer</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NumVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lb</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">ub</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPVariable *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Creates a continuous variable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_NumVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IntVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lb</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">ub</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPVariable *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Creates an integer variable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_IntVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">BoolVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPVariable *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Creates a boolean variable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_BoolVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NumConstraints</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the number of constraints.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_NumConstraints</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; operations_research::MPConstraint * &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the array of constraints handled by the MPSolver.</span>

<span class="sd">        They are listed in the order in which they were created.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPConstraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the constraint at the given index.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">LookupConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constraint_name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPConstraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         Looks up a constraint by name, and returns nullptr if it does not exist.</span>

<span class="sd">        The first call has a O(n) complexity, as the constraint name index is</span>
<span class="sd">        lazily created upon first use. Will crash if constraint names are not</span>
<span class="sd">        unique.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_LookupConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constraint_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPConstraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>

<span class="sd">        Creates a linear constraint with given bounds.</span>

<span class="sd">        Bounds can be finite or +/- MPSolver::infinity(). The MPSolver class</span>
<span class="sd">        assumes ownership of the constraint.</span>

<span class="sd">        :rtype: :py:class:`MPConstraint`</span>
<span class="sd">        :return: a pointer to the newly created constraint.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">         Creates a constraint with -infinity and +infinity bounds.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 3:*</span>
<span class="sd">         Creates a named constraint with given bounds.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 4:*</span>
<span class="sd">         Creates a named constraint with -infinity and +infinity bounds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_Constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Objective</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPObjective *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the mutable objective object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_Objective</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">OPTIMAL</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_OPTIMAL</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; optimal.&quot;&quot;&quot;</span>
    <span class="n">FEASIBLE</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_FEASIBLE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; feasible, or stopped by limit.&quot;&quot;&quot;</span>
    <span class="n">INFEASIBLE</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_INFEASIBLE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; proven infeasible.&quot;&quot;&quot;</span>
    <span class="n">UNBOUNDED</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_UNBOUNDED</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; proven unbounded.&quot;&quot;&quot;</span>
    <span class="n">ABNORMAL</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_ABNORMAL</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; abnormal, i.e., error of some kind.&quot;&quot;&quot;</span>
    <span class="n">NOT_SOLVED</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_NOT_SOLVED</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; not been solved yet.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">Solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPSolver::ResultStatus&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Solves the problem using the default parameter values.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Solves the problem using the specified parameter values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_Solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ComputeConstraintActivities</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; double &gt;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Advanced usage: compute the &quot;activities&quot; of all constraints, which are the</span>
<span class="sd">        sums of their linear terms. The activities are returned in the same order</span>
<span class="sd">        as constraints(), which is the order in which constraints were added; but</span>
<span class="sd">        you can also use MPConstraint::index() to get a constraint&#39;s index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_ComputeConstraintActivities</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">VerifySolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">log_errors</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Advanced usage: Verifies the *correctness* of the solution.</span>

<span class="sd">        It verifies that all variables must be within their domains, all</span>
<span class="sd">        constraints must be satisfied, and the reported objective value must be</span>
<span class="sd">        accurate.</span>

<span class="sd">        Usage:</span>
<span class="sd">        - This can only be called after Solve() was called.</span>
<span class="sd">        - &quot;tolerance&quot; is interpreted as an absolute error threshold.</span>
<span class="sd">        - For the objective value only, if the absolute error is too large,</span>
<span class="sd">          the tolerance is interpreted as a relative error threshold instead.</span>
<span class="sd">        - If &quot;log_errors&quot; is true, every single violation will be logged.</span>
<span class="sd">        - If &quot;tolerance&quot; is negative, it will be set to infinity().</span>

<span class="sd">        Most users should just set the --verify_solution flag and not bother using</span>
<span class="sd">        this method directly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_VerifySolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">log_errors</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">InterruptSolve</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         Interrupts the Solve() execution to terminate processing if possible.</span>

<span class="sd">        If the underlying interface supports interruption; it does that and returns</span>
<span class="sd">        true regardless of whether there&#39;s an ongoing Solve() or not. The Solve()</span>
<span class="sd">        call may still linger for a while depending on the conditions.  If</span>
<span class="sd">        interruption is not supported; returns false and does nothing.</span>
<span class="sd">        MPSolver::SolverTypeSupportsInterruption can be used to check if</span>
<span class="sd">        interruption is supported for a given solver type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_InterruptSolve</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">FillSolutionResponseProto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">response</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPSolutionResponse *&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Encodes the current solution in a solution response protocol buffer.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_FillSolutionResponseProto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">response</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">SolveWithProto</span><span class="p">(</span><span class="n">model_request</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPModelRequest const &amp;&quot;</span><span class="p">,</span> <span class="n">response</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPSolutionResponse *&quot;</span><span class="p">,</span> <span class="n">interrupt</span><span class="p">:</span> <span class="s2">&quot;std::atomic&lt; bool &gt; *&quot;</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPSolutionResponse *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solves the model encoded by a MPModelRequest protocol buffer and fills the</span>
<span class="sd">        solution encoded as a MPSolutionResponse. The solve is stopped prematurely</span>
<span class="sd">        if interrupt is non-null at set to true during (or before) solving.</span>
<span class="sd">        Interruption is only supported if SolverTypeSupportsInterruption() returns</span>
<span class="sd">        true for the requested solver. Passing a non-null interruption with any</span>
<span class="sd">        other solver type immediately returns an MPSOLVER_INCOMPATIBLE_OPTIONS</span>
<span class="sd">        error.</span>

<span class="sd">        Note(user): This attempts to first use `DirectlySolveProto()` (if</span>
<span class="sd">        implemented). Consequently, this most likely does *not* override any of</span>
<span class="sd">        the default parameters of the underlying solver. This behavior *differs*</span>
<span class="sd">        from `MPSolver::Solve()` which by default sets the feasibility tolerance</span>
<span class="sd">        and the gap limit (as of 2020/02/11, to 1e-7 and 0.0001, respectively).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_SolveWithProto</span><span class="p">(</span><span class="n">model_request</span><span class="p">,</span> <span class="n">response</span><span class="p">,</span> <span class="n">interrupt</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ExportModelToProto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_model</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPModelProto *&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Exports model to protocol buffer.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_ExportModelToProto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_model</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetSolverSpecificParametersAsString</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Advanced usage: pass solver specific parameters in text format.</span>

<span class="sd">        The format is solver-specific and is the same as the corresponding solver</span>
<span class="sd">        configuration file format. Returns true if the operation was successful.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_SetSolverSpecificParametersAsString</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>
    <span class="n">FREE</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_FREE</span>
    <span class="n">AT_LOWER_BOUND</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_AT_LOWER_BOUND</span>
    <span class="n">AT_UPPER_BOUND</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_AT_UPPER_BOUND</span>
    <span class="n">FIXED_VALUE</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_FIXED_VALUE</span>
    <span class="n">BASIC</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_BASIC</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">infinity</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Infinity.</span>

<span class="sd">        You can use -MPSolver::infinity() for negative infinity.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_infinity</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">EnableOutput</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Enables solver logging.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_EnableOutput</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SuppressOutput</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Suppresses solver logging.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_SuppressOutput</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">iterations</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the number of simplex iterations.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_iterations</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of branch-and-bound nodes evaluated during the solve.</span>

<span class="sd">        Only available for discrete problems.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ComputeExactConditionNumber</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         Advanced usage: computes the exact condition number of the current scaled</span>
<span class="sd">        basis: L1norm(B) * L1norm(inverse(B)), where B is the scaled basis.</span>

<span class="sd">        This method requires that a basis exists: it should be called after Solve.</span>
<span class="sd">        It is only available for continuous problems. It is implemented for GLPK</span>
<span class="sd">        but not CLP because CLP does not provide the API for doing it.</span>

<span class="sd">        The condition number measures how well the constraint matrix is conditioned</span>
<span class="sd">        and can be used to predict whether numerical issues will arise during the</span>
<span class="sd">        solve: the model is declared infeasible whereas it is feasible (or</span>
<span class="sd">        vice-versa), the solution obtained is not optimal or violates some</span>
<span class="sd">        constraints, the resolution is slow because of repeated singularities.</span>

<span class="sd">        The rule of thumb to interpret the condition number kappa is:</span>
<span class="sd">          - o kappa &lt;= 1e7: virtually no chance of numerical issues</span>
<span class="sd">          - o 1e7 &lt; kappa &lt;= 1e10: small chance of numerical issues</span>
<span class="sd">          - o 1e10 &lt; kappa &lt;= 1e13: medium chance of numerical issues</span>
<span class="sd">          - o kappa &gt; 1e13: high chance of numerical issues</span>

<span class="sd">        The computation of the condition number depends on the quality of the LU</span>
<span class="sd">        decomposition, so it is not very accurate when the matrix is ill</span>
<span class="sd">        conditioned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_ComputeExactConditionNumber</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NextSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Some solvers (MIP only, not LP) can produce multiple solutions to the</span>
<span class="sd">        problem. Returns true when another solution is available, and updates the</span>
<span class="sd">        MPVariable* objects to make the new solution queryable. Call only after</span>
<span class="sd">        calling solve.</span>

<span class="sd">        The optimality properties of the additional solutions found, and whether or</span>
<span class="sd">        not the solver computes them ahead of time or when NextSolution() is called</span>
<span class="sd">        is solver specific.</span>

<span class="sd">        As of 2020-02-10, only Gurobi and SCIP support NextSolution(), see</span>
<span class="sd">        linear_solver_interfaces_test for an example of how to configure these</span>
<span class="sd">        solvers for multiple solutions. Other solvers return false unconditionally.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_NextSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_time_limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_limit_milliseconds</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_set_time_limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_limit_milliseconds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">wall_time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_wall_time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">LoadModelFromProto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_model</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPModelProto const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_LoadModelFromProto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_model</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">LoadModelFromProtoWithUniqueNamesOrDie</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_model</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPModelProto const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_LoadModelFromProtoWithUniqueNamesOrDie</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_model</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">LoadSolutionFromProto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_LoadSolutionFromProto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ExportModelAsLpFormat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obfuscated</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_ExportModelAsLpFormat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obfuscated</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ExportModelAsMpsFormat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fixed_format</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">obfuscated</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_ExportModelAsMpsFormat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fixed_format</span><span class="p">,</span> <span class="n">obfuscated</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetHint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::MPVariable * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; double &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set a hint for solution.</span>

<span class="sd">        If a feasible or almost-feasible solution to the problem is already known,</span>
<span class="sd">        it may be helpful to pass it to the solver so that it can be used. A</span>
<span class="sd">        solver that supports this feature will try to use this information to</span>
<span class="sd">        create its initial feasible solution.</span>

<span class="sd">        Note that it may not always be faster to give a hint like this to the</span>
<span class="sd">        solver. There is also no guarantee that the solver will use this hint or</span>
<span class="sd">        try to return a solution &quot;close&quot; to this assignment in case of multiple</span>
<span class="sd">        optimal solutions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_SetHint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetNumThreads</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_theads</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Sets the number of threads to be used by the solver.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_SetNumThreads</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_theads</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constraint</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">constraint</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">constraint</span><span class="p">:</span>
          <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">RowConstraint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">RowConstraint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">constraint</span><span class="o">.</span><span class="n">Extract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr_array</span><span class="p">):</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">SumArray</span><span class="p">(</span><span class="n">expr_array</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">RowConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Constraint</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Minimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
      <span class="n">objective</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Objective</span><span class="p">()</span>
      <span class="n">objective</span><span class="o">.</span><span class="n">Clear</span><span class="p">()</span>
      <span class="n">objective</span><span class="o">.</span><span class="n">SetMinimization</span><span class="p">()</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span>
          <span class="n">objective</span><span class="o">.</span><span class="n">SetOffset</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
          <span class="n">coeffs</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">GetCoeffs</span><span class="p">()</span>
          <span class="n">objective</span><span class="o">.</span><span class="n">SetOffset</span><span class="p">(</span><span class="n">coeffs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">OFFSET_KEY</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
          <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">coeffs</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">objective</span><span class="o">.</span><span class="n">SetCoefficient</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">Maximize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
      <span class="n">objective</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Objective</span><span class="p">()</span>
      <span class="n">objective</span><span class="o">.</span><span class="n">Clear</span><span class="p">()</span>
      <span class="n">objective</span><span class="o">.</span><span class="n">SetMaximization</span><span class="p">()</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span>
          <span class="n">objective</span><span class="o">.</span><span class="n">SetOffset</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
          <span class="n">coeffs</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">GetCoeffs</span><span class="p">()</span>
          <span class="n">objective</span><span class="o">.</span><span class="n">SetOffset</span><span class="p">(</span><span class="n">coeffs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">OFFSET_KEY</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
          <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">coeffs</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">objective</span><span class="o">.</span><span class="n">SetCoefficient</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">Infinity</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_Infinity</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">SetTimeLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_SetTimeLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WallTime</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_WallTime</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Iterations</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_Iterations</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

<span class="c1"># Register Solver in _pywraplp:</span>
<span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_swigregister</span><span class="p">(</span><span class="n">Solver</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Solver_CreateSolver</span><span class="p">(</span><span class="n">solver_id</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPSolver *&quot;</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Recommended factory method to create a MPSolver instance, especially in</span>
<span class="sd">    non C++ languages.</span>

<span class="sd">    It returns a newly created solver instance if successful, or a nullptr</span>
<span class="sd">    otherwise. This can occur if the relevant interface is not linked in, or if</span>
<span class="sd">    a needed license is not accessible for commercial solvers.</span>

<span class="sd">    Ownership of the solver is passed on to the caller of this method.</span>
<span class="sd">    It will accept both string names of the OptimizationProblemType enum, as</span>
<span class="sd">    well as a short version (i.e. &quot;SCIP_MIXED_INTEGER_PROGRAMMING&quot; or &quot;SCIP&quot;).</span>

<span class="sd">    solver_id is case insensitive, and the following names are supported:</span>
<span class="sd">      - CLP_LINEAR_PROGRAMMING or CLP</span>
<span class="sd">      - CBC_MIXED_INTEGER_PROGRAMMING or CBC</span>
<span class="sd">      - GLOP_LINEAR_PROGRAMMING or GLOP</span>
<span class="sd">      - BOP_INTEGER_PROGRAMMING or BOP</span>
<span class="sd">      - SAT_INTEGER_PROGRAMMING or SAT or CP_SAT</span>
<span class="sd">      - SCIP_MIXED_INTEGER_PROGRAMMING or SCIP</span>
<span class="sd">      - GUROBI_LINEAR_PROGRAMMING or GUROBI_LP</span>
<span class="sd">      - GUROBI_MIXED_INTEGER_PROGRAMMING or GUROBI or GUROBI_MIP</span>
<span class="sd">      - CPLEX_LINEAR_PROGRAMMING or CPLEX_LP</span>
<span class="sd">      - CPLEX_MIXED_INTEGER_PROGRAMMING or CPLEX or CPLEX_MIP</span>
<span class="sd">      - XPRESS_LINEAR_PROGRAMMING or XPRESS_LP</span>
<span class="sd">      - XPRESS_MIXED_INTEGER_PROGRAMMING or XPRESS or XPRESS_MIP</span>
<span class="sd">      - GLPK_LINEAR_PROGRAMMING or GLPK_LP</span>
<span class="sd">      - GLPK_MIXED_INTEGER_PROGRAMMING or GLPK or GLPK_MIP</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_CreateSolver</span><span class="p">(</span><span class="n">solver_id</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Solver_SupportsProblemType</span><span class="p">(</span><span class="n">problem_type</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPSolver::OptimizationProblemType&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Whether the given problem type is supported (this will depend on the</span>
<span class="sd">    targets that you linked).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_SupportsProblemType</span><span class="p">(</span><span class="n">problem_type</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Solver_SolveWithProto</span><span class="p">(</span><span class="n">model_request</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPModelRequest const &amp;&quot;</span><span class="p">,</span> <span class="n">response</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPSolutionResponse *&quot;</span><span class="p">,</span> <span class="n">interrupt</span><span class="p">:</span> <span class="s2">&quot;std::atomic&lt; bool &gt; *&quot;</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPSolutionResponse *&quot;</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solves the model encoded by a MPModelRequest protocol buffer and fills the</span>
<span class="sd">    solution encoded as a MPSolutionResponse. The solve is stopped prematurely</span>
<span class="sd">    if interrupt is non-null at set to true during (or before) solving.</span>
<span class="sd">    Interruption is only supported if SolverTypeSupportsInterruption() returns</span>
<span class="sd">    true for the requested solver. Passing a non-null interruption with any</span>
<span class="sd">    other solver type immediately returns an MPSOLVER_INCOMPATIBLE_OPTIONS</span>
<span class="sd">    error.</span>

<span class="sd">    Note(user): This attempts to first use `DirectlySolveProto()` (if</span>
<span class="sd">    implemented). Consequently, this most likely does *not* override any of</span>
<span class="sd">    the default parameters of the underlying solver. This behavior *differs*</span>
<span class="sd">    from `MPSolver::Solve()` which by default sets the feasibility tolerance</span>
<span class="sd">    and the gap limit (as of 2020/02/11, to 1e-7 and 0.0001, respectively).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_SolveWithProto</span><span class="p">(</span><span class="n">model_request</span><span class="p">,</span> <span class="n">response</span><span class="p">,</span> <span class="n">interrupt</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">Solver_infinity</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Infinity.</span>

<span class="sd">    You can use -MPSolver::infinity() for negative infinity.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_infinity</span><span class="p">()</span>

<span class="k">def</span> <span class="nf">Solver_Infinity</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_Infinity</span><span class="p">()</span>


<span class="k">def</span> <span class="fm">__lshift__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::ostream &amp;&quot;</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="fm">__lshift__</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">Objective</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; A class to express a linear objective.&quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">Clear</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         Clears the offset, all variables and coefficients, and the optimization</span>
<span class="sd">        direction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Objective_Clear</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;Variable&quot;</span><span class="p">,</span> <span class="n">coeff</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the coefficient of the variable in the objective.</span>

<span class="sd">        If the variable does not belong to the solver, the function just returns,</span>
<span class="sd">        or crashes in non-opt mode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Objective_SetCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">coeff</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;Variable&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         Gets the coefficient of a given variable in the objective</span>

<span class="sd">        It returns 0 if the variable does not appear in the objective).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Objective_GetCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetOffset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Sets the constant term in the objective.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Objective_SetOffset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">offset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Gets the constant term in the objective.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Objective_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetOptimizationDirection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maximize</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Sets the optimization direction (maximize: true or minimize: false).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Objective_SetOptimizationDirection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maximize</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetMinimization</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Sets the optimization direction to minimize.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Objective_SetMinimization</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetMaximization</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Sets the optimization direction to maximize.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Objective_SetMaximization</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">maximization</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Is the optimization direction set to maximize?&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Objective_maximization</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">minimization</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Is the optimization direction set to minimize?&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Objective_minimization</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the objective value of the best solution found so far.</span>

<span class="sd">        It is the optimal objective value if the problem has been solved to</span>
<span class="sd">        optimality.</span>

<span class="sd">        Note: the objective value may be slightly different than what you could</span>
<span class="sd">        compute yourself using ``MPVariable::solution_value();`` please use the</span>
<span class="sd">        --verify_solution flag to gain confidence about the numerical stability of</span>
<span class="sd">        your solution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Objective_Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">BestBound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the best objective bound.</span>

<span class="sd">        In case of minimization, it is a lower bound on the objective value of the</span>
<span class="sd">        optimal integer solution. Only available for discrete problems.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Objective_BestBound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Offset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Objective_Offset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">delete_Objective</span>

<span class="c1"># Register Objective in _pywraplp:</span>
<span class="n">_pywraplp</span><span class="o">.</span><span class="n">Objective_swigregister</span><span class="p">(</span><span class="n">Objective</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Variable</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; The class for variables of a Mathematical Programming (MP) model.&quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the name of the variable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetInteger</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">integer</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Sets the integrality requirement of the variable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_SetInteger</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">integer</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">integer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the integrality requirement of the variable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_integer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">solution_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the value of the variable in the current solution.</span>

<span class="sd">        If the variable is integer, then the value will always be an integer (the</span>
<span class="sd">        underlying solver handles floating-point values only, but this function</span>
<span class="sd">        automatically rounds it to the nearest integer; see: man 3 round).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_solution_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the index of the variable in the MPSolver::variables_.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">lb</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the lower bound.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_lb</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ub</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the upper bound.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_ub</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetBounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lb</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">ub</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Sets both the lower and upper bounds.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_SetBounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reduced_cost</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Advanced usage: returns the reduced cost of the variable in the current</span>
<span class="sd">        solution (only available for continuous problems).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_reduced_cost</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">basis_status</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPSolver::BasisStatus&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Advanced usage: returns the basis status of the variable in the current</span>
<span class="sd">        solution (only available for continuous problems).</span>

<span class="sd">        See also: MPSolver::BasisStatus.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_basis_status</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">branching_priority</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Advanced usage: Certain MIP solvers (e.g. Gurobi or SCIP) allow you to set</span>
<span class="sd">        a per-variable priority for determining which variable to branch on.</span>

<span class="sd">        A value of 0 is treated as default, and is equivalent to not setting the</span>
<span class="sd">        branching priority. The solver looks first to branch on fractional</span>
<span class="sd">        variables in higher priority levels. As of 2019-05, only Gurobi and SCIP</span>
<span class="sd">        support setting branching priority; all other solvers will simply ignore</span>
<span class="sd">        this annotation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_branching_priority</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetBranchingPriority</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">priority</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_SetBranchingPriority</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">priority</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable___str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable___repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
      <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">VariableExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">name</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">SolutionValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_SolutionValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Integer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_Integer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Lb</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_Lb</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Ub</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_Ub</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetLb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_SetLb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetUb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_SetUb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ReducedCost</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_ReducedCost</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">delete_Variable</span>

<span class="c1"># Register Variable in _pywraplp:</span>
<span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_swigregister</span><span class="p">(</span><span class="n">Variable</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">Constraint</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The class for constraints of a Mathematical Programming (MP) model.</span>

<span class="sd">    A constraint is represented as a linear equation or inequality.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the name of the constraint.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Clear</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Clears all variables and coefficients. Does not clear the bounds.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_Clear</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;Variable&quot;</span><span class="p">,</span> <span class="n">coeff</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the coefficient of the variable on the constraint.</span>

<span class="sd">        If the variable does not belong to the solver, the function just returns,</span>
<span class="sd">        or crashes in non-opt mode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_SetCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">coeff</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;Variable&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the coefficient of a given variable on the constraint (which is 0 if</span>
<span class="sd">        the variable does not appear in the constraint).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_GetCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">lb</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the lower bound.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_lb</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ub</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the upper bound.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_ub</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetBounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lb</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">ub</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Sets both the lower and upper bounds.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_SetBounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_is_lazy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">laziness</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Advanced usage: sets the constraint &quot;laziness&quot;.</span>

<span class="sd">        **This is only supported for SCIP and has no effect on other</span>
<span class="sd">        solvers.**</span>

<span class="sd">        When **laziness** is true, the constraint is only considered by the Linear</span>
<span class="sd">        Programming solver if its current solution violates the constraint. In this</span>
<span class="sd">        case, the constraint is definitively added to the problem. This may be</span>
<span class="sd">        useful in some MIP problems, and may have a dramatic impact on performance.</span>

<span class="sd">        For more info see: http://tinyurl.com/lazy-constraints.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_set_is_lazy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">laziness</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the index of the constraint in the MPSolver::constraints_.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dual_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Advanced usage: returns the dual value of the constraint in the current</span>
<span class="sd">        solution (only available for continuous problems).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_dual_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">basis_status</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPSolver::BasisStatus&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Advanced usage: returns the basis status of the constraint.</span>

<span class="sd">        It is only available for continuous problems).</span>

<span class="sd">        Note that if a constraint &quot;linear_expression in [lb, ub]&quot; is transformed</span>
<span class="sd">        into &quot;linear_expression + slack = 0&quot; with slack in [-ub, -lb], then this</span>
<span class="sd">        status is the same as the status of the slack variable with AT_UPPER_BOUND</span>
<span class="sd">        and AT_LOWER_BOUND swapped.</span>

<span class="sd">        See also: MPSolver::BasisStatus.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_basis_status</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Lb</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_Lb</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Ub</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_Ub</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetLb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_SetLb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetUb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_SetUb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DualValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_DualValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">delete_Constraint</span>

<span class="c1"># Register Constraint in _pywraplp:</span>
<span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_swigregister</span><span class="p">(</span><span class="n">Constraint</span><span class="p">)</span>

<span class="k">class</span> <span class="nc">MPSolverParameters</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class stores parameter settings for LP and MIP solvers. Some parameters</span>
<span class="sd">    are marked as advanced: do not change their values unless you know what you</span>
<span class="sd">    are doing!</span>

<span class="sd">    For developers: how to add a new parameter:</span>
<span class="sd">    - Add the new Foo parameter in the DoubleParam or IntegerParam enum.</span>
<span class="sd">    - If it is a categorical param, add a FooValues enum.</span>
<span class="sd">    - Decide if the wrapper should define a default value for it: yes</span>
<span class="sd">      if it controls the properties of the solution (example:</span>
<span class="sd">      tolerances) or if it consistently improves performance, no</span>
<span class="sd">      otherwise. If yes, define kDefaultFoo.</span>
<span class="sd">    - Add a foo_value_ member and, if no default value is defined, a</span>
<span class="sd">      foo_is_default_ member.</span>
<span class="sd">    - Add code to handle Foo in Set...Param, Reset...Param,</span>
<span class="sd">      Get...Param, Reset and the constructor.</span>
<span class="sd">    - In class MPSolverInterface, add a virtual method SetFoo, add it</span>
<span class="sd">      to SetCommonParameters or SetMIPParameters, and implement it for</span>
<span class="sd">      each solver. Sometimes, parameters need to be implemented</span>
<span class="sd">      differently, see for example the INCREMENTALITY implementation.</span>
<span class="sd">    - Add a test in linear_solver_test.cc.</span>

<span class="sd">    TODO(user): store the parameter values in a protocol buffer</span>
<span class="sd">    instead. We need to figure out how to deal with the subtleties of</span>
<span class="sd">    the default values.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>
    <span class="n">RELATIVE_MIP_GAP</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_RELATIVE_MIP_GAP</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Limit for relative MIP gap.&quot;&quot;&quot;</span>
    <span class="n">PRIMAL_TOLERANCE</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_PRIMAL_TOLERANCE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Advanced usage: tolerance for primal feasibility of basic solutions.</span>

<span class="sd">    This does not control the integer feasibility tolerance of integer</span>
<span class="sd">    solutions for MIP or the tolerance used during presolve.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">DUAL_TOLERANCE</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_DUAL_TOLERANCE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Advanced usage: tolerance for dual feasibility of basic solutions.&quot;&quot;&quot;</span>
    <span class="n">PRESOLVE</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_PRESOLVE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Advanced usage: presolve mode.&quot;&quot;&quot;</span>
    <span class="n">LP_ALGORITHM</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_LP_ALGORITHM</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Algorithm to solve linear programs.&quot;&quot;&quot;</span>
    <span class="n">INCREMENTALITY</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_INCREMENTALITY</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Advanced usage: incrementality from one solve to the next.&quot;&quot;&quot;</span>
    <span class="n">SCALING</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_SCALING</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Advanced usage: enable or disable matrix scaling.&quot;&quot;&quot;</span>
    <span class="n">PRESOLVE_OFF</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_PRESOLVE_OFF</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Presolve is off.&quot;&quot;&quot;</span>
    <span class="n">PRESOLVE_ON</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_PRESOLVE_ON</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Presolve is on.&quot;&quot;&quot;</span>
    <span class="n">DUAL</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_DUAL</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Dual simplex.&quot;&quot;&quot;</span>
    <span class="n">PRIMAL</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_PRIMAL</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Primal simplex.&quot;&quot;&quot;</span>
    <span class="n">BARRIER</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_BARRIER</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Barrier algorithm.&quot;&quot;&quot;</span>
    <span class="n">INCREMENTALITY_OFF</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_INCREMENTALITY_OFF</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Start solve from scratch.&quot;&quot;&quot;</span>
    <span class="n">INCREMENTALITY_ON</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_INCREMENTALITY_ON</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reuse results from previous solve as much as the underlying solver</span>
<span class="sd">    allows.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">SCALING_OFF</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_SCALING_OFF</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Scaling is off.&quot;&quot;&quot;</span>
    <span class="n">SCALING_ON</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_SCALING_ON</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Scaling is on.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; The constructor sets all parameters to their default value.&quot;&quot;&quot;</span>
        <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">new_MPSolverParameters</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">SetDoubleParam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPSolverParameters::DoubleParam&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Sets a double parameter to a specific value.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_SetDoubleParam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetIntegerParam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPSolverParameters::IntegerParam&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Sets a integer parameter to a specific value.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_SetIntegerParam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetDoubleParam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPSolverParameters::DoubleParam&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the value of a double parameter.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_GetDoubleParam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetIntegerParam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPSolverParameters::IntegerParam&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the value of an integer parameter.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_GetIntegerParam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">delete_MPSolverParameters</span>

<span class="c1"># Register MPSolverParameters in _pywraplp:</span>
<span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_swigregister</span><span class="p">(</span><span class="n">MPSolverParameters</span><span class="p">)</span>
<span class="n">cvar</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">cvar</span>
<span class="n">MPSolverParameters</span><span class="o">.</span><span class="n">kDefaultRelativeMipGap</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">cvar</span><span class="o">.</span><span class="n">MPSolverParameters_kDefaultRelativeMipGap</span>
<span class="n">MPSolverParameters</span><span class="o">.</span><span class="n">kDefaultPrimalTolerance</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">cvar</span><span class="o">.</span><span class="n">MPSolverParameters_kDefaultPrimalTolerance</span>
<span class="n">MPSolverParameters</span><span class="o">.</span><span class="n">kDefaultDualTolerance</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">cvar</span><span class="o">.</span><span class="n">MPSolverParameters_kDefaultDualTolerance</span>
<span class="n">MPSolverParameters</span><span class="o">.</span><span class="n">kDefaultPresolve</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">cvar</span><span class="o">.</span><span class="n">MPSolverParameters_kDefaultPresolve</span>
<span class="n">MPSolverParameters</span><span class="o">.</span><span class="n">kDefaultIncrementality</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">cvar</span><span class="o">.</span><span class="n">MPSolverParameters_kDefaultIncrementality</span>

<span class="k">class</span> <span class="nc">ModelExportOptions</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Export options.&quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">_pywraplp</span><span class="o">.</span><span class="n">ModelExportOptions_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">new_ModelExportOptions</span><span class="p">())</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">delete_ModelExportOptions</span>

<span class="c1"># Register ModelExportOptions in _pywraplp:</span>
<span class="n">_pywraplp</span><span class="o">.</span><span class="n">ModelExportOptions_swigregister</span><span class="p">(</span><span class="n">ModelExportOptions</span><span class="p">)</span>


<span class="k">def</span> <span class="nf">ExportModelAsLpFormat</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">ExportModelAsLpFormat</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">ExportModelAsMpsFormat</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">ExportModelAsMpsFormat</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">FindErrorInModelProto</span><span class="p">(</span><span class="n">input_model</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPModelProto const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">FindErrorInModelProto</span><span class="p">(</span><span class="n">input_model</span><span class="p">)</span>

<span class="k">def</span> <span class="nf">setup_variable_operator</span><span class="p">(</span><span class="n">opname</span><span class="p">):</span>
  <span class="nb">setattr</span><span class="p">(</span><span class="n">Variable</span><span class="p">,</span> <span class="n">opname</span><span class="p">,</span>
          <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">VariableExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">opname</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>
<span class="k">for</span> <span class="n">opname</span> <span class="ow">in</span> <span class="n">LinearExpr</span><span class="o">.</span><span class="n">OVERRIDDEN_OPERATOR_METHODS</span><span class="p">:</span>
  <span class="n">setup_variable_operator</span><span class="p">(</span><span class="n">opname</span><span class="p">)</span>
</pre></div>

        </details>

            </section>
                <section id="Solver">
                                <div class="attr class">
        <a class="headerlink" href="#Solver">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">Solver</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Solver</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This mathematical programming (MP) solver class is the main class</span>
<span class="sd">    though which users build and solve problems.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>
    <span class="n">CLP_LINEAR_PROGRAMMING</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_CLP_LINEAR_PROGRAMMING</span>
    <span class="n">GLPK_LINEAR_PROGRAMMING</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_GLPK_LINEAR_PROGRAMMING</span>
    <span class="n">GLOP_LINEAR_PROGRAMMING</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_GLOP_LINEAR_PROGRAMMING</span>
    <span class="n">SCIP_MIXED_INTEGER_PROGRAMMING</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_SCIP_MIXED_INTEGER_PROGRAMMING</span>
    <span class="n">GLPK_MIXED_INTEGER_PROGRAMMING</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_GLPK_MIXED_INTEGER_PROGRAMMING</span>
    <span class="n">CBC_MIXED_INTEGER_PROGRAMMING</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_CBC_MIXED_INTEGER_PROGRAMMING</span>
    <span class="n">GUROBI_LINEAR_PROGRAMMING</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_GUROBI_LINEAR_PROGRAMMING</span>
    <span class="n">GUROBI_MIXED_INTEGER_PROGRAMMING</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_GUROBI_MIXED_INTEGER_PROGRAMMING</span>
    <span class="n">CPLEX_LINEAR_PROGRAMMING</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_CPLEX_LINEAR_PROGRAMMING</span>
    <span class="n">CPLEX_MIXED_INTEGER_PROGRAMMING</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_CPLEX_MIXED_INTEGER_PROGRAMMING</span>
    <span class="n">XPRESS_LINEAR_PROGRAMMING</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_XPRESS_LINEAR_PROGRAMMING</span>
    <span class="n">XPRESS_MIXED_INTEGER_PROGRAMMING</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_XPRESS_MIXED_INTEGER_PROGRAMMING</span>
    <span class="n">BOP_INTEGER_PROGRAMMING</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_BOP_INTEGER_PROGRAMMING</span>
    <span class="n">SAT_INTEGER_PROGRAMMING</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_SAT_INTEGER_PROGRAMMING</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">,</span> <span class="n">problem_type</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPSolver::OptimizationProblemType&quot;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Create a solver with the given name and underlying solver backend.&quot;&quot;&quot;</span>
        <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">new_Solver</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">problem_type</span><span class="p">))</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">delete_Solver</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">CreateSolver</span><span class="p">(</span><span class="n">solver_id</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPSolver *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recommended factory method to create a MPSolver instance, especially in</span>
<span class="sd">        non C++ languages.</span>

<span class="sd">        It returns a newly created solver instance if successful, or a nullptr</span>
<span class="sd">        otherwise. This can occur if the relevant interface is not linked in, or if</span>
<span class="sd">        a needed license is not accessible for commercial solvers.</span>

<span class="sd">        Ownership of the solver is passed on to the caller of this method.</span>
<span class="sd">        It will accept both string names of the OptimizationProblemType enum, as</span>
<span class="sd">        well as a short version (i.e. &quot;SCIP_MIXED_INTEGER_PROGRAMMING&quot; or &quot;SCIP&quot;).</span>

<span class="sd">        solver_id is case insensitive, and the following names are supported:</span>
<span class="sd">          - CLP_LINEAR_PROGRAMMING or CLP</span>
<span class="sd">          - CBC_MIXED_INTEGER_PROGRAMMING or CBC</span>
<span class="sd">          - GLOP_LINEAR_PROGRAMMING or GLOP</span>
<span class="sd">          - BOP_INTEGER_PROGRAMMING or BOP</span>
<span class="sd">          - SAT_INTEGER_PROGRAMMING or SAT or CP_SAT</span>
<span class="sd">          - SCIP_MIXED_INTEGER_PROGRAMMING or SCIP</span>
<span class="sd">          - GUROBI_LINEAR_PROGRAMMING or GUROBI_LP</span>
<span class="sd">          - GUROBI_MIXED_INTEGER_PROGRAMMING or GUROBI or GUROBI_MIP</span>
<span class="sd">          - CPLEX_LINEAR_PROGRAMMING or CPLEX_LP</span>
<span class="sd">          - CPLEX_MIXED_INTEGER_PROGRAMMING or CPLEX or CPLEX_MIP</span>
<span class="sd">          - XPRESS_LINEAR_PROGRAMMING or XPRESS_LP</span>
<span class="sd">          - XPRESS_MIXED_INTEGER_PROGRAMMING or XPRESS or XPRESS_MIP</span>
<span class="sd">          - GLPK_LINEAR_PROGRAMMING or GLPK_LP</span>
<span class="sd">          - GLPK_MIXED_INTEGER_PROGRAMMING or GLPK or GLPK_MIP</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_CreateSolver</span><span class="p">(</span><span class="n">solver_id</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">SupportsProblemType</span><span class="p">(</span><span class="n">problem_type</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPSolver::OptimizationProblemType&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether the given problem type is supported (this will depend on the</span>
<span class="sd">        targets that you linked).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_SupportsProblemType</span><span class="p">(</span><span class="n">problem_type</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Clear</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clears the objective (including the optimization direction), all variables</span>
<span class="sd">        and constraints. All the other properties of the MPSolver (like the time</span>
<span class="sd">        limit) are kept untouched.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_Clear</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NumVariables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the number of variables.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_NumVariables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">variables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; operations_research::MPVariable * &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the array of variables handled by the MPSolver. (They are listed in</span>
<span class="sd">        the order in which they were created.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPVariable *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the variable at position index.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">LookupVariable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPVariable *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Looks up a variable by name, and returns nullptr if it does not exist. The</span>
<span class="sd">        first call has a O(n) complexity, as the variable name index is lazily</span>
<span class="sd">        created upon first use. Will crash if variable names are not unique.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_LookupVariable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lb</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">ub</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">integer</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPVariable *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a variable with the given bounds, integrality requirement and</span>
<span class="sd">        name. Bounds can be finite or +/- MPSolver::infinity(). The MPSolver owns</span>
<span class="sd">        the variable (i.e. the returned pointer is borrowed). Variable names are</span>
<span class="sd">        optional. If you give an empty name, name() will auto-generate one for you</span>
<span class="sd">        upon request.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_Var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">,</span> <span class="n">integer</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NumVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lb</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">ub</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPVariable *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Creates a continuous variable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_NumVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">IntVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lb</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">ub</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPVariable *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Creates an integer variable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_IntVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">BoolVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPVariable *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Creates a boolean variable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_BoolVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NumConstraints</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the number of constraints.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_NumConstraints</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; operations_research::MPConstraint * &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the array of constraints handled by the MPSolver.</span>

<span class="sd">        They are listed in the order in which they were created.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPConstraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the constraint at the given index.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">LookupConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constraint_name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPConstraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         Looks up a constraint by name, and returns nullptr if it does not exist.</span>

<span class="sd">        The first call has a O(n) complexity, as the constraint name index is</span>
<span class="sd">        lazily created upon first use. Will crash if constraint names are not</span>
<span class="sd">        unique.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_LookupConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constraint_name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPConstraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>

<span class="sd">        Creates a linear constraint with given bounds.</span>

<span class="sd">        Bounds can be finite or +/- MPSolver::infinity(). The MPSolver class</span>
<span class="sd">        assumes ownership of the constraint.</span>

<span class="sd">        :rtype: :py:class:`MPConstraint`</span>
<span class="sd">        :return: a pointer to the newly created constraint.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">         Creates a constraint with -infinity and +infinity bounds.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 3:*</span>
<span class="sd">         Creates a named constraint with given bounds.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 4:*</span>
<span class="sd">         Creates a named constraint with -infinity and +infinity bounds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_Constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Objective</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPObjective *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the mutable objective object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_Objective</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">OPTIMAL</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_OPTIMAL</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; optimal.&quot;&quot;&quot;</span>
    <span class="n">FEASIBLE</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_FEASIBLE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; feasible, or stopped by limit.&quot;&quot;&quot;</span>
    <span class="n">INFEASIBLE</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_INFEASIBLE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; proven infeasible.&quot;&quot;&quot;</span>
    <span class="n">UNBOUNDED</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_UNBOUNDED</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; proven unbounded.&quot;&quot;&quot;</span>
    <span class="n">ABNORMAL</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_ABNORMAL</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; abnormal, i.e., error of some kind.&quot;&quot;&quot;</span>
    <span class="n">NOT_SOLVED</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_NOT_SOLVED</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; not been solved yet.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">Solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPSolver::ResultStatus&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Solves the problem using the default parameter values.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Solves the problem using the specified parameter values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_Solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ComputeConstraintActivities</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; double &gt;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Advanced usage: compute the &quot;activities&quot; of all constraints, which are the</span>
<span class="sd">        sums of their linear terms. The activities are returned in the same order</span>
<span class="sd">        as constraints(), which is the order in which constraints were added; but</span>
<span class="sd">        you can also use MPConstraint::index() to get a constraint&#39;s index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_ComputeConstraintActivities</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">VerifySolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">log_errors</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Advanced usage: Verifies the *correctness* of the solution.</span>

<span class="sd">        It verifies that all variables must be within their domains, all</span>
<span class="sd">        constraints must be satisfied, and the reported objective value must be</span>
<span class="sd">        accurate.</span>

<span class="sd">        Usage:</span>
<span class="sd">        - This can only be called after Solve() was called.</span>
<span class="sd">        - &quot;tolerance&quot; is interpreted as an absolute error threshold.</span>
<span class="sd">        - For the objective value only, if the absolute error is too large,</span>
<span class="sd">          the tolerance is interpreted as a relative error threshold instead.</span>
<span class="sd">        - If &quot;log_errors&quot; is true, every single violation will be logged.</span>
<span class="sd">        - If &quot;tolerance&quot; is negative, it will be set to infinity().</span>

<span class="sd">        Most users should just set the --verify_solution flag and not bother using</span>
<span class="sd">        this method directly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_VerifySolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">log_errors</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">InterruptSolve</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         Interrupts the Solve() execution to terminate processing if possible.</span>

<span class="sd">        If the underlying interface supports interruption; it does that and returns</span>
<span class="sd">        true regardless of whether there&#39;s an ongoing Solve() or not. The Solve()</span>
<span class="sd">        call may still linger for a while depending on the conditions.  If</span>
<span class="sd">        interruption is not supported; returns false and does nothing.</span>
<span class="sd">        MPSolver::SolverTypeSupportsInterruption can be used to check if</span>
<span class="sd">        interruption is supported for a given solver type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_InterruptSolve</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">FillSolutionResponseProto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">response</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPSolutionResponse *&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Encodes the current solution in a solution response protocol buffer.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_FillSolutionResponseProto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">response</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">SolveWithProto</span><span class="p">(</span><span class="n">model_request</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPModelRequest const &amp;&quot;</span><span class="p">,</span> <span class="n">response</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPSolutionResponse *&quot;</span><span class="p">,</span> <span class="n">interrupt</span><span class="p">:</span> <span class="s2">&quot;std::atomic&lt; bool &gt; *&quot;</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPSolutionResponse *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solves the model encoded by a MPModelRequest protocol buffer and fills the</span>
<span class="sd">        solution encoded as a MPSolutionResponse. The solve is stopped prematurely</span>
<span class="sd">        if interrupt is non-null at set to true during (or before) solving.</span>
<span class="sd">        Interruption is only supported if SolverTypeSupportsInterruption() returns</span>
<span class="sd">        true for the requested solver. Passing a non-null interruption with any</span>
<span class="sd">        other solver type immediately returns an MPSOLVER_INCOMPATIBLE_OPTIONS</span>
<span class="sd">        error.</span>

<span class="sd">        Note(user): This attempts to first use `DirectlySolveProto()` (if</span>
<span class="sd">        implemented). Consequently, this most likely does *not* override any of</span>
<span class="sd">        the default parameters of the underlying solver. This behavior *differs*</span>
<span class="sd">        from `MPSolver::Solve()` which by default sets the feasibility tolerance</span>
<span class="sd">        and the gap limit (as of 2020/02/11, to 1e-7 and 0.0001, respectively).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_SolveWithProto</span><span class="p">(</span><span class="n">model_request</span><span class="p">,</span> <span class="n">response</span><span class="p">,</span> <span class="n">interrupt</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ExportModelToProto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_model</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPModelProto *&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Exports model to protocol buffer.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_ExportModelToProto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_model</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetSolverSpecificParametersAsString</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Advanced usage: pass solver specific parameters in text format.</span>

<span class="sd">        The format is solver-specific and is the same as the corresponding solver</span>
<span class="sd">        configuration file format. Returns true if the operation was successful.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_SetSolverSpecificParametersAsString</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>
    <span class="n">FREE</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_FREE</span>
    <span class="n">AT_LOWER_BOUND</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_AT_LOWER_BOUND</span>
    <span class="n">AT_UPPER_BOUND</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_AT_UPPER_BOUND</span>
    <span class="n">FIXED_VALUE</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_FIXED_VALUE</span>
    <span class="n">BASIC</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_BASIC</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">infinity</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Infinity.</span>

<span class="sd">        You can use -MPSolver::infinity() for negative infinity.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_infinity</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">EnableOutput</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Enables solver logging.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_EnableOutput</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SuppressOutput</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Suppresses solver logging.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_SuppressOutput</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">iterations</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the number of simplex iterations.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_iterations</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of branch-and-bound nodes evaluated during the solve.</span>

<span class="sd">        Only available for discrete problems.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ComputeExactConditionNumber</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         Advanced usage: computes the exact condition number of the current scaled</span>
<span class="sd">        basis: L1norm(B) * L1norm(inverse(B)), where B is the scaled basis.</span>

<span class="sd">        This method requires that a basis exists: it should be called after Solve.</span>
<span class="sd">        It is only available for continuous problems. It is implemented for GLPK</span>
<span class="sd">        but not CLP because CLP does not provide the API for doing it.</span>

<span class="sd">        The condition number measures how well the constraint matrix is conditioned</span>
<span class="sd">        and can be used to predict whether numerical issues will arise during the</span>
<span class="sd">        solve: the model is declared infeasible whereas it is feasible (or</span>
<span class="sd">        vice-versa), the solution obtained is not optimal or violates some</span>
<span class="sd">        constraints, the resolution is slow because of repeated singularities.</span>

<span class="sd">        The rule of thumb to interpret the condition number kappa is:</span>
<span class="sd">          - o kappa &lt;= 1e7: virtually no chance of numerical issues</span>
<span class="sd">          - o 1e7 &lt; kappa &lt;= 1e10: small chance of numerical issues</span>
<span class="sd">          - o 1e10 &lt; kappa &lt;= 1e13: medium chance of numerical issues</span>
<span class="sd">          - o kappa &gt; 1e13: high chance of numerical issues</span>

<span class="sd">        The computation of the condition number depends on the quality of the LU</span>
<span class="sd">        decomposition, so it is not very accurate when the matrix is ill</span>
<span class="sd">        conditioned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_ComputeExactConditionNumber</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">NextSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Some solvers (MIP only, not LP) can produce multiple solutions to the</span>
<span class="sd">        problem. Returns true when another solution is available, and updates the</span>
<span class="sd">        MPVariable* objects to make the new solution queryable. Call only after</span>
<span class="sd">        calling solve.</span>

<span class="sd">        The optimality properties of the additional solutions found, and whether or</span>
<span class="sd">        not the solver computes them ahead of time or when NextSolution() is called</span>
<span class="sd">        is solver specific.</span>

<span class="sd">        As of 2020-02-10, only Gurobi and SCIP support NextSolution(), see</span>
<span class="sd">        linear_solver_interfaces_test for an example of how to configure these</span>
<span class="sd">        solvers for multiple solutions. Other solvers return false unconditionally.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_NextSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_time_limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_limit_milliseconds</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_set_time_limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_limit_milliseconds</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">wall_time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_wall_time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">LoadModelFromProto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_model</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPModelProto const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_LoadModelFromProto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_model</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">LoadModelFromProtoWithUniqueNamesOrDie</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_model</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPModelProto const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_LoadModelFromProtoWithUniqueNamesOrDie</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_model</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">LoadSolutionFromProto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_LoadSolutionFromProto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ExportModelAsLpFormat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obfuscated</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_ExportModelAsLpFormat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obfuscated</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ExportModelAsMpsFormat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fixed_format</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">obfuscated</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_ExportModelAsMpsFormat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fixed_format</span><span class="p">,</span> <span class="n">obfuscated</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetHint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::MPVariable * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; double &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set a hint for solution.</span>

<span class="sd">        If a feasible or almost-feasible solution to the problem is already known,</span>
<span class="sd">        it may be helpful to pass it to the solver so that it can be used. A</span>
<span class="sd">        solver that supports this feature will try to use this information to</span>
<span class="sd">        create its initial feasible solution.</span>

<span class="sd">        Note that it may not always be faster to give a hint like this to the</span>
<span class="sd">        solver. There is also no guarantee that the solver will use this hint or</span>
<span class="sd">        try to return a solution &quot;close&quot; to this assignment in case of multiple</span>
<span class="sd">        optimal solutions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_SetHint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetNumThreads</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_theads</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Sets the number of threads to be used by the solver.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_SetNumThreads</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_theads</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constraint</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">constraint</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">constraint</span><span class="p">:</span>
          <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">RowConstraint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">RowConstraint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">constraint</span><span class="o">.</span><span class="n">Extract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr_array</span><span class="p">):</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">SumArray</span><span class="p">(</span><span class="n">expr_array</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">RowConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Constraint</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Minimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
      <span class="n">objective</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Objective</span><span class="p">()</span>
      <span class="n">objective</span><span class="o">.</span><span class="n">Clear</span><span class="p">()</span>
      <span class="n">objective</span><span class="o">.</span><span class="n">SetMinimization</span><span class="p">()</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span>
          <span class="n">objective</span><span class="o">.</span><span class="n">SetOffset</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
          <span class="n">coeffs</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">GetCoeffs</span><span class="p">()</span>
          <span class="n">objective</span><span class="o">.</span><span class="n">SetOffset</span><span class="p">(</span><span class="n">coeffs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">OFFSET_KEY</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
          <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">coeffs</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">objective</span><span class="o">.</span><span class="n">SetCoefficient</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">Maximize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
      <span class="n">objective</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Objective</span><span class="p">()</span>
      <span class="n">objective</span><span class="o">.</span><span class="n">Clear</span><span class="p">()</span>
      <span class="n">objective</span><span class="o">.</span><span class="n">SetMaximization</span><span class="p">()</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span>
          <span class="n">objective</span><span class="o">.</span><span class="n">SetOffset</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
          <span class="n">coeffs</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">GetCoeffs</span><span class="p">()</span>
          <span class="n">objective</span><span class="o">.</span><span class="n">SetOffset</span><span class="p">(</span><span class="n">coeffs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">OFFSET_KEY</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
          <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">coeffs</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">objective</span><span class="o">.</span><span class="n">SetCoefficient</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>


    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">Infinity</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_Infinity</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">SetTimeLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_SetTimeLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">WallTime</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_WallTime</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Iterations</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_Iterations</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>This mathematical programming (MP) solver class is the main class
though which users build and solve problems.</p>
</div>


                            <div id="Solver.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">Solver</span><span class="signature">(
    name: &#39;std::string const &amp;&#39;,
    problem_type: &#39;operations_research::MPSolver::OptimizationProblemType&#39;
)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">,</span> <span class="n">problem_type</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPSolver::OptimizationProblemType&quot;</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Create a solver with the given name and underlying solver backend.&quot;&quot;&quot;</span>
        <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">new_Solver</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">problem_type</span><span class="p">))</span>
</pre></div>

        </details>

            <div class="docstring"><p>Create a solver with the given name and underlying solver backend.</p>
</div>


                            </div>
                            <div id="Solver.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="Solver.CLP_LINEAR_PROGRAMMING" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.CLP_LINEAR_PROGRAMMING">#&nbsp;&nbsp</a>

        <span class="name">CLP_LINEAR_PROGRAMMING</span><span class="default_value"> = 0</span>
    </div>

    

                            </div>
                            <div id="Solver.GLPK_LINEAR_PROGRAMMING" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.GLPK_LINEAR_PROGRAMMING">#&nbsp;&nbsp</a>

        <span class="name">GLPK_LINEAR_PROGRAMMING</span><span class="default_value"> = 1</span>
    </div>

    

                            </div>
                            <div id="Solver.GLOP_LINEAR_PROGRAMMING" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.GLOP_LINEAR_PROGRAMMING">#&nbsp;&nbsp</a>

        <span class="name">GLOP_LINEAR_PROGRAMMING</span><span class="default_value"> = 2</span>
    </div>

    

                            </div>
                            <div id="Solver.SCIP_MIXED_INTEGER_PROGRAMMING" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.SCIP_MIXED_INTEGER_PROGRAMMING">#&nbsp;&nbsp</a>

        <span class="name">SCIP_MIXED_INTEGER_PROGRAMMING</span><span class="default_value"> = 3</span>
    </div>

    

                            </div>
                            <div id="Solver.GLPK_MIXED_INTEGER_PROGRAMMING" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.GLPK_MIXED_INTEGER_PROGRAMMING">#&nbsp;&nbsp</a>

        <span class="name">GLPK_MIXED_INTEGER_PROGRAMMING</span><span class="default_value"> = 4</span>
    </div>

    

                            </div>
                            <div id="Solver.CBC_MIXED_INTEGER_PROGRAMMING" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.CBC_MIXED_INTEGER_PROGRAMMING">#&nbsp;&nbsp</a>

        <span class="name">CBC_MIXED_INTEGER_PROGRAMMING</span><span class="default_value"> = 5</span>
    </div>

    

                            </div>
                            <div id="Solver.GUROBI_LINEAR_PROGRAMMING" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.GUROBI_LINEAR_PROGRAMMING">#&nbsp;&nbsp</a>

        <span class="name">GUROBI_LINEAR_PROGRAMMING</span><span class="default_value"> = 6</span>
    </div>

    

                            </div>
                            <div id="Solver.GUROBI_MIXED_INTEGER_PROGRAMMING" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.GUROBI_MIXED_INTEGER_PROGRAMMING">#&nbsp;&nbsp</a>

        <span class="name">GUROBI_MIXED_INTEGER_PROGRAMMING</span><span class="default_value"> = 7</span>
    </div>

    

                            </div>
                            <div id="Solver.CPLEX_LINEAR_PROGRAMMING" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.CPLEX_LINEAR_PROGRAMMING">#&nbsp;&nbsp</a>

        <span class="name">CPLEX_LINEAR_PROGRAMMING</span><span class="default_value"> = 10</span>
    </div>

    

                            </div>
                            <div id="Solver.CPLEX_MIXED_INTEGER_PROGRAMMING" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.CPLEX_MIXED_INTEGER_PROGRAMMING">#&nbsp;&nbsp</a>

        <span class="name">CPLEX_MIXED_INTEGER_PROGRAMMING</span><span class="default_value"> = 11</span>
    </div>

    

                            </div>
                            <div id="Solver.XPRESS_LINEAR_PROGRAMMING" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.XPRESS_LINEAR_PROGRAMMING">#&nbsp;&nbsp</a>

        <span class="name">XPRESS_LINEAR_PROGRAMMING</span><span class="default_value"> = 101</span>
    </div>

    

                            </div>
                            <div id="Solver.XPRESS_MIXED_INTEGER_PROGRAMMING" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.XPRESS_MIXED_INTEGER_PROGRAMMING">#&nbsp;&nbsp</a>

        <span class="name">XPRESS_MIXED_INTEGER_PROGRAMMING</span><span class="default_value"> = 102</span>
    </div>

    

                            </div>
                            <div id="Solver.BOP_INTEGER_PROGRAMMING" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.BOP_INTEGER_PROGRAMMING">#&nbsp;&nbsp</a>

        <span class="name">BOP_INTEGER_PROGRAMMING</span><span class="default_value"> = 12</span>
    </div>

    

                            </div>
                            <div id="Solver.SAT_INTEGER_PROGRAMMING" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.SAT_INTEGER_PROGRAMMING">#&nbsp;&nbsp</a>

        <span class="name">SAT_INTEGER_PROGRAMMING</span><span class="default_value"> = 14</span>
    </div>

    

                            </div>
                            <div id="Solver.CreateSolver" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.CreateSolver">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">CreateSolver</span><span class="signature">(
    solver_id: &#39;std::string const &amp;&#39;
) -&gt; &#39;operations_research::MPSolver *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">CreateSolver</span><span class="p">(</span><span class="n">solver_id</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPSolver *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Recommended factory method to create a MPSolver instance, especially in</span>
<span class="sd">        non C++ languages.</span>

<span class="sd">        It returns a newly created solver instance if successful, or a nullptr</span>
<span class="sd">        otherwise. This can occur if the relevant interface is not linked in, or if</span>
<span class="sd">        a needed license is not accessible for commercial solvers.</span>

<span class="sd">        Ownership of the solver is passed on to the caller of this method.</span>
<span class="sd">        It will accept both string names of the OptimizationProblemType enum, as</span>
<span class="sd">        well as a short version (i.e. &quot;SCIP_MIXED_INTEGER_PROGRAMMING&quot; or &quot;SCIP&quot;).</span>

<span class="sd">        solver_id is case insensitive, and the following names are supported:</span>
<span class="sd">          - CLP_LINEAR_PROGRAMMING or CLP</span>
<span class="sd">          - CBC_MIXED_INTEGER_PROGRAMMING or CBC</span>
<span class="sd">          - GLOP_LINEAR_PROGRAMMING or GLOP</span>
<span class="sd">          - BOP_INTEGER_PROGRAMMING or BOP</span>
<span class="sd">          - SAT_INTEGER_PROGRAMMING or SAT or CP_SAT</span>
<span class="sd">          - SCIP_MIXED_INTEGER_PROGRAMMING or SCIP</span>
<span class="sd">          - GUROBI_LINEAR_PROGRAMMING or GUROBI_LP</span>
<span class="sd">          - GUROBI_MIXED_INTEGER_PROGRAMMING or GUROBI or GUROBI_MIP</span>
<span class="sd">          - CPLEX_LINEAR_PROGRAMMING or CPLEX_LP</span>
<span class="sd">          - CPLEX_MIXED_INTEGER_PROGRAMMING or CPLEX or CPLEX_MIP</span>
<span class="sd">          - XPRESS_LINEAR_PROGRAMMING or XPRESS_LP</span>
<span class="sd">          - XPRESS_MIXED_INTEGER_PROGRAMMING or XPRESS or XPRESS_MIP</span>
<span class="sd">          - GLPK_LINEAR_PROGRAMMING or GLPK_LP</span>
<span class="sd">          - GLPK_MIXED_INTEGER_PROGRAMMING or GLPK or GLPK_MIP</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_CreateSolver</span><span class="p">(</span><span class="n">solver_id</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Recommended factory method to create a MPSolver instance, especially in
non C++ languages.</p>

<p>It returns a newly created solver instance if successful, or a nullptr
otherwise. This can occur if the relevant interface is not linked in, or if
a needed license is not accessible for commercial solvers.</p>

<p>Ownership of the solver is passed on to the caller of this method.
It will accept both string names of the OptimizationProblemType enum, as
well as a short version (i.e. "SCIP_MIXED_INTEGER_PROGRAMMING" or "SCIP").</p>

<p>solver_id is case insensitive, and the following names are supported:</p>

<ul>
<li>CLP_LINEAR_PROGRAMMING or CLP</li>
<li>CBC_MIXED_INTEGER_PROGRAMMING or CBC</li>
<li>GLOP_LINEAR_PROGRAMMING or GLOP</li>
<li>BOP_INTEGER_PROGRAMMING or BOP</li>
<li>SAT_INTEGER_PROGRAMMING or SAT or CP_SAT</li>
<li>SCIP_MIXED_INTEGER_PROGRAMMING or SCIP</li>
<li>GUROBI_LINEAR_PROGRAMMING or GUROBI_LP</li>
<li>GUROBI_MIXED_INTEGER_PROGRAMMING or GUROBI or GUROBI_MIP</li>
<li>CPLEX_LINEAR_PROGRAMMING or CPLEX_LP</li>
<li>CPLEX_MIXED_INTEGER_PROGRAMMING or CPLEX or CPLEX_MIP</li>
<li>XPRESS_LINEAR_PROGRAMMING or XPRESS_LP</li>
<li>XPRESS_MIXED_INTEGER_PROGRAMMING or XPRESS or XPRESS_MIP</li>
<li>GLPK_LINEAR_PROGRAMMING or GLPK_LP</li>
<li>GLPK_MIXED_INTEGER_PROGRAMMING or GLPK or GLPK_MIP</li>
</ul>
</div>


                            </div>
                            <div id="Solver.SupportsProblemType" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.SupportsProblemType">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">SupportsProblemType</span><span class="signature">(
    problem_type: &#39;operations_research::MPSolver::OptimizationProblemType&#39;
) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">SupportsProblemType</span><span class="p">(</span><span class="n">problem_type</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPSolver::OptimizationProblemType&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Whether the given problem type is supported (this will depend on the</span>
<span class="sd">        targets that you linked).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_SupportsProblemType</span><span class="p">(</span><span class="n">problem_type</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Whether the given problem type is supported (this will depend on the
targets that you linked).</p>
</div>


                            </div>
                            <div id="Solver.Clear" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Clear">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Clear</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Clear</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Clears the objective (including the optimization direction), all variables</span>
<span class="sd">        and constraints. All the other properties of the MPSolver (like the time</span>
<span class="sd">        limit) are kept untouched.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_Clear</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Clears the objective (including the optimization direction), all variables
and constraints. All the other properties of the MPSolver (like the time
limit) are kept untouched.</p>
</div>


                            </div>
                            <div id="Solver.NumVariables" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.NumVariables">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">NumVariables</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">NumVariables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the number of variables.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_NumVariables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the number of variables.</p>
</div>


                            </div>
                            <div id="Solver.variables" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.variables">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">variables</span><span class="signature">(self) -&gt; &#39;std::vector&lt; operations_research::MPVariable * &gt; const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">variables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; operations_research::MPVariable * &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the array of variables handled by the MPSolver. (They are listed in</span>
<span class="sd">        the order in which they were created.)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_variables</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the array of variables handled by the MPSolver. (They are listed in
the order in which they were created.)</p>
</div>


                            </div>
                            <div id="Solver.variable" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.variable">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">variable</span><span class="signature">(self, index: int) -&gt; &#39;operations_research::MPVariable *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPVariable *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;Returns the variable at position index.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_variable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the variable at position index.</p>
</div>


                            </div>
                            <div id="Solver.LookupVariable" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.LookupVariable">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">LookupVariable</span><span class="signature">(
    self,
    var_name: &#39;std::string const &amp;&#39;
) -&gt; &#39;operations_research::MPVariable *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">LookupVariable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPVariable *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Looks up a variable by name, and returns nullptr if it does not exist. The</span>
<span class="sd">        first call has a O(n) complexity, as the variable name index is lazily</span>
<span class="sd">        created upon first use. Will crash if variable names are not unique.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_LookupVariable</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var_name</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Looks up a variable by name, and returns nullptr if it does not exist. The
first call has a O(n) complexity, as the variable name index is lazily
created upon first use. Will crash if variable names are not unique.</p>
</div>


                            </div>
                            <div id="Solver.Var" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Var">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Var</span><span class="signature">(
    self,
    lb: &#39;double&#39;,
    ub: &#39;double&#39;,
    integer: bool,
    name: &#39;std::string const &amp;&#39;
) -&gt; &#39;operations_research::MPVariable *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lb</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">ub</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">integer</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPVariable *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Creates a variable with the given bounds, integrality requirement and</span>
<span class="sd">        name. Bounds can be finite or +/- MPSolver::infinity(). The MPSolver owns</span>
<span class="sd">        the variable (i.e. the returned pointer is borrowed). Variable names are</span>
<span class="sd">        optional. If you give an empty name, name() will auto-generate one for you</span>
<span class="sd">        upon request.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_Var</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">,</span> <span class="n">integer</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates a variable with the given bounds, integrality requirement and
name. Bounds can be finite or +/- MPSolver::infinity(). The MPSolver owns
the variable (i.e. the returned pointer is borrowed). Variable names are
optional. If you give an empty name, name() will auto-generate one for you
upon request.</p>
</div>


                            </div>
                            <div id="Solver.NumVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.NumVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">NumVar</span><span class="signature">(
    self,
    lb: &#39;double&#39;,
    ub: &#39;double&#39;,
    name: &#39;std::string const &amp;&#39;
) -&gt; &#39;operations_research::MPVariable *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">NumVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lb</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">ub</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPVariable *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Creates a continuous variable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_NumVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates a continuous variable.</p>
</div>


                            </div>
                            <div id="Solver.IntVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.IntVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">IntVar</span><span class="signature">(
    self,
    lb: &#39;double&#39;,
    ub: &#39;double&#39;,
    name: &#39;std::string const &amp;&#39;
) -&gt; &#39;operations_research::MPVariable *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">IntVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lb</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">ub</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPVariable *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Creates an integer variable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_IntVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates an integer variable.</p>
</div>


                            </div>
                            <div id="Solver.BoolVar" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.BoolVar">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">BoolVar</span><span class="signature">(
    self,
    name: &#39;std::string const &amp;&#39;
) -&gt; &#39;operations_research::MPVariable *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">BoolVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPVariable *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Creates a boolean variable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_BoolVar</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Creates a boolean variable.</p>
</div>


                            </div>
                            <div id="Solver.NumConstraints" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.NumConstraints">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">NumConstraints</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">NumConstraints</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the number of constraints.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_NumConstraints</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the number of constraints.</p>
</div>


                            </div>
                            <div id="Solver.constraints" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.constraints">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">constraints</span><span class="signature">(self) -&gt; &#39;std::vector&lt; operations_research::MPConstraint * &gt; const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; operations_research::MPConstraint * &gt; const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the array of constraints handled by the MPSolver.</span>

<span class="sd">        They are listed in the order in which they were created.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_constraints</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the array of constraints handled by the MPSolver.</p>

<p>They are listed in the order in which they were created.</p>
</div>


                            </div>
                            <div id="Solver.constraint" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.constraint">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">constraint</span><span class="signature">(self, index: int) -&gt; &#39;operations_research::MPConstraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPConstraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the constraint at the given index.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">index</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the constraint at the given index.</p>
</div>


                            </div>
                            <div id="Solver.LookupConstraint" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.LookupConstraint">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">LookupConstraint</span><span class="signature">(
    self,
    constraint_name: &#39;std::string const &amp;&#39;
) -&gt; &#39;operations_research::MPConstraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">LookupConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constraint_name</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPConstraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         Looks up a constraint by name, and returns nullptr if it does not exist.</span>

<span class="sd">        The first call has a O(n) complexity, as the constraint name index is</span>
<span class="sd">        lazily created upon first use. Will crash if constraint names are not</span>
<span class="sd">        unique.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_LookupConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constraint_name</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Looks up a constraint by name, and returns nullptr if it does not exist.</p>

<p>The first call has a O(n) complexity, as the constraint name index is
lazily created upon first use. Will crash if constraint names are not
unique.</p>
</div>


                            </div>
                            <div id="Solver.Constraint" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Constraint">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Constraint</span><span class="signature">(self, *args) -&gt; &#39;operations_research::MPConstraint *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPConstraint *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>

<span class="sd">        Creates a linear constraint with given bounds.</span>

<span class="sd">        Bounds can be finite or +/- MPSolver::infinity(). The MPSolver class</span>
<span class="sd">        assumes ownership of the constraint.</span>

<span class="sd">        :rtype: :py:class:`MPConstraint`</span>
<span class="sd">        :return: a pointer to the newly created constraint.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">         Creates a constraint with -infinity and +infinity bounds.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 3:*</span>
<span class="sd">         Creates a named constraint with given bounds.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 4:*</span>
<span class="sd">         Creates a named constraint with -infinity and +infinity bounds.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_Constraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p><em>Overload 1:</em></p>

<p>Creates a linear constraint with given bounds.</p>

<p>Bounds can be finite or +/- MPSolver::infinity(). The MPSolver class
assumes ownership of the constraint.</p>

<p>:rtype: <code>MPConstraint</code>
:return: a pointer to the newly created constraint.</p>

<p>|</p>

<p><em>Overload 2:</em>
 Creates a constraint with -infinity and +infinity bounds.</p>

<p>|</p>

<p><em>Overload 3:</em>
 Creates a named constraint with given bounds.</p>

<p>|</p>

<p><em>Overload 4:</em>
 Creates a named constraint with -infinity and +infinity bounds.</p>
</div>


                            </div>
                            <div id="Solver.Objective" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Objective">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Objective</span><span class="signature">(self) -&gt; &#39;operations_research::MPObjective *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Objective</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPObjective *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the mutable objective object.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_Objective</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the mutable objective object.</p>
</div>


                            </div>
                            <div id="Solver.OPTIMAL" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.OPTIMAL">#&nbsp;&nbsp</a>

        <span class="name">OPTIMAL</span><span class="default_value"> = 0</span>
    </div>

            <div class="docstring"><p>optimal.</p>
</div>


                            </div>
                            <div id="Solver.FEASIBLE" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.FEASIBLE">#&nbsp;&nbsp</a>

        <span class="name">FEASIBLE</span><span class="default_value"> = 1</span>
    </div>

            <div class="docstring"><p>feasible, or stopped by limit.</p>
</div>


                            </div>
                            <div id="Solver.INFEASIBLE" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.INFEASIBLE">#&nbsp;&nbsp</a>

        <span class="name">INFEASIBLE</span><span class="default_value"> = 2</span>
    </div>

            <div class="docstring"><p>proven infeasible.</p>
</div>


                            </div>
                            <div id="Solver.UNBOUNDED" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.UNBOUNDED">#&nbsp;&nbsp</a>

        <span class="name">UNBOUNDED</span><span class="default_value"> = 3</span>
    </div>

            <div class="docstring"><p>proven unbounded.</p>
</div>


                            </div>
                            <div id="Solver.ABNORMAL" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.ABNORMAL">#&nbsp;&nbsp</a>

        <span class="name">ABNORMAL</span><span class="default_value"> = 4</span>
    </div>

            <div class="docstring"><p>abnormal, i.e., error of some kind.</p>
</div>


                            </div>
                            <div id="Solver.NOT_SOLVED" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.NOT_SOLVED">#&nbsp;&nbsp</a>

        <span class="name">NOT_SOLVED</span><span class="default_value"> = 6</span>
    </div>

            <div class="docstring"><p>not been solved yet.</p>
</div>


                            </div>
                            <div id="Solver.Solve" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Solve">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Solve</span><span class="signature">(self, *args) -&gt; &#39;operations_research::MPSolver::ResultStatus&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPSolver::ResultStatus&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        *Overload 1:*</span>
<span class="sd">        Solves the problem using the default parameter values.</span>

<span class="sd">        |</span>

<span class="sd">        *Overload 2:*</span>
<span class="sd">        Solves the problem using the specified parameter values.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_Solve</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p><em>Overload 1:</em>
Solves the problem using the default parameter values.</p>

<p>|</p>

<p><em>Overload 2:</em>
Solves the problem using the specified parameter values.</p>
</div>


                            </div>
                            <div id="Solver.ComputeConstraintActivities" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.ComputeConstraintActivities">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ComputeConstraintActivities</span><span class="signature">(self) -&gt; &#39;std::vector&lt; double &gt;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ComputeConstraintActivities</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::vector&lt; double &gt;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Advanced usage: compute the &quot;activities&quot; of all constraints, which are the</span>
<span class="sd">        sums of their linear terms. The activities are returned in the same order</span>
<span class="sd">        as constraints(), which is the order in which constraints were added; but</span>
<span class="sd">        you can also use MPConstraint::index() to get a constraint&#39;s index.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_ComputeConstraintActivities</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Advanced usage: compute the "activities" of all constraints, which are the
sums of their linear terms. The activities are returned in the same order
as constraints(), which is the order in which constraints were added; but
you can also use MPConstraint::index() to get a constraint's index.</p>
</div>


                            </div>
                            <div id="Solver.VerifySolution" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.VerifySolution">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">VerifySolution</span><span class="signature">(self, tolerance: &#39;double&#39;, log_errors: bool) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">VerifySolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">log_errors</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Advanced usage: Verifies the *correctness* of the solution.</span>

<span class="sd">        It verifies that all variables must be within their domains, all</span>
<span class="sd">        constraints must be satisfied, and the reported objective value must be</span>
<span class="sd">        accurate.</span>

<span class="sd">        Usage:</span>
<span class="sd">        - This can only be called after Solve() was called.</span>
<span class="sd">        - &quot;tolerance&quot; is interpreted as an absolute error threshold.</span>
<span class="sd">        - For the objective value only, if the absolute error is too large,</span>
<span class="sd">          the tolerance is interpreted as a relative error threshold instead.</span>
<span class="sd">        - If &quot;log_errors&quot; is true, every single violation will be logged.</span>
<span class="sd">        - If &quot;tolerance&quot; is negative, it will be set to infinity().</span>

<span class="sd">        Most users should just set the --verify_solution flag and not bother using</span>
<span class="sd">        this method directly.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_VerifySolution</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">tolerance</span><span class="p">,</span> <span class="n">log_errors</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Advanced usage: Verifies the <em>correctness</em> of the solution.</p>

<p>It verifies that all variables must be within their domains, all
constraints must be satisfied, and the reported objective value must be
accurate.</p>

<p>Usage:</p>

<ul>
<li>This can only be called after Solve() was called.</li>
<li>"tolerance" is interpreted as an absolute error threshold.</li>
<li>For the objective value only, if the absolute error is too large,
the tolerance is interpreted as a relative error threshold instead.</li>
<li>If "log_errors" is true, every single violation will be logged.</li>
<li>If "tolerance" is negative, it will be set to infinity().</li>
</ul>

<p>Most users should just set the --verify_solution flag and not bother using
this method directly.</p>
</div>


                            </div>
                            <div id="Solver.InterruptSolve" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.InterruptSolve">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">InterruptSolve</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">InterruptSolve</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         Interrupts the Solve() execution to terminate processing if possible.</span>

<span class="sd">        If the underlying interface supports interruption; it does that and returns</span>
<span class="sd">        true regardless of whether there&#39;s an ongoing Solve() or not. The Solve()</span>
<span class="sd">        call may still linger for a while depending on the conditions.  If</span>
<span class="sd">        interruption is not supported; returns false and does nothing.</span>
<span class="sd">        MPSolver::SolverTypeSupportsInterruption can be used to check if</span>
<span class="sd">        interruption is supported for a given solver type.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_InterruptSolve</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Interrupts the Solve() execution to terminate processing if possible.</p>

<p>If the underlying interface supports interruption; it does that and returns
true regardless of whether there's an ongoing Solve() or not. The Solve()
call may still linger for a while depending on the conditions.  If
interruption is not supported; returns false and does nothing.
MPSolver::SolverTypeSupportsInterruption can be used to check if
interruption is supported for a given solver type.</p>
</div>


                            </div>
                            <div id="Solver.FillSolutionResponseProto" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.FillSolutionResponseProto">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">FillSolutionResponseProto</span><span class="signature">(
    self,
    response: &#39;operations_research::MPSolutionResponse *&#39;
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">FillSolutionResponseProto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">response</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPSolutionResponse *&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Encodes the current solution in a solution response protocol buffer.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_FillSolutionResponseProto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">response</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Encodes the current solution in a solution response protocol buffer.</p>
</div>


                            </div>
                            <div id="Solver.SolveWithProto" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.SolveWithProto">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">SolveWithProto</span><span class="signature">(
    model_request: &#39;operations_research::MPModelRequest const &amp;&#39;,
    response: &#39;operations_research::MPSolutionResponse *&#39;,
    interrupt: &#39;std::atomic&lt; bool &gt; *&#39; = None
) -&gt; &#39;operations_research::MPSolutionResponse *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">SolveWithProto</span><span class="p">(</span><span class="n">model_request</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPModelRequest const &amp;&quot;</span><span class="p">,</span> <span class="n">response</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPSolutionResponse *&quot;</span><span class="p">,</span> <span class="n">interrupt</span><span class="p">:</span> <span class="s2">&quot;std::atomic&lt; bool &gt; *&quot;</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPSolutionResponse *&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Solves the model encoded by a MPModelRequest protocol buffer and fills the</span>
<span class="sd">        solution encoded as a MPSolutionResponse. The solve is stopped prematurely</span>
<span class="sd">        if interrupt is non-null at set to true during (or before) solving.</span>
<span class="sd">        Interruption is only supported if SolverTypeSupportsInterruption() returns</span>
<span class="sd">        true for the requested solver. Passing a non-null interruption with any</span>
<span class="sd">        other solver type immediately returns an MPSOLVER_INCOMPATIBLE_OPTIONS</span>
<span class="sd">        error.</span>

<span class="sd">        Note(user): This attempts to first use `DirectlySolveProto()` (if</span>
<span class="sd">        implemented). Consequently, this most likely does *not* override any of</span>
<span class="sd">        the default parameters of the underlying solver. This behavior *differs*</span>
<span class="sd">        from `MPSolver::Solve()` which by default sets the feasibility tolerance</span>
<span class="sd">        and the gap limit (as of 2020/02/11, to 1e-7 and 0.0001, respectively).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_SolveWithProto</span><span class="p">(</span><span class="n">model_request</span><span class="p">,</span> <span class="n">response</span><span class="p">,</span> <span class="n">interrupt</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Solves the model encoded by a MPModelRequest protocol buffer and fills the
solution encoded as a MPSolutionResponse. The solve is stopped prematurely
if interrupt is non-null at set to true during (or before) solving.
Interruption is only supported if SolverTypeSupportsInterruption() returns
true for the requested solver. Passing a non-null interruption with any
other solver type immediately returns an MPSOLVER_INCOMPATIBLE_OPTIONS
error.</p>

<p>Note(user): This attempts to first use <code>DirectlySolveProto()</code> (if
implemented). Consequently, this most likely does <em>not</em> override any of
the default parameters of the underlying solver. This behavior <em>differs</em>
from <code>MPSolver::Solve()</code> which by default sets the feasibility tolerance
and the gap limit (as of 2020/02/11, to 1e-7 and 0.0001, respectively).</p>
</div>


                            </div>
                            <div id="Solver.ExportModelToProto" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.ExportModelToProto">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ExportModelToProto</span><span class="signature">(self, output_model: &#39;operations_research::MPModelProto *&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ExportModelToProto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_model</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPModelProto *&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Exports model to protocol buffer.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_ExportModelToProto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">output_model</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Exports model to protocol buffer.</p>
</div>


                            </div>
                            <div id="Solver.SetSolverSpecificParametersAsString" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.SetSolverSpecificParametersAsString">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetSolverSpecificParametersAsString</span><span class="signature">(self, parameters: &#39;std::string const &amp;&#39;) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetSolverSpecificParametersAsString</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Advanced usage: pass solver specific parameters in text format.</span>

<span class="sd">        The format is solver-specific and is the same as the corresponding solver</span>
<span class="sd">        configuration file format. Returns true if the operation was successful.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_SetSolverSpecificParametersAsString</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parameters</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Advanced usage: pass solver specific parameters in text format.</p>

<p>The format is solver-specific and is the same as the corresponding solver
configuration file format. Returns true if the operation was successful.</p>
</div>


                            </div>
                            <div id="Solver.FREE" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.FREE">#&nbsp;&nbsp</a>

        <span class="name">FREE</span><span class="default_value"> = 0</span>
    </div>

    

                            </div>
                            <div id="Solver.AT_LOWER_BOUND" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.AT_LOWER_BOUND">#&nbsp;&nbsp</a>

        <span class="name">AT_LOWER_BOUND</span><span class="default_value"> = 1</span>
    </div>

    

                            </div>
                            <div id="Solver.AT_UPPER_BOUND" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.AT_UPPER_BOUND">#&nbsp;&nbsp</a>

        <span class="name">AT_UPPER_BOUND</span><span class="default_value"> = 2</span>
    </div>

    

                            </div>
                            <div id="Solver.FIXED_VALUE" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.FIXED_VALUE">#&nbsp;&nbsp</a>

        <span class="name">FIXED_VALUE</span><span class="default_value"> = 3</span>
    </div>

    

                            </div>
                            <div id="Solver.BASIC" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Solver.BASIC">#&nbsp;&nbsp</a>

        <span class="name">BASIC</span><span class="default_value"> = 4</span>
    </div>

    

                            </div>
                            <div id="Solver.infinity" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.infinity">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">infinity</span><span class="signature">() -&gt; &#39;double&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">infinity</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Infinity.</span>

<span class="sd">        You can use -MPSolver::infinity() for negative infinity.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_infinity</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>Infinity.</p>

<p>You can use -MPSolver::infinity() for negative infinity.</p>
</div>


                            </div>
                            <div id="Solver.EnableOutput" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.EnableOutput">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">EnableOutput</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">EnableOutput</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Enables solver logging.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_EnableOutput</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Enables solver logging.</p>
</div>


                            </div>
                            <div id="Solver.SuppressOutput" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.SuppressOutput">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SuppressOutput</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SuppressOutput</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Suppresses solver logging.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_SuppressOutput</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Suppresses solver logging.</p>
</div>


                            </div>
                            <div id="Solver.iterations" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.iterations">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">iterations</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">iterations</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the number of simplex iterations.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_iterations</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the number of simplex iterations.</p>
</div>


                            </div>
                            <div id="Solver.nodes" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.nodes">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">nodes</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the number of branch-and-bound nodes evaluated during the solve.</span>

<span class="sd">        Only available for discrete problems.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the number of branch-and-bound nodes evaluated during the solve.</p>

<p>Only available for discrete problems.</p>
</div>


                            </div>
                            <div id="Solver.ComputeExactConditionNumber" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.ComputeExactConditionNumber">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ComputeExactConditionNumber</span><span class="signature">(self) -&gt; &#39;double&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ComputeExactConditionNumber</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         Advanced usage: computes the exact condition number of the current scaled</span>
<span class="sd">        basis: L1norm(B) * L1norm(inverse(B)), where B is the scaled basis.</span>

<span class="sd">        This method requires that a basis exists: it should be called after Solve.</span>
<span class="sd">        It is only available for continuous problems. It is implemented for GLPK</span>
<span class="sd">        but not CLP because CLP does not provide the API for doing it.</span>

<span class="sd">        The condition number measures how well the constraint matrix is conditioned</span>
<span class="sd">        and can be used to predict whether numerical issues will arise during the</span>
<span class="sd">        solve: the model is declared infeasible whereas it is feasible (or</span>
<span class="sd">        vice-versa), the solution obtained is not optimal or violates some</span>
<span class="sd">        constraints, the resolution is slow because of repeated singularities.</span>

<span class="sd">        The rule of thumb to interpret the condition number kappa is:</span>
<span class="sd">          - o kappa &lt;= 1e7: virtually no chance of numerical issues</span>
<span class="sd">          - o 1e7 &lt; kappa &lt;= 1e10: small chance of numerical issues</span>
<span class="sd">          - o 1e10 &lt; kappa &lt;= 1e13: medium chance of numerical issues</span>
<span class="sd">          - o kappa &gt; 1e13: high chance of numerical issues</span>

<span class="sd">        The computation of the condition number depends on the quality of the LU</span>
<span class="sd">        decomposition, so it is not very accurate when the matrix is ill</span>
<span class="sd">        conditioned.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_ComputeExactConditionNumber</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Advanced usage: computes the exact condition number of the current scaled
basis: L1norm(B) * L1norm(inverse(B)), where B is the scaled basis.</p>

<p>This method requires that a basis exists: it should be called after Solve.
It is only available for continuous problems. It is implemented for GLPK
but not CLP because CLP does not provide the API for doing it.</p>

<p>The condition number measures how well the constraint matrix is conditioned
and can be used to predict whether numerical issues will arise during the
solve: the model is declared infeasible whereas it is feasible (or
vice-versa), the solution obtained is not optimal or violates some
constraints, the resolution is slow because of repeated singularities.</p>

<h6 id="the-rule-of-thumb-to-interpret-the-condition-number-kappa-is">The rule of thumb to interpret the condition number kappa is</h6>

<blockquote>
  <ul>
  <li>o kappa &lt;= 1e7: virtually no chance of numerical issues</li>
  <li>o 1e7 &lt; kappa &lt;= 1e10: small chance of numerical issues</li>
  <li>o 1e10 &lt; kappa &lt;= 1e13: medium chance of numerical issues</li>
  <li>o kappa &gt; 1e13: high chance of numerical issues</li>
  </ul>
</blockquote>

<p>The computation of the condition number depends on the quality of the LU
decomposition, so it is not very accurate when the matrix is ill
conditioned.</p>
</div>


                            </div>
                            <div id="Solver.NextSolution" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.NextSolution">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">NextSolution</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">NextSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Some solvers (MIP only, not LP) can produce multiple solutions to the</span>
<span class="sd">        problem. Returns true when another solution is available, and updates the</span>
<span class="sd">        MPVariable* objects to make the new solution queryable. Call only after</span>
<span class="sd">        calling solve.</span>

<span class="sd">        The optimality properties of the additional solutions found, and whether or</span>
<span class="sd">        not the solver computes them ahead of time or when NextSolution() is called</span>
<span class="sd">        is solver specific.</span>

<span class="sd">        As of 2020-02-10, only Gurobi and SCIP support NextSolution(), see</span>
<span class="sd">        linear_solver_interfaces_test for an example of how to configure these</span>
<span class="sd">        solvers for multiple solutions. Other solvers return false unconditionally.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_NextSolution</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Some solvers (MIP only, not LP) can produce multiple solutions to the
problem. Returns true when another solution is available, and updates the
MPVariable* objects to make the new solution queryable. Call only after
calling solve.</p>

<p>The optimality properties of the additional solutions found, and whether or
not the solver computes them ahead of time or when NextSolution() is called
is solver specific.</p>

<p>As of 2020-02-10, only Gurobi and SCIP support NextSolution(), see
linear_solver_interfaces_test for an example of how to configure these
solvers for multiple solutions. Other solvers return false unconditionally.</p>
</div>


                            </div>
                            <div id="Solver.set_time_limit" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.set_time_limit">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">set_time_limit</span><span class="signature">(self, time_limit_milliseconds: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">set_time_limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_limit_milliseconds</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_set_time_limit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">time_limit_milliseconds</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.wall_time" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.wall_time">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">wall_time</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">wall_time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_wall_time</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.LoadModelFromProto" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.LoadModelFromProto">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">LoadModelFromProto</span><span class="signature">(
    self,
    input_model: &#39;operations_research::MPModelProto const &amp;&#39;
) -&gt; &#39;std::string&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">LoadModelFromProto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_model</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPModelProto const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_LoadModelFromProto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_model</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.LoadModelFromProtoWithUniqueNamesOrDie" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.LoadModelFromProtoWithUniqueNamesOrDie">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">LoadModelFromProtoWithUniqueNamesOrDie</span><span class="signature">(
    self,
    input_model: &#39;operations_research::MPModelProto const &amp;&#39;
) -&gt; &#39;std::string&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">LoadModelFromProtoWithUniqueNamesOrDie</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_model</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPModelProto const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_LoadModelFromProtoWithUniqueNamesOrDie</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_model</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.LoadSolutionFromProto" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.LoadSolutionFromProto">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">LoadSolutionFromProto</span><span class="signature">(self, *args) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">LoadSolutionFromProto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_LoadSolutionFromProto</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.ExportModelAsLpFormat" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.ExportModelAsLpFormat">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ExportModelAsLpFormat</span><span class="signature">(self, obfuscated: bool) -&gt; &#39;std::string&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ExportModelAsLpFormat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obfuscated</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_ExportModelAsLpFormat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obfuscated</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.ExportModelAsMpsFormat" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.ExportModelAsMpsFormat">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ExportModelAsMpsFormat</span><span class="signature">(self, fixed_format: bool, obfuscated: bool) -&gt; &#39;std::string&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ExportModelAsMpsFormat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fixed_format</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">,</span> <span class="n">obfuscated</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_ExportModelAsMpsFormat</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fixed_format</span><span class="p">,</span> <span class="n">obfuscated</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.SetHint" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.SetHint">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetHint</span><span class="signature">(
    self,
    variables: &#39;std::vector&lt; operations_research::MPVariable * &gt; const &amp;&#39;,
    values: &#39;std::vector&lt; double &gt; const &amp;&#39;
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetHint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; operations_research::MPVariable * &gt; const &amp;&quot;</span><span class="p">,</span> <span class="n">values</span><span class="p">:</span> <span class="s2">&quot;std::vector&lt; double &gt; const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Set a hint for solution.</span>

<span class="sd">        If a feasible or almost-feasible solution to the problem is already known,</span>
<span class="sd">        it may be helpful to pass it to the solver so that it can be used. A</span>
<span class="sd">        solver that supports this feature will try to use this information to</span>
<span class="sd">        create its initial feasible solution.</span>

<span class="sd">        Note that it may not always be faster to give a hint like this to the</span>
<span class="sd">        solver. There is also no guarantee that the solver will use this hint or</span>
<span class="sd">        try to return a solution &quot;close&quot; to this assignment in case of multiple</span>
<span class="sd">        optimal solutions.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_SetHint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">variables</span><span class="p">,</span> <span class="n">values</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Set a hint for solution.</p>

<p>If a feasible or almost-feasible solution to the problem is already known,
it may be helpful to pass it to the solver so that it can be used. A
solver that supports this feature will try to use this information to
create its initial feasible solution.</p>

<p>Note that it may not always be faster to give a hint like this to the
solver. There is also no guarantee that the solver will use this hint or
try to return a solution "close" to this assignment in case of multiple
optimal solutions.</p>
</div>


                            </div>
                            <div id="Solver.SetNumThreads" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.SetNumThreads">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetNumThreads</span><span class="signature">(self, num_theads: int) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetNumThreads</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_theads</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Sets the number of threads to be used by the solver.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_SetNumThreads</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">num_theads</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Sets the number of threads to be used by the solver.</p>
</div>


                            </div>
                            <div id="Solver.Add" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Add">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Add</span><span class="signature">(self, constraint, name=&#39;&#39;)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Add</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">constraint</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">):</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">constraint</span><span class="p">,</span> <span class="nb">bool</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">constraint</span><span class="p">:</span>
          <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">RowConstraint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
          <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">RowConstraint</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">constraint</span><span class="o">.</span><span class="n">Extract</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.Sum" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Sum">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Sum</span><span class="signature">(self, expr_array)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Sum</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr_array</span><span class="p">):</span>
      <span class="n">result</span> <span class="o">=</span> <span class="n">SumArray</span><span class="p">(</span><span class="n">expr_array</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">result</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.RowConstraint" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.RowConstraint">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">RowConstraint</span><span class="signature">(self, *args)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">RowConstraint</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">):</span>
      <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">Constraint</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.Minimize" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Minimize">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Minimize</span><span class="signature">(self, expr)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Minimize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
      <span class="n">objective</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Objective</span><span class="p">()</span>
      <span class="n">objective</span><span class="o">.</span><span class="n">Clear</span><span class="p">()</span>
      <span class="n">objective</span><span class="o">.</span><span class="n">SetMinimization</span><span class="p">()</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span>
          <span class="n">objective</span><span class="o">.</span><span class="n">SetOffset</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
          <span class="n">coeffs</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">GetCoeffs</span><span class="p">()</span>
          <span class="n">objective</span><span class="o">.</span><span class="n">SetOffset</span><span class="p">(</span><span class="n">coeffs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">OFFSET_KEY</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
          <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">coeffs</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">objective</span><span class="o">.</span><span class="n">SetCoefficient</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.Maximize" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Maximize">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Maximize</span><span class="signature">(self, expr)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Maximize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">expr</span><span class="p">):</span>
      <span class="n">objective</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Objective</span><span class="p">()</span>
      <span class="n">objective</span><span class="o">.</span><span class="n">Clear</span><span class="p">()</span>
      <span class="n">objective</span><span class="o">.</span><span class="n">SetMaximization</span><span class="p">()</span>
      <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">expr</span><span class="p">,</span> <span class="n">numbers</span><span class="o">.</span><span class="n">Number</span><span class="p">):</span>
          <span class="n">objective</span><span class="o">.</span><span class="n">SetOffset</span><span class="p">(</span><span class="n">expr</span><span class="p">)</span>
      <span class="k">else</span><span class="p">:</span>
          <span class="n">coeffs</span> <span class="o">=</span> <span class="n">expr</span><span class="o">.</span><span class="n">GetCoeffs</span><span class="p">()</span>
          <span class="n">objective</span><span class="o">.</span><span class="n">SetOffset</span><span class="p">(</span><span class="n">coeffs</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">OFFSET_KEY</span><span class="p">,</span> <span class="mf">0.0</span><span class="p">))</span>
          <span class="k">for</span> <span class="n">v</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="ow">in</span> <span class="nb">list</span><span class="p">(</span><span class="n">coeffs</span><span class="o">.</span><span class="n">items</span><span class="p">()):</span>
            <span class="n">objective</span><span class="o">.</span><span class="n">SetCoefficient</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="n">c</span><span class="p">))</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.Infinity" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Infinity">#&nbsp;&nbsp</a>

                <div class="decorator">@staticmethod</div>

            <span class="def">def</span>
            <span class="name">Infinity</span><span class="signature">() -&gt; &#39;double&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">Infinity</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_Infinity</span><span class="p">()</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.SetTimeLimit" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.SetTimeLimit">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetTimeLimit</span><span class="signature">(self, x: &#39;int64_t&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetTimeLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_SetTimeLimit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.WallTime" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.WallTime">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">WallTime</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">WallTime</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_WallTime</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Solver.Iterations" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Solver.Iterations">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Iterations</span><span class="signature">(self) -&gt; &#39;int64_t&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Iterations</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int64_t&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_Iterations</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                </section>
                <section id="Solver_CreateSolver">
                            <div class="attr function"><a class="headerlink" href="#Solver_CreateSolver">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Solver_CreateSolver</span><span class="signature">(
    solver_id: &#39;std::string const &amp;&#39;
) -&gt; &#39;operations_research::MPSolver *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Solver_CreateSolver</span><span class="p">(</span><span class="n">solver_id</span><span class="p">:</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPSolver *&quot;</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Recommended factory method to create a MPSolver instance, especially in</span>
<span class="sd">    non C++ languages.</span>

<span class="sd">    It returns a newly created solver instance if successful, or a nullptr</span>
<span class="sd">    otherwise. This can occur if the relevant interface is not linked in, or if</span>
<span class="sd">    a needed license is not accessible for commercial solvers.</span>

<span class="sd">    Ownership of the solver is passed on to the caller of this method.</span>
<span class="sd">    It will accept both string names of the OptimizationProblemType enum, as</span>
<span class="sd">    well as a short version (i.e. &quot;SCIP_MIXED_INTEGER_PROGRAMMING&quot; or &quot;SCIP&quot;).</span>

<span class="sd">    solver_id is case insensitive, and the following names are supported:</span>
<span class="sd">      - CLP_LINEAR_PROGRAMMING or CLP</span>
<span class="sd">      - CBC_MIXED_INTEGER_PROGRAMMING or CBC</span>
<span class="sd">      - GLOP_LINEAR_PROGRAMMING or GLOP</span>
<span class="sd">      - BOP_INTEGER_PROGRAMMING or BOP</span>
<span class="sd">      - SAT_INTEGER_PROGRAMMING or SAT or CP_SAT</span>
<span class="sd">      - SCIP_MIXED_INTEGER_PROGRAMMING or SCIP</span>
<span class="sd">      - GUROBI_LINEAR_PROGRAMMING or GUROBI_LP</span>
<span class="sd">      - GUROBI_MIXED_INTEGER_PROGRAMMING or GUROBI or GUROBI_MIP</span>
<span class="sd">      - CPLEX_LINEAR_PROGRAMMING or CPLEX_LP</span>
<span class="sd">      - CPLEX_MIXED_INTEGER_PROGRAMMING or CPLEX or CPLEX_MIP</span>
<span class="sd">      - XPRESS_LINEAR_PROGRAMMING or XPRESS_LP</span>
<span class="sd">      - XPRESS_MIXED_INTEGER_PROGRAMMING or XPRESS or XPRESS_MIP</span>
<span class="sd">      - GLPK_LINEAR_PROGRAMMING or GLPK_LP</span>
<span class="sd">      - GLPK_MIXED_INTEGER_PROGRAMMING or GLPK or GLPK_MIP</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_CreateSolver</span><span class="p">(</span><span class="n">solver_id</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Recommended factory method to create a MPSolver instance, especially in
non C++ languages.</p>

<p>It returns a newly created solver instance if successful, or a nullptr
otherwise. This can occur if the relevant interface is not linked in, or if
a needed license is not accessible for commercial solvers.</p>

<p>Ownership of the solver is passed on to the caller of this method.
It will accept both string names of the OptimizationProblemType enum, as
well as a short version (i.e. "SCIP_MIXED_INTEGER_PROGRAMMING" or "SCIP").</p>

<p>solver_id is case insensitive, and the following names are supported:</p>

<ul>
<li>CLP_LINEAR_PROGRAMMING or CLP</li>
<li>CBC_MIXED_INTEGER_PROGRAMMING or CBC</li>
<li>GLOP_LINEAR_PROGRAMMING or GLOP</li>
<li>BOP_INTEGER_PROGRAMMING or BOP</li>
<li>SAT_INTEGER_PROGRAMMING or SAT or CP_SAT</li>
<li>SCIP_MIXED_INTEGER_PROGRAMMING or SCIP</li>
<li>GUROBI_LINEAR_PROGRAMMING or GUROBI_LP</li>
<li>GUROBI_MIXED_INTEGER_PROGRAMMING or GUROBI or GUROBI_MIP</li>
<li>CPLEX_LINEAR_PROGRAMMING or CPLEX_LP</li>
<li>CPLEX_MIXED_INTEGER_PROGRAMMING or CPLEX or CPLEX_MIP</li>
<li>XPRESS_LINEAR_PROGRAMMING or XPRESS_LP</li>
<li>XPRESS_MIXED_INTEGER_PROGRAMMING or XPRESS or XPRESS_MIP</li>
<li>GLPK_LINEAR_PROGRAMMING or GLPK_LP</li>
<li>GLPK_MIXED_INTEGER_PROGRAMMING or GLPK or GLPK_MIP</li>
</ul>
</div>


                </section>
                <section id="Solver_SupportsProblemType">
                            <div class="attr function"><a class="headerlink" href="#Solver_SupportsProblemType">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Solver_SupportsProblemType</span><span class="signature">(
    problem_type: &#39;operations_research::MPSolver::OptimizationProblemType&#39;
) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Solver_SupportsProblemType</span><span class="p">(</span><span class="n">problem_type</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPSolver::OptimizationProblemType&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Whether the given problem type is supported (this will depend on the</span>
<span class="sd">    targets that you linked).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_SupportsProblemType</span><span class="p">(</span><span class="n">problem_type</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Whether the given problem type is supported (this will depend on the
targets that you linked).</p>
</div>


                </section>
                <section id="Solver_SolveWithProto">
                            <div class="attr function"><a class="headerlink" href="#Solver_SolveWithProto">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Solver_SolveWithProto</span><span class="signature">(
    model_request: &#39;operations_research::MPModelRequest const &amp;&#39;,
    response: &#39;operations_research::MPSolutionResponse *&#39;,
    interrupt: &#39;std::atomic&lt; bool &gt; *&#39; = None
) -&gt; &#39;operations_research::MPSolutionResponse *&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Solver_SolveWithProto</span><span class="p">(</span><span class="n">model_request</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPModelRequest const &amp;&quot;</span><span class="p">,</span> <span class="n">response</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPSolutionResponse *&quot;</span><span class="p">,</span> <span class="n">interrupt</span><span class="p">:</span> <span class="s2">&quot;std::atomic&lt; bool &gt; *&quot;</span><span class="o">=</span><span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPSolutionResponse *&quot;</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Solves the model encoded by a MPModelRequest protocol buffer and fills the</span>
<span class="sd">    solution encoded as a MPSolutionResponse. The solve is stopped prematurely</span>
<span class="sd">    if interrupt is non-null at set to true during (or before) solving.</span>
<span class="sd">    Interruption is only supported if SolverTypeSupportsInterruption() returns</span>
<span class="sd">    true for the requested solver. Passing a non-null interruption with any</span>
<span class="sd">    other solver type immediately returns an MPSOLVER_INCOMPATIBLE_OPTIONS</span>
<span class="sd">    error.</span>

<span class="sd">    Note(user): This attempts to first use `DirectlySolveProto()` (if</span>
<span class="sd">    implemented). Consequently, this most likely does *not* override any of</span>
<span class="sd">    the default parameters of the underlying solver. This behavior *differs*</span>
<span class="sd">    from `MPSolver::Solve()` which by default sets the feasibility tolerance</span>
<span class="sd">    and the gap limit (as of 2020/02/11, to 1e-7 and 0.0001, respectively).</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_SolveWithProto</span><span class="p">(</span><span class="n">model_request</span><span class="p">,</span> <span class="n">response</span><span class="p">,</span> <span class="n">interrupt</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Solves the model encoded by a MPModelRequest protocol buffer and fills the
solution encoded as a MPSolutionResponse. The solve is stopped prematurely
if interrupt is non-null at set to true during (or before) solving.
Interruption is only supported if SolverTypeSupportsInterruption() returns
true for the requested solver. Passing a non-null interruption with any
other solver type immediately returns an MPSOLVER_INCOMPATIBLE_OPTIONS
error.</p>

<p>Note(user): This attempts to first use <code>DirectlySolveProto()</code> (if
implemented). Consequently, this most likely does <em>not</em> override any of
the default parameters of the underlying solver. This behavior <em>differs</em>
from <code>MPSolver::Solve()</code> which by default sets the feasibility tolerance
and the gap limit (as of 2020/02/11, to 1e-7 and 0.0001, respectively).</p>
</div>


                </section>
                <section id="Solver_infinity">
                            <div class="attr function"><a class="headerlink" href="#Solver_infinity">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Solver_infinity</span><span class="signature">() -&gt; &#39;double&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Solver_infinity</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Infinity.</span>

<span class="sd">    You can use -MPSolver::infinity() for negative infinity.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_infinity</span><span class="p">()</span>
</pre></div>

        </details>

            <div class="docstring"><p>Infinity.</p>

<p>You can use -MPSolver::infinity() for negative infinity.</p>
</div>


                </section>
                <section id="Solver_Infinity">
                            <div class="attr function"><a class="headerlink" href="#Solver_Infinity">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Solver_Infinity</span><span class="signature">() -&gt; &#39;double&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">Solver_Infinity</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Solver_Infinity</span><span class="p">()</span>
</pre></div>

        </details>

    

                </section>
                <section id="Objective">
                                <div class="attr class">
        <a class="headerlink" href="#Objective">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">Objective</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Objective</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; A class to express a linear objective.&quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">Clear</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         Clears the offset, all variables and coefficients, and the optimization</span>
<span class="sd">        direction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Objective_Clear</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;Variable&quot;</span><span class="p">,</span> <span class="n">coeff</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the coefficient of the variable in the objective.</span>

<span class="sd">        If the variable does not belong to the solver, the function just returns,</span>
<span class="sd">        or crashes in non-opt mode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Objective_SetCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">coeff</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;Variable&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         Gets the coefficient of a given variable in the objective</span>

<span class="sd">        It returns 0 if the variable does not appear in the objective).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Objective_GetCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetOffset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Sets the constant term in the objective.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Objective_SetOffset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">offset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Gets the constant term in the objective.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Objective_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetOptimizationDirection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maximize</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Sets the optimization direction (maximize: true or minimize: false).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Objective_SetOptimizationDirection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maximize</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetMinimization</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Sets the optimization direction to minimize.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Objective_SetMinimization</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetMaximization</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Sets the optimization direction to maximize.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Objective_SetMaximization</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">maximization</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Is the optimization direction set to maximize?&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Objective_maximization</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">minimization</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Is the optimization direction set to minimize?&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Objective_minimization</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the objective value of the best solution found so far.</span>

<span class="sd">        It is the optimal objective value if the problem has been solved to</span>
<span class="sd">        optimality.</span>

<span class="sd">        Note: the objective value may be slightly different than what you could</span>
<span class="sd">        compute yourself using ``MPVariable::solution_value();`` please use the</span>
<span class="sd">        --verify_solution flag to gain confidence about the numerical stability of</span>
<span class="sd">        your solution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Objective_Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">BestBound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the best objective bound.</span>

<span class="sd">        In case of minimization, it is a lower bound on the objective value of the</span>
<span class="sd">        optimal integer solution. Only available for discrete problems.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Objective_BestBound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Offset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Objective_Offset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">delete_Objective</span>
</pre></div>

        </details>

            <div class="docstring"><p>A class to express a linear objective.</p>
</div>


                            <div id="Objective.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Objective.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">Objective</span><span class="signature">(*args, **kwargs)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Objective.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Objective.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="Objective.Clear" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Objective.Clear">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Clear</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Clear</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         Clears the offset, all variables and coefficients, and the optimization</span>
<span class="sd">        direction.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Objective_Clear</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Clears the offset, all variables and coefficients, and the optimization
direction.</p>
</div>


                            </div>
                            <div id="Objective.SetCoefficient" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Objective.SetCoefficient">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetCoefficient</span><span class="signature">(self, var: <a href="#Variable">pywraplp.Variable</a>, coeff: &#39;double&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;Variable&quot;</span><span class="p">,</span> <span class="n">coeff</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the coefficient of the variable in the objective.</span>

<span class="sd">        If the variable does not belong to the solver, the function just returns,</span>
<span class="sd">        or crashes in non-opt mode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Objective_SetCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">coeff</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Sets the coefficient of the variable in the objective.</p>

<p>If the variable does not belong to the solver, the function just returns,
or crashes in non-opt mode.</p>
</div>


                            </div>
                            <div id="Objective.GetCoefficient" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Objective.GetCoefficient">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetCoefficient</span><span class="signature">(self, var: <a href="#Variable">pywraplp.Variable</a>) -&gt; &#39;double&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;Variable&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">         Gets the coefficient of a given variable in the objective</span>

<span class="sd">        It returns 0 if the variable does not appear in the objective).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Objective_GetCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Gets the coefficient of a given variable in the objective</p>

<p>It returns 0 if the variable does not appear in the objective).</p>
</div>


                            </div>
                            <div id="Objective.SetOffset" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Objective.SetOffset">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetOffset</span><span class="signature">(self, value: &#39;double&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetOffset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Sets the constant term in the objective.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Objective_SetOffset</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Sets the constant term in the objective.</p>
</div>


                            </div>
                            <div id="Objective.offset" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Objective.offset">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">offset</span><span class="signature">(self) -&gt; &#39;double&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">offset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Gets the constant term in the objective.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Objective_offset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Gets the constant term in the objective.</p>
</div>


                            </div>
                            <div id="Objective.SetOptimizationDirection" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Objective.SetOptimizationDirection">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetOptimizationDirection</span><span class="signature">(self, maximize: bool) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetOptimizationDirection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maximize</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Sets the optimization direction (maximize: true or minimize: false).&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Objective_SetOptimizationDirection</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">maximize</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Sets the optimization direction (maximize: true or minimize: false).</p>
</div>


                            </div>
                            <div id="Objective.SetMinimization" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Objective.SetMinimization">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetMinimization</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetMinimization</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Sets the optimization direction to minimize.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Objective_SetMinimization</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Sets the optimization direction to minimize.</p>
</div>


                            </div>
                            <div id="Objective.SetMaximization" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Objective.SetMaximization">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetMaximization</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetMaximization</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Sets the optimization direction to maximize.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Objective_SetMaximization</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Sets the optimization direction to maximize.</p>
</div>


                            </div>
                            <div id="Objective.maximization" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Objective.maximization">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">maximization</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">maximization</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Is the optimization direction set to maximize?&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Objective_maximization</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Is the optimization direction set to maximize?</p>
</div>


                            </div>
                            <div id="Objective.minimization" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Objective.minimization">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">minimization</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">minimization</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Is the optimization direction set to minimize?&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Objective_minimization</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Is the optimization direction set to minimize?</p>
</div>


                            </div>
                            <div id="Objective.Value" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Objective.Value">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Value</span><span class="signature">(self) -&gt; &#39;double&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the objective value of the best solution found so far.</span>

<span class="sd">        It is the optimal objective value if the problem has been solved to</span>
<span class="sd">        optimality.</span>

<span class="sd">        Note: the objective value may be slightly different than what you could</span>
<span class="sd">        compute yourself using ``MPVariable::solution_value();`` please use the</span>
<span class="sd">        --verify_solution flag to gain confidence about the numerical stability of</span>
<span class="sd">        your solution.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Objective_Value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the objective value of the best solution found so far.</p>

<p>It is the optimal objective value if the problem has been solved to
optimality.</p>

<p>Note: the objective value may be slightly different than what you could
compute yourself using <code>MPVariable::solution_value();</code> please use the
--verify_solution flag to gain confidence about the numerical stability of
your solution.</p>
</div>


                            </div>
                            <div id="Objective.BestBound" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Objective.BestBound">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">BestBound</span><span class="signature">(self) -&gt; &#39;double&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">BestBound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the best objective bound.</span>

<span class="sd">        In case of minimization, it is a lower bound on the objective value of the</span>
<span class="sd">        optimal integer solution. Only available for discrete problems.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Objective_BestBound</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the best objective bound.</p>

<p>In case of minimization, it is a lower bound on the objective value of the
optimal integer solution. Only available for discrete problems.</p>
</div>


                            </div>
                            <div id="Objective.Offset" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Objective.Offset">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Offset</span><span class="signature">(self) -&gt; &#39;double&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Offset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Objective_Offset</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                </section>
                <section id="Variable">
                                <div class="attr class">
        <a class="headerlink" href="#Variable">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">Variable</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Variable</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; The class for variables of a Mathematical Programming (MP) model.&quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the name of the variable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetInteger</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">integer</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Sets the integrality requirement of the variable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_SetInteger</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">integer</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">integer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the integrality requirement of the variable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_integer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">solution_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the value of the variable in the current solution.</span>

<span class="sd">        If the variable is integer, then the value will always be an integer (the</span>
<span class="sd">        underlying solver handles floating-point values only, but this function</span>
<span class="sd">        automatically rounds it to the nearest integer; see: man 3 round).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_solution_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the index of the variable in the MPSolver::variables_.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">lb</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the lower bound.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_lb</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ub</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the upper bound.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_ub</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetBounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lb</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">ub</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Sets both the lower and upper bounds.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_SetBounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">reduced_cost</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Advanced usage: returns the reduced cost of the variable in the current</span>
<span class="sd">        solution (only available for continuous problems).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_reduced_cost</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">basis_status</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPSolver::BasisStatus&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Advanced usage: returns the basis status of the variable in the current</span>
<span class="sd">        solution (only available for continuous problems).</span>

<span class="sd">        See also: MPSolver::BasisStatus.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_basis_status</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">branching_priority</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Advanced usage: Certain MIP solvers (e.g. Gurobi or SCIP) allow you to set</span>
<span class="sd">        a per-variable priority for determining which variable to branch on.</span>

<span class="sd">        A value of 0 is treated as default, and is equivalent to not setting the</span>
<span class="sd">        branching priority. The solver looks first to branch on fractional</span>
<span class="sd">        variables in higher priority levels. As of 2019-05, only Gurobi and SCIP</span>
<span class="sd">        support setting branching priority; all other solvers will simply ignore</span>
<span class="sd">        this annotation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_branching_priority</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetBranchingPriority</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">priority</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_SetBranchingPriority</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">priority</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable___str__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable___repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">):</span>
      <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">VariableExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">name</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">SolutionValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_SolutionValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Integer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_Integer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Lb</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_Lb</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Ub</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_Ub</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetLb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_SetLb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetUb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_SetUb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ReducedCost</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_ReducedCost</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">delete_Variable</span>
</pre></div>

        </details>

            <div class="docstring"><p>The class for variables of a Mathematical Programming (MP) model.</p>
</div>


                            <div id="Variable.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Variable.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">Variable</span><span class="signature">(*args, **kwargs)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Variable.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Variable.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="Variable.name" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Variable.name">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">name</span><span class="signature">(self) -&gt; &#39;std::string const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the name of the variable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the name of the variable.</p>
</div>


                            </div>
                            <div id="Variable.SetInteger" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Variable.SetInteger">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetInteger</span><span class="signature">(self, integer: bool) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetInteger</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">integer</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Sets the integrality requirement of the variable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_SetInteger</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">integer</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Sets the integrality requirement of the variable.</p>
</div>


                            </div>
                            <div id="Variable.integer" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Variable.integer">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">integer</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">integer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the integrality requirement of the variable.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_integer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the integrality requirement of the variable.</p>
</div>


                            </div>
                            <div id="Variable.solution_value" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Variable.solution_value">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">solution_value</span><span class="signature">(self) -&gt; &#39;double&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">solution_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the value of the variable in the current solution.</span>

<span class="sd">        If the variable is integer, then the value will always be an integer (the</span>
<span class="sd">        underlying solver handles floating-point values only, but this function</span>
<span class="sd">        automatically rounds it to the nearest integer; see: man 3 round).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_solution_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the value of the variable in the current solution.</p>

<p>If the variable is integer, then the value will always be an integer (the
underlying solver handles floating-point values only, but this function
automatically rounds it to the nearest integer; see: man 3 round).</p>
</div>


                            </div>
                            <div id="Variable.index" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Variable.index">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">index</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the index of the variable in the MPSolver::variables_.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the index of the variable in the MPSolver::variables_.</p>
</div>


                            </div>
                            <div id="Variable.lb" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Variable.lb">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">lb</span><span class="signature">(self) -&gt; &#39;double&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">lb</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the lower bound.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_lb</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the lower bound.</p>
</div>


                            </div>
                            <div id="Variable.ub" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Variable.ub">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ub</span><span class="signature">(self) -&gt; &#39;double&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ub</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the upper bound.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_ub</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the upper bound.</p>
</div>


                            </div>
                            <div id="Variable.SetBounds" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Variable.SetBounds">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetBounds</span><span class="signature">(self, lb: &#39;double&#39;, ub: &#39;double&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetBounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lb</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">ub</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Sets both the lower and upper bounds.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_SetBounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Sets both the lower and upper bounds.</p>
</div>


                            </div>
                            <div id="Variable.reduced_cost" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Variable.reduced_cost">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">reduced_cost</span><span class="signature">(self) -&gt; &#39;double&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">reduced_cost</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Advanced usage: returns the reduced cost of the variable in the current</span>
<span class="sd">        solution (only available for continuous problems).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_reduced_cost</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Advanced usage: returns the reduced cost of the variable in the current
solution (only available for continuous problems).</p>
</div>


                            </div>
                            <div id="Variable.basis_status" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Variable.basis_status">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">basis_status</span><span class="signature">(self) -&gt; &#39;operations_research::MPSolver::BasisStatus&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">basis_status</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPSolver::BasisStatus&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Advanced usage: returns the basis status of the variable in the current</span>
<span class="sd">        solution (only available for continuous problems).</span>

<span class="sd">        See also: MPSolver::BasisStatus.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_basis_status</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Advanced usage: returns the basis status of the variable in the current
solution (only available for continuous problems).</p>

<p>See also: MPSolver::BasisStatus.</p>
</div>


                            </div>
                            <div id="Variable.branching_priority" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Variable.branching_priority">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">branching_priority</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">branching_priority</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Advanced usage: Certain MIP solvers (e.g. Gurobi or SCIP) allow you to set</span>
<span class="sd">        a per-variable priority for determining which variable to branch on.</span>

<span class="sd">        A value of 0 is treated as default, and is equivalent to not setting the</span>
<span class="sd">        branching priority. The solver looks first to branch on fractional</span>
<span class="sd">        variables in higher priority levels. As of 2019-05, only Gurobi and SCIP</span>
<span class="sd">        support setting branching priority; all other solvers will simply ignore</span>
<span class="sd">        this annotation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_branching_priority</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Advanced usage: Certain MIP solvers (e.g. Gurobi or SCIP) allow you to set
a per-variable priority for determining which variable to branch on.</p>

<p>A value of 0 is treated as default, and is equivalent to not setting the
branching priority. The solver looks first to branch on fractional
variables in higher priority levels. As of 2019-05, only Gurobi and SCIP
support setting branching priority; all other solvers will simply ignore
this annotation.</p>
</div>


                            </div>
                            <div id="Variable.SetBranchingPriority" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Variable.SetBranchingPriority">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetBranchingPriority</span><span class="signature">(self, priority: int) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetBranchingPriority</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">priority</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_SetBranchingPriority</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">priority</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Variable.SolutionValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Variable.SolutionValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SolutionValue</span><span class="signature">(self) -&gt; &#39;double&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SolutionValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_SolutionValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Variable.Integer" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Variable.Integer">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Integer</span><span class="signature">(self) -&gt; bool</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Integer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;bool&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_Integer</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Variable.Lb" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Variable.Lb">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Lb</span><span class="signature">(self) -&gt; &#39;double&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Lb</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_Lb</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Variable.Ub" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Variable.Ub">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Ub</span><span class="signature">(self) -&gt; &#39;double&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Ub</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_Ub</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Variable.SetLb" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Variable.SetLb">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetLb</span><span class="signature">(self, x: &#39;double&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetLb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_SetLb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Variable.SetUb" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Variable.SetUb">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetUb</span><span class="signature">(self, x: &#39;double&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetUb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_SetUb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Variable.ReducedCost" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Variable.ReducedCost">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ReducedCost</span><span class="signature">(self) -&gt; &#39;double&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ReducedCost</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Variable_ReducedCost</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                </section>
                <section id="Constraint">
                                <div class="attr class">
        <a class="headerlink" href="#Constraint">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">Constraint</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">Constraint</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The class for constraints of a Mathematical Programming (MP) model.</span>

<span class="sd">    A constraint is represented as a linear equation or inequality.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the name of the constraint.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Clear</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Clears all variables and coefficients. Does not clear the bounds.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_Clear</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;Variable&quot;</span><span class="p">,</span> <span class="n">coeff</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the coefficient of the variable on the constraint.</span>

<span class="sd">        If the variable does not belong to the solver, the function just returns,</span>
<span class="sd">        or crashes in non-opt mode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_SetCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">coeff</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;Variable&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the coefficient of a given variable on the constraint (which is 0 if</span>
<span class="sd">        the variable does not appear in the constraint).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_GetCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">lb</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the lower bound.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_lb</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">ub</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the upper bound.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_ub</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetBounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lb</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">ub</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Sets both the lower and upper bounds.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_SetBounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">set_is_lazy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">laziness</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Advanced usage: sets the constraint &quot;laziness&quot;.</span>

<span class="sd">        **This is only supported for SCIP and has no effect on other</span>
<span class="sd">        solvers.**</span>

<span class="sd">        When **laziness** is true, the constraint is only considered by the Linear</span>
<span class="sd">        Programming solver if its current solution violates the constraint. In this</span>
<span class="sd">        case, the constraint is definitively added to the problem. This may be</span>
<span class="sd">        useful in some MIP problems, and may have a dramatic impact on performance.</span>

<span class="sd">        For more info see: http://tinyurl.com/lazy-constraints.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_set_is_lazy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">laziness</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the index of the constraint in the MPSolver::constraints_.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">dual_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Advanced usage: returns the dual value of the constraint in the current</span>
<span class="sd">        solution (only available for continuous problems).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_dual_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">basis_status</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPSolver::BasisStatus&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Advanced usage: returns the basis status of the constraint.</span>

<span class="sd">        It is only available for continuous problems).</span>

<span class="sd">        Note that if a constraint &quot;linear_expression in [lb, ub]&quot; is transformed</span>
<span class="sd">        into &quot;linear_expression + slack = 0&quot; with slack in [-ub, -lb], then this</span>
<span class="sd">        status is the same as the status of the slack variable with AT_UPPER_BOUND</span>
<span class="sd">        and AT_LOWER_BOUND swapped.</span>

<span class="sd">        See also: MPSolver::BasisStatus.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_basis_status</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Lb</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_Lb</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">Ub</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_Ub</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetLb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_SetLb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetUb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_SetUb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">DualValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_DualValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">delete_Constraint</span>
</pre></div>

        </details>

            <div class="docstring"><p>The class for constraints of a Mathematical Programming (MP) model.</p>

<p>A constraint is represented as a linear equation or inequality.</p>
</div>


                            <div id="Constraint.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Constraint.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">Constraint</span><span class="signature">(*args, **kwargs)</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s2">&quot;No constructor defined&quot;</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Constraint.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#Constraint.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="Constraint.name" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Constraint.name">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">name</span><span class="signature">(self) -&gt; &#39;std::string const &amp;&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string const &amp;&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the name of the constraint.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the name of the constraint.</p>
</div>


                            </div>
                            <div id="Constraint.Clear" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Constraint.Clear">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Clear</span><span class="signature">(self) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Clear</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Clears all variables and coefficients. Does not clear the bounds.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_Clear</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Clears all variables and coefficients. Does not clear the bounds.</p>
</div>


                            </div>
                            <div id="Constraint.SetCoefficient" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Constraint.SetCoefficient">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetCoefficient</span><span class="signature">(self, var: <a href="#Variable">pywraplp.Variable</a>, coeff: &#39;double&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;Variable&quot;</span><span class="p">,</span> <span class="n">coeff</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Sets the coefficient of the variable on the constraint.</span>

<span class="sd">        If the variable does not belong to the solver, the function just returns,</span>
<span class="sd">        or crashes in non-opt mode.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_SetCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">,</span> <span class="n">coeff</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Sets the coefficient of the variable on the constraint.</p>

<p>If the variable does not belong to the solver, the function just returns,
or crashes in non-opt mode.</p>
</div>


                            </div>
                            <div id="Constraint.GetCoefficient" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Constraint.GetCoefficient">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetCoefficient</span><span class="signature">(self, var: <a href="#Variable">pywraplp.Variable</a>) -&gt; &#39;double&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">:</span> <span class="s2">&quot;Variable&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets the coefficient of a given variable on the constraint (which is 0 if</span>
<span class="sd">        the variable does not appear in the constraint).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_GetCoefficient</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">var</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Gets the coefficient of a given variable on the constraint (which is 0 if
the variable does not appear in the constraint).</p>
</div>


                            </div>
                            <div id="Constraint.lb" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Constraint.lb">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">lb</span><span class="signature">(self) -&gt; &#39;double&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">lb</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the lower bound.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_lb</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the lower bound.</p>
</div>


                            </div>
                            <div id="Constraint.ub" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Constraint.ub">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ub</span><span class="signature">(self) -&gt; &#39;double&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">ub</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the upper bound.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_ub</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the upper bound.</p>
</div>


                            </div>
                            <div id="Constraint.SetBounds" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Constraint.SetBounds">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetBounds</span><span class="signature">(self, lb: &#39;double&#39;, ub: &#39;double&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetBounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lb</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">,</span> <span class="n">ub</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Sets both the lower and upper bounds.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_SetBounds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lb</span><span class="p">,</span> <span class="n">ub</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Sets both the lower and upper bounds.</p>
</div>


                            </div>
                            <div id="Constraint.set_is_lazy" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Constraint.set_is_lazy">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">set_is_lazy</span><span class="signature">(self, laziness: bool) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">set_is_lazy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">laziness</span><span class="p">:</span> <span class="s2">&quot;bool&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Advanced usage: sets the constraint &quot;laziness&quot;.</span>

<span class="sd">        **This is only supported for SCIP and has no effect on other</span>
<span class="sd">        solvers.**</span>

<span class="sd">        When **laziness** is true, the constraint is only considered by the Linear</span>
<span class="sd">        Programming solver if its current solution violates the constraint. In this</span>
<span class="sd">        case, the constraint is definitively added to the problem. This may be</span>
<span class="sd">        useful in some MIP problems, and may have a dramatic impact on performance.</span>

<span class="sd">        For more info see: http://tinyurl.com/lazy-constraints.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_set_is_lazy</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">laziness</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Advanced usage: sets the constraint "laziness".</p>

<p><strong>This is only supported for SCIP and has no effect on other
solvers.</strong></p>

<p>When <strong>laziness</strong> is true, the constraint is only considered by the Linear
Programming solver if its current solution violates the constraint. In this
case, the constraint is definitively added to the problem. This may be
useful in some MIP problems, and may have a dramatic impact on performance.</p>

<p>For more info see: http://tinyurl.com/lazy-constraints.</p>
</div>


                            </div>
                            <div id="Constraint.index" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Constraint.index">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">index</span><span class="signature">(self) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the index of the constraint in the MPSolver::constraints_.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_index</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the index of the constraint in the MPSolver::constraints_.</p>
</div>


                            </div>
                            <div id="Constraint.dual_value" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Constraint.dual_value">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">dual_value</span><span class="signature">(self) -&gt; &#39;double&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">dual_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Advanced usage: returns the dual value of the constraint in the current</span>
<span class="sd">        solution (only available for continuous problems).</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_dual_value</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Advanced usage: returns the dual value of the constraint in the current
solution (only available for continuous problems).</p>
</div>


                            </div>
                            <div id="Constraint.basis_status" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Constraint.basis_status">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">basis_status</span><span class="signature">(self) -&gt; &#39;operations_research::MPSolver::BasisStatus&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">basis_status</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;operations_research::MPSolver::BasisStatus&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Advanced usage: returns the basis status of the constraint.</span>

<span class="sd">        It is only available for continuous problems).</span>

<span class="sd">        Note that if a constraint &quot;linear_expression in [lb, ub]&quot; is transformed</span>
<span class="sd">        into &quot;linear_expression + slack = 0&quot; with slack in [-ub, -lb], then this</span>
<span class="sd">        status is the same as the status of the slack variable with AT_UPPER_BOUND</span>
<span class="sd">        and AT_LOWER_BOUND swapped.</span>

<span class="sd">        See also: MPSolver::BasisStatus.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_basis_status</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Advanced usage: returns the basis status of the constraint.</p>

<p>It is only available for continuous problems).</p>

<p>Note that if a constraint "linear_expression in [lb, ub]" is transformed
into "linear_expression + slack = 0" with slack in [-ub, -lb], then this
status is the same as the status of the slack variable with AT_UPPER_BOUND
and AT_LOWER_BOUND swapped.</p>

<p>See also: MPSolver::BasisStatus.</p>
</div>


                            </div>
                            <div id="Constraint.Lb" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Constraint.Lb">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Lb</span><span class="signature">(self) -&gt; &#39;double&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Lb</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_Lb</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Constraint.Ub" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Constraint.Ub">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">Ub</span><span class="signature">(self) -&gt; &#39;double&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">Ub</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_Ub</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Constraint.SetLb" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Constraint.SetLb">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetLb</span><span class="signature">(self, x: &#39;double&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetLb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_SetLb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Constraint.SetUb" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Constraint.SetUb">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetUb</span><span class="signature">(self, x: &#39;double&#39;) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetUb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_SetUb</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="Constraint.DualValue" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#Constraint.DualValue">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">DualValue</span><span class="signature">(self) -&gt; &#39;double&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">DualValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">Constraint_DualValue</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
</pre></div>

        </details>

    

                            </div>
                </section>
                <section id="MPSolverParameters">
                                <div class="attr class">
        <a class="headerlink" href="#MPSolverParameters">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">MPSolverParameters</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">MPSolverParameters</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This class stores parameter settings for LP and MIP solvers. Some parameters</span>
<span class="sd">    are marked as advanced: do not change their values unless you know what you</span>
<span class="sd">    are doing!</span>

<span class="sd">    For developers: how to add a new parameter:</span>
<span class="sd">    - Add the new Foo parameter in the DoubleParam or IntegerParam enum.</span>
<span class="sd">    - If it is a categorical param, add a FooValues enum.</span>
<span class="sd">    - Decide if the wrapper should define a default value for it: yes</span>
<span class="sd">      if it controls the properties of the solution (example:</span>
<span class="sd">      tolerances) or if it consistently improves performance, no</span>
<span class="sd">      otherwise. If yes, define kDefaultFoo.</span>
<span class="sd">    - Add a foo_value_ member and, if no default value is defined, a</span>
<span class="sd">      foo_is_default_ member.</span>
<span class="sd">    - Add code to handle Foo in Set...Param, Reset...Param,</span>
<span class="sd">      Get...Param, Reset and the constructor.</span>
<span class="sd">    - In class MPSolverInterface, add a virtual method SetFoo, add it</span>
<span class="sd">      to SetCommonParameters or SetMIPParameters, and implement it for</span>
<span class="sd">      each solver. Sometimes, parameters need to be implemented</span>
<span class="sd">      differently, see for example the INCREMENTALITY implementation.</span>
<span class="sd">    - Add a test in linear_solver_test.cc.</span>

<span class="sd">    TODO(user): store the parameter values in a protocol buffer</span>
<span class="sd">    instead. We need to figure out how to deal with the subtleties of</span>
<span class="sd">    the default values.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>
    <span class="n">RELATIVE_MIP_GAP</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_RELATIVE_MIP_GAP</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Limit for relative MIP gap.&quot;&quot;&quot;</span>
    <span class="n">PRIMAL_TOLERANCE</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_PRIMAL_TOLERANCE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Advanced usage: tolerance for primal feasibility of basic solutions.</span>

<span class="sd">    This does not control the integer feasibility tolerance of integer</span>
<span class="sd">    solutions for MIP or the tolerance used during presolve.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">DUAL_TOLERANCE</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_DUAL_TOLERANCE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Advanced usage: tolerance for dual feasibility of basic solutions.&quot;&quot;&quot;</span>
    <span class="n">PRESOLVE</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_PRESOLVE</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Advanced usage: presolve mode.&quot;&quot;&quot;</span>
    <span class="n">LP_ALGORITHM</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_LP_ALGORITHM</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Algorithm to solve linear programs.&quot;&quot;&quot;</span>
    <span class="n">INCREMENTALITY</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_INCREMENTALITY</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Advanced usage: incrementality from one solve to the next.&quot;&quot;&quot;</span>
    <span class="n">SCALING</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_SCALING</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Advanced usage: enable or disable matrix scaling.&quot;&quot;&quot;</span>
    <span class="n">PRESOLVE_OFF</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_PRESOLVE_OFF</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Presolve is off.&quot;&quot;&quot;</span>
    <span class="n">PRESOLVE_ON</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_PRESOLVE_ON</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Presolve is on.&quot;&quot;&quot;</span>
    <span class="n">DUAL</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_DUAL</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Dual simplex.&quot;&quot;&quot;</span>
    <span class="n">PRIMAL</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_PRIMAL</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Primal simplex.&quot;&quot;&quot;</span>
    <span class="n">BARRIER</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_BARRIER</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Barrier algorithm.&quot;&quot;&quot;</span>
    <span class="n">INCREMENTALITY_OFF</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_INCREMENTALITY_OFF</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Start solve from scratch.&quot;&quot;&quot;</span>
    <span class="n">INCREMENTALITY_ON</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_INCREMENTALITY_ON</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reuse results from previous solve as much as the underlying solver</span>
<span class="sd">    allows.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">SCALING_OFF</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_SCALING_OFF</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Scaling is off.&quot;&quot;&quot;</span>
    <span class="n">SCALING_ON</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_SCALING_ON</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Scaling is on.&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; The constructor sets all parameters to their default value.&quot;&quot;&quot;</span>
        <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">new_MPSolverParameters</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">SetDoubleParam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPSolverParameters::DoubleParam&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Sets a double parameter to a specific value.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_SetDoubleParam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">SetIntegerParam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPSolverParameters::IntegerParam&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Sets a integer parameter to a specific value.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_SetIntegerParam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetDoubleParam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPSolverParameters::DoubleParam&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the value of a double parameter.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_GetDoubleParam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">GetIntegerParam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPSolverParameters::IntegerParam&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the value of an integer parameter.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_GetIntegerParam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">delete_MPSolverParameters</span>
</pre></div>

        </details>

            <div class="docstring"><p>This class stores parameter settings for LP and MIP solvers. Some parameters
are marked as advanced: do not change their values unless you know what you
are doing!</p>

<p>For developers: how to add a new parameter:</p>

<ul>
<li>Add the new Foo parameter in the DoubleParam or IntegerParam enum.</li>
<li>If it is a categorical param, add a FooValues enum.</li>
<li>Decide if the wrapper should define a default value for it: yes
if it controls the properties of the solution (example:
tolerances) or if it consistently improves performance, no
otherwise. If yes, define kDefaultFoo.</li>
<li>Add a foo_value_ member and, if no default value is defined, a
foo_is_default_ member.</li>
<li>Add code to handle Foo in Set...Param, Reset...Param,
Get...Param, Reset and the constructor.</li>
<li>In class MPSolverInterface, add a virtual method SetFoo, add it
to SetCommonParameters or SetMIPParameters, and implement it for
each solver. Sometimes, parameters need to be implemented
differently, see for example the INCREMENTALITY implementation.</li>
<li>Add a test in linear_solver_test.cc.</li>
</ul>

<p>TODO(user): store the parameter values in a protocol buffer
instead. We need to figure out how to deal with the subtleties of
the default values.</p>
</div>


                            <div id="MPSolverParameters.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#MPSolverParameters.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">MPSolverParameters</span><span class="signature">()</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; The constructor sets all parameters to their default value.&quot;&quot;&quot;</span>
        <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">new_MPSolverParameters</span><span class="p">())</span>
</pre></div>

        </details>

            <div class="docstring"><p>The constructor sets all parameters to their default value.</p>
</div>


                            </div>
                            <div id="MPSolverParameters.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#MPSolverParameters.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                            <div id="MPSolverParameters.RELATIVE_MIP_GAP" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#MPSolverParameters.RELATIVE_MIP_GAP">#&nbsp;&nbsp</a>

        <span class="name">RELATIVE_MIP_GAP</span><span class="default_value"> = 0</span>
    </div>

            <div class="docstring"><p>Limit for relative MIP gap.</p>
</div>


                            </div>
                            <div id="MPSolverParameters.PRIMAL_TOLERANCE" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#MPSolverParameters.PRIMAL_TOLERANCE">#&nbsp;&nbsp</a>

        <span class="name">PRIMAL_TOLERANCE</span><span class="default_value"> = 1</span>
    </div>

            <div class="docstring"><p>Advanced usage: tolerance for primal feasibility of basic solutions.</p>

<p>This does not control the integer feasibility tolerance of integer
solutions for MIP or the tolerance used during presolve.</p>
</div>


                            </div>
                            <div id="MPSolverParameters.DUAL_TOLERANCE" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#MPSolverParameters.DUAL_TOLERANCE">#&nbsp;&nbsp</a>

        <span class="name">DUAL_TOLERANCE</span><span class="default_value"> = 2</span>
    </div>

            <div class="docstring"><p>Advanced usage: tolerance for dual feasibility of basic solutions.</p>
</div>


                            </div>
                            <div id="MPSolverParameters.PRESOLVE" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#MPSolverParameters.PRESOLVE">#&nbsp;&nbsp</a>

        <span class="name">PRESOLVE</span><span class="default_value"> = 1000</span>
    </div>

            <div class="docstring"><p>Advanced usage: presolve mode.</p>
</div>


                            </div>
                            <div id="MPSolverParameters.LP_ALGORITHM" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#MPSolverParameters.LP_ALGORITHM">#&nbsp;&nbsp</a>

        <span class="name">LP_ALGORITHM</span><span class="default_value"> = 1001</span>
    </div>

            <div class="docstring"><p>Algorithm to solve linear programs.</p>
</div>


                            </div>
                            <div id="MPSolverParameters.INCREMENTALITY" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#MPSolverParameters.INCREMENTALITY">#&nbsp;&nbsp</a>

        <span class="name">INCREMENTALITY</span><span class="default_value"> = 1002</span>
    </div>

            <div class="docstring"><p>Advanced usage: incrementality from one solve to the next.</p>
</div>


                            </div>
                            <div id="MPSolverParameters.SCALING" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#MPSolverParameters.SCALING">#&nbsp;&nbsp</a>

        <span class="name">SCALING</span><span class="default_value"> = 1003</span>
    </div>

            <div class="docstring"><p>Advanced usage: enable or disable matrix scaling.</p>
</div>


                            </div>
                            <div id="MPSolverParameters.PRESOLVE_OFF" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#MPSolverParameters.PRESOLVE_OFF">#&nbsp;&nbsp</a>

        <span class="name">PRESOLVE_OFF</span><span class="default_value"> = 0</span>
    </div>

            <div class="docstring"><p>Presolve is off.</p>
</div>


                            </div>
                            <div id="MPSolverParameters.PRESOLVE_ON" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#MPSolverParameters.PRESOLVE_ON">#&nbsp;&nbsp</a>

        <span class="name">PRESOLVE_ON</span><span class="default_value"> = 1</span>
    </div>

            <div class="docstring"><p>Presolve is on.</p>
</div>


                            </div>
                            <div id="MPSolverParameters.DUAL" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#MPSolverParameters.DUAL">#&nbsp;&nbsp</a>

        <span class="name">DUAL</span><span class="default_value"> = 10</span>
    </div>

            <div class="docstring"><p>Dual simplex.</p>
</div>


                            </div>
                            <div id="MPSolverParameters.PRIMAL" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#MPSolverParameters.PRIMAL">#&nbsp;&nbsp</a>

        <span class="name">PRIMAL</span><span class="default_value"> = 11</span>
    </div>

            <div class="docstring"><p>Primal simplex.</p>
</div>


                            </div>
                            <div id="MPSolverParameters.BARRIER" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#MPSolverParameters.BARRIER">#&nbsp;&nbsp</a>

        <span class="name">BARRIER</span><span class="default_value"> = 12</span>
    </div>

            <div class="docstring"><p>Barrier algorithm.</p>
</div>


                            </div>
                            <div id="MPSolverParameters.INCREMENTALITY_OFF" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#MPSolverParameters.INCREMENTALITY_OFF">#&nbsp;&nbsp</a>

        <span class="name">INCREMENTALITY_OFF</span><span class="default_value"> = 0</span>
    </div>

            <div class="docstring"><p>Start solve from scratch.</p>
</div>


                            </div>
                            <div id="MPSolverParameters.INCREMENTALITY_ON" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#MPSolverParameters.INCREMENTALITY_ON">#&nbsp;&nbsp</a>

        <span class="name">INCREMENTALITY_ON</span><span class="default_value"> = 1</span>
    </div>

            <div class="docstring"><p>Reuse results from previous solve as much as the underlying solver
allows.</p>
</div>


                            </div>
                            <div id="MPSolverParameters.SCALING_OFF" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#MPSolverParameters.SCALING_OFF">#&nbsp;&nbsp</a>

        <span class="name">SCALING_OFF</span><span class="default_value"> = 0</span>
    </div>

            <div class="docstring"><p>Scaling is off.</p>
</div>


                            </div>
                            <div id="MPSolverParameters.SCALING_ON" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#MPSolverParameters.SCALING_ON">#&nbsp;&nbsp</a>

        <span class="name">SCALING_ON</span><span class="default_value"> = 1</span>
    </div>

            <div class="docstring"><p>Scaling is on.</p>
</div>


                            </div>
                            <div id="MPSolverParameters.SetDoubleParam" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#MPSolverParameters.SetDoubleParam">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetDoubleParam</span><span class="signature">(
    self,
    param: &#39;operations_research::MPSolverParameters::DoubleParam&#39;,
    value: &#39;double&#39;
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetDoubleParam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPSolverParameters::DoubleParam&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;double&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Sets a double parameter to a specific value.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_SetDoubleParam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Sets a double parameter to a specific value.</p>
</div>


                            </div>
                            <div id="MPSolverParameters.SetIntegerParam" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#MPSolverParameters.SetIntegerParam">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">SetIntegerParam</span><span class="signature">(
    self,
    param: &#39;operations_research::MPSolverParameters::IntegerParam&#39;,
    value: int
) -&gt; &#39;void&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">SetIntegerParam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPSolverParameters::IntegerParam&quot;</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="s2">&quot;int&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;void&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Sets a integer parameter to a specific value.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_SetIntegerParam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Sets a integer parameter to a specific value.</p>
</div>


                            </div>
                            <div id="MPSolverParameters.GetDoubleParam" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#MPSolverParameters.GetDoubleParam">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetDoubleParam</span><span class="signature">(
    self,
    param: &#39;operations_research::MPSolverParameters::DoubleParam&#39;
) -&gt; &#39;double&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetDoubleParam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPSolverParameters::DoubleParam&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;double&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the value of a double parameter.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_GetDoubleParam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the value of a double parameter.</p>
</div>


                            </div>
                            <div id="MPSolverParameters.GetIntegerParam" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#MPSolverParameters.GetIntegerParam">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">GetIntegerParam</span><span class="signature">(
    self,
    param: &#39;operations_research::MPSolverParameters::IntegerParam&#39;
) -&gt; int</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="nf">GetIntegerParam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPSolverParameters::IntegerParam&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;int&quot;</span><span class="p">:</span>
        <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Returns the value of an integer parameter.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">MPSolverParameters_GetIntegerParam</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">param</span><span class="p">)</span>
</pre></div>

        </details>

            <div class="docstring"><p>Returns the value of an integer parameter.</p>
</div>


                            </div>
                            <div id="MPSolverParameters.kDefaultRelativeMipGap" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#MPSolverParameters.kDefaultRelativeMipGap">#&nbsp;&nbsp</a>

        <span class="name">kDefaultRelativeMipGap</span><span class="default_value"> = 0.0001</span>
    </div>

    

                            </div>
                            <div id="MPSolverParameters.kDefaultPrimalTolerance" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#MPSolverParameters.kDefaultPrimalTolerance">#&nbsp;&nbsp</a>

        <span class="name">kDefaultPrimalTolerance</span><span class="default_value"> = 1e-07</span>
    </div>

    

                            </div>
                            <div id="MPSolverParameters.kDefaultDualTolerance" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#MPSolverParameters.kDefaultDualTolerance">#&nbsp;&nbsp</a>

        <span class="name">kDefaultDualTolerance</span><span class="default_value"> = 1e-07</span>
    </div>

    

                            </div>
                            <div id="MPSolverParameters.kDefaultPresolve" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#MPSolverParameters.kDefaultPresolve">#&nbsp;&nbsp</a>

        <span class="name">kDefaultPresolve</span><span class="default_value"> = 1</span>
    </div>

    

                            </div>
                            <div id="MPSolverParameters.kDefaultIncrementality" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#MPSolverParameters.kDefaultIncrementality">#&nbsp;&nbsp</a>

        <span class="name">kDefaultIncrementality</span><span class="default_value"> = 1</span>
    </div>

    

                            </div>
                </section>
                <section id="ModelExportOptions">
                                <div class="attr class">
        <a class="headerlink" href="#ModelExportOptions">#&nbsp;&nbsp</a>

        
        <span class="def">class</span>
        <span class="name">ModelExportOptions</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">class</span> <span class="nc">ModelExportOptions</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sa">r</span><span class="sd">&quot;&quot;&quot; Export options.&quot;&quot;&quot;</span>

    <span class="n">thisown</span> <span class="o">=</span> <span class="nb">property</span><span class="p">(</span><span class="k">lambda</span> <span class="n">x</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(),</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">v</span><span class="p">:</span> <span class="n">x</span><span class="o">.</span><span class="n">this</span><span class="o">.</span><span class="n">own</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">doc</span><span class="o">=</span><span class="s2">&quot;The membership flag&quot;</span><span class="p">)</span>
    <span class="fm">__repr__</span> <span class="o">=</span> <span class="n">_swig_repr</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">_pywraplp</span><span class="o">.</span><span class="n">ModelExportOptions_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">new_ModelExportOptions</span><span class="p">())</span>
    <span class="n">__swig_destroy__</span> <span class="o">=</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">delete_ModelExportOptions</span>
</pre></div>

        </details>

            <div class="docstring"><p>Export options.</p>
</div>


                            <div id="ModelExportOptions.__init__" class="classattr">
                                        <div class="attr function"><a class="headerlink" href="#ModelExportOptions.__init__">#&nbsp;&nbsp</a>

        
            <span class="name">ModelExportOptions</span><span class="signature">()</span>
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">_pywraplp</span><span class="o">.</span><span class="n">ModelExportOptions_swiginit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">new_ModelExportOptions</span><span class="p">())</span>
</pre></div>

        </details>

    

                            </div>
                            <div id="ModelExportOptions.thisown" class="classattr">
                                            <div class="attr variable"><a class="headerlink" href="#ModelExportOptions.thisown">#&nbsp;&nbsp</a>

        <span class="name">thisown</span>
    </div>

            <div class="docstring"><p>The membership flag</p>
</div>


                            </div>
                </section>
                <section id="ExportModelAsLpFormat">
                            <div class="attr function"><a class="headerlink" href="#ExportModelAsLpFormat">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ExportModelAsLpFormat</span><span class="signature">(*args) -&gt; &#39;std::string&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">ExportModelAsLpFormat</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">ExportModelAsLpFormat</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                </section>
                <section id="ExportModelAsMpsFormat">
                            <div class="attr function"><a class="headerlink" href="#ExportModelAsMpsFormat">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">ExportModelAsMpsFormat</span><span class="signature">(*args) -&gt; &#39;std::string&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">ExportModelAsMpsFormat</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">ExportModelAsMpsFormat</span><span class="p">(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
</pre></div>

        </details>

    

                </section>
                <section id="FindErrorInModelProto">
                            <div class="attr function"><a class="headerlink" href="#FindErrorInModelProto">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">FindErrorInModelProto</span><span class="signature">(
    input_model: &#39;operations_research::MPModelProto const &amp;&#39;
) -&gt; &#39;std::string&#39;</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">FindErrorInModelProto</span><span class="p">(</span><span class="n">input_model</span><span class="p">:</span> <span class="s2">&quot;operations_research::MPModelProto const &amp;&quot;</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;std::string&quot;</span><span class="p">:</span>
    <span class="k">return</span> <span class="n">_pywraplp</span><span class="o">.</span><span class="n">FindErrorInModelProto</span><span class="p">(</span><span class="n">input_model</span><span class="p">)</span>
</pre></div>

        </details>

    

                </section>
                <section id="setup_variable_operator">
                            <div class="attr function"><a class="headerlink" href="#setup_variable_operator">#&nbsp;&nbsp</a>

        
            <span class="def">def</span>
            <span class="name">setup_variable_operator</span><span class="signature">(opname)</span>:
    </div>

                <details>
            <summary>View Source</summary>
            <div class="codehilite"><pre><span></span><span class="k">def</span> <span class="nf">setup_variable_operator</span><span class="p">(</span><span class="n">opname</span><span class="p">):</span>
  <span class="nb">setattr</span><span class="p">(</span><span class="n">Variable</span><span class="p">,</span> <span class="n">opname</span><span class="p">,</span>
          <span class="k">lambda</span> <span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">VariableExpr</span><span class="p">(</span><span class="bp">self</span><span class="p">),</span> <span class="n">opname</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">))</span>
</pre></div>

        </details>

    

                </section>
    </main>
</body>
</html>