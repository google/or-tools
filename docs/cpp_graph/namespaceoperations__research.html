<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>OR-Tools</title>
        <meta http-equiv="Content-Type" content="text/html;"/>
        <meta charset="utf-8"/>
        <!--<link rel='stylesheet' type='text/css' href="https://fonts.googleapis.com/css?family=Ubuntu:400,700,400italic"/>-->
        <link rel="stylesheet" type="text/css" href="ortools.css" title="default" media="screen,print" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
    </head>
    <body>
        <div id="banner-container">
            <div id="banner">
                <span id="sfml">OR-Tools 7.2</span>
            </div>
        </div>
        <link rel="icon" href="https://developers.google.com/optimization/images/orLogo.png">
        <div id="content">
<!-- Generated by Doxygen 1.8.15 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceoperations__research.html','');});
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">operations_research Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1AnnotatedGraphBuildManager.html">AnnotatedGraphBuildManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1ArcFunctorOrderingByTailAndHead.html">ArcFunctorOrderingByTailAndHead</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1ArcIndexOrderingByTailNode.html">ArcIndexOrderingByTailNode</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logically this class should be defined inside OptimizeGraphLayout, but compilation fails if we do that because C++98 doesn't allow instantiation of member templates with function-scoped types as template parameters, which in turn is because those function-scoped types lack linkage.  <a href="classoperations__research_1_1ArcIndexOrderingByTailNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1BronKerboschAlgorithm.html">BronKerboschAlgorithm</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements the Bron-Kerbosch algorithm for finding maximal cliques.  <a href="classoperations__research_1_1BronKerboschAlgorithm.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1ChristofidesPathSolver.html">ChristofidesPathSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1ConnectedComponents.html">ConnectedComponents</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Template class implementing a Union-Find algorithm with path compression for maintaining the connected components of a graph.  <a href="classoperations__research_1_1ConnectedComponents.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1CostValueCycleHandler.html">CostValueCycleHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1EbertGraph.html">EbertGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declarations.  <a href="classoperations__research_1_1EbertGraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1EbertGraphBase.html">EbertGraphBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A template for the base class that holds the functionality that exists in common between the EbertGraph&lt;&gt; template and the ForwardEbertGraph&lt;&gt; template.  <a href="classoperations__research_1_1EbertGraphBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1ElementIterator.html">ElementIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1ForwardEbertGraph.html">ForwardEbertGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A forward-star-only graph representation for greater efficiency in those algorithms that don't need reverse arcs.  <a href="classoperations__research_1_1ForwardEbertGraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1ForwardStaticGraph.html">ForwardStaticGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1GenericMaxFlow.html">GenericMaxFlow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration.  <a href="classoperations__research_1_1GenericMaxFlow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1GenericMinCostFlow.html">GenericMinCostFlow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration.  <a href="classoperations__research_1_1GenericMinCostFlow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1graph__traits.html">graph_traits</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Traits for <a class="el" href="classoperations__research_1_1EbertGraphBase.html" title="A template for the base class that holds the functionality that exists in common between the EbertGra...">EbertGraphBase</a> types, for use in testing and clients that work with both forward-only and forward/reverse graphs.  <a href="structoperations__research_1_1graph__traits.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1graph__traits_3_01ForwardEbertGraph_3_01NodeIndexType_00_01ArcIndexType_01_4_01_4.html">graph_traits&lt; ForwardEbertGraph&lt; NodeIndexType, ArcIndexType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1graph__traits_3_01ForwardStaticGraph_3_01NodeIndexType_00_01ArcIndexType_01_4_01_4.html">graph_traits&lt; ForwardStaticGraph&lt; NodeIndexType, ArcIndexType &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1Graphs.html">Graphs</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Since StarGraph does not have exactly the same interface as the other graphs, we define a correspondence there.  <a href="structoperations__research_1_1Graphs.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structoperations__research_1_1Graphs_3_01operations__research_1_1StarGraph_01_4.html">Graphs&lt; operations_research::StarGraph &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1HamiltonianPathSolver.html">HamiltonianPathSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1LatticeMemoryManager.html">LatticeMemoryManager</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The Dynamic Programming (DP) algorithm memorizes the values f(set, node) for node in set, for all the subsets of cardinality &lt;= max_card_.  <a href="classoperations__research_1_1LatticeMemoryManager.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1LinearSumAssignment.html">LinearSumAssignment</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class does not take ownership of its underlying graph.  <a href="classoperations__research_1_1LinearSumAssignment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MaxFlow.html">MaxFlow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default instance <a class="el" href="classoperations__research_1_1MaxFlow.html" title="Default instance MaxFlow that uses StarGraph.">MaxFlow</a> that uses StarGraph.  <a href="classoperations__research_1_1MaxFlow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MaxFlowStatusClass.html">MaxFlowStatusClass</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">We want an enum for the Status of a max flow run, and we want this enum to be scoped under GenericMaxFlow&lt;&gt;.  <a href="classoperations__research_1_1MaxFlowStatusClass.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MinCostFlow.html">MinCostFlow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default <a class="el" href="classoperations__research_1_1MinCostFlow.html" title="Default MinCostFlow instance that uses StarGraph.">MinCostFlow</a> instance that uses StarGraph.  <a href="classoperations__research_1_1MinCostFlow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1MinCostFlowBase.html">MinCostFlowBase</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different statuses for a solved problem.  <a href="classoperations__research_1_1MinCostFlowBase.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1PermutationIndexComparisonByArcHead.html">PermutationIndexComparisonByArcHead</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1PriorityQueueWithRestrictedPush.html">PriorityQueueWithRestrictedPush</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specific but efficient priority queue implementation.  <a href="classoperations__research_1_1PriorityQueueWithRestrictedPush.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1PruningHamiltonianSolver.html">PruningHamiltonianSolver</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1Set.html">Set</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1SetRangeIterator.html">SetRangeIterator</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An iterator for sets of increasing corresponding values that have the same cardinality.  <a href="classoperations__research_1_1SetRangeIterator.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1SetRangeWithCardinality.html">SetRangeWithCardinality</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1SimpleMaxFlow.html">SimpleMaxFlow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple and efficient max-cost flow interface.  <a href="classoperations__research_1_1SimpleMaxFlow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1SimpleMinCostFlow.html">SimpleMinCostFlow</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A simple and efficient min-cost flow interface.  <a href="classoperations__research_1_1SimpleMinCostFlow.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1StarGraphBase.html">StarGraphBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1TailArrayManager.html">TailArrayManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a0e629e35bfa311b31dd7f5065eb834bb"><td class="memItemLeft" align="right" valign="top">typedef int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a0e629e35bfa311b31dd7f5065eb834bb">NodeIndex</a></td></tr>
<tr class="memdesc:a0e629e35bfa311b31dd7f5065eb834bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard instantiation of <a class="el" href="classoperations__research_1_1ForwardEbertGraph.html" title="A forward-star-only graph representation for greater efficiency in those algorithms that don&#39;t need r...">ForwardEbertGraph</a> (named 'ForwardStarGraph') of <a class="el" href="classoperations__research_1_1EbertGraph.html" title="Forward declarations.">EbertGraph</a> (named 'StarGraph'); and relevant type shortcuts.  <a href="#a0e629e35bfa311b31dd7f5065eb834bb">More...</a><br /></td></tr>
<tr class="separator:a0e629e35bfa311b31dd7f5065eb834bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31d858394c5eed1fa21edc3da47047c1"><td class="memItemLeft" align="right" valign="top">typedef int32&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a31d858394c5eed1fa21edc3da47047c1">ArcIndex</a></td></tr>
<tr class="separator:a31d858394c5eed1fa21edc3da47047c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5841ff601ab08548afb15c45b2245de7"><td class="memItemLeft" align="right" valign="top">typedef int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a5841ff601ab08548afb15c45b2245de7">FlowQuantity</a></td></tr>
<tr class="separator:a5841ff601ab08548afb15c45b2245de7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7950685633ee869aa9471b2ec5fbcfa"><td class="memItemLeft" align="right" valign="top">typedef int64&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#aa7950685633ee869aa9471b2ec5fbcfa">CostValue</a></td></tr>
<tr class="separator:aa7950685633ee869aa9471b2ec5fbcfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae39f15b318a3cba17b1e60e6da51c0d4"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classoperations__research_1_1EbertGraph.html">EbertGraph</a>&lt; <a class="el" href="namespaceoperations__research.html#a0e629e35bfa311b31dd7f5065eb834bb">NodeIndex</a>, <a class="el" href="namespaceoperations__research.html#a31d858394c5eed1fa21edc3da47047c1">ArcIndex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ae39f15b318a3cba17b1e60e6da51c0d4">StarGraph</a></td></tr>
<tr class="separator:ae39f15b318a3cba17b1e60e6da51c0d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a652af62fa5f211aa0c54d7994ca1c504"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classoperations__research_1_1ForwardEbertGraph.html">ForwardEbertGraph</a>&lt; <a class="el" href="namespaceoperations__research.html#a0e629e35bfa311b31dd7f5065eb834bb">NodeIndex</a>, <a class="el" href="namespaceoperations__research.html#a31d858394c5eed1fa21edc3da47047c1">ArcIndex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a652af62fa5f211aa0c54d7994ca1c504">ForwardStarGraph</a></td></tr>
<tr class="separator:a652af62fa5f211aa0c54d7994ca1c504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7440a08c859325694df19d4d4aee95c"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classoperations__research_1_1ForwardStaticGraph.html">ForwardStaticGraph</a>&lt; <a class="el" href="namespaceoperations__research.html#a0e629e35bfa311b31dd7f5065eb834bb">NodeIndex</a>, <a class="el" href="namespaceoperations__research.html#a31d858394c5eed1fa21edc3da47047c1">ArcIndex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ac7440a08c859325694df19d4d4aee95c">ForwardStarStaticGraph</a></td></tr>
<tr class="separator:ac7440a08c859325694df19d4d4aee95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a389e5320fb5bcd0fb99d894488f9820b"><td class="memItemLeft" align="right" valign="top">typedef ZVector&lt; <a class="el" href="namespaceoperations__research.html#a0e629e35bfa311b31dd7f5065eb834bb">NodeIndex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a389e5320fb5bcd0fb99d894488f9820b">NodeIndexArray</a></td></tr>
<tr class="separator:a389e5320fb5bcd0fb99d894488f9820b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79bf252fa6483cd33cbf95170353fb0"><td class="memItemLeft" align="right" valign="top">typedef ZVector&lt; <a class="el" href="namespaceoperations__research.html#a31d858394c5eed1fa21edc3da47047c1">ArcIndex</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#aa79bf252fa6483cd33cbf95170353fb0">ArcIndexArray</a></td></tr>
<tr class="separator:aa79bf252fa6483cd33cbf95170353fb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4fc0319cb4e28ec175fc9163775a6e"><td class="memItemLeft" align="right" valign="top">typedef ZVector&lt; <a class="el" href="namespaceoperations__research.html#a5841ff601ab08548afb15c45b2245de7">FlowQuantity</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a7d4fc0319cb4e28ec175fc9163775a6e">QuantityArray</a></td></tr>
<tr class="separator:a7d4fc0319cb4e28ec175fc9163775a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdee62ecefa0520e530c18a55b083e6d"><td class="memItemLeft" align="right" valign="top">typedef ZVector&lt; <a class="el" href="namespaceoperations__research.html#aa7950685633ee869aa9471b2ec5fbcfa">CostValue</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#afdee62ecefa0520e530c18a55b083e6d">CostArray</a></td></tr>
<tr class="separator:afdee62ecefa0520e530c18a55b083e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09767b3634289e432c3ce1d7c649666a"><td class="memItemLeft" align="right" valign="top">typedef int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a09767b3634289e432c3ce1d7c649666a">PathNodeIndex</a></td></tr>
<tr class="separator:a09767b3634289e432c3ce1d7c649666a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:af2d89e69d073dc3036a6de24710b416f"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#af2d89e69d073dc3036a6de24710b416f">CliqueResponse</a> { <a class="el" href="namespaceoperations__research.html#af2d89e69d073dc3036a6de24710b416fa2f453cfe638e57e27bb0c9512436111e">CliqueResponse::CONTINUE</a>, 
<a class="el" href="namespaceoperations__research.html#af2d89e69d073dc3036a6de24710b416fa615a46af313786fc4e349f34118be111">CliqueResponse::STOP</a>
 }</td></tr>
<tr class="memdesc:af2d89e69d073dc3036a6de24710b416f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible return values of the callback for reporting cliques.  <a href="namespaceoperations__research.html#af2d89e69d073dc3036a6de24710b416f">More...</a><br /></td></tr>
<tr class="separator:af2d89e69d073dc3036a6de24710b416f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a708cf34b342e7d2ed89a3b73dbec4eae"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a708cf34b342e7d2ed89a3b73dbec4eae">BronKerboschAlgorithmStatus</a> { <a class="el" href="namespaceoperations__research.html#a708cf34b342e7d2ed89a3b73dbec4eaea8f7afecbc8fbc4cd0f50a57d1172482e">BronKerboschAlgorithmStatus::COMPLETED</a>, 
<a class="el" href="namespaceoperations__research.html#a708cf34b342e7d2ed89a3b73dbec4eaea658f2cadfdf09b6046246e9314f7cd43">BronKerboschAlgorithmStatus::INTERRUPTED</a>
 }</td></tr>
<tr class="memdesc:a708cf34b342e7d2ed89a3b73dbec4eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">The status value returned by BronKerboschAlgorithm::Run and BronKerboschAlgorithm::RunIterations.  <a href="namespaceoperations__research.html#a708cf34b342e7d2ed89a3b73dbec4eae">More...</a><br /></td></tr>
<tr class="separator:a708cf34b342e7d2ed89a3b73dbec4eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3175c0c8e9fc36a30b70b6b9c132474a"><td class="memTemplParams" colspan="2">template&lt;typename WeightFunctionType , typename GraphType &gt; </td></tr>
<tr class="memitem:a3175c0c8e9fc36a30b70b6b9c132474a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename GraphType::ArcIndex &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a3175c0c8e9fc36a30b70b6b9c132474a">ComputeMinimumWeightMatchingWithMIP</a> (const GraphType &amp;graph, const WeightFunctionType &amp;weight)</td></tr>
<tr class="memdesc:a3175c0c8e9fc36a30b70b6b9c132474a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes a minimum weight perfect matching on an undirected graph using a Mixed Integer Programming model.  <a href="#a3175c0c8e9fc36a30b70b6b9c132474a">More...</a><br /></td></tr>
<tr class="separator:a3175c0c8e9fc36a30b70b6b9c132474a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a509097448ff5705cf3e64d889362bdec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a509097448ff5705cf3e64d889362bdec">FindCliques</a> (std::function&lt; bool(int, int)&gt; graph, int node_count, std::function&lt; bool(const std::vector&lt; int &gt; &amp;)&gt; callback)</td></tr>
<tr class="memdesc:a509097448ff5705cf3e64d889362bdec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds all maximal cliques, even of size 1, in the graph described by the graph callback.  <a href="#a509097448ff5705cf3e64d889362bdec">More...</a><br /></td></tr>
<tr class="separator:a509097448ff5705cf3e64d889362bdec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4b5a6c0e4019314f288e3f4307c114"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#afe4b5a6c0e4019314f288e3f4307c114">CoverArcsByCliques</a> (std::function&lt; bool(int, int)&gt; graph, int node_count, std::function&lt; bool(const std::vector&lt; int &gt; &amp;)&gt; callback)</td></tr>
<tr class="memdesc:afe4b5a6c0e4019314f288e3f4307c114"><td class="mdescLeft">&#160;</td><td class="mdescRight">Covers the maximum number of arcs of the graph with cliques.  <a href="#afe4b5a6c0e4019314f288e3f4307c114">More...</a><br /></td></tr>
<tr class="separator:afe4b5a6c0e4019314f288e3f4307c114"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb53c505b8fd29ceb3abdcc7dfd809ce"><td class="memTemplParams" colspan="2">template&lt;typename GraphType &gt; </td></tr>
<tr class="memitem:acb53c505b8fd29ceb3abdcc7dfd809ce"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#acb53c505b8fd29ceb3abdcc7dfd809ce">BuildLineGraph</a> (const GraphType &amp;graph, GraphType *const line_graph)</td></tr>
<tr class="memdesc:acb53c505b8fd29ceb3abdcc7dfd809ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds a directed line graph for 'graph' (see "directed line graph" in <a href="http://en.wikipedia.org/wiki/Line_graph">http://en.wikipedia.org/wiki/Line_graph</a>).  <a href="#acb53c505b8fd29ceb3abdcc7dfd809ce">More...</a><br /></td></tr>
<tr class="separator:acb53c505b8fd29ceb3abdcc7dfd809ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1cf773de0cae72d0c44efe5b8f4bb89"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:ab1cf773de0cae72d0c44efe5b8f4bb89"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ab1cf773de0cae72d0c44efe5b8f4bb89">IsEulerianGraph</a> (const Graph &amp;graph)</td></tr>
<tr class="memdesc:ab1cf773de0cae72d0c44efe5b8f4bb89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a graph is Eulerian, aka all its nodes are of even degree.  <a href="#ab1cf773de0cae72d0c44efe5b8f4bb89">More...</a><br /></td></tr>
<tr class="separator:ab1cf773de0cae72d0c44efe5b8f4bb89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b312dd19c90b2af099e6f159869f7ee"><td class="memTemplParams" colspan="2">template&lt;typename NodeIndex , typename Graph &gt; </td></tr>
<tr class="memitem:a6b312dd19c90b2af099e6f159869f7ee"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a6b312dd19c90b2af099e6f159869f7ee">IsSemiEulerianGraph</a> (const Graph &amp;graph, std::vector&lt; <a class="el" href="namespaceoperations__research.html#a0e629e35bfa311b31dd7f5065eb834bb">NodeIndex</a> &gt; *odd_nodes)</td></tr>
<tr class="memdesc:a6b312dd19c90b2af099e6f159869f7ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a graph is Semi-Eulerian, aka at most two of its nodes are of odd degree.  <a href="#a6b312dd19c90b2af099e6f159869f7ee">More...</a><br /></td></tr>
<tr class="separator:a6b312dd19c90b2af099e6f159869f7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a743d8c9d6f64531bdeb7bbf18023e9d4"><td class="memTemplParams" colspan="2">template&lt;typename NodeIndex , typename Graph &gt; </td></tr>
<tr class="memitem:a743d8c9d6f64531bdeb7bbf18023e9d4"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceoperations__research.html#a0e629e35bfa311b31dd7f5065eb834bb">NodeIndex</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a743d8c9d6f64531bdeb7bbf18023e9d4">BuildEulerianPathFromNode</a> (const Graph &amp;graph, <a class="el" href="namespaceoperations__research.html#a0e629e35bfa311b31dd7f5065eb834bb">NodeIndex</a> root)</td></tr>
<tr class="memdesc:a743d8c9d6f64531bdeb7bbf18023e9d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds an Eulerian path/trail on an undirected graph starting from node root.  <a href="#a743d8c9d6f64531bdeb7bbf18023e9d4">More...</a><br /></td></tr>
<tr class="separator:a743d8c9d6f64531bdeb7bbf18023e9d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa63055860fc53f8eed56d23d2571c180"><td class="memTemplParams" colspan="2">template&lt;typename NodeIndex , typename Graph &gt; </td></tr>
<tr class="memitem:aa63055860fc53f8eed56d23d2571c180"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="namespaceoperations__research.html#a0e629e35bfa311b31dd7f5065eb834bb">NodeIndex</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#aa63055860fc53f8eed56d23d2571c180">BuildEulerianTourFromNode</a> (const Graph &amp;graph, <a class="el" href="namespaceoperations__research.html#a0e629e35bfa311b31dd7f5065eb834bb">NodeIndex</a> root)</td></tr>
<tr class="memdesc:aa63055860fc53f8eed56d23d2571c180"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds an Eulerian tour/circuit/cycle starting and ending at node root on an undirected graph.  <a href="#aa63055860fc53f8eed56d23d2571c180">More...</a><br /></td></tr>
<tr class="separator:aa63055860fc53f8eed56d23d2571c180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a034666fe63ca105b735272974006362a"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a034666fe63ca105b735272974006362a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename Graph::NodeIndex &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a034666fe63ca105b735272974006362a">BuildEulerianTour</a> (const Graph &amp;graph)</td></tr>
<tr class="memdesc:a034666fe63ca105b735272974006362a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above but without specifying a start/end root node (node 0 is taken as default root).  <a href="#a034666fe63ca105b735272974006362a">More...</a><br /></td></tr>
<tr class="separator:a034666fe63ca105b735272974006362a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49b170b2d03863c465331e67b21f0c33"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a49b170b2d03863c465331e67b21f0c33"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename Graph::NodeIndex &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a49b170b2d03863c465331e67b21f0c33">BuildEulerianPath</a> (const Graph &amp;graph)</td></tr>
<tr class="memdesc:a49b170b2d03863c465331e67b21f0c33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Builds an Eulerian path/trail on an undirected graph.  <a href="#a49b170b2d03863c465331e67b21f0c33">More...</a><br /></td></tr>
<tr class="separator:a49b170b2d03863c465331e67b21f0c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a715b0dbb9f0903ab629b8c6da1b35b45"><td class="memTemplParams" colspan="2">template&lt;typename CostType , typename CostFunction &gt; </td></tr>
<tr class="memitem:a715b0dbb9f0903ab629b8c6da1b35b45"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classoperations__research_1_1HamiltonianPathSolver.html">HamiltonianPathSolver</a>&lt; CostType, CostFunction &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a715b0dbb9f0903ab629b8c6da1b35b45">MakeHamiltonianPathSolver</a> (int num_nodes, CostFunction cost)</td></tr>
<tr class="memdesc:a715b0dbb9f0903ab629b8c6da1b35b45"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to simplify building a <a class="el" href="classoperations__research_1_1HamiltonianPathSolver.html">HamiltonianPathSolver</a> from a functor.  <a href="#a715b0dbb9f0903ab629b8c6da1b35b45">More...</a><br /></td></tr>
<tr class="separator:a715b0dbb9f0903ab629b8c6da1b35b45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00ab79ee21ffd8dece0996e37f9faa7a"><td class="memTemplParams" colspan="2">template&lt;typename Graph &gt; </td></tr>
<tr class="memitem:a00ab79ee21ffd8dece0996e37f9faa7a"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename Graph::ArcIndex &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a00ab79ee21ffd8dece0996e37f9faa7a">BuildKruskalMinimumSpanningTreeFromSortedArcs</a> (const Graph &amp;graph, const std::vector&lt; typename Graph::ArcIndex &gt; &amp;sorted_arcs)</td></tr>
<tr class="memdesc:a00ab79ee21ffd8dece0996e37f9faa7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of Kruskal's mininumum spanning tree algorithm (c.f.  <a href="#a00ab79ee21ffd8dece0996e37f9faa7a">More...</a><br /></td></tr>
<tr class="separator:a00ab79ee21ffd8dece0996e37f9faa7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa565a47a059ef32ef1aec39768e4ec98"><td class="memTemplParams" colspan="2">template&lt;typename Graph , typename ArcComparator &gt; </td></tr>
<tr class="memitem:aa565a47a059ef32ef1aec39768e4ec98"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename Graph::ArcIndex &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#aa565a47a059ef32ef1aec39768e4ec98">BuildKruskalMinimumSpanningTree</a> (const Graph &amp;graph, const ArcComparator &amp;arc_comparator)</td></tr>
<tr class="memdesc:aa565a47a059ef32ef1aec39768e4ec98"><td class="mdescLeft">&#160;</td><td class="mdescRight">Version taking an arc comparator to sort graph arcs.  <a href="#aa565a47a059ef32ef1aec39768e4ec98">More...</a><br /></td></tr>
<tr class="separator:aa565a47a059ef32ef1aec39768e4ec98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33a2f4c26fd60cd0fa98257b571c974f"><td class="memTemplParams" colspan="2">template&lt;typename Graph , typename ArcValue &gt; </td></tr>
<tr class="memitem:a33a2f4c26fd60cd0fa98257b571c974f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; typename Graph::ArcIndex &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a33a2f4c26fd60cd0fa98257b571c974f">BuildPrimMinimumSpanningTree</a> (const Graph &amp;graph, const ArcValue &amp;arc_value)</td></tr>
<tr class="memdesc:a33a2f4c26fd60cd0fa98257b571c974f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementation of Prim's mininumum spanning tree algorithm (c.f.  <a href="#a33a2f4c26fd60cd0fa98257b571c974f">More...</a><br /></td></tr>
<tr class="separator:a33a2f4c26fd60cd0fa98257b571c974f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e6a83fcbd689abf5b3078b0236f9f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#a53e6a83fcbd689abf5b3078b0236f9f1">DijkstraShortestPath</a> (int node_count, int start_node, int end_node, std::function&lt; int64(int, int)&gt; graph, int64 disconnected_distance, std::vector&lt; int &gt; *nodes)</td></tr>
<tr class="memdesc:a53e6a83fcbd689abf5b3078b0236f9f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dijsktra Shortest path with callback based description of the graph.  <a href="#a53e6a83fcbd689abf5b3078b0236f9f1">More...</a><br /></td></tr>
<tr class="separator:a53e6a83fcbd689abf5b3078b0236f9f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56bae19a2298c3163af96ca7f8b89b1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ad56bae19a2298c3163af96ca7f8b89b1">StableDijkstraShortestPath</a> (int node_count, int start_node, int end_node, std::function&lt; int64(int, int)&gt; graph, int64 disconnected_distance, std::vector&lt; int &gt; *nodes)</td></tr>
<tr class="memdesc:ad56bae19a2298c3163af96ca7f8b89b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stable version of the Dijsktra Shortest path with callback based description of the graph.  <a href="#ad56bae19a2298c3163af96ca7f8b89b1">More...</a><br /></td></tr>
<tr class="separator:ad56bae19a2298c3163af96ca7f8b89b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5bfec6ea714171fbff2d8b791d0d286"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#ad5bfec6ea714171fbff2d8b791d0d286">BellmanFordShortestPath</a> (int node_count, int start_node, int end_node, std::function&lt; int64(int, int)&gt; graph, int64 disconnected_distance, std::vector&lt; int &gt; *nodes)</td></tr>
<tr class="memdesc:ad5bfec6ea714171fbff2d8b791d0d286"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bellman-Ford Shortest path with callback-based description of the graph.  <a href="#ad5bfec6ea714171fbff2d8b791d0d286">More...</a><br /></td></tr>
<tr class="separator:ad5bfec6ea714171fbff2d8b791d0d286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acff272be25bcf9641218c05c59ec1a4e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html#acff272be25bcf9641218c05c59ec1a4e">AStarShortestPath</a> (int node_count, int start_node, int end_node, std::function&lt; int64(int, int)&gt; graph, std::function&lt; int64(int)&gt; heuristic, int64 disconnected_distance, std::vector&lt; int &gt; *nodes)</td></tr>
<tr class="memdesc:acff272be25bcf9641218c05c59ec1a4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">A* Shortest path with function based description of the graph.  <a href="#acff272be25bcf9641218c05c59ec1a4e">More...</a><br /></td></tr>
<tr class="separator:acff272be25bcf9641218c05c59ec1a4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. </p>
<p>You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div></div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. <a class="el" href="classoperations__research_1_1ChristofidesPathSolver.html">ChristofidesPathSolver</a> computes an approximate solution to the Traveling Salesman Problen using the Christofides algorithm (c.f. <a href="https://en.wikipedia.org/wiki/Christofides_algorithm">https://en.wikipedia.org/wiki/Christofides_algorithm</a>). </p><dl class="section note"><dt>Note</dt><dd>the algorithm guarantees finding a solution within 3/2 of the optimum. Its complexity is O(n^2 * log(n)) where n is the number of nodes.</dd></dl>
<p>You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div></div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Maximal clique algorithms, based on the Bron-Kerbosch algorithm. See <a href="http://en.wikipedia.org/wiki/Bron-Kerbosch_algorithm">http://en.wikipedia.org/wiki/Bron-Kerbosch_algorithm</a> and C. Bron and J. Kerbosch, Joep, "Algorithm 457: finding all cliques of an
undirected graph", CACM 16 (9): 575-577, 1973. <a href="http://dl.acm.org/citation.cfm?id=362367&bnc=1">http://dl.acm.org/citation.cfm?id=362367&amp;bnc=1</a>.</p>
<p>Keywords: undirected graph, clique, clique cover, Bron, Kerbosch.</p>
<p>You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div></div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Graph connectivity algorithm for undirected graphs. Memory consumption: O(n) where m is the number of arcs and n the number of nodes. </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd><p class="startdd">(user): add depth-first-search based connectivity for directed graphs. </p>
<p class="enddd">(user): add depth-first-search based biconnectivity for directed graphs. </p>
</dd></dl>
<p>You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div></div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. A few variations on a theme of the "star" graph representation by Ebert, as described in J. Ebert, "A versatile data structure for
edge-oriented graph algorithms." Communications of the ACM 30(6):513-519 (June 1987). <a href="http://portal.acm.org/citation.cfm?id=214769">http://portal.acm.org/citation.cfm?id=214769</a></p>
<p>In this file there are three representations that have much in common. The general one, called simply <a class="el" href="classoperations__research_1_1EbertGraph.html" title="Forward declarations.">EbertGraph</a>, contains both forward- and backward-star representations. The other, called <a class="el" href="classoperations__research_1_1ForwardEbertGraph.html" title="A forward-star-only graph representation for greater efficiency in those algorithms that don&#39;t need r...">ForwardEbertGraph</a>, contains only the forward-star representation of the graph, and is appropriate for applications where the reverse arcs are not needed.</p>
<p>The point of including all the representations in this one file is to capitalize, where possible, on the commonalities among them, and those commonalities are mostly factored out into base classes as described below. Despite the commonalities, however, each of the three representations presents a somewhat different interface because of their different underlying semantics. A quintessential example is that the AddArc() method, very natural for the <a class="el" href="classoperations__research_1_1EbertGraph.html" title="Forward declarations.">EbertGraph</a> representation, cannot exist for an inherently static representation like <a class="el" href="classoperations__research_1_1ForwardStaticGraph.html">ForwardStaticGraph</a>.</p>
<p>Many clients are expected to use the interfaces to the graph objects directly, but some clients are parameterized by graph type and need a consistent interface for their underlying graph objects. For such clients, a small library of class templates is provided to give a consistent interface to clients where the underlying graph interfaces differ. Examples are the AnnotatedGraphBuildManager&lt;&gt; template, which provides a uniform interface for building the various types of graphs; and the TailArrayManager&lt;&gt; template, which provides a uniform interface for applications that need to map from arc indices to arc tail nodes, accounting for the fact that such a mapping has to be requested explicitly from the <a class="el" href="classoperations__research_1_1ForwardStaticGraph.html">ForwardStaticGraph</a> and ForwardStarGraph representations.</p>
<p>There are two base class templates, <a class="el" href="classoperations__research_1_1StarGraphBase.html">StarGraphBase</a>, and <a class="el" href="classoperations__research_1_1EbertGraphBase.html" title="A template for the base class that holds the functionality that exists in common between the EbertGra...">EbertGraphBase</a>; their purpose is to hold methods and data structures that are in common among their descendants. Only classes that are leaves in the following hierarchy tree are eligible for free-standing instantiation and use by clients. The parentheses around <a class="el" href="classoperations__research_1_1StarGraphBase.html">StarGraphBase</a> and <a class="el" href="classoperations__research_1_1EbertGraphBase.html" title="A template for the base class that holds the functionality that exists in common between the EbertGra...">EbertGraphBase</a> indicate that they should not normally be instantiated by clients: </p><div class="fragment"><div class="line">               (StarGraphBase)                       |</div><div class="line">                 /         \                         |</div><div class="line">                /           \                        |</div><div class="line">               /             \                       |</div><div class="line">              /               \                      |</div><div class="line">     (EbertGraphBase)     ForwardStaticGraph         |</div><div class="line">      /            \                                 |</div><div class="line">     /              \                                |</div><div class="line">EbertGraph     ForwardEbertGraph                     |</div></div><!-- fragment --><p> In the general <a class="el" href="classoperations__research_1_1EbertGraph.html" title="Forward declarations.">EbertGraph</a> case, the graph is represented with three arrays. Let n be the number of nodes and m be the number of arcs. Let i be an integer in [0..m-1], denoting the index of an arc.</p><ul>
<li>head_[i] contains the end-node of arc i,</li>
<li>head_[-i-1] contains the start-node of arc i. <dl class="section note"><dt>Note</dt><dd>in two's-complement arithmetic, -i-1 = ~i. Consequently:</dd></dl>
</li>
<li>head_[~i] contains the end-node of the arc reverse to arc i,</li>
<li>head_[i] contains the start-node of the arc reverse to arc i. <dl class="section note"><dt>Note</dt><dd>if arc (u, v) is defined, then the data structure also stores (v, u). Arc ~i thus denotes the arc reverse to arc i. This is what makes this representation useful for undirected graphs and for implementing algorithms like bidirectional shortest paths. Also note that the representation handles multi-graphs. If several arcs going from node u to node v are added to the graph, they will be handled as separate arcs.</dd></dl>
Now, for an integer u in [0..n-1] denoting the index of a node:</li>
<li>first_incident_arc_[u] denotes the first arc in the adjacency list of u.</li>
<li>going from an arc i, the adjacency list can be traversed using j = next_adjacent_arc_[i].</li>
</ul>
<p>The <a class="el" href="classoperations__research_1_1EbertGraph.html" title="Forward declarations.">EbertGraph</a> implementation has the following benefits:</p><ul>
<li>It is able to handle both directed or undirected graphs.</li>
<li>Being based on indices, it is easily serializable. Only the contents of the head_ array need to be stored. Even so, serialization is currently not implemented.</li>
<li>The node indices and arc indices can be stored in 32 bits, while still allowing to go a bit further than the 4-gigabyte limitation (48 gigabytes for a pure graph, without capacities or costs.)</li>
<li>The representation can be recomputed if edges have been loaded from</li>
<li>The representation can be recomputed if edges have been loaded from external memory or if edges have been re-ordered.</li>
<li>The memory consumption is: 2 * m * sizeof(NodeIndexType)<ul>
<li>2 * m * sizeof(ArcIndexType)</li>
<li>n * sizeof(ArcIndexType) plus a small constant.</li>
</ul>
</li>
</ul>
<p>The <a class="el" href="classoperations__research_1_1EbertGraph.html" title="Forward declarations.">EbertGraph</a> implementation differs from the implementation described in [Ebert 1987] in the following respects:</p><ul>
<li>arcs are represented using an (i, ~i) approach, whereas Ebert used (i, -i). Indices for direct arcs thus start at 0, in a fashion that is compatible with the index numbering in C and C++. Note that we also tested a (2*i, 2*i+1) storage pattern, which did not show any speed benefit, and made the use of the API much more difficult.</li>
<li>because of this, the 'nil' values for nodes and arcs are not 0, as Ebert first described. The value for the 'nil' node is set to -1, while the value for the 'nil' arc is set to the smallest integer representable with ArcIndexSize bytes.</li>
<li>it is possible to add arcs to the graph, with AddArc, in a much simpler way than described by Ebert.</li>
<li><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000007">Todo:</a></b></dt><dd>(user) although it is already possible, using the GroupForwardArcsByFunctor method, to group all the outgoing (resp. incoming) arcs of a node, the iterator logic could still be improved to allow traversing the outgoing (resp. incoming) arcs in O(out_degree(node)) (resp. O(in_degree(node))) instead of O(degree(node)).</dd></dl>
</li>
</ul>
<p>The <a class="el" href="classoperations__research_1_1ForwardEbertGraph.html" title="A forward-star-only graph representation for greater efficiency in those algorithms that don&#39;t need r...">ForwardEbertGraph</a> representation is like the <a class="el" href="classoperations__research_1_1EbertGraph.html" title="Forward declarations.">EbertGraph</a> case described above, with the following modifications:</p><ul>
<li>The part of the head_[] array with negative indices is absent. In its place is a pointer tail_ which, if assigned, points to an array of tail nodes indexed by (nonnegative) arc index. In typical usage tail_ is NULL and the memory for the tail nodes need not be allocated.</li>
<li>The array of arc tails can be allocated as needed and populated from the adjacency lists of the graph.</li>
<li>Representing only the forward star of each node implies that the graph cannot be serialized directly nor rebuilt from scratch from just the head_ array. Rebuilding from scratch requires constructing the array of arc tails from the adjacency lists first, and serialization can be done either by first constructing the array of arc tails from the adjacency lists, or by serializing directly from the adjacency lists.</li>
<li>The memory consumption is: m * sizeof(NodeIndexType)<ul>
<li>m * sizeof(ArcIndexType)</li>
<li>n * sizeof(ArcIndexType) plus a small constant when the array of arc tails is absent. Allocating the arc tail array adds another m * sizeof(NodeIndexType).</li>
</ul>
</li>
</ul>
<p>The <a class="el" href="classoperations__research_1_1ForwardStaticGraph.html">ForwardStaticGraph</a> representation is restricted yet farther than <a class="el" href="classoperations__research_1_1ForwardEbertGraph.html" title="A forward-star-only graph representation for greater efficiency in those algorithms that don&#39;t need r...">ForwardEbertGraph</a>, with the benefit that it provides higher performance to those applications that can use it.</p><ul>
<li>As with <a class="el" href="classoperations__research_1_1ForwardEbertGraph.html" title="A forward-star-only graph representation for greater efficiency in those algorithms that don&#39;t need r...">ForwardEbertGraph</a>, the presence of the array of arc tails is optional.</li>
<li>The outgoing adjacency list for each node is stored in a contiguous segment of the head_[] array, obviating the next_adjacent_arc_ structure entirely and ensuring good locality of reference for applications that iterate over outgoing adjacency lists.</li>
<li>The memory consumption is: m * sizeof(NodeIndexType)<ul>
<li>n * sizeof(ArcIndexType) plus a small constant when the array of arc tails is absent. Allocating the arc tail array adds another m * sizeof(NodeIndexType).</li>
</ul>
</li>
</ul>
<p>You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div></div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Utility to build Eulerian paths and tours on a graph. For more information, see <a href="https://en.wikipedia.org/wiki/Eulerian_path">https://en.wikipedia.org/wiki/Eulerian_path</a>. As of 10/2015, only undirected graphs are supported.</p>
<p>Usage:</p><ul>
<li>Building an Eulerian tour on a ReverseArcListGraph: ReverseArcListGraph&lt;int, int&gt; graph; ///&lt; Fill graph std::vector&lt;int&gt; tour = BuildEulerianTour(graph);</li>
<li>Building an Eulerian path on a ReverseArcListGraph: ReverseArcListGraph&lt;int, int&gt; graph; ///&lt; Fill graph std::vector&lt;int&gt; tour = BuildEulerianPath(graph);</li>
</ul>
<p>You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div></div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Temporary utility class needed as long as we have two slightly different graph interface: The one in <a class="el" href="ebert__graph_8h.html">ebert_graph.h</a> and the one in <a class="el" href="graph_8h.html">graph.h</a></p>
<p>You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div></div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Solves the Shortest Hamiltonian Path Problem using a complete algorithm. The algorithm was first described in M. Held, R.M. Karp, A dynamic programming approach to sequencing problems, J. SIAM 10 (1962) 196-210</p>
<p>The Shortest Hamiltonian Path Problem (SHPP) is similar to the Traveling Salesperson Problem (TSP). You have to visit all the cities, starting from a given one and you do not need to return to your starting point. With the TSP, you can start anywhere, but you have to return to your start location.</p>
<p>By complete we mean that the algorithm guarantees to compute the optimal solution. The algorithm uses dynamic programming. Its time complexity is O(n^2 * 2^(n-1)), where n is the number of nodes to be visited, and '^' denotes exponentiation. Its space complexity is O(n * 2 ^ (n - 1)).</p>
<dl class="section note"><dt>Note</dt><dd>the naive implementation of the SHPP exploring all permutations without memorizing intermediate results would have a complexity of (n - 1)! (factorial of (n - 1) ), which is much higher than n^2 * 2^(n-1). To convince oneself of this, just use Stirling's formula: n! ~ sqrt(2 * pi * n)*( n / exp(1)) ^ n. Because of these complexity figures, the algorithm is not practical for problems with more than 20 nodes.</dd></dl>
<p>Here is how the algorithm works: Let us denote the nodes to be visited by their indices 0 .. n - 1 Let us pick 0 as the starting node. Let d(i,j) denote the distance (or cost) from i to j. f(S, j) where S is a set of nodes and j is a node in S is defined as follows: f(S, j) = min (i in S \ {j}, f(S \ {j}, i) + cost(i, j)) (j is an element of S) </p><dl class="section note"><dt>Note</dt><dd>this formulation, from the original Held-Karp paper is a bit different, but equivalent to the one used in Caseau and Laburthe, Solving Small TSPs with Constraints, 1997, ICLP f(S, j) = min (i in S, f(S \ {i}, i) + cost(i, j)) (j is not an element of S)</dd></dl>
<p>The advantage of the Held and Karp formulation is that it enables:</p><ul>
<li>to build the dynamic programming lattice layer by layer starting from the subsets with cardinality 1, and increasing the cardinality.</li>
<li>to traverse the dynamic programming lattice using sequential memory accesses, making the algorithm cache-friendly, and faster, despite the large amount of computation needed to get the position when f(S, j) is stored.</li>
<li><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000025">Todo:</a></b></dt><dd>(user): implement pruning procedures on top of the Held-Karp algorithm.</dd></dl>
</li>
</ul>
<p>The set S can be represented by an integer where bit i corresponds to element i in the set. In the following S denotes the integer corresponding to set S.</p>
<p>The dynamic programming iteration is implemented in the method Solve. The optimal value of the Hamiltonian path starting at 0 is given by min (i in S, f(2 ^ n - 1, i)) The optimal value of the Traveling Salesman tour is given by f(2 ^ n, 0). (There is actually no need to duplicate the first node, as all the paths are computed from node 0.)</p>
<p>To implement dynamic programming, we store the preceding results of computing f(S,j) in an array M[Offset(S,j)]. See the comments about <a class="el" href="classoperations__research_1_1LatticeMemoryManager.html#a5369cd69622c4264ffcf11a2d5006ecd" title="Returns the base offset in memory for f(s, node), with node contained in s.">LatticeMemoryManager::BaseOffset()</a> to see how this is computed.</p>
<p>Keywords: Traveling Salesman, Hamiltonian Path, Dynamic Programming, Held, Karp.</p>
<p>You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div></div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. An implementation of a push-relabel algorithm for the max flow problem.</p>
<p>In the following, we consider a graph G = (V,E,s,t) where V denotes the set of nodes (vertices) in the graph, E denotes the set of arcs (edges). s and t denote distinguished nodes in G called source and target. n = <code>V</code> denotes the number of nodes in the graph, and m = <code>E</code> denotes the number of arcs in the graph.</p>
<p>Each arc (v,w) is associated a capacity c(v,w).</p>
<p>A flow is a function from E to R such that:</p>
<p>a) f(v,w) &lt;= c(v,w) for all (v,w) in E (capacity constraint.)</p>
<p>b) f(v,w) = -f(w,v) for all (v,w) in E (flow antisymmetry constraint.)</p>
<p>c) sum on v f(v,w) = 0 (flow conservation.)</p>
<p>The goal of this algorithm is to find the maximum flow from s to t, i.e. for example to maximize sum v f(s,v).</p>
<p>The starting reference for this class of algorithms is: A.V. Goldberg and R.E. Tarjan. A new approach to the maximum flow problem. ACM Symposium on Theory of Computing, pp. 136-146. <a href="http://portal.acm.org/citation.cfm?id=12144">http://portal.acm.org/citation.cfm?id=12144</a>.</p>
<p>The basic idea of the algorithm is to handle preflows instead of flows, and to refine preflows until a maximum flow is obtained. A preflow is like a flow, except that the inflow can be larger than the outflow. If it is the case at a given node v, it is said that there is an excess at node v, and inflow = outflow + excess.</p>
<p>More formally, a preflow is a function f such that:</p>
<p>1) f(v,w) &lt;= c(v,w) for all (v,w) in E (capacity constraint). c(v,w) is a value representing the maximum capacity for arc (v,w).</p>
<p>2) f(v,w) = -f(w,v) for all (v,w) in E (flow antisymmetry constraint)</p>
<p>3) excess(v) = sum on u f(u,v) &gt;= 0 is the excess at node v, the algebraic sum of all the incoming preflows at this node.</p>
<p>Each node has an associated "height", in addition to its excess. The height of the source is defined to be equal to n, and cannot change. The height of the target is defined to be zero, and cannot change either. The height of all the other nodes is initialized at zero and is updated during the algorithm (see below). For those who want to know the details, the height of a node, corresponds to a reduced cost, and this enables one to prove that the algorithm actually computes the max flow. Note that the height of a node can be initialized to the distance to the target node in terms of number of nodes. This has not been tried in this implementation.</p>
<p>A node v is said to be <em>active</em> if excess(v) &gt; 0.</p>
<p>In this case the following operations can be applied to it:</p>
<ul>
<li>if there are <em>admissible</em> incident arcs, i.e. arcs which are not saturated, and whose head's height is lower than the height of the active node considered, a PushFlow operation can be applied. It consists in sending as much flow as both the excess at the node and the capacity of the arc permit.</li>
<li>if there are no admissible arcs, the active node considered is relabeled, i.e. its height is increased to 1 + the minimum height of its neighboring nodes on admissible arcs. This is implemented in Discharge, which itself calls PushFlow and Relabel.</li>
</ul>
<p>Before running Discharge, it is necessary to initialize the algorithm with a preflow. This is done in InitializePreflow, which saturates all the arcs leaving the source node, and sets the excess at the heads of those arcs accordingly.</p>
<p>The algorithm terminates when there are no remaining active nodes, i.e. all the excesses at all nodes are equal to zero. In this case, a maximum flow is obtained.</p>
<p>The complexity of this algorithm depends amongst other things on the choice of the next active node. It has been shown, for example in: L. Tuncel, "On the Complexity of Preflow-Push Algorithms for Maximum-Flow
Problems", Algorithmica 11(4): 353-359 (1994). and J. Cheriyan and K. Mehlhorn, "An analysis of the highest-level selection rule
in the preflow-push max-flow algorithm", Information processing letters, 69(5):239-242 (1999). <a href="http://www.math.uwaterloo.ca/~jcheriya/PS_files/me3.0.ps">http://www.math.uwaterloo.ca/~jcheriya/PS_files/me3.0.ps</a></p>
<p>...that choosing the active node with the highest level yields a complexity of O(n^2 * sqrt(m)).</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000040">Todo:</a></b></dt><dd>(user): implement the above active node choice rule.</dd></dl>
<p>This has been validated experimentally in: R.K. Ahuja, M. Kodialam, A.K. Mishra, and J.B. Orlin, "Computational
Investigations of Maximum Flow Algorithms", EJOR 97:509-542(1997). <a href="http://jorlin.scripts.mit.edu/docs/publications/58-comput%20investigations%20of.pdf">http://jorlin.scripts.mit.edu/docs/publications/58-comput%20investigations%20of.pdf</a>.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000041">Todo:</a></b></dt><dd>(user): an alternative would be to evaluate: A.V. Goldberg, "The Partial Augment-Relabel Algorithm for the Maximum Flow Problem. In Proceedings of Algorithms ESA, LNCS 5193:466-477, Springer 2008. <a href="http://www.springerlink.com/index/5535k2j1mt646338.pdf">http://www.springerlink.com/index/5535k2j1mt646338.pdf</a></dd></dl>
<p>An interesting general reference on network flows is: R. K. Ahuja, T. L. Magnanti, J. B. Orlin, "Network Flows: Theory, Algorithms,
and Applications," Prentice Hall, 1993, ISBN: 978-0136175490, <a href="http://www.amazon.com/dp/013617549X">http://www.amazon.com/dp/013617549X</a></p>
<p>Keywords: Push-relabel, max-flow, network, graph, Goldberg, Tarjan, Dinic, Dinitz.</p>
<p>You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div></div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. An implementation of a cost-scaling push-relabel algorithm for the min-cost flow problem.</p>
<p>In the following, we consider a graph G = (V,E) where V denotes the set of nodes (vertices) in the graph, E denotes the set of arcs (edges). n = <code>V</code> denotes the number of nodes in the graph, and m = <code>E</code> denotes the number of arcs in the graph.</p>
<p>With each arc (v,w) is associated a nonnegative capacity u(v,w) (where 'u' stands for "upper bound") and a unit cost c(v,w). With each node v is associated a quantity named supply(v), which represents a supply of fluid (if &gt;0) or a demand (if &lt;0). Furthermore, no fluid is created in the graph so sum_{v in V} supply(v) = 0.</p>
<p>A flow is a function from E to R such that: a) f(v,w) &lt;= u(v,w) for all (v,w) in E (capacity constraint). b) f(v,w) = -f(w,v) for all (v,w) in E (flow antisymmetry constraint). c) sum on v f(v,w) + supply(w) = 0 (flow conservation).</p>
<p>The cost of a flow is sum on (v,w) in E ( f(v,w) * c(v,w) ) [Note: It can be confusing to beginners that the cost is actually double the amount that it might seem at first because of flow antisymmetry.]</p>
<p>The problem to solve: find a flow of minimum cost such that all the fluid flows from the supply nodes to the demand nodes.</p>
<p>The principles behind this algorithm are the following: 1/ handle pseudo-flows instead of flows and refine pseudo-flows until an epsilon-optimal minimum-cost flow is obtained, 2/ deal with epsilon-optimal pseudo-flows.</p>
<p>1/ A pseudo-flow is like a flow, except that a node's outflow minus its inflow can be different from its supply. If it is the case at a given node v, it is said that there is an excess (or deficit) at node v. A deficit is denoted by a negative excess and inflow = outflow + excess. (Look at <a class="el" href="max__flow_8h.html">ortools/graph/max_flow.h</a> to see that the definition of preflow is more restrictive than the one for pseudo-flow in that a preflow only allows non-negative excesses, i.e., no deficit.) More formally, a pseudo-flow is a function f such that: a) f(v,w) &lt;= u(v,w) for all (v,w) in E (capacity constraint). b) f(v,w) = -f(w,v) for all (v,w) in E (flow antisymmetry constraint).</p>
<p>For each v in E, we also define the excess at node v, the algebraic sum of all the incoming preflows at this node, added together with the supply at v. excess(v) = sum on u f(u,v) + supply(v)</p>
<p>The goal of the algorithm is to obtain excess(v) = 0 for all v in V, while consuming capacity on some arcs, at the lowest possible cost.</p>
<p>2/ Internally to the algorithm and its analysis (but invisibly to the client), each node has an associated "price" (or potential), in addition to its excess. It is formally a function from E to R (the set of real numbers.). For a given price function p, the reduced cost of an arc (v,w) is: c_p(v,w) = c(v,w) + p(v) - p(w) (c(v,w) is the cost of arc (v,w).) For those familiar with linear programming, the price function can be viewed as a set of dual variables.</p>
<p>For a constant epsilon &gt;= 0, a pseudo-flow f is said to be epsilon-optimal with respect to a price function p if for every residual arc (v,w) in E, c_p(v,w) &gt;= -epsilon.</p>
<p>A flow f is optimal if and only if there exists a price function p such that no arc is admissible with respect to f and p.</p>
<p>If the arc costs are integers, and epsilon &lt; 1/n, any epsilon-optimal flow is optimal. The integer cost case is handled by multiplying all the arc costs and the initial value of epsilon by (n+1). When epsilon reaches 1, and the solution is epsilon-optimal, it means: for all residual arc (v,w) in E, (n+1) * c_p(v,w) &gt;= -1, thus c_p(v,w) &gt;= -1/(n+1) &gt;= 1/n, and the solution is optimal.</p>
<p>A node v is said to be <em>active</em> if excess(v) &gt; 0. In this case the following operations can be applied to it:</p><ul>
<li>if there are <em>admissible</em> incident arcs, i.e. arcs which are not saturated, and whose reduced costs are negative, a PushFlow operation can be applied. It consists in sending as much flow as both the excess at the node and the capacity of the arc permit.</li>
<li>if there are no admissible arcs, the active node considered is relabeled, This is implemented in Discharge, which itself calls PushFlow and Relabel.</li>
</ul>
<p>Discharge itself is called by Refine. Refine first saturates all the admissible arcs, then builds a stack of active nodes. It then applies Discharge for each active node, possibly adding new ones in the process, until no nodes are active. In that case an epsilon-optimal flow is obtained.</p>
<p>Optimize iteratively calls Refine, while epsilon &gt; 1, and divides epsilon by alpha (set by default to 5) before each iteration.</p>
<p>The algorithm starts with epsilon = C, where C is the maximum absolute value of the arc costs. In the integer case which we are dealing with, since all costs are multiplied by (n+1), the initial value of epsilon is (n+1)*C. The algorithm terminates when epsilon = 1, and Refine() has been called. In this case, a minimum-cost flow is obtained.</p>
<p>The complexity of the algorithm is O(n^2*m*log(n*C)) where C is the value of the largest arc cost in the graph.</p>
<p>IMPORTANT: The algorithm is not able to detect the infeasibility of a problem (i.e., when a bottleneck in the network prohibits sending all the supplies.) Worse, it could in some cases loop forever. This is why feasibility checking is enabled by default (FLAGS_min_cost_flow_check_feasibility=true.) Feasibility checking is implemented using a max-flow, which has a much lower complexity. The impact on performance is negligible, while the risk of being caught in an endless loop is removed. Note that using the feasibility checker roughly doubles the memory consumption.</p>
<p>The starting reference for this class of algorithms is: A.V. Goldberg and R.E. Tarjan, "Finding Minimum-Cost Circulations by
Successive Approximation." Mathematics of Operations Research, Vol. 15, 1990:430-466. <a href="http://portal.acm.org/citation.cfm?id=92225">http://portal.acm.org/citation.cfm?id=92225</a></p>
<p>Implementation issues are tackled in: A.V. Goldberg, "An Efficient Implementation of a Scaling Minimum-Cost Flow
Algorithm," Journal of Algorithms, (1997) 22:1-29 <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.31.258">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.31.258</a></p>
<p>A.V. Goldberg and M. Kharitonov, "On Implementing Scaling Push-Relabel
Algorithms for the Minimum-Cost Flow Problem", Network flows and matching: First DIMACS implementation challenge, DIMACS Series in Discrete Mathematics and Theoretical Computer Science, (1993) 12:157-198. <a href="ftp://dimacs.rutgers.edu/pub/netflow/submit/papers/Goldberg-mincost/scalmin.ps">ftp://dimacs.rutgers.edu/pub/netflow/submit/papers/Goldberg-mincost/scalmin.ps</a> and in: U. Bunnagel, B. Korte, and J. Vygen. Efficient implementation of the Goldberg-Tarjan minimum-cost flow algorithm. Optimization Methods and Software (1998) vol. 10, no. 2:157-174. <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.84.9897">http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.84.9897</a></p>
<p>We have tried as much as possible in this implementation to keep the notations and namings of the papers cited above, except for 'demand' or 'balance' which have been replaced by 'supply', with the according sign changes to better accommodate with the API of the rest of our tools. A demand is denoted by a negative supply.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000048">Todo:</a></b></dt><dd>(user): See whether the following can bring any improvements on real-life problems. R.K. Ahuja, A.V. Goldberg, J.B. Orlin, and R.E. Tarjan, "Finding minimum-cost
flows by double scaling," Mathematical Programming, (1992) 53:243-266. <a href="http://www.springerlink.com/index/gu7404218u6kt166.pdf">http://www.springerlink.com/index/gu7404218u6kt166.pdf</a></dd></dl>
<p>An interesting general reference on network flows is: R. K. Ahuja, T. L. Magnanti, J. B. Orlin, "Network Flows: Theory, Algorithms,
and Applications," Prentice Hall, 1993, ISBN: 978-0136175490, <a href="http://www.amazon.com/dp/013617549X">http://www.amazon.com/dp/013617549X</a></p>
<p>Keywords: Push-relabel, min-cost flow, network, graph, Goldberg, Tarjan, Dinic, Dinitz.</p>
<p>You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div></div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>
<p>You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div></div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. This file contains various shortest paths utilities.</p>
<p>Keywords: directed graph, cheapest path, shortest path, Dijkstra, spp. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a31d858394c5eed1fa21edc3da47047c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31d858394c5eed1fa21edc3da47047c1">&#9670;&nbsp;</a></span>ArcIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int32 <a class="el" href="namespaceoperations__research.html#a31d858394c5eed1fa21edc3da47047c1">operations_research::ArcIndex</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ebert__graph_8h_source.html#l00201">201</a> of file <a class="el" href="ebert__graph_8h_source.html">ebert_graph.h</a>.</p>

</div>
</div>
<a id="aa79bf252fa6483cd33cbf95170353fb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa79bf252fa6483cd33cbf95170353fb0">&#9670;&nbsp;</a></span>ArcIndexArray</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ZVector&lt;<a class="el" href="namespaceoperations__research.html#a31d858394c5eed1fa21edc3da47047c1">ArcIndex</a>&gt; <a class="el" href="namespaceoperations__research.html#aa79bf252fa6483cd33cbf95170353fb0">operations_research::ArcIndexArray</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ebert__graph_8h_source.html#l00208">208</a> of file <a class="el" href="ebert__graph_8h_source.html">ebert_graph.h</a>.</p>

</div>
</div>
<a id="afdee62ecefa0520e530c18a55b083e6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdee62ecefa0520e530c18a55b083e6d">&#9670;&nbsp;</a></span>CostArray</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ZVector&lt;<a class="el" href="namespaceoperations__research.html#aa7950685633ee869aa9471b2ec5fbcfa">CostValue</a>&gt; <a class="el" href="namespaceoperations__research.html#afdee62ecefa0520e530c18a55b083e6d">operations_research::CostArray</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ebert__graph_8h_source.html#l00210">210</a> of file <a class="el" href="ebert__graph_8h_source.html">ebert_graph.h</a>.</p>

</div>
</div>
<a id="aa7950685633ee869aa9471b2ec5fbcfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7950685633ee869aa9471b2ec5fbcfa">&#9670;&nbsp;</a></span>CostValue</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int64 <a class="el" href="namespaceoperations__research.html#aa7950685633ee869aa9471b2ec5fbcfa">operations_research::CostValue</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ebert__graph_8h_source.html#l00203">203</a> of file <a class="el" href="ebert__graph_8h_source.html">ebert_graph.h</a>.</p>

</div>
</div>
<a id="a5841ff601ab08548afb15c45b2245de7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5841ff601ab08548afb15c45b2245de7">&#9670;&nbsp;</a></span>FlowQuantity</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int64 <a class="el" href="namespaceoperations__research.html#a5841ff601ab08548afb15c45b2245de7">operations_research::FlowQuantity</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ebert__graph_8h_source.html#l00202">202</a> of file <a class="el" href="ebert__graph_8h_source.html">ebert_graph.h</a>.</p>

</div>
</div>
<a id="a652af62fa5f211aa0c54d7994ca1c504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a652af62fa5f211aa0c54d7994ca1c504">&#9670;&nbsp;</a></span>ForwardStarGraph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classoperations__research_1_1ForwardEbertGraph.html">ForwardEbertGraph</a>&lt;<a class="el" href="namespaceoperations__research.html#a0e629e35bfa311b31dd7f5065eb834bb">NodeIndex</a>, <a class="el" href="namespaceoperations__research.html#a31d858394c5eed1fa21edc3da47047c1">ArcIndex</a>&gt; <a class="el" href="namespaceoperations__research.html#a652af62fa5f211aa0c54d7994ca1c504">operations_research::ForwardStarGraph</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ebert__graph_8h_source.html#l00205">205</a> of file <a class="el" href="ebert__graph_8h_source.html">ebert_graph.h</a>.</p>

</div>
</div>
<a id="ac7440a08c859325694df19d4d4aee95c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7440a08c859325694df19d4d4aee95c">&#9670;&nbsp;</a></span>ForwardStarStaticGraph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classoperations__research_1_1ForwardStaticGraph.html">ForwardStaticGraph</a>&lt;<a class="el" href="namespaceoperations__research.html#a0e629e35bfa311b31dd7f5065eb834bb">NodeIndex</a>, <a class="el" href="namespaceoperations__research.html#a31d858394c5eed1fa21edc3da47047c1">ArcIndex</a>&gt; <a class="el" href="namespaceoperations__research.html#ac7440a08c859325694df19d4d4aee95c">operations_research::ForwardStarStaticGraph</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ebert__graph_8h_source.html#l00206">206</a> of file <a class="el" href="ebert__graph_8h_source.html">ebert_graph.h</a>.</p>

</div>
</div>
<a id="a0e629e35bfa311b31dd7f5065eb834bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e629e35bfa311b31dd7f5065eb834bb">&#9670;&nbsp;</a></span>NodeIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int32 <a class="el" href="namespaceoperations__research.html#a0e629e35bfa311b31dd7f5065eb834bb">operations_research::NodeIndex</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Standard instantiation of <a class="el" href="classoperations__research_1_1ForwardEbertGraph.html" title="A forward-star-only graph representation for greater efficiency in those algorithms that don&#39;t need r...">ForwardEbertGraph</a> (named 'ForwardStarGraph') of <a class="el" href="classoperations__research_1_1EbertGraph.html" title="Forward declarations.">EbertGraph</a> (named 'StarGraph'); and relevant type shortcuts. </p>
<p>Unless their use cases prevent them from doing so, users are encouraged to use StarGraph or ForwardStarGraph according to whether or not they require reverse arcs to be represented explicitly. Along with either graph representation, the other type shortcuts here will often come in handy. </p>

<p class="definition">Definition at line <a class="el" href="ebert__graph_8h_source.html#l00192">192</a> of file <a class="el" href="ebert__graph_8h_source.html">ebert_graph.h</a>.</p>

</div>
</div>
<a id="a389e5320fb5bcd0fb99d894488f9820b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a389e5320fb5bcd0fb99d894488f9820b">&#9670;&nbsp;</a></span>NodeIndexArray</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ZVector&lt;<a class="el" href="namespaceoperations__research.html#a0e629e35bfa311b31dd7f5065eb834bb">NodeIndex</a>&gt; <a class="el" href="namespaceoperations__research.html#a389e5320fb5bcd0fb99d894488f9820b">operations_research::NodeIndexArray</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ebert__graph_8h_source.html#l00207">207</a> of file <a class="el" href="ebert__graph_8h_source.html">ebert_graph.h</a>.</p>

</div>
</div>
<a id="a09767b3634289e432c3ce1d7c649666a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09767b3634289e432c3ce1d7c649666a">&#9670;&nbsp;</a></span>PathNodeIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef int <a class="el" href="namespaceoperations__research.html#a09767b3634289e432c3ce1d7c649666a">operations_research::PathNodeIndex</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="deprecated"><dt><b><a class="el" href="deprecated.html#_deprecated000004">Deprecated:</a></b></dt><dd>type. </dd></dl>

<p class="definition">Definition at line <a class="el" href="hamiltonian__path_8h_source.html#l00450">450</a> of file <a class="el" href="hamiltonian__path_8h_source.html">hamiltonian_path.h</a>.</p>

</div>
</div>
<a id="a7d4fc0319cb4e28ec175fc9163775a6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4fc0319cb4e28ec175fc9163775a6e">&#9670;&nbsp;</a></span>QuantityArray</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef ZVector&lt;<a class="el" href="namespaceoperations__research.html#a5841ff601ab08548afb15c45b2245de7">FlowQuantity</a>&gt; <a class="el" href="namespaceoperations__research.html#a7d4fc0319cb4e28ec175fc9163775a6e">operations_research::QuantityArray</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ebert__graph_8h_source.html#l00209">209</a> of file <a class="el" href="ebert__graph_8h_source.html">ebert_graph.h</a>.</p>

</div>
</div>
<a id="ae39f15b318a3cba17b1e60e6da51c0d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae39f15b318a3cba17b1e60e6da51c0d4">&#9670;&nbsp;</a></span>StarGraph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classoperations__research_1_1EbertGraph.html">EbertGraph</a>&lt;<a class="el" href="namespaceoperations__research.html#a0e629e35bfa311b31dd7f5065eb834bb">NodeIndex</a>, <a class="el" href="namespaceoperations__research.html#a31d858394c5eed1fa21edc3da47047c1">ArcIndex</a>&gt; <a class="el" href="namespaceoperations__research.html#ae39f15b318a3cba17b1e60e6da51c0d4">operations_research::StarGraph</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ebert__graph_8h_source.html#l00204">204</a> of file <a class="el" href="ebert__graph_8h_source.html">ebert_graph.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a708cf34b342e7d2ed89a3b73dbec4eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a708cf34b342e7d2ed89a3b73dbec4eae">&#9670;&nbsp;</a></span>BronKerboschAlgorithmStatus</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceoperations__research.html#a708cf34b342e7d2ed89a3b73dbec4eae">operations_research::BronKerboschAlgorithmStatus</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The status value returned by <a class="el" href="classoperations__research_1_1BronKerboschAlgorithm.html#a6dcb077f31531cc17c94da3364b6f099" title="Runs the Bron-Kerbosch algorithm for kint64max iterations.">BronKerboschAlgorithm::Run</a> and <a class="el" href="classoperations__research_1_1BronKerboschAlgorithm.html#a14b12a4c5ea291009f47c1a98c458f81" title="Runs at most &#39;max_num_iterations&#39; iterations of the Bron-Kerbosch algorithm.">BronKerboschAlgorithm::RunIterations</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a708cf34b342e7d2ed89a3b73dbec4eaea8f7afecbc8fbc4cd0f50a57d1172482e"></a>COMPLETED&#160;</td><td class="fielddoc"><p>The algorithm has enumerated all maximal cliques. </p>
</td></tr>
<tr><td class="fieldname"><a id="a708cf34b342e7d2ed89a3b73dbec4eaea658f2cadfdf09b6046246e9314f7cd43"></a>INTERRUPTED&#160;</td><td class="fielddoc"><p>The search algorithm was interrupted either because it reached the iteration limit or because the clique callback returned <a class="el" href="namespaceoperations__research.html#af2d89e69d073dc3036a6de24710b416fa615a46af313786fc4e349f34118be111" title="The algorithm will stop the search immediately.">CliqueResponse::STOP</a>. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="cliques_8h_source.html#l00068">68</a> of file <a class="el" href="cliques_8h_source.html">cliques.h</a>.</p>

</div>
</div>
<a id="af2d89e69d073dc3036a6de24710b416f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d89e69d073dc3036a6de24710b416f">&#9670;&nbsp;</a></span>CliqueResponse</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceoperations__research.html#af2d89e69d073dc3036a6de24710b416f">operations_research::CliqueResponse</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Possible return values of the callback for reporting cliques. </p>
<p>The returned value determines whether the algorithm will continue the search. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af2d89e69d073dc3036a6de24710b416fa2f453cfe638e57e27bb0c9512436111e"></a>CONTINUE&#160;</td><td class="fielddoc"><p>The algorithm will continue searching for other maximal cliques. </p>
</td></tr>
<tr><td class="fieldname"><a id="af2d89e69d073dc3036a6de24710b416fa615a46af313786fc4e349f34118be111"></a>STOP&#160;</td><td class="fielddoc"><p>The algorithm will stop the search immediately. </p>
<p>The search can be resumed by calling <a class="el" href="classoperations__research_1_1BronKerboschAlgorithm.html#a6dcb077f31531cc17c94da3364b6f099" title="Runs the Bron-Kerbosch algorithm for kint64max iterations.">BronKerboschAlgorithm::Run</a> (resp. RunIterations) again. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="cliques_8h_source.html#l00058">58</a> of file <a class="el" href="cliques_8h_source.html">cliques.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="acff272be25bcf9641218c05c59ec1a4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acff272be25bcf9641218c05c59ec1a4e">&#9670;&nbsp;</a></span>AStarShortestPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::AStarShortestPath </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; int64(int, int)&gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; int64(int)&gt;&#160;</td>
          <td class="paramname"><em>heuristic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>disconnected_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A* Shortest path with function based description of the graph. </p>
<p>The graph function returns the distance between two nodes, a distance of 'disconnected_distance' indicates no arcs between these two nodes. Additionally, the heuristic callback returns a an approximate distance between the node and the target, which guides the search. If the heuristic is admissible (ie. never overestimates cost), the A* algorithm returns an optimal solution. This function returns true if 'start_node' and 'end_node' are connected, false otherwise. </p>

</div>
</div>
<a id="ad5bfec6ea714171fbff2d8b791d0d286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5bfec6ea714171fbff2d8b791d0d286">&#9670;&nbsp;</a></span>BellmanFordShortestPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::BellmanFordShortestPath </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; int64(int, int)&gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>disconnected_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Bellman-Ford Shortest path with callback-based description of the graph. </p>
<p>The callback returns the distance between two nodes, a distance of 'disconnected_distance' indicates no arcs between these two nodes. Ownership of the callback is taken by the function that will delete it in the end. This function returns true if 'start_node' and 'end_node' are connected, false otherwise. If true, it will fill the 'nodes' vector with the sequence of nodes on the shortest path between 'start_node' and 'end_node'. </p>

</div>
</div>
<a id="a49b170b2d03863c465331e67b21f0c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49b170b2d03863c465331e67b21f0c33">&#9670;&nbsp;</a></span>BuildEulerianPath()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename Graph::NodeIndex&gt; operations_research::BuildEulerianPath </td>
          <td>(</td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds an Eulerian path/trail on an undirected graph. </p>
<p>This function works only on Reverse graphs (cf. <a class="el" href="graph_8h.html">ortools/graph/graph.h</a>). Returns an empty tour if a tour cannot be built. As of 10/2015, assumes the graph is connected. </p>

<p class="definition">Definition at line <a class="el" href="eulerian__path_8h_source.html#l00138">138</a> of file <a class="el" href="eulerian__path_8h_source.html">eulerian_path.h</a>.</p>

</div>
</div>
<a id="a743d8c9d6f64531bdeb7bbf18023e9d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a743d8c9d6f64531bdeb7bbf18023e9d4">&#9670;&nbsp;</a></span>BuildEulerianPathFromNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeIndex , typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespaceoperations__research.html#a0e629e35bfa311b31dd7f5065eb834bb">NodeIndex</a>&gt; operations_research::BuildEulerianPathFromNode </td>
          <td>(</td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceoperations__research.html#a0e629e35bfa311b31dd7f5065eb834bb">NodeIndex</a>&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds an Eulerian path/trail on an undirected graph starting from node root. </p>
<p>Supposes the graph is connected and is eulerian or semi-eulerian. This is an implementation of Hierholzer's algorithm. If m is the number of edges in the graph and n the number of nodes, time and memory complexity is O(n + m). </p>

<p class="definition">Definition at line <a class="el" href="eulerian__path_8h_source.html#l00074">74</a> of file <a class="el" href="eulerian__path_8h_source.html">eulerian_path.h</a>.</p>

</div>
</div>
<a id="a034666fe63ca105b735272974006362a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a034666fe63ca105b735272974006362a">&#9670;&nbsp;</a></span>BuildEulerianTour()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename Graph::NodeIndex&gt; operations_research::BuildEulerianTour </td>
          <td>(</td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as above but without specifying a start/end root node (node 0 is taken as default root). </p>

<p class="definition">Definition at line <a class="el" href="eulerian__path_8h_source.html#l00128">128</a> of file <a class="el" href="eulerian__path_8h_source.html">eulerian_path.h</a>.</p>

</div>
</div>
<a id="aa63055860fc53f8eed56d23d2571c180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa63055860fc53f8eed56d23d2571c180">&#9670;&nbsp;</a></span>BuildEulerianTourFromNode()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeIndex , typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="namespaceoperations__research.html#a0e629e35bfa311b31dd7f5065eb834bb">NodeIndex</a>&gt; operations_research::BuildEulerianTourFromNode </td>
          <td>(</td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceoperations__research.html#a0e629e35bfa311b31dd7f5065eb834bb">NodeIndex</a>&#160;</td>
          <td class="paramname"><em>root</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds an Eulerian tour/circuit/cycle starting and ending at node root on an undirected graph. </p>
<p>This function works only on Reverse graphs (cf. <a class="el" href="graph_8h.html">ortools/graph/graph.h</a>). Returns an empty tour if either root is invalid or if a tour cannot be built. As of 10/2015, assumes the graph is connected. </p>

<p class="definition">Definition at line <a class="el" href="eulerian__path_8h_source.html#l00116">116</a> of file <a class="el" href="eulerian__path_8h_source.html">eulerian_path.h</a>.</p>

</div>
</div>
<a id="aa565a47a059ef32ef1aec39768e4ec98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa565a47a059ef32ef1aec39768e4ec98">&#9670;&nbsp;</a></span>BuildKruskalMinimumSpanningTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph , typename ArcComparator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename Graph::ArcIndex&gt; operations_research::BuildKruskalMinimumSpanningTree </td>
          <td>(</td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArcComparator &amp;&#160;</td>
          <td class="paramname"><em>arc_comparator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Version taking an arc comparator to sort graph arcs. </p>
<p>Usage: ListGraph&lt;int, int&gt; graph(...); const auto arc_cost = [&amp;graph](int arc) { return f(graph.Tail(arc), graph.Head(arc)); }; std::vector&lt;int&gt; mst = BuildKruskalMinimumSpanningTree( graph, [&amp;arc_cost](int a, int b) { return arc_cost(a) &lt; arc_cost(b); }); </p>

<p class="definition">Definition at line <a class="el" href="minimum__spanning__tree_8h_source.html#l00091">91</a> of file <a class="el" href="minimum__spanning__tree_8h_source.html">minimum_spanning_tree.h</a>.</p>

</div>
</div>
<a id="a00ab79ee21ffd8dece0996e37f9faa7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00ab79ee21ffd8dece0996e37f9faa7a">&#9670;&nbsp;</a></span>BuildKruskalMinimumSpanningTreeFromSortedArcs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename Graph::ArcIndex&gt; operations_research::BuildKruskalMinimumSpanningTreeFromSortedArcs </td>
          <td>(</td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; typename Graph::ArcIndex &gt; &amp;&#160;</td>
          <td class="paramname"><em>sorted_arcs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of Kruskal's mininumum spanning tree algorithm (c.f. </p>
<p><a href="https://en.wikipedia.org/wiki/Kruskal%27s_algorithm">https://en.wikipedia.org/wiki/Kruskal%27s_algorithm</a>). Returns the index of the arcs appearing in the tree; will return a forest if the graph is disconnected. Nodes without any arcs will be ignored. Each arc of the graph is interpreted as an undirected arc. Complexity of the algorithm is O(E * log(E)) where E is the number of arcs in the graph. Memory usage is O(E * log(E)). </p><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000051">Todo:</a></b></dt><dd>(user): Add a global Minimum Spanning Tree API automatically switching between Prim and Kruskal depending on problem size.</dd></dl>
<p>Version taking sorted graph arcs. Allows somewhat incremental recomputation of minimum spanning trees as most of the processing time is spent sorting arcs. Usage: ListGraph&lt;int, int&gt; graph(...); std::vector&lt;int&gt; sorted_arcs = ...; std::vector&lt;int&gt; mst = BuildKruskalMinimumSpanningTreeFromSortedArcs( graph, sorted_arcs); </p>

<p class="definition">Definition at line <a class="el" href="minimum__spanning__tree_8h_source.html#l00050">50</a> of file <a class="el" href="minimum__spanning__tree_8h_source.html">minimum_spanning_tree.h</a>.</p>

</div>
</div>
<a id="acb53c505b8fd29ceb3abdcc7dfd809ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb53c505b8fd29ceb3abdcc7dfd809ce">&#9670;&nbsp;</a></span>BuildLineGraph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename GraphType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::BuildLineGraph </td>
          <td>(</td>
          <td class="paramtype">const GraphType &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">GraphType *const&#160;</td>
          <td class="paramname"><em>line_graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Builds a directed line graph for 'graph' (see "directed line graph" in <a href="http://en.wikipedia.org/wiki/Line_graph">http://en.wikipedia.org/wiki/Line_graph</a>). </p>
<p>Arcs of the original graph become nodes and the new graph contains only nodes created from arcs in the original graph (we use the notation (a-&gt;b) for these new nodes); the index of the node (a-&gt;b) in the new graph is exactly the same as the index of the arc a-&gt;b in the original graph. An arc from node (a-&gt;b) to node (c-&gt;d) in the new graph is added if and only if b == c in the original graph. This method expects that 'line_graph' is an empty graph (it has no nodes and no arcs). Returns false on an error. </p>
<p>Sizing then filling. </p>

<p class="definition">Definition at line <a class="el" href="ebert__graph_8h_source.html#l02088">2088</a> of file <a class="el" href="ebert__graph_8h_source.html">ebert_graph.h</a>.</p>

</div>
</div>
<a id="a33a2f4c26fd60cd0fa98257b571c974f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33a2f4c26fd60cd0fa98257b571c974f">&#9670;&nbsp;</a></span>BuildPrimMinimumSpanningTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph , typename ArcValue &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename Graph::ArcIndex&gt; operations_research::BuildPrimMinimumSpanningTree </td>
          <td>(</td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const ArcValue &amp;&#160;</td>
          <td class="paramname"><em>arc_value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementation of Prim's mininumum spanning tree algorithm (c.f. </p>
<p><a href="https://en.wikipedia.org/wiki/Prim's_algorithm">https://en.wikipedia.org/wiki/Prim's_algorithm</a>) on undirected connected graphs. Returns the index of the arcs appearing in the tree. Complexity of the algorithm is O(E * log(V)) where E is the number of arcs in the graph, V is the number of vertices. Memory usage is O(V) + memory taken by the graph. Usage: ListGraph&lt;int, int&gt; graph(...); const auto arc_cost = [&amp;graph](int arc) -&gt; int64 { return f(graph.Tail(arc), graph.Head(arc)); }; std::vector&lt;int&gt; mst = BuildPrimMinimumSpanningTree(graph, arc_cost); </p>
<p>This struct represents entries in the adjustable priority queue which maintains active nodes (not added to the tree yet) in decreasing insertion cost order. AdjustablePriorityQueue requires the existence of the SetHeapIndex and GetHeapIndex methods. </p>

<p class="definition">Definition at line <a class="el" href="minimum__spanning__tree_8h_source.html#l00117">117</a> of file <a class="el" href="minimum__spanning__tree_8h_source.html">minimum_spanning_tree.h</a>.</p>

</div>
</div>
<a id="a3175c0c8e9fc36a30b70b6b9c132474a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3175c0c8e9fc36a30b70b6b9c132474a">&#9670;&nbsp;</a></span>ComputeMinimumWeightMatchingWithMIP()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename WeightFunctionType , typename GraphType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;typename GraphType::ArcIndex&gt; operations_research::ComputeMinimumWeightMatchingWithMIP </td>
          <td>(</td>
          <td class="paramtype">const GraphType &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const WeightFunctionType &amp;&#160;</td>
          <td class="paramname"><em>weight</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes a minimum weight perfect matching on an undirected graph using a Mixed Integer Programming model. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>(user): Handle infeasible cases if this algorithm is used outside of Christofides. </dd></dl>
<p>The model is composed of Boolean decision variables to select matching arcs and constraints ensuring that each node appears in exactly one selected arc. The objective is to minimize the sum of the weights of selected arcs. It is assumed the graph is symmetrical.</p>
<p>Creating arc-selection Boolean variable.</p>
<p>Creating matching constraint: for all node i, sum(j) arc(i,j) + sum(j) arc(j,i) = 1 </p>

<p class="definition">Definition at line <a class="el" href="christofides_8h_source.html#l00107">107</a> of file <a class="el" href="christofides_8h_source.html">christofides.h</a>.</p>

</div>
</div>
<a id="afe4b5a6c0e4019314f288e3f4307c114"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe4b5a6c0e4019314f288e3f4307c114">&#9670;&nbsp;</a></span>CoverArcsByCliques()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::CoverArcsByCliques </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(int, int)&gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const std::vector&lt; int &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Covers the maximum number of arcs of the graph with cliques. </p>
<p>The graph is described by the graph callback. graph-&gt;Run(i, j) indicates if there is an arc between i and j. This function takes ownership of 'callback' and deletes it after it has run. It calls 'callback' upon each clique. It ignores cliques of size 1. </p>

</div>
</div>
<a id="a53e6a83fcbd689abf5b3078b0236f9f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53e6a83fcbd689abf5b3078b0236f9f1">&#9670;&nbsp;</a></span>DijkstraShortestPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::DijkstraShortestPath </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; int64(int, int)&gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>disconnected_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dijsktra Shortest path with callback based description of the graph. </p>
<p>The callback returns the distance between two nodes, a distance of 'disconnected_distance' indicates no arcs between these two nodes. Ownership of the callback is taken by the function that will delete it in the end. This function returns true if 'start_node' and 'end_node' are connected, false otherwise. </p>

</div>
</div>
<a id="a509097448ff5705cf3e64d889362bdec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a509097448ff5705cf3e64d889362bdec">&#9670;&nbsp;</a></span>FindCliques()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void operations_research::FindCliques </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; bool(int, int)&gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; bool(const std::vector&lt; int &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds all maximal cliques, even of size 1, in the graph described by the graph callback. </p>
<p>graph-&gt;Run(i, j) indicates if there is an arc between i and j. This function takes ownership of 'callback' and deletes it after it has run. If 'callback' returns true, then the search for cliques stops. </p>

</div>
</div>
<a id="ab1cf773de0cae72d0c44efe5b8f4bb89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1cf773de0cae72d0c44efe5b8f4bb89">&#9670;&nbsp;</a></span>IsEulerianGraph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::IsEulerianGraph </td>
          <td>(</td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if a graph is Eulerian, aka all its nodes are of even degree. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000011">Todo:</a></b></dt><dd>(user): Check graph connectivity. </dd></dl>

<p class="definition">Definition at line <a class="el" href="eulerian__path_8h_source.html#l00040">40</a> of file <a class="el" href="eulerian__path_8h_source.html">eulerian_path.h</a>.</p>

</div>
</div>
<a id="a6b312dd19c90b2af099e6f159869f7ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b312dd19c90b2af099e6f159869f7ee">&#9670;&nbsp;</a></span>IsSemiEulerianGraph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename NodeIndex , typename Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::IsSemiEulerianGraph </td>
          <td>(</td>
          <td class="paramtype">const Graph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="namespaceoperations__research.html#a0e629e35bfa311b31dd7f5065eb834bb">NodeIndex</a> &gt; *&#160;</td>
          <td class="paramname"><em>odd_nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if a graph is Semi-Eulerian, aka at most two of its nodes are of odd degree. </p>
<p>odd_nodes is filled with odd nodes of the graph. </p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000012">Todo:</a></b></dt><dd>(user): Check graph connectivity. </dd></dl>

<p class="definition">Definition at line <a class="el" href="eulerian__path_8h_source.html#l00055">55</a> of file <a class="el" href="eulerian__path_8h_source.html">eulerian_path.h</a>.</p>

</div>
</div>
<a id="a715b0dbb9f0903ab629b8c6da1b35b45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a715b0dbb9f0903ab629b8c6da1b35b45">&#9670;&nbsp;</a></span>MakeHamiltonianPathSolver()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename CostType , typename CostFunction &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classoperations__research_1_1HamiltonianPathSolver.html">HamiltonianPathSolver</a>&lt;CostType, CostFunction&gt; operations_research::MakeHamiltonianPathSolver </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CostFunction&#160;</td>
          <td class="paramname"><em>cost</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function to simplify building a <a class="el" href="classoperations__research_1_1HamiltonianPathSolver.html">HamiltonianPathSolver</a> from a functor. </p>

<p class="definition">Definition at line <a class="el" href="hamiltonian__path_8h_source.html#l00599">599</a> of file <a class="el" href="hamiltonian__path_8h_source.html">hamiltonian_path.h</a>.</p>

</div>
</div>
<a id="ad56bae19a2298c3163af96ca7f8b89b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad56bae19a2298c3163af96ca7f8b89b1">&#9670;&nbsp;</a></span>StableDijkstraShortestPath()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool operations_research::StableDijkstraShortestPath </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>start_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>end_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; int64(int, int)&gt;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64&#160;</td>
          <td class="paramname"><em>disconnected_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stable version of the Dijsktra Shortest path with callback based description of the graph. </p>
<p>The callback returns the distance between two nodes, a distance of 'disconnected_distance' indicates no arcs between these two nodes. Ownership of the callback is taken by the function that will delete it in the end. This function returns true if 'start_node' and 'end_node' are connected, false otherwise. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
        </div>
        <div id="footer-container">
            <div id="footer">
            </div>
        </div>
    </body>
</html>
