<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>OR-Tools</title>
        <meta http-equiv="Content-Type" content="text/html;"/>
        <meta charset="utf-8"/>
        <!--<link rel='stylesheet' type='text/css' href="https://fonts.googleapis.com/css?family=Ubuntu:400,700,400italic"/>-->
        <link rel="stylesheet" type="text/css" href="ortools.css" title="default" media="screen,print" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
    </head>
    <body>
        <div id="banner-container">
            <div id="banner">
                <span id="sfml">OR-Tools 7.2</span>
            </div>
        </div>
        <link rel="icon" href="https://developers.google.com/optimization/images/orLogo.png">
        <div id="content">
<!-- Generated by Doxygen 1.8.15 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('todo.html','');});
/* @license-end */
</script>
<div id="doc-content">
<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Todo List </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="reflist">
<dt>Member <a class="el" href="strongly__connected__components_8h.html#aafab5785b250e1013c13511ce478f36b">FindStronglyConnectedComponents</a>  (const NodeIndex num_nodes, const Graph &amp;graph, SccOutput *components)</dt>
<dd><a class="anchor" id="_todo000054"></a>(user): Possible optimizations:<ul>
<li>Try to reserve the vectors which sizes are bounded by num_nodes.</li>
<li>Use an index rather than doing push_back(), pop_back() on them.</li>
<li>For a client needing many Scc computations one after another, it could be better to wrap this in a class so we don't need to allocate the stacks at each computation.  </li>
</ul>
</dd>
<dt>Namespace <a class="el" href="namespaceoperations__research.html">operations_research</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000005"></a>(user): add depth-first-search based connectivity for directed graphs. </p>
<p class="interdd">(user): add depth-first-search based biconnectivity for directed graphs. </p>
<p class="interdd"><a class="anchor" id="_todo000007"></a>(user) although it is already possible, using the GroupForwardArcsByFunctor method, to group all the outgoing (resp. incoming) arcs of a node, the iterator logic could still be improved to allow traversing the outgoing (resp. incoming) arcs in O(out_degree(node)) (resp. O(in_degree(node))) instead of O(degree(node)).</p><ul>
<li></li>
</ul>
<p class="interdd">(user) it is possible to implement arc deletion and garbage collection in an efficient (relatively) manner. For the time being we haven't seen an application for this.</p>
<p class="interdd"><a class="anchor" id="_todo000025"></a>(user): implement pruning procedures on top of the Held-Karp algorithm.</p>
<p class="interdd"><a class="anchor" id="_todo000040"></a>(user): implement the above active node choice rule.</p>
<p class="interdd"><a class="anchor" id="_todo000041"></a>(user): an alternative would be to evaluate: A.V. Goldberg, "The Partial Augment-Relabel Algorithm for the Maximum Flow Problem.‚Äù In Proceedings of Algorithms ESA, LNCS 5193:466-477, Springer 2008. <a href="http://www.springerlink.com/index/5535k2j1mt646338.pdf">http://www.springerlink.com/index/5535k2j1mt646338.pdf</a></p>
<p class="enddd"><a class="anchor" id="_todo000048"></a>(user): See whether the following can bring any improvements on real-life problems. R.K. Ahuja, A.V. Goldberg, J.B. Orlin, and R.E. Tarjan, "Finding minimum-cost
flows by double scaling," Mathematical Programming, (1992) 53:243-266. <a href="http://www.springerlink.com/index/gu7404218u6kt166.pdf">http://www.springerlink.com/index/gu7404218u6kt166.pdf</a> </p>
</dd>
<dt>Member <a class="el" href="namespaceoperations__research.html#a00ab79ee21ffd8dece0996e37f9faa7a">operations_research::BuildKruskalMinimumSpanningTreeFromSortedArcs</a>  (const Graph &amp;graph, const std::vector&lt; typename Graph::ArcIndex &gt; &amp;sorted_arcs)</dt>
<dd><a class="anchor" id="_todo000051"></a>(user): Add a global Minimum Spanning Tree API automatically switching between Prim and Kruskal depending on problem size. </dd>
<dt>Member <a class="el" href="classoperations__research_1_1ChristofidesPathSolver.html#a76c636e1d48da64087686dd06bc45519">operations_research::ChristofidesPathSolver&lt; CostType, ArcIndex, NodeIndex, CostFunction &gt;::SetMatchingAlgorithm</a>  (MatchingAlgorithm matching)</dt>
<dd><a class="anchor" id="_todo000004"></a>(user): Change the default when minimum matching gets faster.  </dd>
<dt>Member <a class="el" href="namespaceoperations__research.html#a3175c0c8e9fc36a30b70b6b9c132474a">operations_research::ComputeMinimumWeightMatchingWithMIP</a>  (const GraphType &amp;graph, const WeightFunctionType &amp;weight)</dt>
<dd><a class="anchor" id="_todo000001"></a>(user): Handle infeasible cases if this algorithm is used outside of Christofides.  </dd>
<dt>Member <a class="el" href="classoperations__research_1_1ConnectedComponents.html#a257c3606c853fb7b79f62a5b62c65359">operations_research::ConnectedComponents&lt; NodeIndex, ArcIndex &gt;::AddGraph</a>  (const Graph &amp;graph)</dt>
<dd><a class="anchor" id="_todo000006"></a>(user): implement Depth-First Search-based connected components finder.  </dd>
<dt>Member <a class="el" href="classoperations__research_1_1EbertGraphBase.html#a7adcbbf1af098a96abf7a3397246304d">operations_research::EbertGraphBase&lt; NodeIndexType, ArcIndexType, DerivedGraph &gt;::GroupForwardArcsByFunctor</a>  (const ArcIndexTypeStrictWeakOrderingFunctor &amp;compare, PermutationCycleHandler&lt; ArcIndexType &gt; *annotation_handler)</dt>
<dd><a class="anchor" id="_todo000010"></a>(user): Configure SWIG to handle the GroupForwardArcsByFunctor member template and the <a class="el" href="classoperations__research_1_1EbertGraphBase_1_1CycleHandlerForAnnotatedArcs.html">CycleHandlerForAnnotatedArcs</a> class. </dd>
<dt>Class <a class="el" href="classoperations__research_1_1ElementIterator.html">operations_research::ElementIterator&lt; Set &gt;</a>  </dt>
<dd><a class="anchor" id="_todo000026"></a>(user): Move the Set-related classbelow to util/bitset.h Iterates over the elements of a set represented as an unsigned integer, starting from the smallest element. </dd>
<dt>Class <a class="el" href="classoperations__research_1_1ForwardStaticGraph_1_1CycleHandlerForAnnotatedArcs.html">operations_research::ForwardStaticGraph&lt; NodeIndexType, ArcIndexType &gt;::CycleHandlerForAnnotatedArcs</a>  </dt>
<dd><a class="anchor" id="_todo000008"></a>(user): Configure SWIG to handle the <a class="el" href="classoperations__research_1_1ForwardStaticGraph_1_1CycleHandlerForAnnotatedArcs.html">CycleHandlerForAnnotatedArcs</a> class. </dd>
<dt>Member <a class="el" href="classoperations__research_1_1ForwardStaticGraph.html#a299d30373ebbfcb70fc84ecc66d95b92">operations_research::ForwardStaticGraph&lt; NodeIndexType, ArcIndexType &gt;::ForwardStaticGraph</a>  (const NodeIndexType num_nodes, const ArcIndexType num_arcs, const bool sort_arcs_by_head, std::vector&lt; std::pair&lt; NodeIndexType, NodeIndexType &gt; &gt; *client_input_arcs, operations_research::PermutationCycleHandler&lt; ArcIndexType &gt; *const client_cycle_handler)</dt>
<dd><a class="anchor" id="_todo000009"></a>(user): For some reason, SWIG breaks if the <a class="el" href="namespaceoperations__research.html" title="Licensed under the Apache License, Version 2.0 (the &quot;License&quot;); you may not use this file except in c...">operations_research</a> namespace is not explicit in the following argument declaration.  </dd>
<dt>Member <a class="el" href="classoperations__research_1_1GenericMaxFlow.html#a92fbc9576b457ceddeb21395181b3273">operations_research::GenericMaxFlow&lt; Graph &gt;::check_result_</a>  </dt>
<dd><a class="anchor" id="_todo000047"></a>(user): Make the check more exhaustive by checking the optimality?  </dd>
<dt>Member <a class="el" href="classoperations__research_1_1GenericMaxFlow.html#ad7892ad5aa8338015f320267fb7f298f">operations_research::GenericMaxFlow&lt; Graph &gt;::GetSinkSideMinCut</a>  (std::vector&lt; NodeIndex &gt; *result)</dt>
<dd><a class="anchor" id="_todo000046"></a>(user): In the two-phases algorithm, we can get this minimum cut without doing the second phase. Add an option for this if there is a need to, note that the second phase is pretty fast so the gain will be small.  </dd>
<dt>Class <a class="el" href="classoperations__research_1_1GenericMinCostFlow.html">operations_research::GenericMinCostFlow&lt; Graph, ArcFlowType, ArcScaledCostType &gt;</a>  </dt>
<dd><a class="anchor" id="_todo000050"></a>(user): Avoid using the globally defined type CostValue and FlowQuantity. Also uses the Arc*Type where there is no risk of overflow in more places.  </dd>
<dt>Member <a class="el" href="classoperations__research_1_1HamiltonianPathSolver.html#aa5992cec63596c5d6c2ed51fc4f7c9c6">operations_research::HamiltonianPathSolver&lt; CostType, CostFunction &gt;::Integer</a>  </dt>
<dd><a class="anchor" id="_todo000033"></a>(user): remove this limitation by using pruning techniques.  </dd>
<dt>Member <a class="el" href="namespaceoperations__research.html#ab1cf773de0cae72d0c44efe5b8f4bb89">operations_research::IsEulerianGraph</a>  (const Graph &amp;graph)</dt>
<dd><a class="anchor" id="_todo000011"></a>(user): Check graph connectivity.  </dd>
<dt>Member <a class="el" href="namespaceoperations__research.html#a6b312dd19c90b2af099e6f159869f7ee">operations_research::IsSemiEulerianGraph</a>  (const Graph &amp;graph, std::vector&lt; NodeIndex &gt; *odd_nodes)</dt>
<dd><a class="anchor" id="_todo000012"></a>(user): Check graph connectivity.  </dd>
<dt>Member <a class="el" href="classoperations__research_1_1LatticeMemoryManager.html#a5369cd69622c4264ffcf11a2d5006ecd">operations_research::LatticeMemoryManager&lt; Set, CostType &gt;::BaseOffset</a>  (int card, <a class="el" href="classoperations__research_1_1Set.html">Set</a> s) const</dt>
<dd><p class="startdd"><a class="anchor" id="_todo000032"></a>(user): Investigate how to compute BaseOffset(card - 1, s \ { n }) from BaseOffset(card, n) to speed up the DP iteration. </p>
<p class="enddd"><a class="anchor" id="_todo000027"></a>(user): Evaluate the interest of the above. There are 'card' f(set, j) to store. That is why we need to multiply local_offset by card before adding it to the corresponding base_offset_.  </p>
</dd>
<dt>Class <a class="el" href="classoperations__research_1_1MaxFlow.html">operations_research::MaxFlow</a>  </dt>
<dd><a class="anchor" id="_todo000043"></a>(user): Modify this code and remove it.  </dd>
<dt>Member <a class="el" href="classoperations__research_1_1PruningHamiltonianSolver.html#a2857abdd40d541b03ad21bd053b0ac54">operations_research::PruningHamiltonianSolver&lt; CostType, CostFunction &gt;::Integer</a>  </dt>
<dd><p class="startdd"><a class="anchor" id="_todo000035"></a>(user): Use generic map-based cache instead of lattice-based one.</p>
<p class="enddd"><a class="anchor" id="_todo000036"></a>(user): Use SaturatedArithmetic for better precision.  </p>
</dd>
<dt>Class <a class="el" href="classoperations__research_1_1SimpleMaxFlow.html">operations_research::SimpleMaxFlow</a>  </dt>
<dd><a class="anchor" id="_todo000042"></a>(user): If the need arises, extend this interface to support warm start.  </dd>
<dt>Member <a class="el" href="classoperations__research_1_1SimpleMaxFlow.html#a8a7acde49c4d55f2eb42e2b6869cdb3da18a3ff25435f10be68329d4b39de4700">operations_research::SimpleMaxFlow::POSSIBLE_OVERFLOW</a>  </dt>
<dd><a class="anchor" id="_todo000045"></a>(user): rename POSSIBLE_OVERFLOW to INT_OVERFLOW and modify our clients.  </dd>
<dt>Member <a class="el" href="classoperations__research_1_1SimpleMaxFlow.html#a57296b653813abdd8d711048e87d1212">operations_research::SimpleMaxFlow::SetArcCapacity</a>  (ArcIndex arc, FlowQuantity capacity)</dt>
<dd><a class="anchor" id="_todo000044"></a>(user): Support incrementality in the max flow implementation.  </dd>
<dt>Class <a class="el" href="classoperations__research_1_1SimpleMinCostFlow.html">operations_research::SimpleMinCostFlow</a>  </dt>
<dd><a class="anchor" id="_todo000049"></a>(user): If the need arises, extend this interface to support warm start and incrementality between solves. Note that this is already supported by the GenericMinCostFlow&lt;&gt; interface.  </dd>
<dt>Member <a class="el" href="classutil_1_1BaseGraph.html#a92ffd852b2ab2e5241f9832e71a2de71">util::BaseGraph&lt; NodeIndexType, ArcIndexType, HasReverseArcs &gt;::arc_capacity</a>  () const</dt>
<dd><a class="anchor" id="_todo000015"></a>(user): Same questions as the ones in <a class="el" href="classutil_1_1BaseGraph.html#a463d57480c9563a7a707c5d0928c9946" title="Capacity reserved for future nodes, always &gt;= num_nodes_.">node_capacity()</a>.  </dd>
<dt>Member <a class="el" href="classutil_1_1BaseGraph.html#aa3bd051d1e141b09dda17aa9b5f24f69">util::BaseGraph&lt; NodeIndexType, ArcIndexType, HasReverseArcs &gt;::FreezeCapacities</a>  ()</dt>
<dd><a class="anchor" id="_todo000016"></a>(user): Only define this in debug mode at the cost of having a lot of ifndef NDEBUG all over the place? remove the function completely ?  </dd>
<dt>Member <a class="el" href="classutil_1_1BaseGraph.html#a07214b96597069d781e27b1dd17ef83e">util::BaseGraph&lt; NodeIndexType, ArcIndexType, HasReverseArcs &gt;::GroupForwardArcsByFunctor</a>  (const A &amp;a, B *b)</dt>
<dd><a class="anchor" id="_todo000018"></a>(user): remove the public functions below. </dd>
<dt>Member <a class="el" href="classutil_1_1BaseGraph.html#a463d57480c9563a7a707c5d0928c9946">util::BaseGraph&lt; NodeIndexType, ArcIndexType, HasReverseArcs &gt;::node_capacity</a>  () const</dt>
<dd><a class="anchor" id="_todo000014"></a>(user): Is it needed? remove completely? return the real capacities at the cost of having a different implementation for each graphs?  </dd>
<dt>Member <a class="el" href="namespaceutil.html#a9470623ca7db3c4a62ce3b326c6b07d8">util::PermuteWithExplicitElementType</a>  (const IntVector &amp;permutation, Array *array_to_permute, ElementType unused)</dt>
<dd><a class="anchor" id="_todo000013"></a>(user): consider slower but more memory efficient implementations that follow the cycles of the permutation and use a bitmap to indicate what has been permuted or to mark the beginning of each cycle.  </dd>
<dt>Member <a class="el" href="namespaceutil.html#a06fa201576c927d92657e090fa86bfdb">util::RemoveCyclesFromPath</a>  (const Graph &amp;graph, std::vector&lt; int &gt; *arc_path)</dt>
<dd><a class="anchor" id="_todo000055"></a>(user): In some cases, there is more than one possible solution. We could take some arc costs and return the cheapest path instead. Or return the shortest path in term of number of arcs.  </dd>
<dt>Member <a class="el" href="classutil_1_1ReverseArcMixedGraph.html#a5ebe11f2abcd78ad1f5606e27d1688bb">util::ReverseArcMixedGraph&lt; NodeIndexType, ArcIndexType &gt;::Head</a>  (ArcIndexType arc) const</dt>
<dd><a class="anchor" id="_todo000020"></a>(user): support <a class="el" href="classutil_1_1ReverseArcMixedGraph.html#a5ebe11f2abcd78ad1f5606e27d1688bb">Head()</a> and <a class="el" href="classutil_1_1ReverseArcMixedGraph.html#a351cbc3c0c79e22f010e697bf65d7100">Tail()</a> before <a class="el" href="classutil_1_1ReverseArcMixedGraph.html#a06e56a529396bbd2595f5c32c2f73142">Build()</a>, like StaticGraph&lt;&gt;.  </dd>
<dt>Member <a class="el" href="classutil_1_1ReverseArcMixedGraph_1_1OutgoingArcIterator.html#ac265893b8e1a6db1380522442bf66c84">util::ReverseArcMixedGraph&lt; NodeIndexType, ArcIndexType &gt;::OutgoingArcIterator::DEFINE_STL_ITERATOR_FUNCTIONS</a>  (<a class="el" href="classutil_1_1ReverseArcMixedGraph_1_1OutgoingArcIterator.html">OutgoingArcIterator</a>)</dt>
<dd><a class="anchor" id="_todo000024"></a>(user): we lose a bit by returning a BeginEndWrapper&lt;&gt; on top of this iterator rather than a simple IntegerRange on the arc indices. </dd>
<dt>Member <a class="el" href="classutil_1_1ReverseArcStaticGraph.html#a590ee70b96ce87433ba89b067495aa5f">util::ReverseArcStaticGraph&lt; NodeIndexType, ArcIndexType &gt;::Build</a>  (std::vector&lt; ArcIndexType &gt; *permutation)</dt>
<dd><a class="anchor" id="_todo000017"></a>(user): the 0 is wasted here, but minor optimisation.  </dd>
<dt>Member <a class="el" href="classutil_1_1ReverseArcStaticGraph.html#a72e8ed03fe3f8ff27d156622a86900aa">util::ReverseArcStaticGraph&lt; NodeIndexType, ArcIndexType &gt;::Head</a>  (ArcIndexType arc) const</dt>
<dd><a class="anchor" id="_todo000019"></a>(user): support <a class="el" href="classutil_1_1ReverseArcStaticGraph.html#a72e8ed03fe3f8ff27d156622a86900aa">Head()</a> and <a class="el" href="classutil_1_1ReverseArcStaticGraph.html#a12cf8d1312236cac409d9a1a934c1ad3">Tail()</a> before <a class="el" href="classutil_1_1ReverseArcStaticGraph.html#a485803d141f9c80beaaae7094548d672">Build()</a>, like StaticGraph&lt;&gt;.  </dd>
<dt>Member <a class="el" href="classutil_1_1ReverseArcStaticGraph_1_1OutgoingArcIterator.html#a4f7501971b3fcc6ab34772a93c449ac6">util::ReverseArcStaticGraph&lt; NodeIndexType, ArcIndexType &gt;::OutgoingArcIterator::DEFINE_STL_ITERATOR_FUNCTIONS</a>  (<a class="el" href="classutil_1_1ReverseArcStaticGraph_1_1OutgoingArcIterator.html">OutgoingArcIterator</a>)</dt>
<dd><a class="anchor" id="_todo000023"></a>(user): we lose a bit by returning a BeginEndWrapper&lt;&gt; on top of this iterator rather than a simple IntegerRange on the arc indices. </dd>
<dt>Member <a class="el" href="classutil_1_1SVector.html#a287f9791ba2e68e137d53fc038bbe432">util::SVector&lt; T &gt;::reserve</a>  (int n)</dt>
<dd><a class="anchor" id="_todo000021"></a>(user): in C++17 we could use std::uninitialized_move instead of this loop. </dd>
</dl>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
        </div>
        <div id="footer-container">
            <div id="footer">
            </div>
        </div>
    </body>
</html>
