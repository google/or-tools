<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>OR-Tools</title>
        <meta http-equiv="Content-Type" content="text/html;"/>
        <meta charset="utf-8"/>
        <!--<link rel='stylesheet' type='text/css' href="https://fonts.googleapis.com/css?family=Ubuntu:400,700,400italic"/>-->
        <link rel="stylesheet" type="text/css" href="ortools.css" title="default" media="screen,print" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
    </head>
    <body>
        <div id="banner-container">
            <div id="banner">
                <span id="sfml">OR-Tools 7.2</span>
            </div>
        </div>
        <link rel="icon" href="https://developers.google.com/optimization/images/orLogo.png">
        <div id="content">
<!-- Generated by Doxygen 1.8.15 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('linear__assignment_8h.html','');});
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#namespaces">Namespaces</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">linear_assignment.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><a href="linear__assignment_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1LinearSumAssignment.html">operations_research::LinearSumAssignment&lt; GraphType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class does not take ownership of its underlying graph.  <a href="classoperations__research_1_1LinearSumAssignment.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1LinearSumAssignment_1_1BipartiteLeftNodeIterator.html">operations_research::LinearSumAssignment&lt; GraphType &gt;::BipartiteLeftNodeIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1CostValueCycleHandler.html">operations_research::CostValueCycleHandler&lt; ArcIndexType &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classoperations__research_1_1ArcIndexOrderingByTailNode.html">operations_research::ArcIndexOrderingByTailNode&lt; GraphType &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logically this class should be defined inside OptimizeGraphLayout, but compilation fails if we do that because C++98 doesn't allow instantiation of member templates with function-scoped types as template parameters, which in turn is because those function-scoped types lack linkage.  <a href="classoperations__research_1_1ArcIndexOrderingByTailNode.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespaceoperations__research"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceoperations__research.html">operations_research</a></td></tr>
<tr class="memdesc:namespaceoperations__research"><td class="mdescLeft">&#160;</td><td class="mdescRight">Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aeb1d0880abde13d03b5dc361d19d8cf3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linear__assignment_8h.html#aeb1d0880abde13d03b5dc361d19d8cf3">DECLARE_int64</a> (assignment_alpha)</td></tr>
<tr class="memdesc:aeb1d0880abde13d03b5dc361d19d8cf3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License.  <a href="#aeb1d0880abde13d03b5dc361d19d8cf3">More...</a><br /></td></tr>
<tr class="separator:aeb1d0880abde13d03b5dc361d19d8cf3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e9c0b76beb761af447a08684cded9a7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linear__assignment_8h.html#a7e9c0b76beb761af447a08684cded9a7">DECLARE_int32</a> (assignment_progress_logging_period)</td></tr>
<tr class="separator:a7e9c0b76beb761af447a08684cded9a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9982454bded965321d3f3b7d5300b0dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="linear__assignment_8h.html#a9982454bded965321d3f3b7d5300b0dc">DECLARE_bool</a> (assignment_stack_order)</td></tr>
<tr class="separator:a9982454bded965321d3f3b7d5300b0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Function Documentation</h2>
<a id="a9982454bded965321d3f3b7d5300b0dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9982454bded965321d3f3b7d5300b0dc">&#9670;&nbsp;</a></span>DECLARE_bool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DECLARE_bool </td>
          <td>(</td>
          <td class="paramtype">assignment_stack_order&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e9c0b76beb761af447a08684cded9a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e9c0b76beb761af447a08684cded9a7">&#9670;&nbsp;</a></span>DECLARE_int32()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DECLARE_int32 </td>
          <td>(</td>
          <td class="paramtype">assignment_progress_logging_period&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb1d0880abde13d03b5dc361d19d8cf3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb1d0880abde13d03b5dc361d19d8cf3">&#9670;&nbsp;</a></span>DECLARE_int64()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">DECLARE_int64 </td>
          <td>(</td>
          <td class="paramtype">assignment_alpha&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. </p>
<p>You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div></div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. An implementation of a cost-scaling push-relabel algorithm for the assignment problem (minimum-cost perfect bipartite matching), from the paper of Goldberg and Kennedy (1995).</p>
<p>This implementation finds the minimum-cost perfect assignment in the given graph with integral edge weights set through the SetArcCost method.</p>
<p>The running time is O(n*m*log(nC)) where n is the number of nodes, m is the number of edges, and C is the largest magnitude of an edge cost. In principle it can be worse than the Hungarian algorithm but we don't know of any class of problems where that actually happens. An additional sqrt(n) factor could be shaved off the running time bound using the technique described in <a href="http://dx.doi.org/10.1137/S0895480194281185">http://dx.doi.org/10.1137/S0895480194281185</a> (see also <a href="http://theory.stanford.edu/~robert/papers/glob_upd.ps">http://theory.stanford.edu/~robert/papers/glob_upd.ps</a>).</p>
<p>Example usage:</p>
<p>#include "ortools/graph/graph.h" #include "ortools/graph/linear_assignment.h"</p>
<p>///&lt; Choose a graph implementation (we recommend StaticGraph&lt;&gt;). typedef util::StaticGraph&lt;&gt; Graph;</p>
<p>///&lt; Define a num_nodes / 2 by num_nodes / 2 assignment problem: const int num_nodes = ... const int num_arcs = ... const int num_left_nodes = num_nodes / 2; Graph graph(num_nodes, num_arcs); std::vector&lt;operations_research::CostValue&gt; arc_costs(num_arcs); for (int arc = 0; arc &lt; num_arcs; ++arc) { const int arc_tail = ... ///&lt; must be in [0, num_left_nodes) const int arc_head = ... ///&lt; must be in [num_left_nodes, num_nodes) graph.AddArc(arc_tail, arc_head); arc_costs[arc] = ... }</p>
<p>///&lt; Build the StaticGraph. You can skip this step by using a ListGraph&lt;&gt; ///&lt; instead, but then the ComputeAssignment() below will be slower. It is ///&lt; okay if your graph is small and performance is not critical though. { std::vector&lt;Graph::ArcIndex&gt; arc_permutation; graph.Build(&amp;arc_permutation); util::Permute(arc_permutation, &amp;arc_costs); }</p>
<p>///&lt; Construct the LinearSumAssignment. ::operations_research::LinearSumAssignment&lt;Graph&gt; a(graph, num_left_nodes); for (int arc = 0; arc &lt; num_arcs; ++arc) { ///&lt; You can also replace 'arc_costs[arc]' by something like ///&lt; ComputeArcCost(permutation.empty() ? arc : permutation[arc]) ///&lt; if you don't want to store the costs in arc_costs to save memory. a.SetArcCost(arc, arc_costs[arc]); }</p>
<p>///&lt; Compute the optimum assignment. bool success = a.ComputeAssignment(); ///&lt; Retrieve the cost of the optimum assignment. <a class="el" href="namespaceoperations__research.html#aa7950685633ee869aa9471b2ec5fbcfa">operations_research::CostValue</a> optimum_cost = a.GetCost(); ///&lt; Retrieve the node-node correspondence of the optimum assignment and the ///&lt; cost of each node pairing. for (int left_node = 0; left_node &lt; num_left_nodes; ++left_node) { const int right_node = a.GetMate(left_node); <a class="el" href="namespaceoperations__research.html#aa7950685633ee869aa9471b2ec5fbcfa">operations_research::CostValue</a> node_pair_cost = a.GetAssignmentCost(left_node); ... }</p>
<p>In the following, we consider a bipartite graph G = (V = X union Y, E subset XxY), where V denotes the set of nodes (vertices) in the graph, E denotes the set of arcs (edges), n = <code>V</code> denotes the number of nodes in the graph, and m = <code>E</code> denotes the number of arcs in the graph.</p>
<p>The set of nodes is divided into two parts, X and Y, and every arc must go between a node of X and a node of Y. With each arc is associated a cost c(v, w). A matching M is a subset of E with the property that no two arcs in M have a head or tail node in common, and a perfect matching is a matching that touches every node in the graph. The cost of a matching M is the sum of the costs of all the arcs in M.</p>
<p>The assignment problem is to find a perfect matching of minimum cost in the given bipartite graph. The present algorithm reduces the assignment problem to an instance of the minimum-cost flow problem and takes advantage of special properties of the resulting minimum-cost flow problem to solve it efficiently using a push-relabel method. For more information about minimum-cost flow see google3/ortools/graph/min_cost_flow.h</p>
<p>The method used here is the cost-scaling approach for the minimum-cost circulation problem as described in [Goldberg and Tarjan] with some technical modifications:</p><ol type="1">
<li>For efficiency, we solve a transportation problem instead of minimum-cost circulation. We might revisit this decision if it is important to handle problems in which no perfect matching exists.</li>
<li>We use a modified "asymmetric" notion of epsilon-optimality in which left-to-right residual arcs are required to have reduced cost bounded below by zero and right-to-left residual arcs are required to have reduced cost bounded below by -epsilon. For each residual arc direction, the reduced-cost threshold for admissibility is epsilon/2 above the threshold for epsilon optimality.</li>
<li>We do not limit the applicability of the relabeling operation to nodes with excess. Instead we use the double-push operation (discussed in the Goldberg and Kennedy CSA paper and Kennedy's thesis) which relabels right-side nodes just <em>after</em> they have been discharged. The above differences are explained in detail in [Kennedy's thesis] and explained not quite as cleanly in [Goldberg and Kennedy's CSA paper]. But note that the thesis explanation uses a value of epsilon that's double what we use here.</li>
</ol>
<p>Some definitions: Active: A node is called active when it has excess. It is eligible to be pushed from. In this implementation, every active node is on the left side of the graph where prices are determined implicitly, so no left-side relabeling is necessary before pushing from an active node. We do, however, need to compute the implications for price changes on the affected right-side nodes. Admissible: A residual arc (one that can carry more flow) is called admissible when its reduced cost is small enough. We can push additional flow along such an arc without violating epsilon-optimality. In the case of a left-to-right residual arc, the reduced cost must be at most epsilon/2. In the case of a right-to-left residual arc, the reduced cost must be at most -epsilon/2. The careful reader will note that these thresholds are not used explicitly anywhere in this implementation, and the reason is the implicit pricing of left-side nodes. Reduced cost: Essentially an arc's reduced cost is its complementary slackness. In push-relabel algorithms this is c_p(v, w) = p(v) + c(v, w) - p(w), where p() is the node price function and c(v, w) is the cost of the arc from v to w. See <a class="el" href="min__cost__flow_8h.html">min_cost_flow.h</a> for more details. Partial reduced cost: We maintain prices implicitly for left-side nodes in this implementation, so instead of reduced costs we work with partial reduced costs, defined as c'_p(v, w) = c(v, w) - p(w).</p>
<p>We check at initialization time for the possibility of arithmetic overflow and warn if the given costs are too large. In many cases the bound we use to trigger the warning is pessimistic so the given problem can often be solved even if we warn that overflow is possible.</p>
<p>We don't use the interface from operations_research/algorithms/hungarian.h because we want to be able to express sparse problems efficiently.</p>
<p>When asked to solve the given assignment problem we return a boolean to indicate whether the given problem was feasible.</p>
<p>References: [ Goldberg and Kennedy's CSA paper ] A. V. Goldberg and R. Kennedy, "An Efficient Cost Scaling Algorithm for the Assignment Problem." Mathematical Programming, Vol. 71, pages 153-178, December 1995.</p>
<p>[ Goldberg and Tarjan ] A. V. Goldberg and R. E. Tarjan, "Finding
Minimum-Cost Circulations by Successive Approximation." Mathematics of Operations Research, Vol. 15, No. 3, pages 430-466, August 1990.</p>
<p>[ Kennedy's thesis ] J. R. Kennedy, Jr., "Solving Unweighted and
Weighted Bipartite Matching Problems in Theory and Practice." Stanford University Doctoral Dissertation, Department of Computer Science, 1995.</p>
<p>[ Burkard et al. ] R. Burkard, M. Dell'Amico, S. Martello, "Assignment
Problems", SIAM, 2009, ISBN: 978-0898716634, <a href="http://www.amazon.com/dp/0898716632/">http://www.amazon.com/dp/0898716632/</a></p>
<p>[ Ahuja et al. ] R. K. Ahuja, T. L. Magnanti, J. B. Orlin, "Network Flows:
Theory, Algorithms, and Applications," Prentice Hall, 1993, ISBN: 978-0136175490, <a href="http://www.amazon.com/dp/013617549X">http://www.amazon.com/dp/013617549X</a>.</p>
<p>Keywords: linear sum assignment problem, Hungarian method, Goldberg, Kennedy. </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
        </div>
        <div id="footer-container">
            <div id="footer">
            </div>
        </div>
    </body>
</html>
