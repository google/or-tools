<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <title>OR-Tools</title>
        <meta http-equiv="Content-Type" content="text/html;"/>
        <meta charset="utf-8"/>
        <!--<link rel='stylesheet' type='text/css' href="https://fonts.googleapis.com/css?family=Ubuntu:400,700,400italic"/>-->
        <link rel="stylesheet" type="text/css" href="ortools.css" title="default" media="screen,print" />
        <script type="text/javascript" src="jquery.js"></script>
        <script type="text/javascript" src="dynsections.js"></script>
    </head>
    <body>
        <div id="banner-container">
            <div id="banner">
                <span id="sfml">OR-Tools 7.2</span>
            </div>
        </div>
        <link rel="icon" href="https://developers.google.com/optimization/images/orLogo.png">
        <div id="content">
<!-- Generated by Doxygen 1.8.15 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('namespaceutil.html','');});
/* @license-end */
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">util Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1BaseGraph.html">BaseGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base class of all Graphs implemented here.  <a href="classutil_1_1BaseGraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1CompleteBipartiteGraph.html">CompleteBipartiteGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classutil_1_1CompleteBipartiteGraph.html" title="CompleteBipartiteGraph implementation ------------------------------------— Nodes and arcs are implic...">CompleteBipartiteGraph</a> implementation ------------------------------------&mdash; Nodes and arcs are implicit and not stored.  <a href="classutil_1_1CompleteBipartiteGraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1CompleteGraph.html">CompleteGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classutil_1_1CompleteGraph.html" title="CompleteGraph implementation ---------------------------------------------— Nodes and arcs are implic...">CompleteGraph</a> implementation ---------------------------------------------&mdash; Nodes and arcs are implicit and not stored.  <a href="classutil_1_1CompleteGraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1ListGraph.html">ListGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic graph implementation without reverse arc.  <a href="classutil_1_1ListGraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1ReverseArcListGraph.html">ReverseArcListGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extends the <a class="el" href="classutil_1_1ListGraph.html" title="Basic graph implementation without reverse arc.">ListGraph</a> by also storing the reverse arcs.  <a href="classutil_1_1ReverseArcListGraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1ReverseArcMixedGraph.html">ReverseArcMixedGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This graph is a mix between the <a class="el" href="classutil_1_1ReverseArcListGraph.html" title="Extends the ListGraph by also storing the reverse arcs.">ReverseArcListGraph</a> and the <a class="el" href="classutil_1_1ReverseArcStaticGraph.html" title="StaticGraph with reverse arc.">ReverseArcStaticGraph</a>.  <a href="classutil_1_1ReverseArcMixedGraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1ReverseArcStaticGraph.html">ReverseArcStaticGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classutil_1_1StaticGraph.html" title="Most efficient implementation of a graph without reverse arcs:">StaticGraph</a> with reverse arc.  <a href="classutil_1_1ReverseArcStaticGraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1StaticGraph.html">StaticGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Most efficient implementation of a graph without reverse arcs:  <a href="classutil_1_1StaticGraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1SVector.html">SVector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Forward declaration.  <a href="classutil_1_1SVector.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classutil_1_1UndirectedAdjacencyListsOfDirectedGraph.html">UndirectedAdjacencyListsOfDirectedGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This can be used to view a directed graph (that supports reverse arcs) from <a class="el" href="graph_8h.html">graph.h</a> as un undirected graph: operator[](node) returns a pseudo-container that iterates over all nodes adjacent to "node" (from outgoing or incoming arcs).  <a href="classutil_1_1UndirectedAdjacencyListsOfDirectedGraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae76339cb2dcd3bc05ad762146f91fdda"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classutil_1_1ListGraph.html">ListGraph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a></td></tr>
<tr class="memdesc:ae76339cb2dcd3bc05ad762146f91fdda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defining the simplest Graph interface as Graph for convenience.  <a href="#ae76339cb2dcd3bc05ad762146f91fdda">More...</a><br /></td></tr>
<tr class="separator:ae76339cb2dcd3bc05ad762146f91fdda"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae705e1342dacc10a13fb3f11f91d0696"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#ae705e1342dacc10a13fb3f11f91d0696">GraphToStringFormat</a> { <a class="el" href="namespaceutil.html#ae705e1342dacc10a13fb3f11f91d0696acac9245da1bf36d1d9382dc579e1a4fd">PRINT_GRAPH_ARCS</a>, 
<a class="el" href="namespaceutil.html#ae705e1342dacc10a13fb3f11f91d0696aaed5759e3b6e3a8592c9a21e0048b565">PRINT_GRAPH_ADJACENCY_LISTS</a>, 
<a class="el" href="namespaceutil.html#ae705e1342dacc10a13fb3f11f91d0696a454bb1ede69e280a1e4959acb82748ef">PRINT_GRAPH_ADJACENCY_LISTS_SORTED</a>
 }</td></tr>
<tr class="memdesc:ae705e1342dacc10a13fb3f11f91d0696"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a std::string representation of a graph.  <a href="namespaceutil.html#ae705e1342dacc10a13fb3f11f91d0696">More...</a><br /></td></tr>
<tr class="separator:ae705e1342dacc10a13fb3f11f91d0696"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a13f0e8f7e15873600cf8e395958c71e1"><td class="memTemplParams" colspan="2">template&lt;class UndirectedGraph &gt; </td></tr>
<tr class="memitem:a13f0e8f7e15873600cf8e395958c71e1"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a13f0e8f7e15873600cf8e395958c71e1">GetConnectedComponents</a> (int num_nodes, const UndirectedGraph &amp;graph)</td></tr>
<tr class="memdesc:a13f0e8f7e15873600cf8e395958c71e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finds the connected components of the graph, using BFS internally.  <a href="#a13f0e8f7e15873600cf8e395958c71e1">More...</a><br /></td></tr>
<tr class="separator:a13f0e8f7e15873600cf8e395958c71e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9470623ca7db3c4a62ce3b326c6b07d8"><td class="memTemplParams" colspan="2">template&lt;class IntVector , class Array , class ElementType &gt; </td></tr>
<tr class="memitem:a9470623ca7db3c4a62ce3b326c6b07d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a9470623ca7db3c4a62ce3b326c6b07d8">PermuteWithExplicitElementType</a> (const IntVector &amp;permutation, Array *array_to_permute, ElementType unused)</td></tr>
<tr class="memdesc:a9470623ca7db3c4a62ce3b326c6b07d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Permutes the elements of array_to_permute: element #i will be moved to position permutation[i].  <a href="#a9470623ca7db3c4a62ce3b326c6b07d8">More...</a><br /></td></tr>
<tr class="separator:a9470623ca7db3c4a62ce3b326c6b07d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c227a057c1ce9d46b1185abf77ad91e"><td class="memTemplParams" colspan="2">template&lt;class IntVector , class Array &gt; </td></tr>
<tr class="memitem:a8c227a057c1ce9d46b1185abf77ad91e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a8c227a057c1ce9d46b1185abf77ad91e">Permute</a> (const IntVector &amp;permutation, Array *array_to_permute)</td></tr>
<tr class="separator:a8c227a057c1ce9d46b1185abf77ad91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac497881c4166bc694adc4bee62746118"><td class="memTemplParams" colspan="2">template&lt;class IntVector &gt; </td></tr>
<tr class="memitem:ac497881c4166bc694adc4bee62746118"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#ac497881c4166bc694adc4bee62746118">Permute</a> (const IntVector &amp;permutation, std::vector&lt; bool &gt; *array_to_permute)</td></tr>
<tr class="memdesc:ac497881c4166bc694adc4bee62746118"><td class="mdescLeft">&#160;</td><td class="mdescRight">We need a specialization for std::vector&lt;bool&gt;, because the default code uses (*array_to_permute)[0] as ElementType, which isn't 'bool' in that case.  <a href="#ac497881c4166bc694adc4bee62746118">More...</a><br /></td></tr>
<tr class="separator:ac497881c4166bc694adc4bee62746118"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37be0131ae922e30a286797a0bef0c96"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a37be0131ae922e30a286797a0bef0c96">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1ListGraph.html">ListGraph</a>, Outgoing, Base::kNilArc)</td></tr>
<tr class="memdesc:a37be0131ae922e30a286797a0bef0c96"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classutil_1_1ListGraph.html" title="Basic graph implementation without reverse arc.">ListGraph</a> implementation -------------------------------------------------&mdash;.  <a href="#a37be0131ae922e30a286797a0bef0c96">More...</a><br /></td></tr>
<tr class="separator:a37be0131ae922e30a286797a0bef0c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c40fc068f645d9dcd15c332e44fc25"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#af3c40fc068f645d9dcd15c332e44fc25">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1StaticGraph.html">StaticGraph</a>, Outgoing, DirectArcLimit(node))</td></tr>
<tr class="memdesc:af3c40fc068f645d9dcd15c332e44fc25"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classutil_1_1StaticGraph.html" title="Most efficient implementation of a graph without reverse arcs:">StaticGraph</a> implementation -----------------------------------------------&mdash;.  <a href="#af3c40fc068f645d9dcd15c332e44fc25">More...</a><br /></td></tr>
<tr class="separator:af3c40fc068f645d9dcd15c332e44fc25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3098e161a6aceeca482be78d2d221b3b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a3098e161a6aceeca482be78d2d221b3b">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1ReverseArcListGraph.html">ReverseArcListGraph</a>, Outgoing, Base::kNilArc)</td></tr>
<tr class="memdesc:a3098e161a6aceeca482be78d2d221b3b"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classutil_1_1ReverseArcListGraph.html" title="Extends the ListGraph by also storing the reverse arcs.">ReverseArcListGraph</a> implementation ---------------------------------------&mdash;.  <a href="#a3098e161a6aceeca482be78d2d221b3b">More...</a><br /></td></tr>
<tr class="separator:a3098e161a6aceeca482be78d2d221b3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d0ae05975a2063f2edbeb749f690fc7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a4d0ae05975a2063f2edbeb749f690fc7">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1ReverseArcListGraph.html">ReverseArcListGraph</a>, Incoming, Base::kNilArc)</td></tr>
<tr class="separator:a4d0ae05975a2063f2edbeb749f690fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22b5dcc01043ab8da01ebab71ec3ad31"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a22b5dcc01043ab8da01ebab71ec3ad31">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1ReverseArcListGraph.html">ReverseArcListGraph</a>, OutgoingOrOppositeIncoming, Base::kNilArc)</td></tr>
<tr class="separator:a22b5dcc01043ab8da01ebab71ec3ad31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a863ccdb51afb5ef92fe6c94188a5f7e0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a863ccdb51afb5ef92fe6c94188a5f7e0">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1ReverseArcListGraph.html">ReverseArcListGraph</a>, OppositeIncoming, Base::kNilArc)</td></tr>
<tr class="separator:a863ccdb51afb5ef92fe6c94188a5f7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cc2a1037195d237820edc97d35404be"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a2cc2a1037195d237820edc97d35404be">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1ReverseArcStaticGraph.html">ReverseArcStaticGraph</a>, Outgoing, DirectArcLimit(node))</td></tr>
<tr class="memdesc:a2cc2a1037195d237820edc97d35404be"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classutil_1_1ReverseArcStaticGraph.html" title="StaticGraph with reverse arc.">ReverseArcStaticGraph</a> implementation -------------------------------------&mdash;.  <a href="#a2cc2a1037195d237820edc97d35404be">More...</a><br /></td></tr>
<tr class="separator:a2cc2a1037195d237820edc97d35404be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a51d676cd5d9354bfe1f80d09c44f39"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a2a51d676cd5d9354bfe1f80d09c44f39">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1ReverseArcStaticGraph.html">ReverseArcStaticGraph</a>, Incoming, ReverseArcLimit(node))</td></tr>
<tr class="separator:a2a51d676cd5d9354bfe1f80d09c44f39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1db1a919e67261878ff8abda53e664c7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a1db1a919e67261878ff8abda53e664c7">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1ReverseArcStaticGraph.html">ReverseArcStaticGraph</a>, OutgoingOrOppositeIncoming, DirectArcLimit(node))</td></tr>
<tr class="separator:a1db1a919e67261878ff8abda53e664c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1728675285eb75f9f18d6ed7c134d0b6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a1728675285eb75f9f18d6ed7c134d0b6">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1ReverseArcStaticGraph.html">ReverseArcStaticGraph</a>, OppositeIncoming, ReverseArcLimit(node))</td></tr>
<tr class="separator:a1728675285eb75f9f18d6ed7c134d0b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3308688d13e59e2351bef038ce1fdb0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#ab3308688d13e59e2351bef038ce1fdb0">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1ReverseArcMixedGraph.html">ReverseArcMixedGraph</a>, Outgoing, DirectArcLimit(node))</td></tr>
<tr class="memdesc:ab3308688d13e59e2351bef038ce1fdb0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classutil_1_1ReverseArcMixedGraph.html" title="This graph is a mix between the ReverseArcListGraph and the ReverseArcStaticGraph.">ReverseArcMixedGraph</a> implementation --------------------------------------&mdash;.  <a href="#ab3308688d13e59e2351bef038ce1fdb0">More...</a><br /></td></tr>
<tr class="separator:ab3308688d13e59e2351bef038ce1fdb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c022b68f68916770fe09996df2f35a3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a3c022b68f68916770fe09996df2f35a3">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1ReverseArcMixedGraph.html">ReverseArcMixedGraph</a>, Incoming, Base::kNilArc)</td></tr>
<tr class="separator:a3c022b68f68916770fe09996df2f35a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97910ddfce7560b406aa3f4939434eb8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a97910ddfce7560b406aa3f4939434eb8">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1ReverseArcMixedGraph.html">ReverseArcMixedGraph</a>, OutgoingOrOppositeIncoming, DirectArcLimit(node))</td></tr>
<tr class="separator:a97910ddfce7560b406aa3f4939434eb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce1a67d16c75b202f56301321a457c6"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a6ce1a67d16c75b202f56301321a457c6">DEFINE_RANGE_BASED_ARC_ITERATION</a> (<a class="el" href="classutil_1_1ReverseArcMixedGraph.html">ReverseArcMixedGraph</a>, OppositeIncoming, Base::kNilArc)</td></tr>
<tr class="separator:a6ce1a67d16c75b202f56301321a457c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affed79554a202aaa8bda5b5e98c3a6b2"><td class="memTemplParams" colspan="2">template&lt;class Graph &gt; </td></tr>
<tr class="memitem:affed79554a202aaa8bda5b5e98c3a6b2"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#affed79554a202aaa8bda5b5e98c3a6b2">GraphToString</a> (const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph, <a class="el" href="namespaceutil.html#ae705e1342dacc10a13fb3f11f91d0696">GraphToStringFormat</a> format)</td></tr>
<tr class="memdesc:affed79554a202aaa8bda5b5e98c3a6b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implementations of the templated methods.  <a href="#affed79554a202aaa8bda5b5e98c3a6b2">More...</a><br /></td></tr>
<tr class="separator:affed79554a202aaa8bda5b5e98c3a6b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86199e4832dd5c1d61baa53bfecb7b6d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespaceutil.html#aadd7603ae6e78cc2490ca9710fbaf180">false</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a86199e4832dd5c1d61baa53bfecb7b6d">ValueOrDie</a> ())</td></tr>
<tr class="memdesc:a86199e4832dd5c1d61baa53bfecb7b6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a graph file in the simple ".g" format: the file should be a text file containing only space-separated integers, whose first line is: &lt;num nodes&gt;=""&gt; &lt;num edges&gt;=""&gt; [&lt;num_colors&gt; &lt;index of first node with color #1&gt; &lt;index of first node with color #2&gt; ...] and whose subsequent lines represent edges if "directed" is false, or arcs if "directed" is true: &lt;node1&gt; &lt;node2&gt;.  <a href="#a86199e4832dd5c1d61baa53bfecb7b6d">More...</a><br /></td></tr>
<tr class="separator:a86199e4832dd5c1d61baa53bfecb7b6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a640b5d8a0ba7deaba9afbd4f3ca438"><td class="memItemLeft" align="right" valign="top">*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a0a640b5d8a0ba7deaba9afbd4f3ca438">if</a> (!error_or_graph.ok())</td></tr>
<tr class="separator:a0a640b5d8a0ba7deaba9afbd4f3ca438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c5c6763e52cd1465a3e1a3ab2437e37"><td class="memTemplParams" colspan="2">template&lt;class Graph &gt; </td></tr>
<tr class="memitem:a9c5c6763e52cd1465a3e1a3ab2437e37"><td class="memTemplItemLeft" align="right" valign="top">***util::StatusOr&lt; <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a9c5c6763e52cd1465a3e1a3ab2437e37">ReadGraphFile</a> (const std::string &amp;filename, bool directed, std::vector&lt; int &gt; *num_nodes_with_color_or_null)</td></tr>
<tr class="separator:a9c5c6763e52cd1465a3e1a3ab2437e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6600986f328a49c9485aa03fb6c82946"><td class="memTemplParams" colspan="2">template&lt;class Graph &gt; </td></tr>
<tr class="memitem:a6600986f328a49c9485aa03fb6c82946"><td class="memTemplItemLeft" align="right" valign="top">util::Status&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a6600986f328a49c9485aa03fb6c82946">WriteGraphToFile</a> (const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph, const std::string &amp;filename, bool directed, const std::vector&lt; int &gt; &amp;num_nodes_with_color)</td></tr>
<tr class="memdesc:a6600986f328a49c9485aa03fb6c82946"><td class="mdescLeft">&#160;</td><td class="mdescRight">Writes a graph to the ".g" file format described above.  <a href="#a6600986f328a49c9485aa03fb6c82946">More...</a><br /></td></tr>
<tr class="separator:a6600986f328a49c9485aa03fb6c82946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeec5b66be4fd6b3021e6eb08b3045a0e"><td class="memTemplParams" colspan="2">template&lt;class Graph &gt; </td></tr>
<tr class="memitem:aeec5b66be4fd6b3021e6eb08b3045a0e"><td class="memTemplItemLeft" align="right" valign="top">util::StatusOr&lt; <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#aeec5b66be4fd6b3021e6eb08b3045a0e">ReadGraphFile</a> (const std::string &amp;filename, bool directed, std::vector&lt; int &gt; *num_nodes_with_color_or_null)</td></tr>
<tr class="separator:aeec5b66be4fd6b3021e6eb08b3045a0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4af76993c891ee4ad507783edec2a1c"><td class="memTemplParams" colspan="2">template&lt;class Graph &gt; </td></tr>
<tr class="memitem:ac4af76993c891ee4ad507783edec2a1c"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#ac4af76993c891ee4ad507783edec2a1c">GraphHasSelfArcs</a> (const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:ac4af76993c891ee4ad507783edec2a1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Here's a set of simple diagnosis tools.  <a href="#ac4af76993c891ee4ad507783edec2a1c">More...</a><br /></td></tr>
<tr class="separator:ac4af76993c891ee4ad507783edec2a1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b37593970a26f5c88b3d2ea9acea9d2"><td class="memTemplParams" colspan="2">template&lt;class Graph &gt; </td></tr>
<tr class="memitem:a6b37593970a26f5c88b3d2ea9acea9d2"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a6b37593970a26f5c88b3d2ea9acea9d2">GraphHasDuplicateArcs</a> (const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph)</td></tr>
<tr class="separator:a6b37593970a26f5c88b3d2ea9acea9d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784b483eeae1b49164a8a02fe9c0d3ba"><td class="memTemplParams" colspan="2">template&lt;class Graph &gt; </td></tr>
<tr class="memitem:a784b483eeae1b49164a8a02fe9c0d3ba"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a784b483eeae1b49164a8a02fe9c0d3ba">GraphIsSymmetric</a> (const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph)</td></tr>
<tr class="separator:a784b483eeae1b49164a8a02fe9c0d3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97311561fd1f01e9f35b2f7ce18b0af3"><td class="memTemplParams" colspan="2">template&lt;class Graph &gt; </td></tr>
<tr class="memitem:a97311561fd1f01e9f35b2f7ce18b0af3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a97311561fd1f01e9f35b2f7ce18b0af3">GraphIsWeaklyConnected</a> (const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph)</td></tr>
<tr class="separator:a97311561fd1f01e9f35b2f7ce18b0af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed748741b17dad9e6cc485728bb0043"><td class="memTemplParams" colspan="2">template&lt;class Graph &gt; </td></tr>
<tr class="memitem:a0ed748741b17dad9e6cc485728bb0043"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a0ed748741b17dad9e6cc485728bb0043">CopyGraph</a> (const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:a0ed748741b17dad9e6cc485728bb0043"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a fresh copy of a given graph.  <a href="#a0ed748741b17dad9e6cc485728bb0043">More...</a><br /></td></tr>
<tr class="separator:a0ed748741b17dad9e6cc485728bb0043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfecdce43e9933bde2a94fd879f12f5f"><td class="memTemplParams" colspan="2">template&lt;class Graph &gt; </td></tr>
<tr class="memitem:acfecdce43e9933bde2a94fd879f12f5f"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#acfecdce43e9933bde2a94fd879f12f5f">RemapGraph</a> (const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph, const std::vector&lt; int &gt; &amp;new_node_index)</td></tr>
<tr class="memdesc:acfecdce43e9933bde2a94fd879f12f5f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a remapped copy of graph "graph", where node i becomes node new_node_index[i].  <a href="#acfecdce43e9933bde2a94fd879f12f5f">More...</a><br /></td></tr>
<tr class="separator:acfecdce43e9933bde2a94fd879f12f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1df170a504d335462a1104a942e6069"><td class="memTemplParams" colspan="2">template&lt;class Graph &gt; </td></tr>
<tr class="memitem:ad1df170a504d335462a1104a942e6069"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#ad1df170a504d335462a1104a942e6069">GetSubgraphOfNodes</a> (const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph, const std::vector&lt; int &gt; &amp;nodes)</td></tr>
<tr class="memdesc:ad1df170a504d335462a1104a942e6069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the induced subgraph of "graph" restricted to the nodes in "nodes": the resulting graph will have exactly nodes.size() nodes, and its node #0 will be the former graph's node #nodes[0], etc.  <a href="#ad1df170a504d335462a1104a942e6069">More...</a><br /></td></tr>
<tr class="separator:ad1df170a504d335462a1104a942e6069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab34783e729bb5fc99042893f6bfcbb2f"><td class="memTemplParams" colspan="2">template&lt;class Graph &gt; </td></tr>
<tr class="memitem:ab34783e729bb5fc99042893f6bfcbb2f"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#ab34783e729bb5fc99042893f6bfcbb2f">GetWeaklyConnectedComponents</a> (const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:ab34783e729bb5fc99042893f6bfcbb2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the weakly connected components of a directed graph that provides the OutgoingOrOppositeIncomingArcs() API, and returns them as a mapping from node to component index.  <a href="#ab34783e729bb5fc99042893f6bfcbb2f">More...</a><br /></td></tr>
<tr class="separator:ab34783e729bb5fc99042893f6bfcbb2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9fb4c9a176acaf72053b11727436e9e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#aa9fb4c9a176acaf72053b11727436e9e">IsSubsetOf0N</a> (const std::vector&lt; int &gt; &amp;v, int n)</td></tr>
<tr class="memdesc:aa9fb4c9a176acaf72053b11727436e9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the given vector is a subset of [0..n-1], i.e.  <a href="#aa9fb4c9a176acaf72053b11727436e9e">More...</a><br /></td></tr>
<tr class="separator:aa9fb4c9a176acaf72053b11727436e9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7986b01cf61a31c09a27b4a97db6a83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#ad7986b01cf61a31c09a27b4a97db6a83">IsValidPermutation</a> (const std::vector&lt; int &gt; &amp;v)</td></tr>
<tr class="memdesc:ad7986b01cf61a31c09a27b4a97db6a83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the given vector is a permutation of [0..size()-1].  <a href="#ad7986b01cf61a31c09a27b4a97db6a83">More...</a><br /></td></tr>
<tr class="separator:ad7986b01cf61a31c09a27b4a97db6a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a06031908a024a50dbdddc394a22490"><td class="memTemplParams" colspan="2">template&lt;class Graph &gt; </td></tr>
<tr class="memitem:a8a06031908a024a50dbdddc394a22490"><td class="memTemplItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a8a06031908a024a50dbdddc394a22490">RemoveSelfArcsAndDuplicateArcs</a> (const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:a8a06031908a024a50dbdddc394a22490"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a copy of "graph", without self-arcs and duplicate arcs.  <a href="#a8a06031908a024a50dbdddc394a22490">More...</a><br /></td></tr>
<tr class="separator:a8a06031908a024a50dbdddc394a22490"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06fa201576c927d92657e090fa86bfdb"><td class="memTemplParams" colspan="2">template&lt;class Graph &gt; </td></tr>
<tr class="memitem:a06fa201576c927d92657e090fa86bfdb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a06fa201576c927d92657e090fa86bfdb">RemoveCyclesFromPath</a> (const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph, std::vector&lt; int &gt; *arc_path)</td></tr>
<tr class="memdesc:a06fa201576c927d92657e090fa86bfdb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given an arc path, changes it to a sub-path with the same source and destination but without any cycle.  <a href="#a06fa201576c927d92657e090fa86bfdb">More...</a><br /></td></tr>
<tr class="separator:a06fa201576c927d92657e090fa86bfdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbb18bcb2f9d64cbbaeb57c328f57e7b"><td class="memTemplParams" colspan="2">template&lt;class Graph &gt; </td></tr>
<tr class="memitem:adbb18bcb2f9d64cbbaeb57c328f57e7b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#adbb18bcb2f9d64cbbaeb57c328f57e7b">PathHasCycle</a> (const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph, const std::vector&lt; int &gt; &amp;arc_path)</td></tr>
<tr class="memdesc:adbb18bcb2f9d64cbbaeb57c328f57e7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true iff the given path contains a cycle.  <a href="#adbb18bcb2f9d64cbbaeb57c328f57e7b">More...</a><br /></td></tr>
<tr class="separator:adbb18bcb2f9d64cbbaeb57c328f57e7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae469c559688b92f36bae2788c2e6063e"><td class="memTemplParams" colspan="2">template&lt;class Graph &gt; </td></tr>
<tr class="memitem:ae469c559688b92f36bae2788c2e6063e"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; int &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceutil.html#ae469c559688b92f36bae2788c2e6063e">ComputeOnePossibleReverseArcMapping</a> (const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;graph, bool die_if_not_symmetric)</td></tr>
<tr class="memdesc:ae469c559688b92f36bae2788c2e6063e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a vector representing a mapping from arcs to arcs such that each arc is mapped to another arc with its (tail, head) flipped, if such an arc exists (otherwise it is mapped to -1).  <a href="#ae469c559688b92f36bae2788c2e6063e">More...</a><br /></td></tr>
<tr class="separator:ae469c559688b92f36bae2788c2e6063e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a123e77d101e4aeb54a2b9e7d9612ad1b"><td class="memItemLeft" align="right" valign="top">***util::StatusOr&lt; MyGraph * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a123e77d101e4aeb54a2b9e7d9612ad1b">error_or_graph</a></td></tr>
<tr class="memdesc:a123e77d101e4aeb54a2b9e7d9612ad1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">&lt; More complicated error handling.  <a href="#a123e77d101e4aeb54a2b9e7d9612ad1b">More...</a><br /></td></tr>
<tr class="separator:a123e77d101e4aeb54a2b9e7d9612ad1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99d2b83baf3f908e76fb2161b1c73322"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#a99d2b83baf3f908e76fb2161b1c73322">else</a></td></tr>
<tr class="separator:a99d2b83baf3f908e76fb2161b1c73322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aadd7603ae6e78cc2490ca9710fbaf180"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#aadd7603ae6e78cc2490ca9710fbaf180">false</a></td></tr>
<tr class="memdesc:aadd7603ae6e78cc2490ca9710fbaf180"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is useful for wrapping iterators of a class that support many different iterations.  <a href="#aadd7603ae6e78cc2490ca9710fbaf180">More...</a><br /></td></tr>
<tr class="separator:aadd7603ae6e78cc2490ca9710fbaf180"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc90f8dbcd326a450a7c781ea7a9539d"><td class="memItemLeft" align="right" valign="top">*OutgoingArcIterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceutil.html#acc90f8dbcd326a450a7c781ea7a9539d">this</a></td></tr>
<tr class="separator:acc90f8dbcd326a450a7c781ea7a9539d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. </p>
<p>Implementations of the method templates.</p>
<p>You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div></div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with the License. You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div></div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Finds the connected components in an undirected graph: <a href="https://en.wikipedia.org/wiki/Connected_component_(graph_theory)">https://en.wikipedia.org/wiki/Connected_component_(graph_theory)</a></p>
<p>If you have a fixed graph where the node are dense integers, use <a class="el" href="namespaceutil.html#a13f0e8f7e15873600cf8e395958c71e1" title="Finds the connected components of the graph, using BFS internally.">GetConnectedComponents()</a>: it's very fast and uses little memory.</p>
<p>If you have a more dynamic scenario where you want to incrementally add nodes or edges and query the connectivity between them, use the [Dense]<a class="el" href="classConnectedComponentsFinder.html" title="Usage: ConnectedComponentsFinder&lt;MyNodeType&gt; cc; cc.AddNode(node1); cc.AddNode(node2); cc....">ConnectedComponentsFinder</a> class, which uses the union-find algorithm aka disjoint sets: <a href="https://en.wikipedia.org/wiki/Disjoint-set_data_structure">https://en.wikipedia.org/wiki/Disjoint-set_data_structure</a>.</p>
<p>You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div></div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. This file defines a generic graph interface on which most algorithms can be built and provides a few efficient implementations with a fast construction time. Its design is based on the experience acquired by the Operations Research team in their various graph algorithm implementations.</p>
<p>The main ideas are:</p><ul>
<li>Graph nodes and arcs are represented by integers.</li>
<li>Node or arc annotations (weight, cost, ...) are not part of the graph class, they can be stored outside in one or more arrays and can be easily retrieved using a node or arc as an index.</li>
</ul>
<p>Terminology:</p><ul>
<li>An arc of a graph is directed and going from a tail node to a head node.</li>
<li>Some implementations also store 'reverse' arcs and can be used for undirected graph or flow-like algorithm.</li>
<li>A node or arc index is 'valid' if it represents a node or arc of the graph. The validity ranges are always [0, num_nodes()) for nodes and [0, num_arcs()) for forward arcs. Reverse arcs are elements of [-num_arcs(), 0) and are also considered valid by the implementations that store them.</li>
</ul>
<p>Provided implementations:</p><ul>
<li>ListGraph&lt;&gt; for the simplest api. Also aliased to <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda" title="Defining the simplest Graph interface as Graph for convenience.">util::Graph</a>.</li>
<li>StaticGraph&lt;&gt; for performance, but require calling Build(), see below</li>
<li>CompleteGraph&lt;&gt; if you need a fully connected graph</li>
<li>CompleteBipartiteGraph&lt;&gt; if you need a fully connected bipartite graph</li>
<li>ReverseArcListGraph&lt;&gt; to add reverse arcs to ListGraph&lt;&gt;</li>
<li>ReverseArcStaticGraph&lt;&gt; to add reverse arcs to StaticGraph&lt;&gt;</li>
<li>ReverseArcMixedGraph&lt;&gt; for a smaller memory footprint</li>
</ul>
<p>Utility classes &amp; functions:</p><ul>
<li><a class="el" href="namespaceutil.html#a8c227a057c1ce9d46b1185abf77ad91e">Permute()</a> to permute an array according to a given permutation.</li>
<li>SVector&lt;&gt; vector with index range [-size(), size()) for ReverseArcGraph.</li>
</ul>
<p>Basic usage: typedef ListGraph&lt;&gt; Graph; ///&lt; Choose a graph implementation. Graph graph; for (...) { graph.AddArc(tail, head); } ... for (int node = 0; node &lt; graph.num_nodes(); ++node) { for (const int arc : graph.OutgoingArcs(node)) { head = graph.Head(arc); tail = node; ///&lt; or graph.Tail(arc) which is fast but not as much. } }</p>
<p>Iteration over the arcs touching a node:</p>
<ul>
<li>OutgoingArcs(node): All the forward arcs leaving the node.</li>
<li>IncomingArcs(node): All the forward arcs arriving at the node.</li>
</ul>
<p>And two more involved ones:</p>
<ul>
<li>OutgoingOrOppositeIncomingArcs(node): This returns both the forward arcs leaving the node (i.e. OutgoingArcs(node)) and the reverse arcs leaving the node (i.e. the opposite arcs of the ones returned by IncomingArcs(node)).</li>
<li>OppositeIncomingArcs(node): This returns the reverse arcs leaving the node.</li>
</ul>
<p>Note on iteration efficiency: When re-indexing the arcs it is not possible to have both the outgoing arcs and the incoming ones form a consecutive range.</p>
<p>It is however possible to do so for the outgoing arcs and the opposite incoming arcs. It is why the OutgoingOrOppositeIncomingArcs() and OutgoingArcs() iterations are more efficient than the IncomingArcs() one.</p>
<p>If you know the graph size in advance, this already set the number of nodes, reserve space for the arcs and check in DEBUG mode that you don't go over the bounds: Graph graph(num_nodes, arc_capacity);</p>
<p>Storing and using node annotations: std::vector&lt;bool&gt; is_visited(graph.num_nodes(), false); ... for (int node = 0; node &lt; graph.num_nodes(); ++node) { if (!is_visited[node]) ... }</p>
<p>Storing and using arc annotations: std::vector&lt;int&gt; weights; for (...) { graph.AddArc(tail, head); weights.push_back(arc_weight); } ... for (const int arc : graph.OutgoingArcs(node)) { ... weights[arc] ...; }</p>
<p>More efficient version: typedef StaticGraph&lt;&gt; Graph; Graph graph(num_nodes, arc_capacity); ///&lt; Optional, but help memory usage. std::vector&lt;int&gt; weights; weights.reserve(arc_capacity); ///&lt; Optional, but help memory usage. for (...) { graph.AddArc(tail, head); weights.push_back(arc_weight); } ... std::vector&lt;Graph::ArcIndex&gt; permutation; graph.Build(&amp;permutation); ///&lt; A static graph must be Build() before usage. Permute(permutation, &amp;weights); ///&lt; Build() may permute the arc index. ...</p>
<p>Encoding an undirected graph: If you don't need arc annotation, then the best is to add two arcs for each edge (one in each direction) to a directed graph. Otherwise you can do the following.</p>
<p>typedef ReverseArc... Graph; Graph graph; for (...) { graph.AddArc(tail, head); ///&lt; or graph.AddArc(head, tail) but not both. edge_annotations.push_back(value); } ... for (const <a class="el" href="classutil_1_1BaseGraph.html#adb271cf4bcf2de5b5bbe300d7054af29" title="Typedef so you can use Graph::NodeIndex and Graph::ArcIndex to be generic but also to improve the rea...">Graph::NodeIndex</a> node : graph.AllNodes()) { for (const <a class="el" href="classutil_1_1BaseGraph.html#a0eba6e5899924388644dfa2258ae8929">Graph::ArcIndex</a> arc : graph.OutgoingOrOppositeIncomingArcs(node)) { destination = graph.Head(arc); annotation = edge_annotations[arc &lt; 0 ? graph.OppositeArc(arc) : arc]; } }</p>
<dl class="section note"><dt>Note</dt><dd>The graphs are primarily designed to be constructed first and then used because it covers most of the use cases. It is possible to extend the interface with more dynamicity (like removing arcs), but this is not done at this point. Note that a "dynamic" implementation will break some assumptions we make on what node or arc are valid and also on the indices returned by AddArc(). Some arguments for simplifying the interface at the cost of dynamicity are:</dd></dl>
<ul>
<li>It is always possible to construct a static graph from a dynamic one before calling a complex algo.</li>
<li>If you really need a dynamic graph, maybe it is better to compute a graph property incrementally rather than calling an algorithm that starts from scratch each time.</li>
</ul>
<p>You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div></div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. A collections of i/o utilities for the Graph classes in ./graph.h.</p>
<p>You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div></div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. Helper classes to make it easy to implement range-based for loops.</p>
<p>You may obtain a copy of the License at </p><div class="fragment"><div class="line">http:<span class="comment">//www.apache.org/licenses/LICENSE-2.0</span></div></div><!-- fragment --><p> Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. A collections of utilities for the Graph classes in ./graph.h. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="ae76339cb2dcd3bc05ad762146f91fdda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae76339cb2dcd3bc05ad762146f91fdda">&#9670;&nbsp;</a></span>Graph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classutil_1_1ListGraph.html">ListGraph</a> <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">util::Graph</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Defining the simplest Graph interface as Graph for convenience. </p>

<p class="definition">Definition at line <a class="el" href="graph_8h_source.html#l02358">2358</a> of file <a class="el" href="graph_8h_source.html">graph.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ae705e1342dacc10a13fb3f11f91d0696"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae705e1342dacc10a13fb3f11f91d0696">&#9670;&nbsp;</a></span>GraphToStringFormat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespaceutil.html#ae705e1342dacc10a13fb3f11f91d0696">util::GraphToStringFormat</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a std::string representation of a graph. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae705e1342dacc10a13fb3f11f91d0696acac9245da1bf36d1d9382dc579e1a4fd"></a>PRINT_GRAPH_ARCS&#160;</td><td class="fielddoc"><p>One arc per line, eg. "3-&gt;1". </p>
</td></tr>
<tr><td class="fieldname"><a id="ae705e1342dacc10a13fb3f11f91d0696aaed5759e3b6e3a8592c9a21e0048b565"></a>PRINT_GRAPH_ADJACENCY_LISTS&#160;</td><td class="fielddoc"><p>One space-separated adjacency list per line, eg. </p>
<p>"3: 5 1 3 1". Nodes with no outgoing arc get an empty list. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae705e1342dacc10a13fb3f11f91d0696a454bb1ede69e280a1e4959acb82748ef"></a>PRINT_GRAPH_ADJACENCY_LISTS_SORTED&#160;</td><td class="fielddoc"><p>Ditto, but the adjacency lists are sorted. </p>
</td></tr>
</table>

<p class="definition">Definition at line <a class="el" href="io_8h_source.html#l00038">38</a> of file <a class="el" href="io_8h_source.html">io.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ae469c559688b92f36bae2788c2e6063e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae469c559688b92f36bae2788c2e6063e">&#9670;&nbsp;</a></span>ComputeOnePossibleReverseArcMapping()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; util::ComputeOnePossibleReverseArcMapping </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>die_if_not_symmetric</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a vector representing a mapping from arcs to arcs such that each arc is mapped to another arc with its (tail, head) flipped, if such an arc exists (otherwise it is mapped to -1). </p>
<p>If the graph is symmetric, the returned mapping is bijective and reflexive, i.e. out[out[arc]] = arc for all "arc", where "out" is the returned vector. If "die_if_not_symmetric" is true, this function CHECKs() that the graph is symmetric.</p>
<p>Self-arcs are always mapped to themselves.</p>
<dl class="section note"><dt>Note</dt><dd>since graphs may have multi-arcs, the mapping isn't necessarily unique, hence the function name. </dd></dl>
<p>Special case: directly map any self-arc to itself.</p>
<p>Lookup for the reverse arc of the current one...</p>
<p>Found a reverse arc! Store the mapping and remove the reverse arc from the map.</p>
<p>Reverse arc not in the map. Add the current arc to the map.</p>
<p>Algorithm check, for debugging.</p>
<p>Special case: directly map any self-arc to itself.</p>
<p>Lookup for the reverse arc of the current one...</p>
<p>Found a reverse arc! Store the mapping and remove the reverse arc from the map.</p>
<p>Reverse arc not in the map. Add the current arc to the map.</p>
<p>Algorithm check, for debugging. </p>

<p class="definition">Definition at line <a class="el" href="util_8h_source.html#l00382">382</a> of file <a class="el" href="util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="a0ed748741b17dad9e6cc485728bb0043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed748741b17dad9e6cc485728bb0043">&#9670;&nbsp;</a></span>CopyGraph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; util::CopyGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a fresh copy of a given graph. </p>

<p class="definition">Definition at line <a class="el" href="util_8h_source.html#l00258">258</a> of file <a class="el" href="util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="a37be0131ae922e30a286797a0bef0c96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37be0131ae922e30a286797a0bef0c96">&#9670;&nbsp;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[1/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1ListGraph.html">ListGraph</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Outgoing&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Base::kNilArc&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classutil_1_1ListGraph.html" title="Basic graph implementation without reverse arc.">ListGraph</a> implementation -------------------------------------------------&mdash;. </p>

</div>
</div>
<a id="af3c40fc068f645d9dcd15c332e44fc25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3c40fc068f645d9dcd15c332e44fc25">&#9670;&nbsp;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[2/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1StaticGraph.html">StaticGraph</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Outgoing&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DirectArcLimit(node)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classutil_1_1StaticGraph.html" title="Most efficient implementation of a graph without reverse arcs:">StaticGraph</a> implementation -----------------------------------------------&mdash;. </p>

</div>
</div>
<a id="a3098e161a6aceeca482be78d2d221b3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3098e161a6aceeca482be78d2d221b3b">&#9670;&nbsp;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[3/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1ReverseArcListGraph.html">ReverseArcListGraph</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Outgoing&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Base::kNilArc&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classutil_1_1ReverseArcListGraph.html" title="Extends the ListGraph by also storing the reverse arcs.">ReverseArcListGraph</a> implementation ---------------------------------------&mdash;. </p>

</div>
</div>
<a id="a4d0ae05975a2063f2edbeb749f690fc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d0ae05975a2063f2edbeb749f690fc7">&#9670;&nbsp;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[4/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1ReverseArcListGraph.html">ReverseArcListGraph</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Incoming&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Base::kNilArc&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a22b5dcc01043ab8da01ebab71ec3ad31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22b5dcc01043ab8da01ebab71ec3ad31">&#9670;&nbsp;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[5/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1ReverseArcListGraph.html">ReverseArcListGraph</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutgoingOrOppositeIncoming&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Base::kNilArc&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a863ccdb51afb5ef92fe6c94188a5f7e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a863ccdb51afb5ef92fe6c94188a5f7e0">&#9670;&nbsp;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[6/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1ReverseArcListGraph.html">ReverseArcListGraph</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OppositeIncoming&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Base::kNilArc&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2cc2a1037195d237820edc97d35404be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cc2a1037195d237820edc97d35404be">&#9670;&nbsp;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[7/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1ReverseArcStaticGraph.html">ReverseArcStaticGraph</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Outgoing&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DirectArcLimit(node)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classutil_1_1ReverseArcStaticGraph.html" title="StaticGraph with reverse arc.">ReverseArcStaticGraph</a> implementation -------------------------------------&mdash;. </p>

</div>
</div>
<a id="a2a51d676cd5d9354bfe1f80d09c44f39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a51d676cd5d9354bfe1f80d09c44f39">&#9670;&nbsp;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[8/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1ReverseArcStaticGraph.html">ReverseArcStaticGraph</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Incoming&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReverseArcLimit(node)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1db1a919e67261878ff8abda53e664c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1db1a919e67261878ff8abda53e664c7">&#9670;&nbsp;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[9/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1ReverseArcStaticGraph.html">ReverseArcStaticGraph</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutgoingOrOppositeIncoming&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DirectArcLimit(node)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1728675285eb75f9f18d6ed7c134d0b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1728675285eb75f9f18d6ed7c134d0b6">&#9670;&nbsp;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[10/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1ReverseArcStaticGraph.html">ReverseArcStaticGraph</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OppositeIncoming&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ReverseArcLimit(node)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3308688d13e59e2351bef038ce1fdb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3308688d13e59e2351bef038ce1fdb0">&#9670;&nbsp;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[11/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1ReverseArcMixedGraph.html">ReverseArcMixedGraph</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Outgoing&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DirectArcLimit(node)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classutil_1_1ReverseArcMixedGraph.html" title="This graph is a mix between the ReverseArcListGraph and the ReverseArcStaticGraph.">ReverseArcMixedGraph</a> implementation --------------------------------------&mdash;. </p>

</div>
</div>
<a id="a3c022b68f68916770fe09996df2f35a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c022b68f68916770fe09996df2f35a3">&#9670;&nbsp;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[12/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1ReverseArcMixedGraph.html">ReverseArcMixedGraph</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Incoming&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Base::kNilArc&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a97910ddfce7560b406aa3f4939434eb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97910ddfce7560b406aa3f4939434eb8">&#9670;&nbsp;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[13/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1ReverseArcMixedGraph.html">ReverseArcMixedGraph</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OutgoingOrOppositeIncoming&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">DirectArcLimit(node)&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ce1a67d16c75b202f56301321a457c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce1a67d16c75b202f56301321a457c6">&#9670;&nbsp;</a></span>DEFINE_RANGE_BASED_ARC_ITERATION() <span class="overload">[14/14]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::DEFINE_RANGE_BASED_ARC_ITERATION </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classutil_1_1ReverseArcMixedGraph.html">ReverseArcMixedGraph</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OppositeIncoming&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Base::kNilArc&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a13f0e8f7e15873600cf8e395958c71e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13f0e8f7e15873600cf8e395958c71e1">&#9670;&nbsp;</a></span>GetConnectedComponents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class UndirectedGraph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; int &gt; util::GetConnectedComponents </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>num_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const UndirectedGraph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finds the connected components of the graph, using BFS internally. </p>
<p>Works on any <em>undirected</em> graph class whose nodes are dense integers and that supports the [] operator for adjacency lists: graph[x] must be an integer container listing the nodes that are adjacent to node #x. Example: std::vector&lt;std::vector&lt;int&gt;&gt;.</p>
<p>"Undirected" means that for all y in graph[x], x is in graph[y].</p>
<p>Returns the mapping from node to component index. The component indices are deterministic: Component #0 will be the one that has node #0, component #1 the one that has the lowest-index node that isn't in component #0, and so on.</p>
<p>Example on the following 6-node graph: 5&ndash;3&ndash;0&ndash;1 2&ndash;4 std::vector&lt;std::vector&lt;int&gt;&gt; graph = {{1, 3}, {0}, {4}, {0, 5}, {2}, {3}}; GetConnectedComponents(graph); ///&lt; returns [0, 0, 1, 0, 1, 0]. </p>

<p class="definition">Definition at line <a class="el" href="connected__components_8h_source.html#l00289">289</a> of file <a class="el" href="connected__components_8h_source.html">connected_components.h</a>.</p>

</div>
</div>
<a id="ad1df170a504d335462a1104a942e6069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1df170a504d335462a1104a942e6069">&#9670;&nbsp;</a></span>GetSubgraphOfNodes()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; util::GetSubgraphOfNodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets the induced subgraph of "graph" restricted to the nodes in "nodes": the resulting graph will have exactly nodes.size() nodes, and its node #0 will be the former graph's node #nodes[0], etc. </p>
<p>See <a href="https://en.wikipedia.org/wiki/Induced_subgraph">https://en.wikipedia.org/wiki/Induced_subgraph</a> . The "nodes" must be a valid subset (no repetitions) of [0..graph.num_nodes()-1], or the behavior is undefined (it may die). </p><dl class="section note"><dt>Note</dt><dd>you can call <a class="el" href="namespaceutil.html#aa9fb4c9a176acaf72053b11727436e9e" title="Returns true iff the given vector is a subset of [0..n-1], i.e.">IsSubsetOf0N()</a> to check it yourself.</dd></dl>
<p>Current complexity: O(num old nodes + num new arcs). It could easily be done in O(num new nodes + num new arcs) but with a higher constant. </p>
<p>Do a first pass to count the arcs, so that we don't allocate more memory than needed.</p>
<p>A second pass where we actually copy the subgraph. NOTE(user): there might seem to be a bit of duplication with <a class="el" href="namespaceutil.html#acfecdce43e9933bde2a94fd879f12f5f" title="Creates a remapped copy of graph &quot;graph&quot;, where node i becomes node new_node_index[i].">RemapGraph()</a>, but there is a key difference: the loop below only iterates on "nodes", which could be much smaller than all the graph's nodes.</p>
<p>Do a first pass to count the arcs, so that we don't allocate more memory than needed.</p>
<p>A second pass where we actually copy the subgraph. NOTE(user): there might seem to be a bit of duplication with <a class="el" href="namespaceutil.html#acfecdce43e9933bde2a94fd879f12f5f" title="Creates a remapped copy of graph &quot;graph&quot;, where node i becomes node new_node_index[i].">RemapGraph()</a>, but there is a key difference: the loop below only iterates on "nodes", which could be much smaller than all the graph's nodes. </p>

<p class="definition">Definition at line <a class="el" href="util_8h_source.html#l00290">290</a> of file <a class="el" href="util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="ab34783e729bb5fc99042893f6bfcbb2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab34783e729bb5fc99042893f6bfcbb2f">&#9670;&nbsp;</a></span>GetWeaklyConnectedComponents()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;int&gt; util::GetWeaklyConnectedComponents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the weakly connected components of a directed graph that provides the OutgoingOrOppositeIncomingArcs() API, and returns them as a mapping from node to component index. </p>
<p>See GetConnectedComponens(). </p>

<p class="definition">Definition at line <a class="el" href="util_8h_source.html#l00132">132</a> of file <a class="el" href="util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="a6b37593970a26f5c88b3d2ea9acea9d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b37593970a26f5c88b3d2ea9acea9d2">&#9670;&nbsp;</a></span>GraphHasDuplicateArcs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool util::GraphHasDuplicateArcs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="util_8h_source.html#l00195">195</a> of file <a class="el" href="util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="ac4af76993c891ee4ad507783edec2a1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4af76993c891ee4ad507783edec2a1c">&#9670;&nbsp;</a></span>GraphHasSelfArcs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool util::GraphHasSelfArcs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Here's a set of simple diagnosis tools. </p>
<p>Implementations of the templated methods.</p>
<p>Notes:</p><ul>
<li>A self-arc is an arc from a node to itself.</li>
<li>We say that an arc A-&gt;B is duplicate when there is another arc A-&gt;B in the same graph.</li>
<li>A graph is said "weakly connected" if it is connected when considering all arcs as undirected edges.</li>
<li>A graph is said "symmetric" iff for all (a, b), the number of arcs a-&gt;b is equal to the number of arcs b-&gt;a.</li>
</ul>
<p>All these diagnosis work in O(graph size), since the inverse Ackerman function is &lt;= 5 for all practical instances, and are very fast.</p>
<p>If the graph is a "static" kind, they must be finalized, except for <a class="el" href="namespaceutil.html#ac4af76993c891ee4ad507783edec2a1c" title="Here&#39;s a set of simple diagnosis tools.">GraphHasSelfArcs()</a> and <a class="el" href="namespaceutil.html#a97311561fd1f01e9f35b2f7ce18b0af3">GraphIsWeaklyConnected()</a> which also support non-finalized StaticGraph&lt;&gt;. </p>

<p class="definition">Definition at line <a class="el" href="util_8h_source.html#l00187">187</a> of file <a class="el" href="util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="a784b483eeae1b49164a8a02fe9c0d3ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a784b483eeae1b49164a8a02fe9c0d3ba">&#9670;&nbsp;</a></span>GraphIsSymmetric()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool util::GraphIsSymmetric </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a reverse copy of the graph.</p>
<p>Compare the graph to its reverse, one adjacency list at a time.</p>
<p>Create a reverse copy of the graph.</p>
<p>Compare the graph to its reverse, one adjacency list at a time. </p>

<p class="definition">Definition at line <a class="el" href="util_8h_source.html#l00213">213</a> of file <a class="el" href="util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="a97311561fd1f01e9f35b2f7ce18b0af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97311561fd1f01e9f35b2f7ce18b0af3">&#9670;&nbsp;</a></span>GraphIsWeaklyConnected()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool util::GraphIsWeaklyConnected </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="util_8h_source.html#l00242">242</a> of file <a class="el" href="util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="affed79554a202aaa8bda5b5e98c3a6b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affed79554a202aaa8bda5b5e98c3a6b2">&#9670;&nbsp;</a></span>GraphToString()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string util::GraphToString </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceutil.html#ae705e1342dacc10a13fb3f11f91d0696">GraphToStringFormat</a>&#160;</td>
          <td class="paramname"><em>format</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Implementations of the templated methods. </p>

<p class="definition">Definition at line <a class="el" href="io_8h_source.html#l00107">107</a> of file <a class="el" href="io_8h_source.html">io.h</a>.</p>

</div>
</div>
<a id="a0a640b5d8a0ba7deaba9afbd4f3ca438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a640b5d8a0ba7deaba9afbd4f3ca438">&#9670;&nbsp;</a></span>if()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">* util::if </td>
          <td>(</td>
          <td class="paramtype">!error_or_graph.&#160;</td>
          <td class="paramname"><em>ok</em>()</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="io_8h_source.html#l00076">76</a> of file <a class="el" href="io_8h_source.html">io.h</a>.</p>

</div>
</div>
<a id="aa9fb4c9a176acaf72053b11727436e9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9fb4c9a176acaf72053b11727436e9e">&#9670;&nbsp;</a></span>IsSubsetOf0N()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool util::IsSubsetOf0N </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true iff the given vector is a subset of [0..n-1], i.e. </p>
<p>all elements i are such that 0 &lt;= i &lt; n and no two elements are equal. "n" must be &gt;= 0 or the result is undefined. </p>

</div>
</div>
<a id="ad7986b01cf61a31c09a27b4a97db6a83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7986b01cf61a31c09a27b4a97db6a83">&#9670;&nbsp;</a></span>IsValidPermutation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool util::IsValidPermutation </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true iff the given vector is a permutation of [0..size()-1]. </p>

<p class="definition">Definition at line <a class="el" href="util_8h_source.html#l00143">143</a> of file <a class="el" href="util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="adbb18bcb2f9d64cbbaeb57c328f57e7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbb18bcb2f9d64cbbaeb57c328f57e7b">&#9670;&nbsp;</a></span>PathHasCycle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool util::PathHasCycle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>arc_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true iff the given path contains a cycle. </p>

<p class="definition">Definition at line <a class="el" href="util_8h_source.html#l00371">371</a> of file <a class="el" href="util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="a8c227a057c1ce9d46b1185abf77ad91e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c227a057c1ce9d46b1185abf77ad91e">&#9670;&nbsp;</a></span>Permute() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IntVector , class Array &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void util::Permute </td>
          <td>(</td>
          <td class="paramtype">const IntVector &amp;&#160;</td>
          <td class="paramname"><em>permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array *&#160;</td>
          <td class="paramname"><em>array_to_permute</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="graph_8h_source.html#l00737">737</a> of file <a class="el" href="graph_8h_source.html">graph.h</a>.</p>

</div>
</div>
<a id="ac497881c4166bc694adc4bee62746118"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac497881c4166bc694adc4bee62746118">&#9670;&nbsp;</a></span>Permute() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IntVector &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void util::Permute </td>
          <td>(</td>
          <td class="paramtype">const IntVector &amp;&#160;</td>
          <td class="paramname"><em>permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; bool &gt; *&#160;</td>
          <td class="paramname"><em>array_to_permute</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>We need a specialization for std::vector&lt;bool&gt;, because the default code uses (*array_to_permute)[0] as ElementType, which isn't 'bool' in that case. </p>

<p class="definition">Definition at line <a class="el" href="graph_8h_source.html#l00748">748</a> of file <a class="el" href="graph_8h_source.html">graph.h</a>.</p>

</div>
</div>
<a id="a9470623ca7db3c4a62ce3b326c6b07d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9470623ca7db3c4a62ce3b326c6b07d8">&#9670;&nbsp;</a></span>PermuteWithExplicitElementType()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class IntVector , class Array , class ElementType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void util::PermuteWithExplicitElementType </td>
          <td>(</td>
          <td class="paramtype">const IntVector &amp;&#160;</td>
          <td class="paramname"><em>permutation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Array *&#160;</td>
          <td class="paramname"><em>array_to_permute</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ElementType&#160;</td>
          <td class="paramname"><em>unused</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Permutes the elements of array_to_permute: element #i will be moved to position permutation[i]. </p>
<p>permutation must be either empty (in which case nothing happens), or a permutation of [0, permutation.size()).</p>
<p>The algorithm is fast but need extra memory for a copy of the permuted part of array_to_permute.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000013">Todo:</a></b></dt><dd>(user): consider slower but more memory efficient implementations that follow the cycles of the permutation and use a bitmap to indicate what has been permuted or to mark the beginning of each cycle. </dd></dl>
<p>Some compiler do not know typeof(), so we have to use this extra function internally. </p>

<p class="definition">Definition at line <a class="el" href="graph_8h_source.html#l00724">724</a> of file <a class="el" href="graph_8h_source.html">graph.h</a>.</p>

</div>
</div>
<a id="a9c5c6763e52cd1465a3e1a3ab2437e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5c6763e52cd1465a3e1a3ab2437e37">&#9670;&nbsp;</a></span>ReadGraphFile() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">* * * util::StatusOr&lt;<a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a>*&gt; util::ReadGraphFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>directed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>num_nodes_with_color_or_null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>if (!SplitStringAndParse(line, " ", &amp;absl::SimpleAtoi, &amp;header_ints) || header_ints.size() &lt; 2 || header_ints[0] &lt; 0 || header_ints[1] &lt; 0) { return util::Status( util::error::INVALID_ARGUMENT, absl::StrCat("First line of '", filename, "' should be at least two nonnegative integers.")); }</p>
<p>No coloring: all the nodes have the same color.</p>
<p>We don't add superfluous arcs to the graph, but we still keep reading the file, to get better error messages: we want to know the actual number of lines, and also want to check the validity of the superfluous arcs (i.e. that their src/dst nodes are ok). </p>

<p class="definition">Definition at line <a class="el" href="io_8h_source.html#l00132">132</a> of file <a class="el" href="io_8h_source.html">io.h</a>.</p>

</div>
</div>
<a id="aeec5b66be4fd6b3021e6eb08b3045a0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeec5b66be4fd6b3021e6eb08b3045a0e">&#9670;&nbsp;</a></span>ReadGraphFile() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">util::StatusOr&lt;<a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a>*&gt; util::ReadGraphFile </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>directed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>num_nodes_with_color_or_null</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>if (!SplitStringAndParse(line, " ", &amp;absl::SimpleAtoi, &amp;header_ints) || header_ints.size() &lt; 2 || header_ints[0] &lt; 0 || header_ints[1] &lt; 0) { return util::Status( util::error::INVALID_ARGUMENT, absl::StrCat("First line of '", filename, "' should be at least two nonnegative integers.")); }</p>
<p>No coloring: all the nodes have the same color.</p>
<p>We don't add superfluous arcs to the graph, but we still keep reading the file, to get better error messages: we want to know the actual number of lines, and also want to check the validity of the superfluous arcs (i.e. that their src/dst nodes are ok). </p>

<p class="definition">Definition at line <a class="el" href="io_8h_source.html#l00132">132</a> of file <a class="el" href="io_8h_source.html">io.h</a>.</p>

</div>
</div>
<a id="acfecdce43e9933bde2a94fd879f12f5f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfecdce43e9933bde2a94fd879f12f5f">&#9670;&nbsp;</a></span>RemapGraph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; util::RemapGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_node_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a remapped copy of graph "graph", where node i becomes node new_node_index[i]. </p>
<p>"new_node_index" must be a valid permutation of [0..num_nodes-1] or the behavior is undefined (it may die). </p><dl class="section note"><dt>Note</dt><dd>you can call <a class="el" href="namespaceutil.html#ad7986b01cf61a31c09a27b4a97db6a83" title="Returns true iff the given vector is a permutation of [0..size()-1].">IsValidPermutation()</a> to check it yourself. </dd></dl>

<p class="definition">Definition at line <a class="el" href="util_8h_source.html#l00271">271</a> of file <a class="el" href="util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="a06fa201576c927d92657e090fa86bfdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06fa201576c927d92657e090fa86bfdb">&#9670;&nbsp;</a></span>RemoveCyclesFromPath()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void util::RemoveCyclesFromPath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>arc_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Given an arc path, changes it to a sub-path with the same source and destination but without any cycle. </p>
<p>Nothing happen if the path was already without cycle.</p>
<p>The graph class should support Tail(arc) and Head(arc). They should both return an integer representing the corresponding tail/head of the passed arc.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000055">Todo:</a></b></dt><dd>(user): In some cases, there is more than one possible solution. We could take some arc costs and return the cheapest path instead. Or return the shortest path in term of number of arcs. </dd></dl>
<p>This maps each node to the latest arc in the given path that leaves it.</p>
<p>Special case for the destination. </p><dl class="section note"><dt>Note</dt><dd>this requires that -1 is not a valid arc of Graph.</dd></dl>
<p>Reconstruct the path by starting at the source and then following the "next" arcs. We override the given arc_path at the same time.</p>
<p>This maps each node to the latest arc in the given path that leaves it.</p>
<p>Special case for the destination. </p><dl class="section note"><dt>Note</dt><dd>this requires that -1 is not a valid arc of Graph.</dd></dl>
<p>Reconstruct the path by starting at the source and then following the "next" arcs. We override the given arc_path at the same time. </p>

<p class="definition">Definition at line <a class="el" href="util_8h_source.html#l00346">346</a> of file <a class="el" href="util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="a8a06031908a024a50dbdddc394a22490"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a06031908a024a50dbdddc394a22490">&#9670;&nbsp;</a></span>RemoveSelfArcsAndDuplicateArcs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &gt; util::RemoveSelfArcsAndDuplicateArcs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a copy of "graph", without self-arcs and duplicate arcs. </p>

<p class="definition">Definition at line <a class="el" href="util_8h_source.html#l00324">324</a> of file <a class="el" href="util_8h_source.html">util.h</a>.</p>

</div>
</div>
<a id="a86199e4832dd5c1d61baa53bfecb7b6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86199e4832dd5c1d61baa53bfecb7b6d">&#9670;&nbsp;</a></span>ValueOrDie()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespaceutil.html#aadd7603ae6e78cc2490ca9710fbaf180">false</a> util::ValueOrDie </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a graph file in the simple ".g" format: the file should be a text file containing only space-separated integers, whose first line is: &lt;num nodes&gt;=""&gt; &lt;num edges&gt;=""&gt; [&lt;num_colors&gt; &lt;index of first node with color #1&gt; &lt;index of first node with color #2&gt; ...] and whose subsequent lines represent edges if "directed" is false, or arcs if "directed" is true: &lt;node1&gt; &lt;node2&gt;. </p>
<p>This returns a newly created graph upon success, which the user needs to take ownership of, or a failure status. See ortools/base/statusor.h.</p>
<p>If "num_nodes_with_color_or_null" is not nullptr, it will be filled with the color information: num_nodes_with_color_or_null[i] will be the number of nodes with color #i. Furthermore, nodes are sorted by color.</p>
<p>Examples: ///&lt; Simply crash if the graph isn't successfully read from the file. typedef StaticGraph&lt;&gt; MyGraph; ///&lt; This is just an example. std::unique_ptr&lt;MyGraph&gt; my_graph( ReadGraphFile&lt;MyGraph&gt;("graph.g", /*directed= </p>

</div>
</div>
<a id="a6600986f328a49c9485aa03fb6c82946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6600986f328a49c9485aa03fb6c82946">&#9670;&nbsp;</a></span>WriteGraphToFile()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Graph &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">util::Status util::WriteGraphToFile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceutil.html#ae76339cb2dcd3bc05ad762146f91fdda">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>directed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>num_nodes_with_color</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Writes a graph to the ".g" file format described above. </p>
<p>If "directed" is true, all arcs are written to the file. If it is false, the graph is expected to be undirected (i.e. the number of arcs a-&gt;b is equal to the number of arcs b-&gt;a for all nodes a,b); and only the arcs a-&gt;b where a&lt;=b are written. Note however that in this case, the symmetry of the graph is not fully checked (only the parity of the number of non-self arcs is).</p>
<p>"num_nodes_with_color" is optional. If it is not empty, then the color information will be written to the header of the .g file. See ReadGraphFile.</p>
<p>This method is the reverse of ReadGraphFile (with the same value for "directed"). </p>
<p>In undirected mode, we must count the self-arcs separately. All other arcs should be duplicated.</p>
<p>In undirected mode, we must count the self-arcs separately. All other arcs should be duplicated. </p>

<p class="definition">Definition at line <a class="el" href="io_8h_source.html#l00223">223</a> of file <a class="el" href="io_8h_source.html">io.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a99d2b83baf3f908e76fb2161b1c73322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99d2b83baf3f908e76fb2161b1c73322">&#9670;&nbsp;</a></span>else</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::else</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{</div><div class="line"> *      std::unique_ptr&lt;MyGraph&gt; my_graph(<a class="code" href="namespaceutil.html#a123e77d101e4aeb54a2b9e7d9612ad1b">error_or_graph</a>.ValueOrDie())</div><div class="ttc" id="namespaceutil_html_a123e77d101e4aeb54a2b9e7d9612ad1b"><div class="ttname"><a href="namespaceutil.html#a123e77d101e4aeb54a2b9e7d9612ad1b">util::error_or_graph</a></div><div class="ttdeci">***util::StatusOr&lt; MyGraph * &gt; error_or_graph</div><div class="ttdoc">&lt; More complicated error handling.</div><div class="ttdef"><b>Definition:</b> <a href="io_8h_source.html#l00074">io.h:74</a></div></div>
</div><!-- fragment -->
<p class="definition">Definition at line <a class="el" href="io_8h_source.html#l00078">78</a> of file <a class="el" href="io_8h_source.html">io.h</a>.</p>

</div>
</div>
<a id="a123e77d101e4aeb54a2b9e7d9612ad1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a123e77d101e4aeb54a2b9e7d9612ad1b">&#9670;&nbsp;</a></span>error_or_graph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">* * * util::StatusOr&lt;MyGraph*&gt; util::error_or_graph</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">=</div><div class="line"> *        ReadGraphFile&lt;MyGraph&gt;(<span class="stringliteral">&quot;graph.g&quot;</span>,  <span class="keyword">false</span>)</div></div><!-- fragment -->
<p>&lt; More complicated error handling. </p>

<p class="definition">Definition at line <a class="el" href="io_8h_source.html#l00074">74</a> of file <a class="el" href="io_8h_source.html">io.h</a>.</p>

</div>
</div>
<a id="aadd7603ae6e78cc2490ca9710fbaf180"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aadd7603ae6e78cc2490ca9710fbaf180">&#9670;&nbsp;</a></span>false</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">util::false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is useful for wrapping iterators of a class that support many different iterations. </p>
<p>For instance, on a Graph class, one can write:</p>
<p>BeginEndWrapper&lt;OutgoingArcIterator&gt; Graph::OutgoingArcs(NodeInde node) const { return BeginEndRange( OutgoingArcIterator(*this, node, /*at_end= </p>

<p class="definition">Definition at line <a class="el" href="iterators_8h_source.html#l00030">30</a> of file <a class="el" href="iterators_8h_source.html">iterators.h</a>.</p>

</div>
</div>
<a id="acc90f8dbcd326a450a7c781ea7a9539d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc90f8dbcd326a450a7c781ea7a9539d">&#9670;&nbsp;</a></span>this</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">* OutgoingArcIterator util::this</td>
        </tr>
      </table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="iterators_8h_source.html#l00031">31</a> of file <a class="el" href="iterators_8h_source.html">iterators.h</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
        </div>
        <div id="footer-container">
            <div id="footer">
            </div>
        </div>
    </body>
</html>
